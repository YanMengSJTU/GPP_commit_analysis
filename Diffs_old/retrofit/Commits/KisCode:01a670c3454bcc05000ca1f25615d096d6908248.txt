diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index fd12a9838..8743f45b4 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -3,7 +3,7 @@
 # Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
 #
 # Adapted from https://coderwall.com/p/9b_lfq and
-# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
 
 SLUG="square/retrofit"
 JDK="oraclejdk8"
diff --git a/.travis.yml b/.travis.yml
index 79fe36a95..d5b32858e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,6 +3,10 @@ language: java
 jdk:
   - oraclejdk8
 
+# Ensure Javadoc and source jar generation is exercised.
+install: mvn install javadoc:jar source:jar -DskipTests=true -B -V
+script: mvn test -B
+
 after_success:
   - .buildscript/deploy_snapshot.sh
 
@@ -18,8 +22,6 @@ branches:
 notifications:
   email: false
 
-sudo: false
-
 cache:
   directories:
     - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4ade4be59..4a4492fe4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,83 @@
 Change Log
 ==========
 
+Version 2.5.0 *(2018-11-18)*
+----------------------------
+
+ * New: Built-in support for Kotlin's `Unit` type. This behaves the same as Java's `Void` where the body
+   content is ignored and immediately discarded.
+ * New: Built-in support for Java 8's `Optional` and `CompletableFuture` types. Previously the 'converter-java8'
+   and 'adapter-java8' dependencies were needed and explicitly adding `Java8OptionalConverterFactory` and/or
+   `Java8CallAdapterFactory` to your `Retrofit.Builder` in order to use these types. Support is now built-in and
+   those types and their artifacts are marked as deprecated.
+ * New: `Invocation` class provides a reference to the invoked method and argument list as a tag on the
+   underlying OkHttp `Call`. This can be accessed from an OkHttp interceptor for things like logging, analytics,
+   or metrics aggregation.
+ * New: Kotlin extension for `Retrofit` which allows you call `create` passing the interface type only as
+   a generic parameter (e.g., `retrofit.create<MyService>()`).
+ * New: Added `Response.success` overload which allows specifying a custom 2xx status code.
+ * New: Added `Calls.failure` overload which allows passing any `Throwable` subtype.
+ * New: Minimal R8 rules now ship inside the jar requiring no client configuration in the common case.
+ * Fix: Do not propagate fatal errors to the callback. They are sent to the thread's uncaught
+   exception handler.
+ * Fix: Do not enqueue/execute an otherwise useless call when the RxJava type is disposed by `onSubscribe`.
+ * Fix: Call `RxJavaPlugins` assembly hook when creating an RxJava 2 type.
+ * Fix: Ensure both the Guava and Java 8 `Optional` converters delegate properly. This ensures that converters
+   registered prior to the optional converter can be used for deserializing the body type.
+ * Fix: Prevent `@Path` values from participating in path-traversal. This ensures untrusted input passed as
+   a path value cannot cause you to make a request to an un-intended relative URL.
+ * Fix: Simple XML converter (which is deprecated) no longer wraps subtypes of `RuntimeException`
+   or `IOException` when it fails.
+ * Fix: Prevent JAXB converter from loading remote entities and DTDs.
+ * Fix: Correctly detect default methods in interfaces on Android (API 24+). These still do not work, but
+   now a correct exception will be thrown when detected.
+ * Fix: Report more accurate exceptions when a `@QueryName` or `@QueryMap` precedes a `@Url` parameter.
+ * Update OkHttp dependency to 3.12.
+
+
+Version 2.4.0 *(2018-03-14)*
+----------------------------
+
+ * New: `Retrofit.Builder` exposes mutable lists of the added converter and call adapter factories.
+ * New: Call adapter added for Scala's `Future`.
+ * New: Converter for JAXB replaces the now-deprecated converter for Simple XML Framework.
+ * New: Add Java 9 automatic module names for each artifact corresponding to their root package.
+ * Fix: Do not swallow `Error`s from callbacks (usually `OutOfMemoryError`).
+ * Fix: Moshi and Gson converters now assert that the full response was consumed. This prevents
+   hiding bugs in faulty adapters which might not have consumed the full JSON input which would
+   then cause failures on the next request over that connection.
+ * Fix: Do not conflate OkHttp `Call` cancelation with RxJava unsubscription/disposal. Prior to
+   this change, canceling of a `Call` would prevent a cancelation exception from propagating down
+   the Rx stream.
+
+
+Version 2.3.0 *(2017-05-13)*
+----------------------------
+
+ *  **Retrofit now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+    **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ * New: Converters added for Java 8's and Guava's `Optional` which wrap a potentially-nullable
+   response body. These converters still rely on normal serialization library converters for parsing
+   the response bytes into an object.
+ * New: String converters that return `null` for an `@Query` or `@Field` parameter are now skipped.
+ * New: The mock module's `NetworkBehavior` now throws a custom subclass of `IOException` to more
+   clearly indicate the exception's source.
+ * RxJava 1.x converter updated to 1.3.0 which stabilizes the use of `Completable`.
+ * Fix: Add explicit handling for `OnCompleteFailedException`, `OnErrorFailedException`, and
+   `OnErrorNotImplementedException` for RxJava 1.x to ensure they're correct delivered to the
+   plugins/hooks for handling.
+ * Fix: `NoSuchElementException` thrown when unsubscribing from an RxJava 1.x `Single`.
+
+
 Version 2.2.0 *(2017-02-21)*
 ----------------------------
 
@@ -340,7 +417,7 @@ Version 1.5.0 *(2014-03-20)*
  * Fix: Support empty HTTP response status reason.
  * If an `ErrorHandler` is supplied it will be invoked for `Callback` and `Observable` methods.
  * HTTP `PATCH` method using `HttpUrlConnection` is no longer supported. Add the
-   [OkHttp](http://square.github.io/okhttp) jar to your project if you need this behavior.
+   [OkHttp](https://square.github.io/okhttp) jar to your project if you need this behavior.
  * Custom `Client` implementations should no longer set `Content-Type` or `Content-Length` headers
    based on the `TypedInput` body of the `Request`. These headers will now be added automatically
    as part of the standard `Request` header list.
@@ -393,7 +470,7 @@ Version 1.2.2 *(2013-09-12)*
 Version 1.2.1 *(2013-08-30)*
 ----------------------------
 
- * New: Converter for [Wire protocol buffers](http://github.com/square/wire)!
+ * New: Converter for [Wire protocol buffers](https://github.com/square/wire)!
 
 
 Version 1.2.0 *(2013-08-23)*
@@ -455,3 +532,6 @@ Version 1.0.0 *(2013-05-13)*
 ----------------------------
 
 Initial release.
+
+
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/README.md b/README.md
index 0688de8e5..74d6a26f2 100644
--- a/README.md
+++ b/README.md
@@ -9,24 +9,22 @@ For more information please see [the website][1].
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>retrofit</artifactId>
-  <version>2.2.0</version>
-</dependency>
-```
-or Gradle:
-```groovy
-compile 'com.squareup.retrofit2:retrofit:2.2.0'
-```
+Download [the latest JAR][2] or grab from Maven central at the coordinates `com.squareup.retrofit2:retrofit:2.5.0`.
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 Retrofit requires at minimum Java 7 or Android 2.3.
 
 
+R8 / ProGuard
+-------------
+
+If you are using R8 the shrinking and obfuscation rules are included automatically.
+
+ProGuard users must manually add the options from
+[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro).
+(Note: You might also need rules for OkHttp and Okio which are dependencies of this library)
+
 
 License
 =======
@@ -46,6 +44,6 @@ License
     limitations under the License.
 
 
- [1]: http://square.github.io/retrofit/
+ [1]: https://square.github.io/retrofit/
  [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/checkstyle.xml b/checkstyle.xml
index 73b55406d..4721a2fdc 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
     <module name="NewlineAtEndOfFile">
diff --git a/pom.xml b/pom.xml
index a93e7e2ec..5779d6d7d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,12 +25,12 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.3.0-SNAPSHOT</version>
+  <version>2.6.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
   <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
-  <url>http://github.com/square/retrofit/</url>
+  <url>https://github.com/square/retrofit/</url>
 
   <modules>
     <module>retrofit</module>
@@ -46,24 +46,28 @@
 
     <!-- Compilation -->
     <java.version>1.7</java.version>
+    <kotlin.version>1.3.10</kotlin.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.6.0</okhttp.version>
+    <okhttp.version>3.12.0</okhttp.version>
+    <kotlinx.coroutines.version>1.1.0</kotlinx.coroutines.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.2.0</rxjava.version>
+    <rxjava.version>1.3.0</rxjava.version>
     <rxjava2.version>2.0.0</rxjava2.version>
     <guava.version>19.0</guava.version>
+    <scala.version>2.12.4</scala.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.7</gson.version>
-    <protobuf.version>3.0.0</protobuf.version>
-    <jackson.version>2.7.2</jackson.version>
+    <gson.version>2.8.5</gson.version>
+    <protobuf.version>3.5.0</protobuf.version>
+    <jackson.version>2.9.8</jackson.version>
     <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.4.0</moshi.version>
+    <moshi.version>1.8.0</moshi.version>
+    <jaxb.version>2.2.12</jaxb.version><!-- 2.3.0 breaks due to https://github.com/mojohaus/animal-sniffer/issues/29 -->
 
     <!-- Sample Dependencies -->
     <jsoup.version>1.7.3</jsoup.version>
@@ -71,12 +75,11 @@
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
-    <mockito.version>1.9.5</mockito.version>
-    <robolectric.version>3.0</robolectric.version>
+    <robolectric.version>3.8</robolectric.version>
   </properties>
 
   <scm>
-    <url>http://github.com/square/retrofit</url>
+    <url>https://github.com/square/retrofit</url>
     <connection>scm:git:git://github.com/square/retrofit.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
     <tag>HEAD</tag>
@@ -84,19 +87,19 @@
 
   <issueManagement>
     <system>GitHub Issues</system>
-    <url>http://github.com/square/retrofit/issues</url>
+    <url>https://github.com/square/retrofit/issues</url>
   </issueManagement>
 
   <licenses>
     <license>
       <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+      <url>https://www.apache.org/licenses/LICENSE-2.0.txt</url>
     </license>
   </licenses>
 
   <organization>
     <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
+    <url>https://squareup.com</url>
   </organization>
 
   <dependencyManagement>
@@ -106,6 +109,16 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-stdlib</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlinx</groupId>
+        <artifactId>kotlinx-coroutines-core</artifactId>
+        <version>${kotlinx.coroutines.version}</version>
+      </dependency>
       <dependency>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-annotations</artifactId>
@@ -156,7 +169,21 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>javax.xml.bind</groupId>
+        <artifactId>jaxb-api</artifactId>
+        <version>${jaxb.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.scala-lang</groupId>
+        <artifactId>scala-library</artifactId>
+        <version>${scala.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -167,11 +194,6 @@
         <artifactId>assertj-core</artifactId>
         <version>${assertj.version}</version>
       </dependency>
-      <dependency>
-        <groupId>org.mockito</groupId>
-        <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
@@ -193,6 +215,11 @@
   <build>
     <pluginManagement>
       <plugins>
+        <plugin>
+          <groupId>org.jetbrains.kotlin</groupId>
+          <artifactId>kotlin-maven-plugin</artifactId>
+          <version>${kotlin.version}</version>
+        </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
@@ -223,7 +250,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.5</version>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
@@ -237,7 +271,7 @@
           <dependency>
             <groupId>com.puppycrawl.tools</groupId>
             <artifactId>checkstyle</artifactId>
-            <version>7.3</version>
+            <version>7.7</version>
           </dependency>
         </dependencies>
         <configuration>
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
index 171ba8a5e..c2c3badfa 100644
--- a/retrofit-adapters/guava/README.md
+++ b/retrofit-adapters/guava/README.md
@@ -4,6 +4,26 @@ Guava Adapter
 An `Adapter` for adapting [Guava][1] `ListenableFuture`.
 
 
+Usage
+-----
+
+Add `GuavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `ListenableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  ListenableFuture<User> getUser();
+}
+```
+
+
 Download
 --------
 
@@ -17,7 +37,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-guava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index 884e97963..074b15d90 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.guava</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index 64dd0f5ad..046bf3450 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -21,6 +21,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -56,8 +57,8 @@ public static GuavaCallAdapterFactory create() {
   private GuavaCallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != ListenableFuture.class) {
       return null;
     }
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
new file mode 100644
index 000000000..1866bbf30
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.guava;
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
index bb9ccf189..f56fcf63a 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 1280b727b..86510b820 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -1,30 +1,10 @@
-Java8 Adapter
-==============
+Java 8 Adapter (Deprecated)
+===========================
 
-An `Adapter` for adapting [Java8][1] `CompletableFuture`.
-
-
-Download
---------
-
-Download [the latest JAR][2] or grab via [Maven][3]:
-```xml
-<dependency>
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>adapter-java8</artifactId>
-  <version>latest.version</version>
-</dependency>
-```
-or [Gradle][3]:
-```groovy
-compile 'com.squareup.retrofit2:adapter-java8:latest.version'
-```
-
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+A call adapter [Java 8's `CompletableFuture`][1].
 
+This adapter is no longer needed. Support for `CompletableFuture` is built-in to Retrofit and now
+works without configuration.
 
 
  [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
- [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
- [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 87893ff43..1a513ac2e 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -60,6 +65,17 @@
           </signature>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.java8</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index 35b79f1a3..8b1695eb8 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.CompletableFuture;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -27,6 +28,9 @@
 import retrofit2.Retrofit;
 
 /**
+ * @deprecated Retrofit includes support for CompletableFuture. This no longer needs to be added to
+ * the Retrofit instance explicitly.
+ * <p>
  * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
  * <p>
  * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
@@ -47,6 +51,7 @@
  * errors</li>
  * </ul>
  */
+@Deprecated
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
   public static Java8CallAdapterFactory create() {
     return new Java8CallAdapterFactory();
@@ -55,8 +60,8 @@ public static Java8CallAdapterFactory create() {
   private Java8CallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != CompletableFuture.class) {
       return null;
     }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
new file mode 100644
index 000000000..a45aba2ed
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.java8;
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
index de4b63e61..81c6ec90b 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index da39f934c..ef0a5b107 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,5 +19,6 @@
     <module>java8</module>
     <module>rxjava</module>
     <module>rxjava2</module>
+    <module>scala</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
index 42e1804e0..9b0a95828 100644
--- a/retrofit-adapters/rxjava/README.md
+++ b/retrofit-adapters/rxjava/README.md
@@ -9,6 +9,34 @@ Available types:
  * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
  * `Completable` where response bodies are discarded.
 
+
+Usage
+-----
+
+Add `RxJavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
+
 Download
 --------
 
@@ -22,7 +50,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index 9046f2d28..60ccffe7b 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>io.reactivex</groupId>
       <artifactId>rxjava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -45,4 +50,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.rxjava</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
index 2bedc367e..d91105734 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -20,6 +20,9 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
 import rx.plugins.RxJavaPlugins;
 
 final class BodyOnSubscribe<T> implements OnSubscribe<T> {
@@ -51,6 +54,10 @@
         Throwable t = new HttpException(response);
         try {
           subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
         } catch (Throwable inner) {
           Exceptions.throwIfFatal(inner);
           CompositeException composite = new CompositeException(t, inner);
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
index 34b0b004a..430ec2c36 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
@@ -23,6 +23,9 @@
 import rx.Subscription;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
 import rx.plugins.RxJavaPlugins;
 
 final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
@@ -34,6 +37,7 @@
   private final Call<T> call;
   private final Subscriber<? super Response<T>> subscriber;
 
+  private volatile boolean unsubscribed;
   private volatile Response<T> response;
 
   CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
@@ -44,11 +48,12 @@
   }
 
   @Override public void unsubscribe() {
+    unsubscribed = true;
     call.cancel();
   }
 
   @Override public boolean isUnsubscribed() {
-    return call.isCanceled();
+    return unsubscribed;
   }
 
   @Override public void request(long amount) {
@@ -114,10 +119,19 @@ private void deliverResponse(Response<T> response) {
       if (!isUnsubscribed()) {
         subscriber.onNext(response);
       }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      return;
     } catch (Throwable t) {
       Exceptions.throwIfFatal(t);
       try {
         subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
       } catch (Throwable inner) {
         Exceptions.throwIfFatal(inner);
         CompositeException composite = new CompositeException(t, inner);
@@ -126,7 +140,13 @@ private void deliverResponse(Response<T> response) {
       return;
     }
     try {
-      subscriber.onCompleted();
+      if (!isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
     } catch (Throwable t) {
       Exceptions.throwIfFatal(t);
       RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
@@ -139,6 +159,10 @@ void emitError(Throwable t) {
     if (!isUnsubscribed()) {
       try {
         subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
       } catch (Throwable inner) {
         Exceptions.throwIfFatal(inner);
         CompositeException composite = new CompositeException(t, inner);
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 49abfae2b..29af1ff44 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -16,24 +16,27 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> error(Throwable error) {
     if (error == null) throw new NullPointerException("error == null");
     return new Result<>(null, error);
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> response(Response<T> response) {
     if (response == null) throw new NullPointerException("response == null");
     return new Result<>(response, null);
   }
 
-  private final Response<T> response;
-  private final Throwable error;
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -42,7 +45,7 @@ private Result(Response<T> response, Throwable error) {
    * The response received from executing an HTTP request. Only present when {@link #isError()} is
    * false, null otherwise.
    */
-  public Response<T> response() {
+  public @Nullable Response<T> response() {
     return response;
   }
 
@@ -54,7 +57,7 @@ private Result(Response<T> response, Throwable error) {
    * remote server. Any other exception type indicates an unexpected failure and should be
    * considered fatal (configuration error, programming error, etc.).
    */
-  public Throwable error() {
+  public @Nullable Throwable error() {
     return error;
   }
 
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
index 798df5af8..4ac19c4fe 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
@@ -20,6 +20,9 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
 import rx.plugins.RxJavaPlugins;
 
 final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
@@ -51,6 +54,10 @@
       } catch (Throwable t) {
         try {
           subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
         } catch (Throwable inner) {
           Exceptions.throwIfFatal(inner);
           CompositeException composite = new CompositeException(t, inner);
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index f14c47181..cb75bdc2b 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -16,6 +16,7 @@
 package retrofit2.adapter.rxjava;
 
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
@@ -25,15 +26,15 @@
 
 final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isSingle;
   private final boolean isCompletable;
 
-  RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
-      boolean isBody, boolean isSingle, boolean isCompletable) {
+  RxJavaCallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isSingle, boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
     this.isAsync = isAsync;
@@ -70,18 +71,8 @@
       return observable.toSingle();
     }
     if (isCompletable) {
-      return CompletableHelper.toCompletable(observable);
-    }
-    return observable;
-  }
-
-  /**
-   * Separate static class defers classloading and bytecode verification since Completable is not an
-   * RxJava stable API yet.
-   */
-  private static final class CompletableHelper {
-    static Object toCompletable(Observable<?> observable) {
       return observable.toCompletable();
     }
+    return observable;
   }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index ee297ad30..abec3e745 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.HttpException;
 import retrofit2.Response;
@@ -77,24 +78,25 @@ public static RxJavaCallAdapterFactory createAsync() {
    * Returns an instance which creates synchronous observables that
    * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
     return new RxJavaCallAdapterFactory(scheduler, false);
   }
 
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
 
-  private RxJavaCallAdapterFactory(Scheduler scheduler, boolean isAsync) {
+  private RxJavaCallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
     this.isAsync = isAsync;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
     boolean isSingle = rawType == Single.class;
-    boolean isCompletable = "rx.Completable".equals(rawType.getCanonicalName());
+    boolean isCompletable = rawType == Completable.class;
     if (rawType != Observable.class && !isSingle && !isCompletable) {
       return null;
     }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
new file mode 100644
index 000000000..e3d8acb68
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.rxjava;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
index 2c2703769..30f04cc7c 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
@@ -29,6 +29,7 @@
 import rx.Completable;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorFailedException;
 import rx.observers.AsyncCompletableSubscriber;
 import rx.observers.TestSubscriber;
 import rx.plugins.RxJavaErrorHandler;
@@ -38,6 +39,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public final class AsyncTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -135,9 +137,45 @@
       }
     });
 
-    latch.await(1, SECONDS);
-    //noinspection ThrowableResultOfMethodCallIgnored
+    assertTrue(latch.await(1, SECONDS));
     CompositeException composite = (CompositeException) pluginRef.get();
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
+
+  @Test public void bodyThrowingInOnSafeSubscriberErrorDeliveredToPlugin()
+      throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+          latch.countDown();
+        }
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    OnErrorFailedException failed = (OnErrorFailedException) pluginRef.get();
+    CompositeException composite = (CompositeException) failed.getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CancelDisposeTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CancelDisposeTest.java
new file mode 100644
index 000000000..333bf97c1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CancelDisposeTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.Subscription;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class CancelDisposeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createAsync())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeCancelsCall() {
+    Subscription subscription = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    subscription.unsubscribe();
+    assertTrue(calls.get(0).isCanceled());
+  }
+
+  @Test public void cancelDoesNotDispose() {
+    Subscription subscription = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    calls.get(0).cancel();
+    assertFalse(subscription.isUnsubscribed());
+  }
+}
+
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index 3d84b39f2..27603602a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -71,4 +71,19 @@
     service.completable().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Completable observable = service.completable();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..9a0dec34a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
new file mode 100644
index 000000000..be4263b8c
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 4a8d8652f..07b56dc36 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -26,6 +26,7 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
+import rx.functions.Action1;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -133,6 +134,22 @@
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
+  @Test public void responseUnsubscribedDoesNotCallCompleted() throws InterruptedException {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response()
+        .doOnNext(new Action1<Response<String>>() {
+          @Override
+          public void call(Response<String> response) {
+            subscriber.unsubscribe();
+          }
+        })
+        .subscribe(subscriber);
+
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+  }
+
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
@@ -174,4 +191,19 @@
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Observable<String> observable = service.body();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..550d6cbc3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
new file mode 100644
index 000000000..59c8ae5ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index babd05c73..dae833a40 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -171,4 +171,19 @@
 
     subscriber.assertError(e);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Single<String> observable = service.body();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
new file mode 100644
index 000000000..5266a4f44
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.SingleSubscriber;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> extends SingleSubscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingObserver(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onNext(value);
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
index c44038d02..49de8bf19 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
index 67564e490..74d14b4be 100644
--- a/retrofit-adapters/rxjava2/README.md
+++ b/retrofit-adapters/rxjava2/README.md
@@ -11,6 +11,33 @@ Available types:
  * `Maybe<T>`, `Maybe<Response<T>>`, and `Maybe<Result<T>>`  where `T` is the body type.
  * `Completable` where response bodies are discarded.
 
+
+Usage
+-----
+
+Add `RxJava2CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
 Download
 --------
 
@@ -24,7 +51,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+implementation 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
index 1bc459ded..d75008a48 100644
--- a/retrofit-adapters/rxjava2/pom.xml
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>io.reactivex.rxjava2</groupId>
       <artifactId>rxjava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -45,4 +50,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.rxjava2</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
index aa5ca67a8..c58c426f4 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -37,12 +37,15 @@
     Call<T> call = originalCall.clone();
     CallCallback<T> callback = new CallCallback<>(call, observer);
     observer.onSubscribe(callback);
-    call.enqueue(callback);
+    if (!callback.isDisposed()) {
+      call.enqueue(callback);
+    }
   }
 
   private static final class CallCallback<T> implements Disposable, Callback<T> {
     private final Call<?> call;
     private final Observer<? super Response<T>> observer;
+    private volatile boolean disposed;
     boolean terminated = false;
 
     CallCallback(Call<?> call, Observer<? super Response<T>> observer) {
@@ -51,19 +54,20 @@
     }
 
     @Override public void onResponse(Call<T> call, Response<T> response) {
-      if (call.isCanceled()) return;
+      if (disposed) return;
 
       try {
         observer.onNext(response);
 
-        if (!call.isCanceled()) {
+        if (!disposed) {
           terminated = true;
           observer.onComplete();
         }
       } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
         if (terminated) {
           RxJavaPlugins.onError(t);
-        } else if (!call.isCanceled()) {
+        } else if (!disposed) {
           try {
             observer.onError(t);
           } catch (Throwable inner) {
@@ -86,11 +90,12 @@
     }
 
     @Override public void dispose() {
+      disposed = true;
       call.cancel();
     }
 
     @Override public boolean isDisposed() {
-      return call.isCanceled();
+      return disposed;
     }
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
index bf9453368..71b9066e7 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -34,15 +34,19 @@
   @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
     // Since Call is a one-shot type, clone it for each new observer.
     Call<T> call = originalCall.clone();
-    observer.onSubscribe(new CallDisposable(call));
+    CallDisposable disposable = new CallDisposable(call);
+    observer.onSubscribe(disposable);
+    if (disposable.isDisposed()) {
+      return;
+    }
 
     boolean terminated = false;
     try {
       Response<T> response = call.execute();
-      if (!call.isCanceled()) {
+      if (!disposable.isDisposed()) {
         observer.onNext(response);
       }
-      if (!call.isCanceled()) {
+      if (!disposable.isDisposed()) {
         terminated = true;
         observer.onComplete();
       }
@@ -50,7 +54,7 @@
       Exceptions.throwIfFatal(t);
       if (terminated) {
         RxJavaPlugins.onError(t);
-      } else if (!call.isCanceled()) {
+      } else if (!disposable.isDisposed()) {
         try {
           observer.onError(t);
         } catch (Throwable inner) {
@@ -63,17 +67,19 @@
 
   private static final class CallDisposable implements Disposable {
     private final Call<?> call;
+    private volatile boolean disposed;
 
     CallDisposable(Call<?> call) {
       this.call = call;
     }
 
     @Override public void dispose() {
+      disposed = true;
       call.cancel();
     }
 
     @Override public boolean isDisposed() {
-      return call.isCanceled();
+      return disposed;
     }
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
index dac56cdbb..e43d7204f 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
@@ -16,24 +16,27 @@
 package retrofit2.adapter.rxjava2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> error(Throwable error) {
     if (error == null) throw new NullPointerException("error == null");
     return new Result<>(null, error);
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> response(Response<T> response) {
     if (response == null) throw new NullPointerException("response == null");
     return new Result<>(response, null);
   }
 
-  private final Response<T> response;
-  private final Throwable error;
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -42,7 +45,7 @@ private Result(Response<T> response, Throwable error) {
    * The response received from executing an HTTP request. Only present when {@link #isError()} is
    * false, null otherwise.
    */
-  public Response<T> response() {
+  public @Nullable Response<T> response() {
     return response;
   }
 
@@ -54,7 +57,7 @@ private Result(Response<T> response, Throwable error) {
    * remote server. Any other exception type indicates an unexpected failure and should be
    * considered fatal (configuration error, programming error, etc.).
    */
-  public Throwable error() {
+  public @Nullable Throwable error() {
     return error;
   }
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index a585e3113..254f921ad 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -18,14 +18,16 @@
 import io.reactivex.BackpressureStrategy;
 import io.reactivex.Observable;
 import io.reactivex.Scheduler;
+import io.reactivex.plugins.RxJavaPlugins;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 
 final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
@@ -34,8 +36,8 @@
   private final boolean isMaybe;
   private final boolean isCompletable;
 
-  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
-      boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
+  RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
       boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
@@ -82,6 +84,6 @@
     if (isCompletable) {
       return observable.ignoreElements();
     }
-    return observable;
+    return RxJavaPlugins.onAssembly(observable);
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index e4b685999..0870af1f1 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -25,6 +25,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.HttpException;
 import retrofit2.Response;
@@ -75,21 +76,22 @@ public static RxJava2CallAdapterFactory createAsync() {
    * Returns an instance which creates synchronous observables that
    * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
     return new RxJava2CallAdapterFactory(scheduler, false);
   }
 
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
 
-  private RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync) {
+  private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
     this.isAsync = isAsync;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
 
     if (rawType == Completable.class) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
new file mode 100644
index 000000000..e778f0fb9
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.rxjava2;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
index d008a5e70..d020b3a6a 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
@@ -22,10 +22,18 @@
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Dispatcher;
+import okhttp3.OkHttpClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -36,7 +44,10 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public final class AsyncTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -46,14 +57,36 @@
   }
 
   private Service service;
+  private List<Throwable> uncaughtExceptions = new ArrayList<>();
+
   @Before public void setUp() {
+    ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactory() {
+      @Override public Thread newThread(Runnable r) {
+        Thread thread = new Thread(r);
+        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+          @Override public void uncaughtException(Thread t, Throwable e) {
+            uncaughtExceptions.add(e);
+          }
+        });
+        return thread;
+      }
+    });
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .dispatcher(new Dispatcher(executorService))
+        .build();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
+        .client(client)
         .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
         .build();
     service = retrofit.create(Service.class);
   }
 
+  @After public void tearDown() {
+    assertTrue("Uncaught exceptions: " + uncaughtExceptions, uncaughtExceptions.isEmpty());
+  }
+
   @Test public void success() throws InterruptedException {
     TestObserver<Void> observer = new TestObserver<>();
     service.completable().subscribe(observer);
@@ -130,4 +163,23 @@
     CompositeException composite = (CompositeException) pluginRef.get();
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
+
+  @Test public void bodyThrowingFatalInOnErrorPropagates() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final Error e = new OutOfMemoryError("Not real");
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+
+    assertEquals(1, uncaughtExceptions.size());
+    assertSame(e, uncaughtExceptions.remove(0));
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
new file mode 100644
index 000000000..8a9a6c375
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.disposables.Disposable;
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class CancelDisposeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeCancelsCall() {
+    Disposable disposable = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    disposable.dispose();
+    assertTrue(calls.get(0).isCanceled());
+  }
+
+  @Test public void disposeBeforeEnqueueDoesNotEnqueue() {
+    service.go().test(true);
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(0, calls.size());
+  }
+
+  @Test public void cancelDoesNotDispose() {
+    Disposable disposable = service.go().subscribe();
+    List<Call> calls = client.dispatcher().runningCalls();
+    assertEquals(1, calls.size());
+    calls.get(0).cancel();
+    assertFalse(disposable.isDisposed());
+  }
+}
+
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
new file mode 100644
index 000000000..174536d13
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CancelDisposeTestSync.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import okhttp3.OkHttpClient;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.junit.Assert.assertEquals;
+
+public final class CancelDisposeTestSync {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> go();
+  }
+
+  private final OkHttpClient client = new OkHttpClient();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .callFactory(client)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void disposeBeforeExecuteDoesNotEnqueue() {
+    service.go().test(true);
+    assertEquals(0, server.getRequestCount());
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
index 999cf31bd..4f00f7112 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -70,4 +70,19 @@
     service.completable().subscribe(observer);
     observer.assertError(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Completable observable = service.completable();
+
+    RecordingCompletableObserver observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertComplete();
+
+    RecordingCompletableObserver observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
index 22efcee2b..6347fa674 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -184,4 +184,19 @@
     subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Flowable<String> observable = service.body();
+
+    RecordingSubscriber<Object> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertComplete();
+
+    RecordingSubscriber<Object> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
index 21f69c68a..73295bf02 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -16,6 +16,7 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Maybe;
+import java.io.IOException;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
@@ -25,8 +26,6 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
-import java.io.IOException;
-
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -130,4 +129,19 @@
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Maybe<String> observable = service.body();
+
+    RecordingMaybeObserver<Object> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi");
+
+    RecordingMaybeObserver<Object> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey");
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
index e421c1652..1afe1eaa3 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -16,6 +16,8 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Observable;
+import io.reactivex.functions.Function;
+import io.reactivex.plugins.RxJavaPlugins;
 import java.io.IOException;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -133,4 +135,33 @@
     assertThat(result.error()).isInstanceOf(IOException.class);
     observer.assertComplete();
   }
+
+  @Test public void observableAssembly() {
+    try {
+      final Observable<String> justMe = Observable.just("me");
+      RxJavaPlugins.setOnObservableAssembly(new Function<Observable, Observable>() {
+        @Override public Observable apply(Observable f) {
+          return justMe;
+        }
+      });
+      assertThat(service.body()).isEqualTo(justMe);
+    } finally {
+      RxJavaPlugins.reset();
+    }
+  }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Observable<String> observable = service.body();
+
+    RecordingObserver<String> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi").assertComplete();
+
+    RecordingObserver<String> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey").assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
index 589716125..dea046f63 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
@@ -73,10 +73,10 @@
     assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mBodyClass = new TypeToken<Maybe<String>>() {}.getType();
-    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mBodyClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fBodyClass = new TypeToken<Flowable<String>>() {}.getType();
-    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fBodyClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
@@ -86,10 +86,10 @@
     assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mBodyWildcard = new TypeToken<Maybe<? extends String>>() {}.getType();
-    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fBodyWildcard = new TypeToken<Flowable<? extends String>>() {}.getType();
-    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
@@ -99,10 +99,10 @@
     assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type mBodyGeneric = new TypeToken<Maybe<List<String>>>() {}.getType();
-    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type fBodyGeneric = new TypeToken<Flowable<List<String>>>() {}.getType();
-    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
 
     Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
@@ -112,10 +112,10 @@
     assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();
-    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResponseClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();
-    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResponseClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
@@ -125,10 +125,10 @@
     assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResponseWildcard = new TypeToken<Maybe<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResponseWildcard = new TypeToken<Flowable<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
@@ -138,10 +138,10 @@
     assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResultClass = new TypeToken<Maybe<Result<String>>>() {}.getType();
-    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResultClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResultClass = new TypeToken<Flowable<Result<String>>>() {}.getType();
-    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResultClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
@@ -151,10 +151,10 @@
     assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResultWildcard = new TypeToken<Maybe<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResultWildcard = new TypeToken<Flowable<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
   }
 
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
index dba2dd62a..2181e4eed 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -129,4 +129,19 @@
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Single<String> observable = service.body();
+
+    RecordingSingleObserver<Object> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi");
+
+    RecordingSingleObserver<Object> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey");
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
index 5a6841840..c975258cb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -39,7 +39,7 @@
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     return new Converter<String, RequestBody>() {
       @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
+        return RequestBody.create(MediaType.get("text/plain"), value);
       }
     };
   }
diff --git a/retrofit-adapters/scala/README.md b/retrofit-adapters/scala/README.md
new file mode 100644
index 000000000..24c427fed
--- /dev/null
+++ b/retrofit-adapters/scala/README.md
@@ -0,0 +1,49 @@
+Scala Adapter
+=============
+
+An `Adapter` for adapting Scala `Future`.
+
+
+Usage
+-----
+
+Add `ScalaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(ScalaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `Future` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Future<User> getUser();
+}
+```
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-scala</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+implementation 'com.squareup.retrofit2:adapter-scala:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-scala&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-scala%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/scala/pom.xml b/retrofit-adapters/scala/pom.xml
new file mode 100644
index 000000000..a432d79b9
--- /dev/null
+++ b/retrofit-adapters/scala/pom.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-scala</artifactId>
+  <name>Adapter: Scala</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.scala-lang</groupId>
+      <artifactId>scala-library</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.adapter.scala</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
new file mode 100644
index 000000000..500f07808
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import scala.concurrent.Future;
+import scala.concurrent.Promise;
+
+final class BodyCallAdapter<T> implements CallAdapter<T, Future<T>> {
+  private final Type responseType;
+
+  BodyCallAdapter(Type responseType) {
+    this.responseType = responseType;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Future<T> adapt(Call<T> call) {
+    Promise<T> promise = Promise.apply();
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
+        if (response.isSuccessful()) {
+          promise.success(response.body());
+        } else {
+          promise.failure(new HttpException(response));
+        }
+      }
+
+      @Override public void onFailure(Call<T> call, Throwable t) {
+        promise.failure(t);
+      }
+    });
+
+    return promise.future();
+  }
+}
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
new file mode 100644
index 000000000..e9462dd61
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import scala.concurrent.Future;
+import scala.concurrent.Promise;
+
+final class ResponseCallAdapter<T> implements CallAdapter<T, Future<Response<T>>> {
+  private final Type responseType;
+
+  ResponseCallAdapter(Type responseType) {
+    this.responseType = responseType;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Future<Response<T>> adapt(Call<T> call) {
+    Promise<Response<T>> promise = Promise.apply();
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
+        promise.success(response);
+      }
+
+      @Override public void onFailure(Call<T> call, Throwable t) {
+        promise.failure(t);
+      }
+    });
+
+    return promise.future();
+  }
+}
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
new file mode 100644
index 000000000..7737b8b0b
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import scala.concurrent.Future;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Scala futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link Future} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Future&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code Future} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Future<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Future<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+public final class ScalaCallAdapterFactory extends CallAdapter.Factory {
+  public static ScalaCallAdapterFactory create() {
+    return new ScalaCallAdapterFactory();
+  }
+
+  private ScalaCallAdapterFactory() {
+  }
+
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Future.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException(
+          "Future return type must be parameterized as Future<Foo> or Future<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+}
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java
new file mode 100644
index 000000000..882801bd2
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.scala;
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/FutureTest.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/FutureTest.java
new file mode 100644
index 000000000..58556ef0c
--- /dev/null
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/FutureTest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.HttpException;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import scala.concurrent.Await;
+import scala.concurrent.Future;
+import scala.concurrent.duration.Duration;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class FutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Future<String> body();
+    @GET("/") Future<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(ScalaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Future<String> future = service.body();
+    String result = Await.result(future, Duration.create(5, SECONDS));
+    assertThat(result).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    Future<String> future = service.body();
+    try {
+      Await.result(future, Duration.create(5, SECONDS));
+      fail();
+    } catch (Exception e) {
+      assertThat(e)
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    Future<String> future = service.body();
+    try {
+      Await.result(future, Duration.create(5, SECONDS));
+      fail();
+    } catch (Exception e) {
+      assertThat(e).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Future<Response<String>> future = service.response();
+    Response<String> response = Await.result(future, Duration.create(5, SECONDS));
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    Future<Response<String>> future = service.response();
+    Response<String> response = Await.result(future, Duration.create(5, SECONDS));
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    Future<Response<String>> future = service.response();
+    try {
+      Await.result(future, Duration.create(5, SECONDS));
+      fail();
+    } catch (Exception e) {
+      assertThat(e).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/ScalaCallAdapterFactoryTest.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/ScalaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..06c8b30fd
--- /dev/null
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/ScalaCallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import scala.concurrent.Future;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ScalaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = ScalaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<Future<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<Future<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<Future<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<Future<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<Future<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<Future<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<Future<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<Future>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Future return type must be parameterized as Future<Foo> or Future<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Future<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
new file mode 100644
index 000000000..a46c087d3
--- /dev/null
+++ b/retrofit-adapters/scala/src/test/java/retrofit2/adapter/scala/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.scala;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.get("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 980d1d1f0..814f49ab1 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-gson:latest.version'
+implementation 'com.squareup.retrofit2:converter-gson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index b8347a96b..66d816eb3 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.gson</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index e6c702705..468d576d7 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -46,14 +46,15 @@ public static GsonConverterFactory create() {
    * Create an instance using {@code gson} for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static GsonConverterFactory create(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
     return new GsonConverterFactory(gson);
   }
 
   private final Gson gson;
 
   private GsonConverterFactory(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
     this.gson = gson;
   }
 
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 2e30a4478..a47775748 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -28,7 +28,7 @@
 import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
   private final Gson gson;
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
index bd9509a18..d751e7402 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -16,8 +16,10 @@
 package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
+import com.google.gson.JsonIOException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
 import java.io.IOException;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -34,7 +36,11 @@
   @Override public T convert(ResponseBody value) throws IOException {
     JsonReader jsonReader = gson.newJsonReader(value.charStream());
     try {
-      return adapter.read(jsonReader);
+      T result = adapter.read(jsonReader);
+      if (jsonReader.peek() != JsonToken.END_DOCUMENT) {
+        throw new JsonIOException("JSON document was not fully consumed.");
+      }
+      return result;
     } finally {
       value.close();
     }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
new file mode 100644
index 000000000..677188914
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.gson;
diff --git a/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
index 5f584ec85..6113988de 100644
--- a/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -17,6 +17,7 @@
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+import com.google.gson.JsonIOException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -32,9 +33,11 @@
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.Body;
+import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
 
 public final class GsonConverterFactoryTest {
   interface AnInterface {
@@ -53,6 +56,27 @@
     }
   }
 
+  static final class Value {
+    static final TypeAdapter<Value> BROKEN_ADAPTER = new TypeAdapter<Value>() {
+      @Override public void write(JsonWriter out, Value value) {
+        throw new AssertionError();
+      }
+
+      @Override public Value read(JsonReader reader) throws IOException {
+        reader.beginObject();
+        reader.nextName();
+        String theName = reader.nextString();
+        return new Value(theName);
+      }
+    };
+
+    final String theName;
+
+    Value(String theName) {
+      this.theName = theName;
+    }
+  }
+
   static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
     @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
       jsonWriter.beginObject();
@@ -80,6 +104,7 @@
   interface Service {
     @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+    @GET("/") Call<Value> value();
   }
 
   @Rule public final MockWebServer server = new MockWebServer();
@@ -89,6 +114,7 @@
   @Before public void setUp() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .registerTypeAdapter(Value.class, Value.BROKEN_ADAPTER)
         .setLenient()
         .create();
     Retrofit retrofit = new Retrofit.Builder()
@@ -141,4 +167,16 @@
         service.anImplementation(new AnImplementation("value")).execute();
     assertThat(response.body().getName()).isNull();
   }
+
+  @Test public void requireFullResponseDocumentConsumption() throws Exception {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<Value> call = service.value();
+    try {
+      call.execute();
+      fail();
+    } catch (JsonIOException e) {
+      assertThat(e).hasMessage("JSON document was not fully consumed.");
+    }
+  }
 }
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
new file mode 100644
index 000000000..e77280b77
--- /dev/null
+++ b/retrofit-converters/guava/README.md
@@ -0,0 +1,30 @@
+Guava Converter
+===============
+
+A `Converter` which supports [Guava][1]'s `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+implementation 'com.squareup.retrofit2:converter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+ [1]: https://github.com/google/guava
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-guava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/guava/pom.xml b/retrofit-converters/guava/pom.xml
new file mode 100644
index 000000000..ea734f257
--- /dev/null
+++ b/retrofit-converters/guava/pom.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-guava</artifactId>
+  <name>Converter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.guava</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
new file mode 100644
index 000000000..42b2c2745
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class GuavaOptionalConverterFactory extends Converter.Factory {
+  public static GuavaOptionalConverterFactory create() {
+    return new GuavaOptionalConverterFactory();
+  }
+
+  private GuavaOptionalConverterFactory() {
+  }
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.responseBodyConverter(innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
new file mode 100644
index 000000000..72f2184db
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.fromNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
new file mode 100644
index 000000000..04152af9c
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit.converter.guava;
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..5ef6abfaa
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
new file mode 100644
index 000000000..24426222a
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GuavaOptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+
+  @Test public void delegates() throws IOException {
+    final Object object = new Object();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Nullable @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(type) != Object.class) {
+              return null;
+            }
+            return new Converter<ResponseBody, Object>() {
+              @Override public Object convert(ResponseBody value) {
+                return object;
+              }
+            };
+          }
+        })
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Service service = retrofit.create(Service.class);
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(object);
+  }
+}
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index 2335d2903..0b6149e1e 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -20,14 +20,15 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+implementation 'com.squareup.retrofit2:converter-jackson:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
 
- [1]: http://wiki.fasterxml.com/JacksonHome
+ [1]: https://github.com/FasterXML/jackson
  [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jackson&v=LATEST
  [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jackson%22
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index b22877e60..c8191ab87 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-databind</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.jackson</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index 4b224bd97..5e5106c45 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -41,14 +41,15 @@ public static JacksonConverterFactory create() {
   }
 
   /** Create an instance using {@code mapper} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static JacksonConverterFactory create(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException("mapper == null");
     return new JacksonConverterFactory(mapper);
   }
 
   private final ObjectMapper mapper;
 
   private JacksonConverterFactory(ObjectMapper mapper) {
-    if (mapper == null) throw new NullPointerException("mapper == null");
     this.mapper = mapper;
   }
 
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index bd20a0ae0..85408a479 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final ObjectWriter adapter;
 
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
new file mode 100644
index 000000000..567bad26a
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.jackson;
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
new file mode 100644
index 000000000..331ca6866
--- /dev/null
+++ b/retrofit-converters/java8/README.md
@@ -0,0 +1,8 @@
+Java 8 Converter (Deprecated)
+=============================
+
+A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+This converter is no longer needed. Support for `Optional` is built-in to Retrofit and now works
+without configuration.
diff --git a/retrofit-converters/java8/pom.xml b/retrofit-converters/java8/pom.xml
new file mode 100644
index 000000000..3fbe9c62c
--- /dev/null
+++ b/retrofit-converters/java8/pom.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-java8</artifactId>
+  <name>Converter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.java8</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
new file mode 100644
index 000000000..512d73cb3
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * @deprecated Retrofit includes support for Optional. This no longer needs to be added to the
+ * Retrofit instance explicitly.
+ * <p>
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+@Deprecated
+public final class Java8OptionalConverterFactory extends Converter.Factory {
+  public static Java8OptionalConverterFactory create() {
+    return new Java8OptionalConverterFactory();
+  }
+
+  private Java8OptionalConverterFactory() {
+  }
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.responseBodyConverter(innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
new file mode 100644
index 000000000..438443256
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.ofNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
new file mode 100644
index 000000000..fdd62e2d4
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit.converter.java8;
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..b94d5fd78
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..1052787da
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class Java8OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+
+  @Test public void delegates() throws IOException {
+    Object object = new Object();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Nullable @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(type) != Object.class) {
+              return null;
+            }
+            return value -> object;
+          }
+        })
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Service service = retrofit.create(Service.class);
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(object);
+  }
+}
diff --git a/retrofit-converters/jaxb/README.md b/retrofit-converters/jaxb/README.md
new file mode 100644
index 000000000..a2de474a9
--- /dev/null
+++ b/retrofit-converters/jaxb/README.md
@@ -0,0 +1,34 @@
+JAXB Converter
+==============
+
+A `Converter` which uses [JAXB][1] for serialization to and from XML.
+
+A default `JAXBContext` instance will be created or one can be configured and passed
+to `JaxbConverterFactory.create()` to further control the serialization.
+
+**Note that JAXB does not work on Android.**
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-jaxb</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+implementation 'com.squareup.retrofit2:converter-jaxb:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/eclipse-ee4j/jaxb-ri
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jaxb&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jaxb%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/jaxb/pom.xml b/retrofit-converters/jaxb/pom.xml
new file mode 100644
index 000000000..857b8e84c
--- /dev/null
+++ b/retrofit-converters/jaxb/pom.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-jaxb</artifactId>
+  <name>Converter: JAXB</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>javax.xml.bind</groupId>
+      <artifactId>jaxb-api</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.jaxb</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
new file mode 100644
index 000000000..b1317f838
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.annotation.XmlRootElement;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses JAXB for XML. All validation events are
+ * ignored.
+ */
+public final class JaxbConverterFactory extends Converter.Factory {
+  static final MediaType XML = MediaType.get("application/xml; charset=utf-8");
+
+  /** Create an instance using a default {@link JAXBContext} instance for conversion. */
+  public static JaxbConverterFactory create() {
+    return new JaxbConverterFactory(null);
+  }
+
+  /** Create an instance using {@code context} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+  public static JaxbConverterFactory create(JAXBContext context) {
+    if (context == null) throw new NullPointerException("context == null");
+    return new JaxbConverterFactory(context);
+  }
+
+  /** If null, a new JAXB context will be created for each type to be converted. */
+  private final @Nullable JAXBContext context;
+
+  private JaxbConverterFactory(@Nullable JAXBContext context) {
+    this.context = context;
+  }
+
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
+      return new JaxbRequestConverter<>(contextForType((Class<?>) type), (Class<?>) type);
+    }
+    return null;
+  }
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
+      return new JaxbResponseConverter<>(contextForType((Class<?>) type), (Class<?>) type);
+    }
+    return null;
+  }
+
+  private JAXBContext contextForType(Class<?> type) {
+    try {
+      return context != null ? context : JAXBContext.newInstance(type);
+    } catch (JAXBException e) {
+      throw new IllegalArgumentException(e);
+    }
+  }
+}
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbRequestConverter.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbRequestConverter.java
new file mode 100644
index 000000000..7030c7a90
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbRequestConverter.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.io.IOException;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+import okhttp3.RequestBody;
+import okio.Buffer;
+import retrofit2.Converter;
+
+final class JaxbRequestConverter<T> implements Converter<T, RequestBody> {
+  final XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newInstance();
+  final JAXBContext context;
+  final Class<T> type;
+
+  JaxbRequestConverter(JAXBContext context, Class<T> type) {
+    this.context = context;
+    this.type = type;
+  }
+
+  @Override public RequestBody convert(final T value) throws IOException {
+    Buffer buffer = new Buffer();
+    try {
+      Marshaller marshaller = context.createMarshaller();
+
+      XMLStreamWriter xmlWriter = xmlOutputFactory.createXMLStreamWriter(
+          buffer.outputStream(), JaxbConverterFactory.XML.charset().name());
+      marshaller.marshal(value, xmlWriter);
+    } catch (JAXBException | XMLStreamException e) {
+      throw new RuntimeException(e);
+    }
+    return RequestBody.create(JaxbConverterFactory.XML, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
new file mode 100644
index 000000000..e42568997
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbResponseConverter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.io.IOException;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class JaxbResponseConverter<T> implements Converter<ResponseBody, T> {
+  final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
+  final JAXBContext context;
+  final Class<T> type;
+
+  JaxbResponseConverter(JAXBContext context, Class<T> type) {
+    this.context = context;
+    this.type = type;
+
+    // Prevent XML External Entity attacks (XXE).
+    xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
+    xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    try {
+      Unmarshaller unmarshaller = context.createUnmarshaller();
+      XMLStreamReader streamReader = xmlInputFactory.createXMLStreamReader(value.charStream());
+      return unmarshaller.unmarshal(streamReader, type).getValue();
+    } catch (JAXBException | XMLStreamException e) {
+      throw new RuntimeException(e);
+    } finally {
+      value.close();
+    }
+  }
+}
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
new file mode 100644
index 000000000..c14c5d1ff
--- /dev/null
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.jaxb;
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Contact.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Contact.java
new file mode 100644
index 000000000..78e523456
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Contact.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "contact")
+final class Contact {
+  @XmlElement(required = true)
+  public final String name;
+
+  @XmlElement(name = "phone_number")
+  public final List<PhoneNumber> phone_numbers;
+
+  @SuppressWarnings("unused") // Used by JAXB.
+  private Contact() {
+    this("", new ArrayList<PhoneNumber>());
+  }
+
+  public Contact(String name, List<PhoneNumber> phoneNumbers) {
+    this.name = name;
+    this.phone_numbers = phoneNumbers;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof Contact
+        && ((Contact) o).name.equals(name)
+        && ((Contact) o).phone_numbers.equals(phone_numbers);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.asList(name, phone_numbers).hashCode();
+  }
+}
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/JaxbConverterFactoryTest.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/JaxbConverterFactoryTest.java
new file mode 100644
index 000000000..186d506fb
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/JaxbConverterFactoryTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.util.Collections;
+import javax.xml.bind.JAXBContext;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.Body;
+import retrofit2.http.GET;
+import retrofit2.http.POST;
+
+import static junit.framework.TestCase.fail;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class JaxbConverterFactoryTest {
+  static final Contact SAMPLE_CONTACT = new Contact("Jenny",
+      Collections.singletonList(new PhoneNumber("867-5309", Type.MOBILE)));
+
+  static final String SAMPLE_CONTACT_XML = ""
+      + "<?xml version=\"1.0\" ?>"
+      + "<contact>"
+      + "<name>Jenny</name>"
+      + "<phone_number type=\"MOBILE\">"
+      + "<number>867-5309</number>"
+      + "</phone_number>"
+      + "</contact>";
+
+  interface Service {
+    @POST("/") Call<Void> postXml(@Body Contact contact);
+    @GET("/") Call<Contact> getXml();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    JaxbConverterFactory factory = JaxbConverterFactory.create();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factory)
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void xmlRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Call<Void> call = service.postXml(SAMPLE_CONTACT);
+    call.execute();
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=utf-8");
+    assertThat(request.getBody().readUtf8()).isEqualTo(SAMPLE_CONTACT_XML);
+  }
+
+  @Test public void xmlResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(SAMPLE_CONTACT_XML));
+
+    Call<Contact> call = service.getXml();
+    Response<Contact> response = call.execute();
+    assertThat(response.body()).isEqualTo(SAMPLE_CONTACT);
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<?xml version=\"1.0\" ?>"
+            + "<contact>"
+            + "<name>Бронтозавр \uD83E\uDD95 ティラノサウルス・レックス &#129430;</name>"
+            + "</contact>"));
+
+    Call<Contact> call = service.getXml();
+    Response<Contact> response = call.execute();
+    assertThat(response.body().name)
+        .isEqualTo("Бронтозавр \uD83E\uDD95 ティラノサウルス・レックス \uD83E\uDD96");
+  }
+
+  @Test public void userSuppliedJaxbContext() throws Exception {
+    JAXBContext context = JAXBContext.newInstance(Contact.class);
+    JaxbConverterFactory factory = JaxbConverterFactory.create(context);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factory)
+        .build();
+    service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    Call<Void> call = service.postXml(SAMPLE_CONTACT);
+    call.execute();
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=utf-8");
+    assertThat(request.getBody().readUtf8()).isEqualTo(SAMPLE_CONTACT_XML);
+  }
+
+  @Test public void malformedXml() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This is not XML"));
+
+    Call<Contact> call = service.getXml();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected).hasMessageContaining("ParseError");
+    }
+  }
+
+  @Test public void unrecognizedField() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<?xml version=\"1.0\" ?>"
+            + "<contact>"
+            + "<name>Jenny</name>"
+            + "<age>21</age>"
+            + "<phone_number type=\"FAX\">"
+            + "<number>867-5309</number>"
+            + "</phone_number>"
+            + "</contact>"));
+
+    Call<Contact> call = service.getXml();
+    Response<Contact> response = call.execute();
+    assertThat(response.body().name).isEqualTo("Jenny");
+  }
+
+  @Test public void externalEntity() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<?xml version=\"1.0\" ?>"
+            + "<!DOCTYPE contact["
+            + "  <!ENTITY secret SYSTEM \"" + server.url("/secret.txt") + "\">"
+            + "]>"
+            + "<contact>"
+            + "<name>&secret;</name>"
+            + "</contact>"));
+    server.enqueue(new MockResponse()
+        .setBody("hello"));
+
+    Call<Contact> call = service.getXml();
+    try {
+      Response<Contact> response = call.execute();
+      response.body();
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected).hasMessageContaining("ParseError");
+    }
+
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void externalDtd() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<?xml version=\"1.0\" ?>"
+            + "<!DOCTYPE contact SYSTEM \"" + server.url("/contact.dtd") + "\">"
+            + "<contact>"
+            + "<name>&secret;</name>"
+            + "</contact>"));
+    server.enqueue(new MockResponse()
+        .setBody(""
+            + "<!ELEMENT contact (name)>\n"
+            + "<!ELEMENT name (#PCDATA)>\n"
+            + "<!ENTITY secret \"hello\">"));
+
+    Call<Contact> call = service.getXml();
+    try {
+      Response<Contact> response = call.execute();
+      response.body();
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected).hasMessageContaining("ParseError");
+    }
+
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/PhoneNumber.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/PhoneNumber.java
new file mode 100644
index 000000000..927f0e8f1
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/PhoneNumber.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+import java.util.Arrays;
+import javax.annotation.Nullable;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+
+final class PhoneNumber {
+  @XmlElement(required = true)
+  public final String number;
+
+  @XmlAttribute
+  public final Type type;
+
+  @SuppressWarnings("unused") // Used by JAXB.
+  private PhoneNumber() {
+    this("", Type.OTHER);
+  }
+
+  PhoneNumber(String number, @Nullable Type type) {
+    this.number = number;
+    this.type = type;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof PhoneNumber
+        && ((PhoneNumber) o).number.equals(number)
+        && ((PhoneNumber) o).type.equals(type);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.asList(number, type).hashCode();
+  }
+}
diff --git a/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Type.java b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Type.java
new file mode 100644
index 000000000..e8b93d2e6
--- /dev/null
+++ b/retrofit-converters/jaxb/src/test/java/retrofit2/converter/jaxb/Type.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.jaxb;
+
+enum Type {
+  OTHER, MOBILE
+}
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index c5668f9ab..343b22dc0 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -20,7 +20,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+implementation 'com.squareup.retrofit2:converter-moshi:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 11ab6a2f4..2aefc02a8 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.moshi</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index 311d76d0d..b7c016190 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -49,6 +49,7 @@ public static MoshiConverterFactory create() {
   }
 
   /** Create an instance using {@code moshi} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static MoshiConverterFactory create(Moshi moshi) {
     if (moshi == null) throw new NullPointerException("moshi == null");
     return new MoshiConverterFactory(moshi, false, false, false);
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index edbcf243e..879d73fc4 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
 
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index 199776ff2..a19a66ccd 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -16,6 +16,8 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonDataException;
+import com.squareup.moshi.JsonReader;
 import java.io.IOException;
 import okhttp3.ResponseBody;
 import okio.BufferedSource;
@@ -39,7 +41,12 @@
       if (source.rangeEquals(0, UTF8_BOM)) {
         source.skip(UTF8_BOM.size());
       }
-      return adapter.fromJson(source);
+      JsonReader reader = JsonReader.of(source);
+      T result = adapter.fromJson(reader);
+      if (reader.peek() != JsonReader.Token.END_DOCUMENT) {
+        throw new JsonDataException("JSON document was not fully consumed.");
+      }
+      return result;
     } finally {
       value.close();
     }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
new file mode 100644
index 000000000..38bee8e2f
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.moshi;
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index 14b00dafd..3eb6ceebc 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -41,6 +41,7 @@
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.Body;
+import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -72,6 +73,14 @@
     }
   }
 
+  static final class Value {
+    final String theName;
+
+    Value(String theName) {
+      this.theName = theName;
+    }
+  }
+
   static class Adapters {
     @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
       jsonWriter.beginObject();
@@ -106,11 +115,19 @@
       }
       throw new AssertionError("Found: " + string);
     }
+
+    @FromJson public Value readWithoutEndingObject(JsonReader reader) throws IOException {
+      reader.beginObject();
+      reader.skipName();
+      String theName = reader.nextString();
+      return new Value(theName);
+    }
   }
 
   interface Service {
     @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+    @GET("/") Call<Value> value();
 
     @POST("/") @Qualifier @NonQualifer //
     Call<String> annotations(@Body @Qualifier @NonQualifer String body);
@@ -238,7 +255,7 @@
       call.execute();
       fail();
     } catch (JsonDataException e) {
-      assertThat(e).hasMessage("Cannot skip unexpected STRING at $.taco");
+      assertThat(e).hasMessage("Cannot skip unexpected NAME at $.");
     }
   }
 
@@ -269,4 +286,16 @@
     } catch (IOException expected) {
     }
   }
+
+  @Test public void requireFullResponseDocumentConsumption() throws Exception {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<Value> call = service.value();
+    try {
+      call.execute();
+      fail();
+    } catch (JsonDataException e) {
+      assertThat(e).hasMessage("JSON document was not fully consumed.");
+    }
+  }
 }
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 4c49a4a88..399f25e60 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -16,11 +16,14 @@
 
   <modules>
     <module>gson</module>
+    <module>guava</module>
     <module>protobuf</module>
     <module>jackson</module>
+    <module>java8</module>
     <module>wire</module>
     <module>simplexml</module>
     <module>scalars</module>
     <module>moshi</module>
+    <module>jaxb</module>
   </modules>
 </project>
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index 7575a3d6c..2569fe962 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+implementation 'com.squareup.retrofit2:converter-protobuf:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 55f42504e..82ff21956 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.protobuf</groupId>
       <artifactId>protobuf-java</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,4 +45,44 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <extensions>
+      <extension>
+        <groupId>kr.motd.maven</groupId>
+        <artifactId>os-maven-plugin</artifactId>
+        <version>1.6.2</version>
+      </extension>
+    </extensions>
+    <plugins>
+      <plugin>
+        <groupId>org.xolstice.maven.plugins</groupId>
+        <artifactId>protobuf-maven-plugin</artifactId>
+        <version>0.6.1</version>
+        <executions>
+          <execution>
+            <phase>generate-test-sources</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <protoTestSourceRoot>src/test/protos</protoTestSourceRoot>
+          <protocArtifact>com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.classifier}</protocArtifact>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.protobuf</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index ec2aac452..d41ebd2f8 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -23,6 +23,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -40,19 +41,18 @@ public static ProtoConverterFactory create() {
   }
 
   /** Create an instance which uses {@code registry} when deserializing. */
-  public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
+  public static ProtoConverterFactory createWithRegistry(@Nullable ExtensionRegistryLite registry) {
     return new ProtoConverterFactory(registry);
   }
 
-  private final ExtensionRegistryLite registry;
+  private final @Nullable ExtensionRegistryLite registry;
 
-  private ProtoConverterFactory(ExtensionRegistryLite registry) {
+  private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
     this.registry = registry;
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
@@ -83,8 +83,7 @@ private ProtoConverterFactory(ExtensionRegistryLite registry) {
     return new ProtoResponseBodyConverter<>(parser, registry);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 814dc326b..90905db40 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -22,7 +22,7 @@
 import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   @Override public RequestBody convert(T value) throws IOException {
     byte[] bytes = value.toByteArray();
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index 324199458..57daa759b 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -20,22 +20,24 @@
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
     implements Converter<ResponseBody, T> {
   private final Parser<T> parser;
-  private final ExtensionRegistryLite registry;
+  private final @Nullable ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
+  ProtoResponseBodyConverter(Parser<T> parser, @Nullable ExtensionRegistryLite registry) {
     this.parser = parser;
     this.registry = registry;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
     try {
-      return parser.parseFrom(value.byteStream(), registry);
+      return registry == null ? parser.parseFrom(value.byteStream())
+              : parser.parseFrom(value.byteStream(), registry);
     } catch (InvalidProtocolBufferException e) {
       throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
new file mode 100644
index 000000000..84ed323c0
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.protobuf;
diff --git a/retrofit-converters/protobuf/src/test/gen-protos.sh b/retrofit-converters/protobuf/src/test/gen-protos.sh
deleted file mode 100755
index 999d7f533..000000000
--- a/retrofit-converters/protobuf/src/test/gen-protos.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/bash
-
-set -ex
-protoc --java_out=java/ protos/phone.proto
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
deleted file mode 100644
index 3ad1bb0f6..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
+++ /dev/null
@@ -1,656 +0,0 @@
-// Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: protos/phone.proto
-
-package retrofit2.converter.protobuf;
-
-public final class PhoneProtos {
-  private PhoneProtos() {}
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistryLite registry) {
-    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
-  }
-
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistry registry) {
-    registerAllExtensions(
-        (com.google.protobuf.ExtensionRegistryLite) registry);
-  }
-  public interface PhoneOrBuilder extends
-      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
-      com.google.protobuf.GeneratedMessage.
-          ExtendableMessageOrBuilder<Phone> {
-
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    boolean hasNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    java.lang.String getNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    com.google.protobuf.ByteString
-        getNumberBytes();
-  }
-  /**
-   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-   */
-  public  static final class Phone extends
-      com.google.protobuf.GeneratedMessage.ExtendableMessage<
-        Phone> implements
-      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
-      PhoneOrBuilder {
-    // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
-      super(builder);
-    }
-    private Phone() {
-      number_ = "";
-    }
-
-    @java.lang.Override
-    public final com.google.protobuf.UnknownFieldSet
-    getUnknownFields() {
-      return this.unknownFields;
-    }
-    private Phone(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      this();
-      int mutable_bitField0_ = 0;
-      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
-          com.google.protobuf.UnknownFieldSet.newBuilder();
-      try {
-        boolean done = false;
-        while (!done) {
-          int tag = input.readTag();
-          switch (tag) {
-            case 0:
-              done = true;
-              break;
-            default: {
-              if (!parseUnknownField(input, unknownFields,
-                                     extensionRegistry, tag)) {
-                done = true;
-              }
-              break;
-            }
-            case 10: {
-              com.google.protobuf.ByteString bs = input.readBytes();
-              bitField0_ |= 0x00000001;
-              number_ = bs;
-              break;
-            }
-          }
-        }
-      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-        throw e.setUnfinishedMessage(this);
-      } catch (java.io.IOException e) {
-        throw new com.google.protobuf.InvalidProtocolBufferException(
-            e).setUnfinishedMessage(this);
-      } finally {
-        this.unknownFields = unknownFields.build();
-        makeExtensionsImmutable();
-      }
-    }
-    public static final com.google.protobuf.Descriptors.Descriptor
-        getDescriptor() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-    }
-
-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-        internalGetFieldAccessorTable() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-          .ensureFieldAccessorsInitialized(
-              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-    }
-
-    private int bitField0_;
-    public static final int NUMBER_FIELD_NUMBER = 1;
-    private volatile java.lang.Object number_;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public boolean hasNumber() {
-      return ((bitField0_ & 0x00000001) == 0x00000001);
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public java.lang.String getNumber() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        return (java.lang.String) ref;
-      } else {
-        com.google.protobuf.ByteString bs = 
-            (com.google.protobuf.ByteString) ref;
-        java.lang.String s = bs.toStringUtf8();
-        if (bs.isValidUtf8()) {
-          number_ = s;
-        }
-        return s;
-      }
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public com.google.protobuf.ByteString
-        getNumberBytes() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b = 
-            com.google.protobuf.ByteString.copyFromUtf8(
-                (java.lang.String) ref);
-        number_ = b;
-        return b;
-      } else {
-        return (com.google.protobuf.ByteString) ref;
-      }
-    }
-
-    private byte memoizedIsInitialized = -1;
-    public final boolean isInitialized() {
-      byte isInitialized = memoizedIsInitialized;
-      if (isInitialized == 1) return true;
-      if (isInitialized == 0) return false;
-
-      if (!extensionsAreInitialized()) {
-        memoizedIsInitialized = 0;
-        return false;
-      }
-      memoizedIsInitialized = 1;
-      return true;
-    }
-
-    public void writeTo(com.google.protobuf.CodedOutputStream output)
-                        throws java.io.IOException {
-      com.google.protobuf.GeneratedMessage
-        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
-          extensionWriter = newExtensionWriter();
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
-      }
-      extensionWriter.writeUntil(3, output);
-      unknownFields.writeTo(output);
-    }
-
-    public int getSerializedSize() {
-      int size = memoizedSize;
-      if (size != -1) return size;
-
-      size = 0;
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
-      }
-      size += extensionsSerializedSize();
-      size += unknownFields.getSerializedSize();
-      memoizedSize = size;
-      return size;
-    }
-
-    private static final long serialVersionUID = 0L;
-    @java.lang.Override
-    public boolean equals(final java.lang.Object obj) {
-      if (obj == this) {
-       return true;
-      }
-      if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
-        return super.equals(obj);
-      }
-      retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
-
-      boolean result = true;
-      result = result && (hasNumber() == other.hasNumber());
-      if (hasNumber()) {
-        result = result && getNumber()
-            .equals(other.getNumber());
-      }
-      result = result && unknownFields.equals(other.unknownFields);
-      result = result &&
-          getExtensionFields().equals(other.getExtensionFields());
-      return result;
-    }
-
-    @java.lang.Override
-    public int hashCode() {
-      if (memoizedHashCode != 0) {
-        return memoizedHashCode;
-      }
-      int hash = 41;
-      hash = (19 * hash) + getDescriptorForType().hashCode();
-      if (hasNumber()) {
-        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
-        hash = (53 * hash) + getNumber().hashCode();
-      }
-      hash = hashFields(hash, getExtensionFields());
-      hash = (29 * hash) + unknownFields.hashCode();
-      memoizedHashCode = hash;
-      return hash;
-    }
-
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        byte[] data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseDelimitedWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input, extensionRegistry);
-    }
-
-    public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder() {
-      return DEFAULT_INSTANCE.toBuilder();
-    }
-    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
-      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
-    }
-    public Builder toBuilder() {
-      return this == DEFAULT_INSTANCE
-          ? new Builder() : new Builder().mergeFrom(this);
-    }
-
-    @java.lang.Override
-    protected Builder newBuilderForType(
-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-      Builder builder = new Builder(parent);
-      return builder;
-    }
-    /**
-     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-     */
-    public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
-          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
-        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
-        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
-      public static final com.google.protobuf.Descriptors.Descriptor
-          getDescriptor() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-          internalGetFieldAccessorTable() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-            .ensureFieldAccessorsInitialized(
-                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-      }
-
-      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
-      private Builder() {
-        maybeForceBuilderInitialization();
-      }
-
-      private Builder(
-          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-        super(parent);
-        maybeForceBuilderInitialization();
-      }
-      private void maybeForceBuilderInitialization() {
-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-        }
-      }
-      public Builder clear() {
-        super.clear();
-        number_ = "";
-        bitField0_ = (bitField0_ & ~0x00000001);
-        return this;
-      }
-
-      public com.google.protobuf.Descriptors.Descriptor
-          getDescriptorForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
-        if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
-        }
-        return result;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
-        int from_bitField0_ = bitField0_;
-        int to_bitField0_ = 0;
-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
-          to_bitField0_ |= 0x00000001;
-        }
-        result.number_ = number_;
-        result.bitField0_ = to_bitField0_;
-        onBuilt();
-        return result;
-      }
-
-      public Builder clone() {
-        return (Builder) super.clone();
-      }
-      public Builder setField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          Object value) {
-        return (Builder) super.setField(field, value);
-      }
-      public Builder clearField(
-          com.google.protobuf.Descriptors.FieldDescriptor field) {
-        return (Builder) super.clearField(field);
-      }
-      public Builder clearOneof(
-          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
-        return (Builder) super.clearOneof(oneof);
-      }
-      public Builder setRepeatedField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          int index, Object value) {
-        return (Builder) super.setRepeatedField(field, index, value);
-      }
-      public Builder addRepeatedField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          Object value) {
-        return (Builder) super.addRepeatedField(field, value);
-      }
-      public <Type> Builder setExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
-          Type value) {
-        return (Builder) super.setExtension(extension, value);
-      }
-      public <Type> Builder setExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
-          int index, Type value) {
-        return (Builder) super.setExtension(extension, index, value);
-      }
-      public <Type> Builder addExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
-          Type value) {
-        return (Builder) super.addExtension(extension, value);
-      }
-      public <Type> Builder clearExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
-        return (Builder) super.clearExtension(extension);
-      }
-      public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
-          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
-        } else {
-          super.mergeFrom(other);
-          return this;
-        }
-      }
-
-      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
-        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
-        if (other.hasNumber()) {
-          bitField0_ |= 0x00000001;
-          number_ = other.number_;
-          onChanged();
-        }
-        this.mergeExtensionFields(other);
-        this.mergeUnknownFields(other.unknownFields);
-        onChanged();
-        return this;
-      }
-
-      public final boolean isInitialized() {
-        if (!extensionsAreInitialized()) {
-          return false;
-        }
-        return true;
-      }
-
-      public Builder mergeFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws java.io.IOException {
-        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
-        try {
-          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
-        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e.unwrapIOException();
-        } finally {
-          if (parsedMessage != null) {
-            mergeFrom(parsedMessage);
-          }
-        }
-        return this;
-      }
-      private int bitField0_;
-
-      private java.lang.Object number_ = "";
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public boolean hasNumber() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public java.lang.String getNumber() {
-        java.lang.Object ref = number_;
-        if (!(ref instanceof java.lang.String)) {
-          com.google.protobuf.ByteString bs =
-              (com.google.protobuf.ByteString) ref;
-          java.lang.String s = bs.toStringUtf8();
-          if (bs.isValidUtf8()) {
-            number_ = s;
-          }
-          return s;
-        } else {
-          return (java.lang.String) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public com.google.protobuf.ByteString
-          getNumberBytes() {
-        java.lang.Object ref = number_;
-        if (ref instanceof String) {
-          com.google.protobuf.ByteString b = 
-              com.google.protobuf.ByteString.copyFromUtf8(
-                  (java.lang.String) ref);
-          number_ = b;
-          return b;
-        } else {
-          return (com.google.protobuf.ByteString) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumber(
-          java.lang.String value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder clearNumber() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        number_ = getDefaultInstance().getNumber();
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumberBytes(
-          com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      public final Builder setUnknownFields(
-          final com.google.protobuf.UnknownFieldSet unknownFields) {
-        return super.setUnknownFields(unknownFields);
-      }
-
-      public final Builder mergeUnknownFields(
-          final com.google.protobuf.UnknownFieldSet unknownFields) {
-        return super.mergeUnknownFields(unknownFields);
-      }
-
-
-      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
-    }
-
-    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
-    private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
-    static {
-      DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
-    }
-
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
-      return DEFAULT_INSTANCE;
-    }
-
-    @java.lang.Deprecated public static final com.google.protobuf.Parser<Phone>
-        PARSER = new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-          return new Phone(input, extensionRegistry);
-      }
-    };
-
-    public static com.google.protobuf.Parser<Phone> parser() {
-      return PARSER;
-    }
-
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
-    }
-
-    public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-      return DEFAULT_INSTANCE;
-    }
-
-  }
-
-  public static final int VOICEMAIL_FIELD_NUMBER = 2;
-  /**
-   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
-   */
-  public static final
-    com.google.protobuf.GeneratedMessage.GeneratedExtension<
-      retrofit2.converter.protobuf.PhoneProtos.Phone,
-      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
-          .newFileScopedGeneratedExtension(
-        java.lang.Boolean.class,
-        null);
-  private static final com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-  private static final 
-    com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
-
-  public static com.google.protobuf.Descriptors.FileDescriptor
-      getDescriptor() {
-    return descriptor;
-  }
-  private static  com.google.protobuf.Descriptors.FileDescriptor
-      descriptor;
-  static {
-    java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\034retrofit2.converte" +
-      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
-      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
-      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
-      ".protobufB\013PhoneProtos"
-    };
-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
-          public com.google.protobuf.ExtensionRegistry assignDescriptors(
-              com.google.protobuf.Descriptors.FileDescriptor root) {
-            descriptor = root;
-            return null;
-          }
-        };
-    com.google.protobuf.Descriptors.FileDescriptor
-      .internalBuildGeneratedFileFrom(descriptorData,
-        new com.google.protobuf.Descriptors.FileDescriptor[] {
-        }, assigner);
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
-      getDescriptor().getMessageTypes().get(0);
-    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
-      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
-        new java.lang.String[] { "Number", });
-    voicemail.internalInit(descriptor.getExtensions().get(0));
-  }
-
-  // @@protoc_insertion_point(outer_class_scope)
-}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 5a585b21f..6f4cdf28e 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -119,7 +119,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -138,7 +139,8 @@
           + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index 5231b6129..67f0fd15b 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -18,7 +18,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+implementation 'com.squareup.retrofit2:converter-scalars:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index 70d15a493..daa0b6838 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -36,4 +41,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.scalars</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index fd65200d4..fb2f4ec43 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -22,7 +22,7 @@
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("text/plain; charset=UTF-8");
 
   private ScalarRequestBodyConverter() {
   }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
index 5bf838fe9..73189634d 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -43,7 +44,7 @@ public static ScalarsConverterFactory create() {
   private ScalarsConverterFactory() {
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (type == String.class
         || type == boolean.class
@@ -67,9 +68,8 @@ private ScalarsConverterFactory() {
     return null;
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type == String.class) {
       return StringResponseBodyConverter.INSTANCE;
     }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
new file mode 100644
index 000000000..ffb138825
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.scalars;
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index cc19d4fbc..6e39dd537 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -26,7 +26,6 @@
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
-import retrofit2.converter.scalars.ScalarsConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -93,7 +92,8 @@
           + "Could not locate RequestBody converter for class java.lang.Object.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -232,7 +232,8 @@
           + "Could not locate ResponseBody converter for class java.lang.Object.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index b791e8122..1a7ca6bf6 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -1,6 +1,14 @@
 Simple XML Converter
 ====================
 
+Deprecated – Please switch to the JAXB Converter
+------------------------------------------------
+
+The Simple XML project is no longer maintained. We recommend switching to the
+[JAXB converter](https://github.com/square/retrofit/tree/master/retrofit-converters/jaxb).
+
+-----
+
 A `Converter` which uses [Simple][1] for XML serialization.
 
 A default `Serializer` instance will be created or one can be configured and passed to the
@@ -28,7 +36,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+implementation 'com.squareup.retrofit2:converter-simplexml:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index b7f03efcf..360212071 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>org.simpleframework</groupId>
       <artifactId>simple-xml</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -40,4 +45,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.simplexml</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index b7563455e..a961721ca 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
@@ -29,7 +30,10 @@
  * <p>
  * This converter only applies for class types. Parameterized types (e.g., {@code List<Foo>}) are
  * not handled.
+ *
+ * @deprecated we recommend switching to the JAXB converter.
  */
+@Deprecated
 public final class SimpleXmlConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Persister} instance for conversion. */
   public static SimpleXmlConverterFactory create() {
@@ -47,7 +51,9 @@ public static SimpleXmlConverterFactory createNonStrict() {
   }
 
   /** Create an instance using {@code serializer} for non-strict conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    if (serializer == null) throw new NullPointerException("serializer == null");
     return new SimpleXmlConverterFactory(serializer, false);
   }
 
@@ -55,7 +61,6 @@ public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
   private final boolean strict;
 
   private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
     this.serializer = serializer;
     this.strict = strict;
   }
@@ -74,8 +79,7 @@ public boolean isStrict() {
     return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class)) {
       return null;
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index 06aeee1e6..645b4bb73 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/xml; charset=UTF-8");
   private static final String CHARSET = "UTF-8";
 
   private final Serializer serializer;
@@ -39,6 +39,8 @@
       OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
       serializer.write(value, osw);
       osw.flush();
+    } catch (RuntimeException | IOException e) {
+      throw e;
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
new file mode 100644
index 000000000..b12e7e178
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.simplexml;
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 6289cc8a7..eec260fd4 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -17,7 +17,7 @@ Download [the latest JAR][2] or grab via [Maven][3]:
 ```
 or [Gradle][3]:
 ```groovy
-compile 'com.squareup.retrofit2:converter-wire:latest.version'
+implementation 'com.squareup.retrofit2:converter-wire:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 9c36850ac..5d188cf89 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -34,6 +34,11 @@
         </exclusion>
       </exclusions>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -51,4 +56,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.converter.wire</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index fbaaeac4a..b97ce1011 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -19,6 +19,7 @@
 import com.squareup.wire.ProtoAdapter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -37,9 +38,8 @@ public static WireConverterFactory create() {
   private WireConverterFactory() {
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
@@ -52,8 +52,7 @@ private WireConverterFactory() {
     return new WireResponseBodyConverter<>(adapter);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index d388a944c..fd6cc3291 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -24,7 +24,7 @@
 import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.get("application/x-protobuf");
 
   private final ProtoAdapter<T> adapter;
 
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
new file mode 100644
index 000000000..fb1bd79c6
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.converter.wire;
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index e972d5287..486de11f5 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -94,7 +94,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+          + "   * retrofit2.converter.wire.WireConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -113,7 +114,8 @@
           + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+          + "   * retrofit2.converter.wire.WireConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
index 4474e5af3..d846650b4 100644
--- a/retrofit-mock/README.md
+++ b/retrofit-mock/README.md
@@ -1,7 +1,7 @@
 Mock Web Server
 ==============
 
-An mock web server for mocking HTTP responses from a server, and simulating network behaviour.
+A mock web server for mocking HTTP responses from a server, and simulating network behaviour.
 
 Download
 --------
@@ -16,7 +16,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][1]:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+implementation 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 2e6079447..7cd6d4e3a 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,10 +35,21 @@
       <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2.mock</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index 8ec2b7073..a41664876 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -32,9 +34,10 @@
   final ExecutorService backgroundExecutor;
   final Call<T> delegate;
 
-  private volatile Future<?> task;
+  private volatile @Nullable Future<?> task;
   volatile boolean canceled;
-  private volatile boolean executed;
+  @GuardedBy("this")
+  private boolean executed;
 
   BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
     this.behavior = behavior;
@@ -51,6 +54,7 @@
     return delegate.request();
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   @Override public void enqueue(final Callback<T> callback) {
     if (callback == null) throw new NullPointerException("callback == null");
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 21af3a6d3..b525696fb 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutorService;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -46,7 +47,7 @@
     this.service = service;
   }
 
-  public T returningResponse(Object response) {
+  public T returningResponse(@Nullable Object response) {
     return returning(Calls.response(response));
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 4a4721e6a..65d3afd4a 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -33,7 +34,7 @@
     return new DeferredCall<>(callable);
   }
 
-  public static <T> Call<T> response(T successValue) {
+  public static <T> Call<T> response(@Nullable T successValue) {
     return new FakeCall<>(Response.success(successValue), null);
   }
 
@@ -41,7 +42,20 @@
     return new FakeCall<>(response, null);
   }
 
+  /** Creates a failed {@link Call} from {@code failure}. */
   public static <T> Call<T> failure(IOException failure) {
+    // TODO delete this overload in Retrofit 3.0.
+    return new FakeCall<>(null, failure);
+  }
+
+  /**
+   * Creates a failed {@link Call} from {@code failure}.
+   * <p>
+   * Note: When invoking {@link Call#execute() execute()} on the returned {@link Call}, if
+   * {@code failure} is a {@link RuntimeException}, {@link Error}, or {@link IOException} subtype
+   * it is thrown directly. Otherwise it is "sneaky thrown" despite not being declared.
+   */
+  public static <T> Call<T> failure(Throwable failure) {
     return new FakeCall<>(null, failure);
   }
 
@@ -51,11 +65,11 @@ private Calls() {
 
   static final class FakeCall<T> implements Call<T> {
     private final Response<T> response;
-    private final IOException error;
+    private final Throwable error;
     private final AtomicBoolean canceled = new AtomicBoolean();
     private final AtomicBoolean executed = new AtomicBoolean();
 
-    FakeCall(Response<T> response, IOException error) {
+    FakeCall(@Nullable Response<T> response, @Nullable Throwable error) {
       if ((response == null) == (error == null)) {
         throw new AssertionError("Only one of response or error can be set.");
       }
@@ -73,9 +87,15 @@ private Calls() {
       if (response != null) {
         return response;
       }
-      throw error;
+      throw FakeCall.<Error>sneakyThrow2(error);
     }
 
+    @SuppressWarnings("unchecked") // Intentionally abusing this feature.
+    private static <T extends Throwable> T sneakyThrow2(Throwable t) throws T {
+      throw (T) t;
+    }
+
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     @Override public void enqueue(Callback<T> callback) {
       if (callback == null) {
         throw new NullPointerException("callback == null");
@@ -112,13 +132,15 @@ private Calls() {
       if (response != null) {
         return response.raw().request();
       }
-      return new Request.Builder().url("http://localhost").build();
+      return new Request.Builder()
+          .url("http://localhost")
+          .build();
     }
   }
 
   static final class DeferredCall<T> implements Call<T> {
     private final Callable<Call<T>> callable;
-    private Call<T> delegate;
+    private @Nullable Call<T> delegate;
 
     DeferredCall(Callable<Call<T>> callable) {
       this.callable = callable;
@@ -129,10 +151,8 @@ private Calls() {
       if (delegate == null) {
         try {
           delegate = callable.call();
-        } catch (IOException e) {
-          delegate = failure(e);
         } catch (Exception e) {
-          throw new IllegalStateException("Callable threw unrecoverable exception", e);
+          delegate = failure(e);
         }
         this.delegate = delegate;
       }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..e7708f591 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -18,6 +18,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import javax.annotation.Nullable;
 import retrofit2.Retrofit;
 
 public final class MockRetrofit {
@@ -50,20 +51,23 @@ public Executor backgroundExecutor() {
 
   public static final class Builder {
     private final Retrofit retrofit;
-    private NetworkBehavior behavior;
-    private ExecutorService executor;
+    private @Nullable NetworkBehavior behavior;
+    private @Nullable ExecutorService executor;
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder(Retrofit retrofit) {
       if (retrofit == null) throw new NullPointerException("retrofit == null");
       this.retrofit = retrofit;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder networkBehavior(NetworkBehavior behavior) {
       if (behavior == null) throw new NullPointerException("behavior == null");
       this.behavior = behavior;
       return this;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder backgroundExecutor(ExecutorService executor) {
       if (executor == null) throw new NullPointerException("executor == null");
       this.executor = executor;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
new file mode 100644
index 000000000..d4cdfc2c0
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+
+final class MockRetrofitIOException extends IOException {
+  MockRetrofitIOException() {
+    super("Failure triggered by MockRetrofit's NetworkBehavior");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index 5636e9dd5..263808dd4 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -36,8 +36,8 @@
  * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
  * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
  * <p>
- * By default, instances of this class will use a 2 second delay with 40% variance and failures
- * will occur 3% of the time.
+ * By default, instances of this class will use a 2 second delay with 40% variance. Failures
+ * will occur 3% of the time. HTTP errors will occur 0% of the time.
  */
 public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
@@ -54,6 +54,7 @@ public static NetworkBehavior create() {
    * Create an instance with default behavior which uses {@code random} to control variance and
    * failure calculation.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static NetworkBehavior create(Random random) {
     if (random == null) throw new NullPointerException("random == null");
     return new NetworkBehavior(random);
@@ -75,7 +76,7 @@ public static NetworkBehavior create(Random random) {
   private NetworkBehavior(Random random) {
     this.random = random;
 
-    failureException = new IOException("Mock failure!");
+    failureException = new MockRetrofitIOException();
     failureException.setStackTrace(new StackTraceElement[0]);
   }
 
@@ -120,6 +121,7 @@ public int failurePercent() {
    * It is a best practice to remove the stack trace from {@code exception} since it can
    * misleadingly point to code unrelated to this class.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public void setFailureException(Throwable exception) {
     if (exception == null) {
       throw new NullPointerException("exception == null");
@@ -147,6 +149,7 @@ public void setErrorPercent(int errorPercent) {
    * Set the error response factory to be used when an error is triggered. This factory may only
    * return responses for which {@link Response#isSuccessful()} returns false.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public void setErrorFactory(Callable<Response<?>> errorFactory) {
     if (errorFactory == null) {
       throw new NullPointerException("errorFactory == null");
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
new file mode 100644
index 000000000..f2e13328e
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.mock;
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
index f32f4c4ee..8b044175a 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -16,6 +16,7 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+import java.security.cert.CertificateException;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Test;
@@ -155,6 +156,19 @@
     assertTrue(taco.isExecuted());
   }
 
+  @Test public void failureExecuteCheckedException() {
+    CertificateException failure = new CertificateException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (Throwable e) {
+      assertSame(failure, e);
+    }
+    assertTrue(taco.isExecuted());
+  }
+
   @Test public void failureEnqueue() {
     IOException failure = new IOException("Hey");
     Call<Object> taco = Calls.failure(failure);
@@ -260,4 +274,19 @@
     });
     assertSame(failure, failureRef.get());
   }
+
+  @Test public void deferredThrowUncheckedExceptionEnqueue() {
+    final RuntimeException failure = new RuntimeException("Hey");
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    Calls.failure(failure).enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+  }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 300d57135..73de57911 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -33,7 +33,8 @@
 
   @Test public void defaultThrowable() {
     Throwable t = behavior.failureException();
-    assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage("Mock failure!");
+    assertThat(t).isInstanceOf(IOException.class)
+        .isExactlyInstanceOf(MockRetrofitIOException.class);
     assertThat(t.getStackTrace()).isEmpty();
   }
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index f4e4a45b8..eab2b859a 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -24,12 +24,27 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-stdlib</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlinx</groupId>
+      <artifactId>kotlinx-coroutines-core</artifactId>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>org.codehaus.mojo</groupId>
       <artifactId>animal-sniffer-annotations</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -41,11 +56,6 @@
       <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
@@ -62,4 +72,48 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>process-sources</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>retrofit2</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>retrofit2.internal</excludePackageNames>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index f729383a3..df0f1073d 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,14 +18,18 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import kotlin.Unit;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  /** Not volatile because we don't mind multiple threads discovering this. */
+  private boolean checkForKotlinUnit = true;
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type == ResponseBody.class) {
       return Utils.isAnnotationPresent(annotations, Streaming.class)
           ? StreamingResponseBodyConverter.INSTANCE
@@ -34,11 +38,19 @@
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
     }
+    if (checkForKotlinUnit) {
+      try {
+        if (type == Unit.class) {
+          return UnitResponseBodyConverter.INSTANCE;
+        }
+      } catch (NoClassDefFoundError ignored) {
+        checkForKotlinUnit = false;
+      }
+    }
     return null;
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
       return RequestBodyConverter.INSTANCE;
@@ -49,16 +61,25 @@
   static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
     static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
-    @Override public Void convert(ResponseBody value) throws IOException {
+    @Override public Void convert(ResponseBody value) {
       value.close();
       return null;
     }
   }
 
+  static final class UnitResponseBodyConverter implements Converter<ResponseBody, Unit> {
+    static final UnitResponseBodyConverter INSTANCE = new UnitResponseBodyConverter();
+
+    @Override public Unit convert(ResponseBody value) {
+      value.close();
+      return Unit.INSTANCE;
+    }
+  }
+
   static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
     static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
-    @Override public RequestBody convert(RequestBody value) throws IOException {
+    @Override public RequestBody convert(RequestBody value) {
       return value;
     }
   }
@@ -67,7 +88,7 @@
       implements Converter<ResponseBody, ResponseBody> {
     static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+    @Override public ResponseBody convert(ResponseBody value) {
       return value;
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 927540bf4..97d34585d 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 
 /**
  * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
@@ -64,7 +65,7 @@
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+    public abstract @Nullable CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit);
 
     /**
diff --git a/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
new file mode 100644
index 000000000..537c16412
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import javax.annotation.Nullable;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+@IgnoreJRERequirement // Only added when CompletableFuture is available (Java 8+ / Android API 24+).
+final class CompletableFutureCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new CompletableFutureCallAdapterFactory();
+
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  @IgnoreJRERequirement
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccessful()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  @IgnoreJRERequirement
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 880eea9b8..370a14710 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -17,7 +17,9 @@
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
@@ -37,7 +39,7 @@
  * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
-  T convert(F value) throws IOException;
+  @Nullable T convert(F value) throws IOException;
 
   /** Creates {@link Converter} instances based on a type and target usage. */
   abstract class Factory {
@@ -47,8 +49,8 @@
      * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
      * declaration.
      */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,
+        Annotation[] annotations, Retrofit retrofit) {
       return null;
     }
 
@@ -58,7 +60,7 @@
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
      */
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
+    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       return null;
     }
@@ -70,9 +72,25 @@
      * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
      * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,
         Retrofit retrofit) {
       return null;
     }
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..a16aef4b2 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -15,32 +15,110 @@
  */
 package retrofit2;
 
+import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
+import okhttp3.Request;
+
+import static retrofit2.Utils.checkNotNull;
 
-/**
- * Creates call adapters for that uses the same thread for both I/O and application-level
- * callbacks. For synchronous calls this is the application thread making the request; for
- * asynchronous calls this is a thread provided by OkHttp's dispatcher.
- */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
-  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+  private final @Nullable Executor callbackExecutor;
+
+  DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+    this.callbackExecutor = callbackExecutor;
+  }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)
+        ? null
+        : callbackExecutor;
 
-    final Type responseType = Utils.getCallResponseType(returnType);
     return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
       @Override public Call<Object> adapt(Call<Object> call) {
-        return call;
+        return executor == null
+            ? call
+            : new ExecutorCallbackCall<>(executor, call);
       }
     };
   }
+
+  static final class ExecutorCallbackCall<T> implements Call<T> {
+    final Executor callbackExecutor;
+    final Call<T> delegate;
+
+    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void enqueue(final Callback<T> callback) {
+      checkNotNull(callback, "callback == null");
+
+      delegate.enqueue(new Callback<T>() {
+        @Override public void onResponse(Call<T> call, final Response<T> response) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              if (delegate.isCanceled()) {
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+              } else {
+                callback.onResponse(ExecutorCallbackCall.this, response);
+              }
+            }
+          });
+        }
+
+        @Override public void onFailure(Call<T> call, final Throwable t) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              callback.onFailure(ExecutorCallbackCall.this, t);
+            }
+          });
+        }
+      });
+    }
+
+    @Override public boolean isExecuted() {
+      return delegate.isExecuted();
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      return delegate.execute();
+    }
+
+    @Override public void cancel() {
+      delegate.cancel();
+    }
+
+    @Override public boolean isCanceled() {
+      return delegate.isCanceled();
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+    @Override public Call<T> clone() {
+      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+    }
+
+    @Override public Request request() {
+      return delegate.request();
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
deleted file mode 100644
index a633d60e8..000000000
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.concurrent.Executor;
-import okhttp3.Request;
-
-final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object, Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public Call<Object> adapt(Call<Object> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
-    final Executor callbackExecutor;
-    final Call<T> delegate;
-
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
-    }
-
-    @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
-        }
-
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
-            }
-          });
-        }
-      });
-    }
-
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
-
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
-
-    @Override public void cancel() {
-      delegate.cancel();
-    }
-
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
-
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
-
-    @Override public Request request() {
-      return delegate.request();
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/HttpException.java b/retrofit/src/main/java/retrofit2/HttpException.java
index 0018948ed..f53e76e78 100644
--- a/retrofit/src/main/java/retrofit2/HttpException.java
+++ b/retrofit/src/main/java/retrofit2/HttpException.java
@@ -15,10 +15,14 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
+
+import static retrofit2.Utils.checkNotNull;
+
 /** Exception for an unexpected, non-2xx HTTP response. */
-public class HttpException extends Exception {
+public class HttpException extends RuntimeException {
   private static String getMessage(Response<?> response) {
-    if (response == null) throw new NullPointerException("response == null");
+    checkNotNull(response, "response == null");
     return "HTTP " + response.code() + " " + response.message();
   }
 
@@ -46,7 +50,7 @@ public String message() {
   /**
    * The full HTTP response. This may be null if the exception was serialized.
    */
-  public Response<?> response() {
+  public @Nullable Response<?> response() {
     return response;
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
new file mode 100644
index 000000000..bc8bdf814
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import kotlin.coroutines.Continuation;
+import okhttp3.ResponseBody;
+
+import static retrofit2.Utils.getRawType;
+import static retrofit2.Utils.methodError;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+abstract class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method that
+   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+   * method only once and reuse it.
+   */
+  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+      Retrofit retrofit, Method method, RequestFactory requestFactory) {
+    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
+    boolean continuationWantsResponse = false;
+    boolean continuationBodyNullable = false;
+
+    Annotation[] annotations = method.getAnnotations();
+    Type adapterType;
+    if (isKotlinSuspendFunction) {
+      Type[] parameterTypes = method.getGenericParameterTypes();
+      Type responseType = Utils.getParameterLowerBound(0,
+          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
+      if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {
+        // Unwrap the actual body type from Response<T>.
+        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
+        continuationWantsResponse = true;
+      } else {
+        // TODO figure out if type is nullable or not
+        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
+        // Find the entry for method
+        // Determine if return type is nullable or not
+      }
+
+      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
+      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
+    } else {
+      adapterType = method.getGenericReturnType();
+    }
+
+    CallAdapter<ResponseT, ReturnT> callAdapter =
+        createCallAdapter(retrofit, method, adapterType, annotations);
+    Type responseType = callAdapter.responseType();
+    if (responseType == okhttp3.Response.class) {
+      throw methodError(method, "'"
+          + getRawType(responseType).getName()
+          + "' is not a valid response body type. Did you mean ResponseBody?");
+    }
+    if (responseType == Response.class) {
+      throw methodError(method, "Response must include generic type (e.g., Response<String>)");
+    }
+    // TODO support Unit for Kotlin?
+    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+      throw methodError(method, "HEAD method must use Void as response type.");
+    }
+
+    Converter<ResponseBody, ResponseT> responseConverter =
+        createResponseConverter(retrofit, method, responseType);
+
+    okhttp3.Call.Factory callFactory = retrofit.callFactory;
+    if (!isKotlinSuspendFunction) {
+      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);
+    } else if (continuationWantsResponse) {
+      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
+      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,
+          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);
+    } else {
+      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
+      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,
+          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,
+          continuationBodyNullable);
+    }
+  }
+
+  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+      Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) {
+    try {
+      //noinspection unchecked
+      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+    }
+  }
+
+  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+      Retrofit retrofit, Method method, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseBodyConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, "Unable to create converter for %s", responseType);
+    }
+  }
+
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+      Converter<ResponseBody, ResponseT> responseConverter) {
+    this.requestFactory = requestFactory;
+    this.callFactory = callFactory;
+    this.responseConverter = responseConverter;
+  }
+
+  @Override final @Nullable ReturnT invoke(Object[] args) {
+    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
+    return adapt(call, args);
+  }
+
+  protected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);
+
+  static final class CallAdapted<ResponseT, ReturnT> extends HttpServiceMethod<ResponseT, ReturnT> {
+    private final CallAdapter<ResponseT, ReturnT> callAdapter;
+
+    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+        Converter<ResponseBody, ResponseT> responseConverter,
+        CallAdapter<ResponseT, ReturnT> callAdapter) {
+      super(requestFactory, callFactory, responseConverter);
+      this.callAdapter = callAdapter;
+    }
+
+    @Override protected ReturnT adapt(Call<ResponseT> call, Object[] args) {
+      return callAdapter.adapt(call);
+    }
+  }
+
+  static final class SuspendForResponse<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
+    private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
+
+    SuspendForResponse(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+        Converter<ResponseBody, ResponseT> responseConverter,
+        CallAdapter<ResponseT, Call<ResponseT>> callAdapter) {
+      super(requestFactory, callFactory, responseConverter);
+      this.callAdapter = callAdapter;
+    }
+
+    @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
+      call = callAdapter.adapt(call);
+
+      //noinspection unchecked Checked by reflection inside RequestFactory.
+      Continuation<Response<ResponseT>> continuation =
+          (Continuation<Response<ResponseT>>) args[args.length - 1];
+      return KotlinExtensions.awaitResponse(call, continuation);
+    }
+  }
+
+  static final class SuspendForBody<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
+    private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
+    private final boolean isNullable;
+
+    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+        Converter<ResponseBody, ResponseT> responseConverter,
+        CallAdapter<ResponseT, Call<ResponseT>> callAdapter, boolean isNullable) {
+      super(requestFactory, callFactory, responseConverter);
+      this.callAdapter = callAdapter;
+      this.isNullable = isNullable;
+    }
+
+    @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
+      call = callAdapter.adapt(call);
+
+      //noinspection unchecked Checked by reflection inside RequestFactory.
+      Continuation<ResponseT> continuation = (Continuation<ResponseT>) args[args.length - 1];
+      return isNullable
+          ? KotlinExtensions.awaitNullable(call, continuation)
+          : KotlinExtensions.await(call, continuation);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Invocation.java b/retrofit/src/main/java/retrofit2/Invocation.java
new file mode 100644
index 000000000..6f1ca5fb4
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/Invocation.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static retrofit2.Utils.checkNotNull;
+
+/**
+ * A single invocation of a Retrofit service interface method. This class captures both the method
+ * that was called and the arguments to the method.
+ *
+ * <p>Retrofit automatically adds an invocation to each OkHttp request as a tag. You can retrieve
+ * the invocation in an OkHttp interceptor for metrics and monitoring.
+ *
+ * <pre><code>
+ * class InvocationLogger implements Interceptor {
+ *   &#64;Override public Response intercept(Chain chain) throws IOException {
+ *     Request request = chain.request();
+ *     Invocation invocation = request.tag(Invocation.class);
+ *     if (invocation != null) {
+ *       System.out.printf("%s.%s %s%n",
+ *           invocation.method().getDeclaringClass().getSimpleName(),
+ *           invocation.method().getName(), invocation.arguments());
+ *     }
+ *     return chain.proceed(request);
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <strong>Note:</strong> use caution when examining an invocation's arguments. Although the
+ * arguments list is unmodifiable, the arguments themselves may be mutable. They may also be unsafe
+ * for concurrent access. For best results declare Retrofit service interfaces using only immutable
+ * types for parameters!
+ */
+public final class Invocation {
+  public static Invocation of(Method method, List<?> arguments) {
+    checkNotNull(method, "method == null");
+    checkNotNull(arguments, "arguments == null");
+    return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
+  }
+
+  private final Method method;
+  private final List<?> arguments;
+
+  /** Trusted constructor assumes ownership of {@code arguments}. */
+  Invocation(Method method, List<?> arguments) {
+    this.method = method;
+    this.arguments = Collections.unmodifiableList(arguments);
+  }
+
+  public Method method() {
+    return method;
+  }
+
+  public List<?> arguments() {
+    return arguments;
+  }
+
+  @Override public String toString() {
+    return String.format("%s.%s() %s",
+        method.getDeclaringClass().getName(), method.getName(), arguments);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
new file mode 100644
index 000000000..b24212e08
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@file:JvmName("KotlinExtensions")
+
+package retrofit2
+
+import kotlinx.coroutines.suspendCancellableCoroutine
+import kotlin.coroutines.resume
+import kotlin.coroutines.resumeWithException
+
+inline fun <reified T> Retrofit.create(): T = create(T::class.java)
+
+suspend fun <T : Any> Call<T>.await(): T {
+  return suspendCancellableCoroutine { continuation ->
+    continuation.invokeOnCancellation {
+      cancel()
+    }
+    enqueue(object : Callback<T> {
+      override fun onResponse(call: Call<T>, response: Response<T>) {
+        if (response.isSuccessful) {
+          val body = response.body()
+          if (body == null) {
+            val invocation = call.request().tag(Invocation::class.java)!!
+            val method = invocation.method()
+            val e = KotlinNullPointerException("Response from " +
+                method.declaringClass.name +
+                '.' +
+                method.name +
+                " was null but response body type was declared as non-null")
+            continuation.resumeWithException(e)
+          } else {
+            continuation.resume(body)
+          }
+        } else {
+          continuation.resumeWithException(HttpException(response))
+        }
+      }
+
+      override fun onFailure(call: Call<T>, t: Throwable) {
+        continuation.resumeWithException(t)
+      }
+    })
+  }
+}
+
+@JvmName("awaitNullable")
+suspend fun <T : Any> Call<T?>.await(): T? {
+  return suspendCancellableCoroutine { continuation ->
+    continuation.invokeOnCancellation {
+      cancel()
+    }
+    enqueue(object : Callback<T?> {
+      override fun onResponse(call: Call<T?>, response: Response<T?>) {
+        if (response.isSuccessful) {
+          continuation.resume(response.body())
+        } else {
+          continuation.resumeWithException(HttpException(response))
+        }
+      }
+
+      override fun onFailure(call: Call<T?>, t: Throwable) {
+        continuation.resumeWithException(t)
+      }
+    })
+  }
+}
+
+suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
+  return suspendCancellableCoroutine { continuation ->
+    continuation.invokeOnCancellation {
+      cancel()
+    }
+    enqueue(object : Callback<T> {
+      override fun onResponse(call: Call<T>, response: Response<T>) {
+        continuation.resume(response)
+      }
+
+      override fun onFailure(call: Call<T>, t: Throwable) {
+        continuation.resumeWithException(t)
+      }
+    })
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index ccbfe1ab2..a5b5b9237 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,8 @@
 package retrofit2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -24,25 +26,35 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+import static retrofit2.Utils.checkNotNull;
+import static retrofit2.Utils.throwIfFatal;
+
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T, ?> serviceMethod;
+  private final RequestFactory requestFactory;
   private final Object[] args;
+  private final okhttp3.Call.Factory callFactory;
+  private final Converter<ResponseBody, T> responseConverter;
 
   private volatile boolean canceled;
 
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
+  @GuardedBy("this")
+  private @Nullable okhttp3.Call rawCall;
+  @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
+  private @Nullable Throwable creationFailure;
+  @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
-    this.serviceMethod = serviceMethod;
+  OkHttpCall(RequestFactory requestFactory, Object[] args,
+      okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
+    this.requestFactory = requestFactory;
     this.args = args;
+    this.callFactory = callFactory;
+    this.responseConverter = responseConverter;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(serviceMethod, args);
+    return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
   }
 
   @Override public synchronized Request request() {
@@ -53,13 +65,16 @@
     if (creationFailure != null) {
       if (creationFailure instanceof IOException) {
         throw new RuntimeException("Unable to create request.", creationFailure);
-      } else {
+      } else if (creationFailure instanceof RuntimeException) {
         throw (RuntimeException) creationFailure;
+      } else {
+        throw (Error) creationFailure;
       }
     }
     try {
       return (rawCall = createRawCall()).request();
-    } catch (RuntimeException e) {
+    } catch (RuntimeException | Error e) {
+      throwIfFatal(e); // Do not assign a fatal error to creationFailure.
       creationFailure = e;
       throw e;
     } catch (IOException e) {
@@ -69,7 +84,7 @@
   }
 
   @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    checkNotNull(callback, "callback == null");
 
     okhttp3.Call call;
     Throwable failure;
@@ -84,6 +99,7 @@
         try {
           call = rawCall = createRawCall();
         } catch (Throwable t) {
+          throwIfFatal(t);
           failure = creationFailure = t;
         }
       }
@@ -99,39 +115,34 @@
     }
 
     call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
-          throws IOException {
+      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
         Response<T> response;
         try {
           response = parseResponse(rawResponse);
         } catch (Throwable e) {
+          throwIfFatal(e);
           callFailure(e);
           return;
         }
-        callSuccess(response);
-      }
 
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
         try {
-          callback.onFailure(OkHttpCall.this, e);
+          callback.onResponse(OkHttpCall.this, response);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
 
-      private void callFailure(Throwable e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
-        }
+      @Override public void onFailure(okhttp3.Call call, IOException e) {
+        callFailure(e);
       }
 
-      private void callSuccess(Response<T> response) {
+      private void callFailure(Throwable e) {
         try {
-          callback.onResponse(OkHttpCall.this, response);
+          callback.onFailure(OkHttpCall.this, e);
         } catch (Throwable t) {
-          t.printStackTrace();
+          throwIfFatal(t);
+          t.printStackTrace(); // TODO this is not great
         }
       }
     });
@@ -151,8 +162,10 @@ private void callSuccess(Response<T> response) {
       if (creationFailure != null) {
         if (creationFailure instanceof IOException) {
           throw (IOException) creationFailure;
-        } else {
+        } else if (creationFailure instanceof RuntimeException) {
           throw (RuntimeException) creationFailure;
+        } else {
+          throw (Error) creationFailure;
         }
       }
 
@@ -160,7 +173,8 @@ private void callSuccess(Response<T> response) {
       if (call == null) {
         try {
           call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException e) {
+        } catch (IOException | RuntimeException | Error e) {
+          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
           creationFailure = e;
           throw e;
         }
@@ -175,8 +189,7 @@ private void callSuccess(Response<T> response) {
   }
 
   private okhttp3.Call createRawCall() throws IOException {
-    Request request = serviceMethod.toRequest(args);
-    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
     if (call == null) {
       throw new NullPointerException("Call.Factory returned null.");
     }
@@ -207,9 +220,9 @@ private void callSuccess(Response<T> response) {
       return Response.success(null, rawResponse);
     }
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
     try {
-      T body = serviceMethod.toResponse(catchingBody);
+      T body = responseConverter.convert(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -241,10 +254,10 @@ public void cancel() {
   }
 
   static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
+    private final @Nullable MediaType contentType;
     private final long contentLength;
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
+    NoContentResponseBody(@Nullable MediaType contentType, long contentLength) {
       this.contentType = contentType;
       this.contentLength = contentLength;
     }
@@ -262,12 +275,23 @@ public void cancel() {
     }
   }
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
+  static final class ExceptionCatchingResponseBody extends ResponseBody {
     private final ResponseBody delegate;
-    IOException thrownException;
+    private final BufferedSource delegateSource;
+    @Nullable IOException thrownException;
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
+    ExceptionCatchingResponseBody(ResponseBody delegate) {
       this.delegate = delegate;
+      this.delegateSource = Okio.buffer(new ForwardingSource(delegate.source()) {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          try {
+            return super.read(sink, byteCount);
+          } catch (IOException e) {
+            thrownException = e;
+            throw e;
+          }
+        }
+      });
     }
 
     @Override public MediaType contentType() {
@@ -279,16 +303,7 @@ public void cancel() {
     }
 
     @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
-        }
-      });
+      return delegateSource;
     }
 
     @Override public void close() {
diff --git a/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java b/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java
new file mode 100644
index 000000000..a9325322c
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+@IgnoreJRERequirement // Only added when Optional is available (Java 8+ / Android API 24+).
+final class OptionalConverterFactory extends Converter.Factory {
+  static final Converter.Factory INSTANCE = new OptionalConverterFactory();
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.responseBodyConverter(innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+
+  @IgnoreJRERequirement
+  static final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+    final Converter<ResponseBody, T> delegate;
+
+    OptionalConverter(Converter<ResponseBody, T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public Optional<T> convert(ResponseBody value) throws IOException {
+      return Optional.ofNullable(delegate.convert(value));
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index f0aa001d1..1d416c475 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -17,19 +17,21 @@
 
 import java.io.IOException;
 import java.lang.reflect.Array;
+import java.lang.reflect.Method;
 import java.util.Map;
-import okhttp3.Headers;
+import javax.annotation.Nullable;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
 
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, T value) throws IOException;
+  abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
 
   final ParameterHandler<Iterable<T>> iterable() {
     return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+      @Override void apply(RequestBuilder builder, @Nullable Iterable<T> values)
+          throws IOException {
         if (values == null) return; // Skip null values.
 
         for (T value : values) {
@@ -41,7 +43,7 @@
 
   final ParameterHandler<Object> array() {
     return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, Object values) throws IOException {
+      @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException {
         if (values == null) return; // Skip null values.
 
         for (int i = 0, size = Array.getLength(values); i < size; i++) {
@@ -53,7 +55,18 @@
   }
 
   static final class RelativeUrl extends ParameterHandler<Object> {
-    @Override void apply(RequestBuilder builder, Object value) {
+    private final Method method;
+    private final int p;
+
+    RelativeUrl(Method method, int p) {
+      this.method = method;
+      this.p = p;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable Object value) {
+      if (value == null) {
+        throw Utils.parameterError(method, p, "@Url parameter is null.");
+      }
       builder.setRelativeUrl(value);
     }
   }
@@ -67,27 +80,36 @@
       this.valueConverter = valueConverter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
+
+      String headerValue = valueConverter.convert(value);
+      if (headerValue == null) return; // Skip converted but null values.
+
+      builder.addHeader(name, headerValue);
     }
   }
 
   static final class Path<T> extends ParameterHandler<T> {
+    private final Method method;
+    private final int p;
     private final String name;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+
+    Path(Method method, int p, String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.method = method;
+      this.p = p;
       this.name = checkNotNull(name, "name == null");
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
+        throw Utils.parameterError(method, p,
+                "Path parameter \"" + name + "\" value must not be null.");
       }
       builder.addPathParam(name, valueConverter.convert(value), encoded);
     }
@@ -104,9 +126,13 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
+
+      String queryValue = valueConverter.convert(value);
+      if (queryValue == null) return; // Skip converted but null values
+
+      builder.addQueryParam(name, queryValue, encoded);
     }
   }
 
@@ -119,68 +145,107 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
       builder.addQueryParam(nameConverter.convert(value), null, encoded);
     }
   }
 
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+    QueryMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Query map was null.");
+        throw Utils.parameterError(method, p, "Query map was null");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
+          throw Utils.parameterError(method, p, "Query map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Query map contained null value for key '" + entryKey + "'.");
+          throw Utils.parameterError(method, p,
+                  "Query map contained null value for key '" + entryKey + "'.");
+        }
+
+        String convertedEntryValue = valueConverter.convert(entryValue);
+        if (convertedEntryValue == null) {
+          throw Utils.parameterError(method, p, "Query map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
         }
-        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+
+        builder.addQueryParam(entryKey, convertedEntryValue, encoded);
       }
     }
   }
 
   static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, String> valueConverter;
 
-    HeaderMap(Converter<T, String> valueConverter) {
+    HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Header map was null.");
+        throw Utils.parameterError(method, p, "Header map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String headerName = entry.getKey();
         if (headerName == null) {
-          throw new IllegalArgumentException("Header map contained null key.");
+          throw Utils.parameterError(method, p, "Header map contained null key.");
         }
         T headerValue = entry.getValue();
         if (headerValue == null) {
-          throw new IllegalArgumentException(
-              "Header map contained null value for key '" + headerName + "'.");
+          throw Utils.parameterError(method, p,
+                  "Header map contained null value for key '" + headerName + "'.");
         }
         builder.addHeader(headerName, valueConverter.convert(headerValue));
       }
     }
   }
 
+  static final class Headers extends ParameterHandler<okhttp3.Headers> {
+    private final Method method;
+    private final int p;
+
+    Headers(Method method, int p) {
+      this.method = method;
+      this.p = p;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable okhttp3.Headers headers) {
+      if (headers == null) {
+        throw Utils.parameterError(method, p, "Headers parameter must not be null.");
+      }
+      builder.addHeaders(headers);
+    }
+  }
+
   static final class Field<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -192,58 +257,83 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
+
+      String fieldValue = valueConverter.convert(value);
+      if (fieldValue == null) return; // Skip null converted values
+
+      builder.addFormField(name, fieldValue, encoded);
     }
   }
 
   static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+    FieldMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Field map was null.");
+        throw Utils.parameterError(method, p, "Field map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
+          throw Utils.parameterError(method, p, "Field map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Field map contained null value for key '" + entryKey + "'.");
+          throw Utils.parameterError(method, p,
+                  "Field map contained null value for key '" + entryKey + "'.");
+        }
+
+        String fieldEntry = valueConverter.convert(entryValue);
+        if (fieldEntry == null) {
+          throw Utils.parameterError(method, p, "Field map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
         }
-        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+
+        builder.addFormField(entryKey, fieldEntry, encoded);
       }
     }
   }
 
   static final class Part<T> extends ParameterHandler<T> {
-    private final Headers headers;
+    private final Method method;
+    private final int p;
+    private final okhttp3.Headers headers;
     private final Converter<T, RequestBody> converter;
 
-    Part(Headers headers, Converter<T, RequestBody> converter) {
+    Part(Method method, int p, okhttp3.Headers headers, Converter<T, RequestBody> converter) {
+      this.method = method;
+      this.p = p;
       this.headers = headers;
       this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) return; // Skip null values.
 
       RequestBody body;
       try {
         body = converter.convert(value);
       } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+        throw Utils.parameterError(method, p, "Unable to convert " + value + " to RequestBody", e);
       }
       builder.addPart(headers, body);
     }
@@ -255,7 +345,7 @@
     private RawPart() {
     }
 
-    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable MultipartBody.Part value) {
       if (value != null) { // Skip null values.
         builder.addPart(value);
       }
@@ -263,31 +353,37 @@ private RawPart() {
   }
 
   static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Method method;
+    private final int p;
     private final Converter<T, RequestBody> valueConverter;
     private final String transferEncoding;
 
-    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+    PartMap(Method method, int p,
+            Converter<T, RequestBody> valueConverter, String transferEncoding) {
+      this.method = method;
+      this.p = p;
       this.valueConverter = valueConverter;
       this.transferEncoding = transferEncoding;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
-        throw new IllegalArgumentException("Part map was null.");
+        throw Utils.parameterError(method, p, "Part map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
+          throw Utils.parameterError(method, p, "Part map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Part map contained null value for key '" + entryKey + "'.");
+          throw Utils.parameterError(method, p,
+                  "Part map contained null value for key '" + entryKey + "'.");
         }
 
-        Headers headers = Headers.of(
+        okhttp3.Headers headers = okhttp3.Headers.of(
             "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
             "Content-Transfer-Encoding", transferEncoding);
 
@@ -297,23 +393,39 @@ private RawPart() {
   }
 
   static final class Body<T> extends ParameterHandler<T> {
+    private final Method method;
+    private final int p;
     private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T, RequestBody> converter) {
+    Body(Method method, int p, Converter<T, RequestBody> converter) {
+      this.method = method;
+      this.p = p;
       this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
+        throw Utils.parameterError(method, p, "Body parameter value must not be null.");
       }
       RequestBody body;
       try {
         body = converter.convert(value);
       } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+        throw Utils.parameterError(method, e, p, "Unable to convert " + value + " to RequestBody");
       }
       builder.setBody(body);
     }
   }
+
+  static final class Tag<T> extends ParameterHandler<T> {
+    final Class<T> cls;
+
+    Tag(Class<T> cls) {
+      this.cls = cls;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
+      builder.addTag(cls, value);
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index ad9cf533c..f24d4817a 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -21,9 +21,18 @@
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.unmodifiableList;
+
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
@@ -47,23 +56,33 @@ private static Platform findPlatform() {
     return new Platform();
   }
 
-  Executor defaultCallbackExecutor() {
+  @Nullable Executor defaultCallbackExecutor() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
-    }
-    return DefaultCallAdapterFactory.INSTANCE;
+  List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+      @Nullable Executor callbackExecutor) {
+    return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
+  }
+
+  int defaultCallAdapterFactoriesSize() {
+    return 1;
+  }
+
+  List<? extends Converter.Factory> defaultConverterFactories() {
+    return emptyList();
+  }
+
+  int defaultConverterFactoriesSize() {
+    return 0;
   }
 
   boolean isDefaultMethod(Method method) {
     return false;
   }
 
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
+  @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+      @Nullable Object... args) throws Throwable {
     throw new UnsupportedOperationException();
   }
 
@@ -74,7 +93,7 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
     }
 
     @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
+        @Nullable Object... args) throws Throwable {
       // Because the service interface might not be public, we need to use a MethodHandle lookup
       // that ignores the visibility of the declaringClass.
       Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
@@ -84,15 +103,62 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
           .bindTo(object)
           .invokeWithArguments(args);
     }
+
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
+      List<CallAdapter.Factory> factories = new ArrayList<>(2);
+      factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
+      factories.add(new DefaultCallAdapterFactory(callbackExecutor));
+      return unmodifiableList(factories);
+    }
+
+    @Override int defaultCallAdapterFactoriesSize() {
+      return 2;
+    }
+
+    @Override List<? extends Converter.Factory> defaultConverterFactories() {
+      return singletonList(OptionalConverterFactory.INSTANCE);
+    }
+
+    @Override int defaultConverterFactoriesSize() {
+      return 1;
+    }
   }
 
   static class Android extends Platform {
+    @IgnoreJRERequirement // Guarded by API check.
+    @Override boolean isDefaultMethod(Method method) {
+      if (Build.VERSION.SDK_INT < 24) {
+        return false;
+      }
+      return method.isDefault();
+    }
+
     @Override public Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
+      if (callbackExecutor == null) throw new AssertionError();
+      DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);
+      return Build.VERSION.SDK_INT >= 24
+        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
+        : singletonList(executorFactory);
+    }
+
+    @Override int defaultCallAdapterFactoriesSize() {
+      return Build.VERSION.SDK_INT >= 24 ? 2 : 1;
+    }
+
+    @Override List<? extends Converter.Factory> defaultConverterFactories() {
+      return Build.VERSION.SDK_INT >= 24
+          ? singletonList(OptionalConverterFactory.INSTANCE)
+          : Collections.<Converter.Factory>emptyList();
+    }
+
+    @Override int defaultConverterFactoriesSize() {
+      return Build.VERSION.SDK_INT >= 24 ? 1 : 0;
     }
 
     static class MainThreadExecutor implements Executor {
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 3a25b6f53..6aab20dfc 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,8 @@
 package retrofit2;
 
 import java.io.IOException;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -31,22 +33,39 @@
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
   private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
 
+  /**
+   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also
+   * matches dots in their percent-encoded form, {@code %2E}.
+   *
+   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code
+   * index.html}) but when alone they have a special meaning. A single dot resolves to no path
+   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding
+   * directory, so {@code /one/../three/} becomes {@code /three/}.
+   *
+   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.
+   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE
+   * /account/}.
+   */
+  private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");
+
   private final String method;
 
   private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
+  private @Nullable String relativeUrl;
+  private @Nullable HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType contentType;
+  private final Headers.Builder headersBuilder;
+  private @Nullable MediaType contentType;
 
   private final boolean hasBody;
-  private MultipartBody.Builder multipartBuilder;
-  private FormBody.Builder formBuilder;
-  private RequestBody body;
+  private @Nullable MultipartBody.Builder multipartBuilder;
+  private @Nullable FormBody.Builder formBuilder;
+  private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl,
+      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
+      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -55,7 +74,9 @@
     this.hasBody = hasBody;
 
     if (headers != null) {
-      requestBuilder.headers(headers);
+      headersBuilder = headers.newBuilder();
+    } else {
+      headersBuilder = new Headers.Builder();
     }
 
     if (isFormEncoded) {
@@ -69,28 +90,37 @@
   }
 
   void setRelativeUrl(Object relativeUrl) {
-    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
     this.relativeUrl = relativeUrl.toString();
   }
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      MediaType type = MediaType.parse(value);
-      if (type == null) {
-        throw new IllegalArgumentException("Malformed content type: " + value);
+      try {
+        contentType = MediaType.get(value);
+      } catch (IllegalArgumentException e) {
+        throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
-      contentType = type;
     } else {
-      requestBuilder.addHeader(name, value);
+      headersBuilder.add(name, value);
     }
   }
 
+  void addHeaders(Headers headers) {
+    headersBuilder.addAll(headers);
+  }
+
   void addPathParam(String name, String value, boolean encoded) {
     if (relativeUrl == null) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
+    String replacement = canonicalizeForPath(value, encoded);
+    String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);
+    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
+      throw new IllegalArgumentException(
+          "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);
+    }
+    relativeUrl = newRelativeUrl;
   }
 
   private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
@@ -142,7 +172,7 @@ private static void canonicalizeForPath(Buffer out, String input, int pos, int l
     }
   }
 
-  void addQueryParam(String name, String value, boolean encoded) {
+  void addQueryParam(String name, @Nullable String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
       urlBuilder = baseUrl.newBuilder(relativeUrl);
@@ -154,12 +184,15 @@ void addQueryParam(String name, String value, boolean encoded) {
     }
 
     if (encoded) {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addEncodedQueryParameter(name, value);
     } else {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addQueryParameter(name, value);
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
   void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
       formBuilder.addEncoded(name, value);
@@ -168,10 +201,12 @@ void addFormField(String name, String value, boolean encoded) {
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(Headers headers, RequestBody body) {
     multipartBuilder.addPart(headers, body);
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(MultipartBody.Part part) {
     multipartBuilder.addPart(part);
   }
@@ -180,13 +215,18 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  <T> void addTag(Class<T> cls, @Nullable T value) {
+    requestBuilder.tag(cls, value);
+  }
+
+  Request.Builder get() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
     if (urlBuilder != null) {
       url = urlBuilder.build();
     } else {
       // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      //noinspection ConstantConditions Non-null if urlBuilder is null.
       url = baseUrl.resolve(relativeUrl);
       if (url == null) {
         throw new IllegalArgumentException(
@@ -212,14 +252,14 @@ Request build() {
       if (body != null) {
         body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
+        headersBuilder.add("Content-Type", contentType.toString());
       }
     }
 
     return requestBuilder
         .url(url)
-        .method(method, body)
-        .build();
+        .headers(headersBuilder.build())
+        .method(method, body);
   }
 
   private static class ContentTypeOverridingRequestBody extends RequestBody {
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
new file mode 100644
index 000000000..cc43226ed
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -0,0 +1,805 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import kotlin.coroutines.Continuation;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
+import retrofit2.http.Body;
+import retrofit2.http.DELETE;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.HEAD;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Multipart;
+import retrofit2.http.OPTIONS;
+import retrofit2.http.PATCH;
+import retrofit2.http.POST;
+import retrofit2.http.PUT;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
+import retrofit2.http.Tag;
+import retrofit2.http.Url;
+
+import static retrofit2.Utils.methodError;
+import static retrofit2.Utils.parameterError;
+
+final class RequestFactory {
+  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
+    return new Builder(retrofit, method).build();
+  }
+
+  private final Method method;
+  private final HttpUrl baseUrl;
+  final String httpMethod;
+  private final @Nullable String relativeUrl;
+  private final @Nullable Headers headers;
+  private final @Nullable MediaType contentType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final ParameterHandler<?>[] parameterHandlers;
+  final boolean isKotlinSuspendFunction;
+
+  RequestFactory(Builder builder) {
+    method = builder.method;
+    baseUrl = builder.retrofit.baseUrl;
+    httpMethod = builder.httpMethod;
+    relativeUrl = builder.relativeUrl;
+    headers = builder.headers;
+    contentType = builder.contentType;
+    hasBody = builder.hasBody;
+    isFormEncoded = builder.isFormEncoded;
+    isMultipart = builder.isMultipart;
+    parameterHandlers = builder.parameterHandlers;
+    isKotlinSuspendFunction = builder.isKotlinSuspendFunction;
+  }
+
+  okhttp3.Request create(Object[] args) throws IOException {
+    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
+
+    int argumentCount = args.length;
+    if (argumentCount != handlers.length) {
+      throw new IllegalArgumentException("Argument count (" + argumentCount
+          + ") doesn't match expected count (" + handlers.length + ")");
+    }
+
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
+        headers, contentType, hasBody, isFormEncoded, isMultipart);
+
+    if (isKotlinSuspendFunction) {
+      // The Continuation is the last parameter and the handlers array contains null at that index.
+      argumentCount--;
+    }
+
+    List<Object> argumentList = new ArrayList<>(argumentCount);
+    for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
+      handlers[p].apply(requestBuilder, args[p]);
+    }
+
+    return requestBuilder.get()
+        .tag(Invocation.class, new Invocation(method, argumentList))
+        .build();
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder {
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+    final Retrofit retrofit;
+    final Method method;
+    final Annotation[] methodAnnotations;
+    final Annotation[][] parameterAnnotationsArray;
+    final Type[] parameterTypes;
+
+    boolean gotField;
+    boolean gotPart;
+    boolean gotBody;
+    boolean gotPath;
+    boolean gotQuery;
+    boolean gotQueryName;
+    boolean gotQueryMap;
+    boolean gotUrl;
+    @Nullable String httpMethod;
+    boolean hasBody;
+    boolean isFormEncoded;
+    boolean isMultipart;
+    @Nullable String relativeUrl;
+    @Nullable Headers headers;
+    @Nullable MediaType contentType;
+    @Nullable Set<String> relativeUrlParamNames;
+    @Nullable ParameterHandler<?>[] parameterHandlers;
+    boolean isKotlinSuspendFunction;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+      this.methodAnnotations = method.getAnnotations();
+      this.parameterTypes = method.getGenericParameterTypes();
+      this.parameterAnnotationsArray = method.getParameterAnnotations();
+    }
+
+    RequestFactory build() {
+      for (Annotation annotation : methodAnnotations) {
+        parseMethodAnnotation(annotation);
+      }
+
+      if (httpMethod == null) {
+        throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+      }
+
+      if (!hasBody) {
+        if (isMultipart) {
+          throw methodError(method,
+              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+        }
+        if (isFormEncoded) {
+          throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
+              + "request body (e.g., @POST).");
+        }
+      }
+
+      int parameterCount = parameterAnnotationsArray.length;
+      parameterHandlers = new ParameterHandler<?>[parameterCount];
+      for (int p = 0, lastParameter = parameterCount - 1; p < parameterCount; p++) {
+        parameterHandlers[p] =
+            parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);
+      }
+
+      if (relativeUrl == null && !gotUrl) {
+        throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
+      }
+      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+        throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+      }
+      if (isFormEncoded && !gotField) {
+        throw methodError(method, "Form-encoded method must contain at least one @Field.");
+      }
+      if (isMultipart && !gotPart) {
+        throw methodError(method, "Multipart method must contain at least one @Part.");
+      }
+
+      return new RequestFactory(this);
+    }
+
+    private void parseMethodAnnotation(Annotation annotation) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof OPTIONS) {
+        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof retrofit2.http.Headers) {
+        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError(method, "@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+      if (this.httpMethod != null) {
+        throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+            this.httpMethod, httpMethod);
+      }
+      this.httpMethod = httpMethod;
+      this.hasBody = hasBody;
+
+      if (value.isEmpty()) {
+        return;
+      }
+
+      // Get the relative URL path and existing query string, if present.
+      int question = value.indexOf('?');
+      if (question != -1 && question < value.length() - 1) {
+        // Ensure the query string does not have any named parameters.
+        String queryParams = value.substring(question + 1);
+        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+        if (queryParamMatcher.find()) {
+          throw methodError(method, "URL query string \"%s\" must not have replace block. "
+              + "For dynamic query parameters use @Query.", queryParams);
+        }
+      }
+
+      this.relativeUrl = value;
+      this.relativeUrlParamNames = parsePathParameters(value);
+    }
+
+    private Headers parseHeaders(String[] headers) {
+      Headers.Builder builder = new Headers.Builder();
+      for (String header : headers) {
+        int colon = header.indexOf(':');
+        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+          throw methodError(method,
+              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        }
+        String headerName = header.substring(0, colon);
+        String headerValue = header.substring(colon + 1).trim();
+        if ("Content-Type".equalsIgnoreCase(headerName)) {
+          try {
+            contentType = MediaType.get(headerValue);
+          } catch (IllegalArgumentException e) {
+            throw methodError(method, e, "Malformed content type: %s", headerValue);
+          }
+        } else {
+          builder.add(headerName, headerValue);
+        }
+      }
+      return builder.build();
+    }
+
+    private @Nullable ParameterHandler<?> parseParameter(
+        int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) {
+      ParameterHandler<?> result = null;
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
+
+          if (annotationAction == null) {
+            continue;
+          }
+
+          if (result != null) {
+            throw parameterError(method, p,
+                "Multiple Retrofit annotations found, only one allowed.");
+          }
+
+          result = annotationAction;
+        }
+      }
+
+      if (result == null) {
+        if (allowContinuation) {
+          try {
+            if (Utils.getRawType(parameterType) == Continuation.class) {
+              isKotlinSuspendFunction = true;
+              return null;
+            }
+          } catch (NoClassDefFoundError ignored) {
+          }
+        }
+        throw parameterError(method, p, "No Retrofit annotation found.");
+      }
+
+      return result;
+    }
+
+    @Nullable
+    private ParameterHandler<?> parseParameterAnnotation(
+        int p, Type type, Annotation[] annotations, Annotation annotation) {
+      if (annotation instanceof Url) {
+        validateResolvableType(p, type);
+        if (gotUrl) {
+          throw parameterError(method, p, "Multiple @Url method annotations found.");
+        }
+        if (gotPath) {
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+        }
+        if (gotQuery) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
+        }
+        if (relativeUrl != null) {
+          throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
+        }
+
+        gotUrl = true;
+
+        if (type == HttpUrl.class
+            || type == String.class
+            || type == URI.class
+            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+          return new ParameterHandler.RelativeUrl(method, p);
+        } else {
+          throw parameterError(method, p,
+              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        }
+
+      } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
+        if (gotQuery) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
+        }
+        if (gotUrl) {
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+        }
+        if (relativeUrl == null) {
+          throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+              httpMethod);
+        }
+        gotPath = true;
+
+        Path path = (Path) annotation;
+        String name = path.value();
+        validatePathName(p, name);
+
+        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+        return new ParameterHandler.Path<>(method, p, name, converter, path.encoded());
+
+      } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
+        Query query = (Query) annotation;
+        String name = query.value();
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQueryName = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQueryMap = true;
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@QueryMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.QueryMap<>(method, p,
+                valueConverter, ((QueryMap) annotation).encoded());
+
+      } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
+        Header header = (Header) annotation;
+        String name = header.value();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Header<>(name, converter).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Header<>(name, converter).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Header<>(name, converter);
+        }
+
+      } else if (annotation instanceof HeaderMap) {
+        if (type == Headers.class) {
+          return new ParameterHandler.Headers(method, p);
+        }
+
+        validateResolvableType(p, type);
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
+
+      } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
+        if (!isFormEncoded) {
+          throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
+        }
+        Field field = (Field) annotation;
+        String name = field.value();
+        boolean encoded = field.encoded();
+
+        gotField = true;
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(method, p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
+        if (!isFormEncoded) {
+          throw parameterError(method, p,
+              "@FieldMap parameters can only be used with form encoding.");
+        }
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@FieldMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        gotField = true;
+        return new ParameterHandler.FieldMap<>(method, p,
+                valueConverter, ((FieldMap) annotation).encoded());
+
+      } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
+        if (!isMultipart) {
+          throw parameterError(method, p,
+              "@Part parameters can only be used with multipart encoding.");
+        }
+        Part part = (Part) annotation;
+        gotPart = true;
+
+        String partName = part.value();
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (partName.isEmpty()) {
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(method, p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(method, p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = rawParameterType.getComponentType();
+            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(method, p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            return ParameterHandler.RawPart.INSTANCE;
+          } else {
+            throw parameterError(method, p,
+                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+          }
+        } else {
+          Headers headers =
+              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                  "Content-Transfer-Encoding", part.encoding());
+
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(method, p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(method, p, headers, converter).iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(method, p, headers, converter).array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            throw parameterError(method, p,
+                "@Part parameters using the MultipartBody.Part must not "
+                    + "include a part name in the annotation.");
+          } else {
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(method, p, headers, converter);
+          }
+        }
+
+      } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
+        if (!isMultipart) {
+          throw parameterError(method, p,
+              "@PartMap parameters can only be used with multipart encoding.");
+        }
+        gotPart = true;
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(method, p, "@PartMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+        }
+
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+          throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
+              + "Use @Part List<Part> or a different value type instead.");
+        }
+
+        Converter<?, RequestBody> valueConverter =
+            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+        PartMap partMap = (PartMap) annotation;
+        return new ParameterHandler.PartMap<>(method, p, valueConverter, partMap.encoding());
+
+      } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
+        if (isFormEncoded || isMultipart) {
+          throw parameterError(method, p,
+              "@Body parameters cannot be used with form or multi-part encoding.");
+        }
+        if (gotBody) {
+          throw parameterError(method, p, "Multiple @Body method annotations found.");
+        }
+
+        Converter<?, RequestBody> converter;
+        try {
+          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+        } catch (RuntimeException e) {
+          // Wide exception range because factories are user code.
+          throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
+        }
+        gotBody = true;
+        return new ParameterHandler.Body<>(method, p, converter);
+
+      } else if (annotation instanceof Tag) {
+        validateResolvableType(p, type);
+
+        Class<?> tagType = Utils.getRawType(type);
+        for (int i = p - 1; i >= 0; i--) {
+          ParameterHandler<?> otherHandler = parameterHandlers[i];
+          if (otherHandler instanceof ParameterHandler.Tag
+              && ((ParameterHandler.Tag) otherHandler).cls.equals(tagType)) {
+            throw parameterError(method, p, "@Tag type "
+                + tagType.getName()
+                + " is duplicate of parameter #"
+                + (i + 1)
+                + " and would always overwrite its value.");
+          }
+        }
+
+        return new ParameterHandler.Tag<>(tagType);
+      }
+
+      return null; // Not a Retrofit annotation.
+    }
+
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            "Parameter type must not include a type variable or wildcard: %s", type);
+      }
+    }
+
+    private void validatePathName(int p, String name) {
+      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+        throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
+            PARAM_URL_REGEX.pattern(), name);
+      }
+      // Verify URL replacement name is actually present in the URL path.
+      if (!relativeUrlParamNames.contains(name)) {
+        throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+      }
+    }
+
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+      Matcher m = PARAM_URL_REGEX.matcher(path);
+      Set<String> patterns = new LinkedHashSet<>();
+      while (m.find()) {
+        patterns.add(m.group(1));
+      }
+      return patterns;
+    }
+
+    private static Class<?> boxIfPrimitive(Class<?> type) {
+      if (boolean.class == type) return Boolean.class;
+      if (byte.class == type) return Byte.class;
+      if (char.class == type) return Character.class;
+      if (double.class == type) return Double.class;
+      if (float.class == type) return Float.class;
+      if (int.class == type) return Integer.class;
+      if (long.class == type) return Long.class;
+      if (short.class == type) return Short.class;
+      return type;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index a0efab014..1db6eb479 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -15,15 +15,18 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
+import static retrofit2.Utils.checkNotNull;
+
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
+  public static <T> Response<T> success(@Nullable T body) {
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -32,12 +35,28 @@
         .build());
   }
 
+  /**
+   * Create a synthetic successful response with an HTTP status code of {@code code} and
+   * {@code body} as the deserialized body.
+   */
+  public static <T> Response<T> success(int code, @Nullable T body) {
+    if (code < 200 || code >= 300) {
+      throw new IllegalArgumentException("code < 200 or >= 300: " + code);
+    }
+    return success(body, new okhttp3.Response.Builder() //
+        .code(code)
+        .message("Response.success()")
+        .protocol(Protocol.HTTP_1_1)
+        .request(new Request.Builder().url("http://localhost/").build())
+        .build());
+  }
+
   /**
    * Create a synthetic successful response using {@code headers} with {@code body} as the
    * deserialized body.
    */
-  public static <T> Response<T> success(T body, Headers headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
+  public static <T> Response<T> success(@Nullable T body, Headers headers) {
+    checkNotNull(headers, "headers == null");
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -51,8 +70,8 @@
    * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
    * body.
    */
-  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+  public static <T> Response<T> success(@Nullable T body, okhttp3.Response rawResponse) {
+    checkNotNull(rawResponse, "rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
     }
@@ -67,6 +86,7 @@
     if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
     return error(body, new okhttp3.Response.Builder() //
         .code(code)
+        .message("Response.error()")
         .protocol(Protocol.HTTP_1_1)
         .request(new Request.Builder().url("http://localhost/").build())
         .build());
@@ -74,8 +94,8 @@
 
   /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
   public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    checkNotNull(body, "body == null");
+    checkNotNull(rawResponse, "rawResponse == null");
     if (rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse should not be successful response");
     }
@@ -83,10 +103,11 @@
   }
 
   private final okhttp3.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+  private final @Nullable T body;
+  private final @Nullable ResponseBody errorBody;
 
-  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+  private Response(okhttp3.Response rawResponse, @Nullable T body,
+      @Nullable ResponseBody errorBody) {
     this.rawResponse = rawResponse;
     this.body = body;
     this.errorBody = errorBody;
@@ -118,12 +139,12 @@ public boolean isSuccessful() {
   }
 
   /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
-  public T body() {
+  public @Nullable T body() {
     return body;
   }
 
   /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
-  public ResponseBody errorBody() {
+  public @Nullable ResponseBody errorBody() {
     return errorBody;
   }
 
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index a048b01c3..a0cc56929 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -25,6 +26,7 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -57,22 +59,22 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+  private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   final okhttp3.Call.Factory callFactory;
   final HttpUrl baseUrl;
   final List<Converter.Factory> converterFactories;
-  final List<CallAdapter.Factory> adapterFactories;
-  final Executor callbackExecutor;
+  final List<CallAdapter.Factory> callAdapterFactories;
+  final @Nullable Executor callbackExecutor;
   final boolean validateEagerly;
 
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
+      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> callAdapterFactories,
+      @Nullable Executor callbackExecutor, boolean validateEagerly) {
     this.callFactory = callFactory;
     this.baseUrl = baseUrl;
-    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
-    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
+    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
+    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
     this.callbackExecutor = callbackExecutor;
     this.validateEagerly = validateEagerly;
   }
@@ -132,9 +134,10 @@
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
+          private final Object[] emptyArgs = new Object[0];
 
-          @Override public Object invoke(Object proxy, Method method, Object[] args)
-              throws Throwable {
+          @Override public @Nullable Object invoke(Object proxy, Method method,
+              @Nullable Object[] args) throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
               return method.invoke(this, args);
@@ -142,10 +145,7 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            ServiceMethod<Object, Object> serviceMethod =
-                (ServiceMethod<Object, Object>) loadServiceMethod(method);
-            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.callAdapter.adapt(okHttpCall);
+            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
           }
         });
   }
@@ -153,20 +153,20 @@
   private void eagerlyValidateMethods(Class<?> service) {
     Platform platform = Platform.get();
     for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
+      if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
         loadServiceMethod(method);
       }
     }
   }
 
-  ServiceMethod<?, ?> loadServiceMethod(Method method) {
-    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+  ServiceMethod<?> loadServiceMethod(Method method) {
+    ServiceMethod<?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
-        result = new ServiceMethod.Builder<>(this, method).build();
+        result = ServiceMethod.parseAnnotations(this, method);
         serviceMethodCache.put(method, result);
       }
     }
@@ -191,7 +191,7 @@ public HttpUrl baseUrl() {
    * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
    */
   public List<CallAdapter.Factory> callAdapterFactories() {
-    return adapterFactories;
+    return callAdapterFactories;
   }
 
   /**
@@ -210,14 +210,14 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+  public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
     checkNotNull(returnType, "returnType == null");
     checkNotNull(annotations, "annotations == null");
 
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+    int start = callAdapterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+      CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
       if (adapter != null) {
         return adapter;
       }
@@ -229,19 +229,19 @@ public HttpUrl baseUrl() {
     if (skipPast != null) {
       builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
       }
       builder.append('\n');
     }
     builder.append("  Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
 
   /**
-   * Returns a list of the factories tried when creating a
+   * Returns an unmodifiable list of the factories tried when creating a
    * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
    * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
    * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
@@ -267,8 +267,9 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+  public <T> Converter<T, RequestBody> nextRequestBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
+      Annotation[] methodAnnotations) {
     checkNotNull(type, "type == null");
     checkNotNull(parameterAnnotations, "parameterAnnotations == null");
     checkNotNull(methodAnnotations, "methodAnnotations == null");
@@ -317,8 +318,8 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
     checkNotNull(type, "type == null");
     checkNotNull(annotations, "annotations == null");
 
@@ -375,7 +376,7 @@ public HttpUrl baseUrl() {
    * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
    * in which case callbacks should be made synchronously on the background thread.
    */
-  public Executor callbackExecutor() {
+  public @Nullable Executor callbackExecutor() {
     return callbackExecutor;
   }
 
@@ -391,18 +392,15 @@ public Builder newBuilder() {
    */
   public static final class Builder {
     private final Platform platform;
-    private okhttp3.Call.Factory callFactory;
-    private HttpUrl baseUrl;
+    private @Nullable okhttp3.Call.Factory callFactory;
+    private @Nullable HttpUrl baseUrl;
     private final List<Converter.Factory> converterFactories = new ArrayList<>();
-    private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
+    private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>();
+    private @Nullable Executor callbackExecutor;
     private boolean validateEagerly;
 
     Builder(Platform platform) {
       this.platform = platform;
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
     }
 
     public Builder() {
@@ -413,10 +411,21 @@ public Builder() {
       platform = Platform.get();
       callFactory = retrofit.callFactory;
       baseUrl = retrofit.baseUrl;
-      converterFactories.addAll(retrofit.converterFactories);
-      adapterFactories.addAll(retrofit.adapterFactories);
-      // Remove the default, platform-aware call adapter added by build().
-      adapterFactories.remove(adapterFactories.size() - 1);
+
+      // Do not add the default BuiltIntConverters and platform-aware converters added by build().
+      for (int i = 1,
+          size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();
+          i < size; i++) {
+        converterFactories.add(retrofit.converterFactories.get(i));
+      }
+
+      // Do not add the default, platform-aware call adapters added by build().
+      for (int i = 0,
+          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
+          i < size; i++) {
+        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
+      }
+
       callbackExecutor = retrofit.callbackExecutor;
       validateEagerly = retrofit.validateEagerly;
     }
@@ -447,11 +456,7 @@ public Builder callFactory(okhttp3.Call.Factory factory) {
      */
     public Builder baseUrl(String baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+      return baseUrl(HttpUrl.get(baseUrl));
     }
 
     /**
@@ -525,7 +530,7 @@ public Builder addConverterFactory(Converter.Factory factory) {
      * Call}.
      */
     public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
+      callAdapterFactories.add(checkNotNull(factory, "factory == null"));
       return this;
     }
 
@@ -541,6 +546,16 @@ public Builder callbackExecutor(Executor executor) {
       return this;
     }
 
+    /** Returns a modifiable list of call adapter factories. */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+      return this.callAdapterFactories;
+    }
+
+    /** Returns a modifiable list of converter factories. */
+    public List<Converter.Factory> converterFactories() {
+      return this.converterFactories;
+    }
+
     /**
      * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
      * the configuration of all methods in the supplied interface.
@@ -572,14 +587,21 @@ public Retrofit build() {
       }
 
       // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
+      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
 
       // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+      List<Converter.Factory> converterFactories = new ArrayList<>(
+          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
+
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverters());
+      converterFactories.addAll(this.converterFactories);
+      converterFactories.addAll(platform.defaultConverterFactories());
 
-      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
+          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index a32f8101a..758511f5f 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -15,774 +15,27 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.net.URI;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.HeaderMap;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.QueryName;
-import retrofit2.http.Url;
+import javax.annotation.Nullable;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<R, T> {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+import static retrofit2.Utils.methodError;
 
-  final okhttp3.Call.Factory callFactory;
-  final CallAdapter<R, T> callAdapter;
+abstract class ServiceMethod<T> {
+  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
 
-  private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, R> responseConverter;
-  private final String httpMethod;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-
-  ServiceMethod(Builder<R, T> builder) {
-    this.callFactory = builder.retrofit.callFactory();
-    this.callAdapter = builder.callAdapter;
-    this.baseUrl = builder.retrofit.baseUrl();
-    this.responseConverter = builder.responseConverter;
-    this.httpMethod = builder.httpMethod;
-    this.relativeUrl = builder.relativeUrl;
-    this.headers = builder.headers;
-    this.contentType = builder.contentType;
-    this.hasBody = builder.hasBody;
-    this.isFormEncoded = builder.isFormEncoded;
-    this.isMultipart = builder.isMultipart;
-    this.parameterHandlers = builder.parameterHandlers;
-  }
-
-  /** Builds an HTTP request from method arguments. */
-  Request toRequest(Object... args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args != null ? args.length : 0;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
-    }
-
-    for (int p = 0; p < argumentCount; p++) {
-      handlers[p].apply(requestBuilder, args[p]);
-    }
-
-    return requestBuilder.build();
-  }
-
-  /** Builds a method return value from an HTTP response body. */
-  R toResponse(ResponseBody body) throws IOException {
-    return responseConverter.convert(body);
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder<T, R> {
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    Type responseType;
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotUrl;
-    String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    String relativeUrl;
-    Headers headers;
-    MediaType contentType;
-    Set<String> relativeUrlParamNames;
-    ParameterHandler<?>[] parameterHandlers;
-    Converter<ResponseBody, T> responseConverter;
-    CallAdapter<T, R> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
-
-    public ServiceMethod build() {
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError("'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
-
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
-
-      if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
-
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
-        }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
-              parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
-      }
-
-      return new ServiceMethod<>(this);
-    }
-
-    private CallAdapter<T, R> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create call adapter for %s", returnType);
-      }
-    }
-
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError("HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
-
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
-        }
-      }
-
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
-
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-        }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          MediaType type = MediaType.parse(headerValue);
-          if (type == null) {
-            throw methodError("Malformed content type: %s", headerValue);
-          }
-          contentType = type;
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
-
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
-      ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
-
-        if (annotationAction == null) {
-          continue;
-        }
-
-        if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
-        }
-
-        result = annotationAction;
-      }
-
-      if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
-      }
-
-      return result;
-    }
-
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
-        }
-
-        gotUrl = true;
-
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
-        } else {
-          throw parameterError(p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
-        }
-
-      } else if (annotation instanceof Path) {
-        if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
-        }
-
-      } else if (annotation instanceof QueryName) {
-        QueryName query = (QueryName) annotation;
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded);
-        }
-
-      } else if (annotation instanceof QueryMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
-        }
-
-      } else if (annotation instanceof HeaderMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.HeaderMap<>(valueConverter);
-
-      } else if (annotation instanceof Field) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
-        }
-
-      } else if (annotation instanceof FieldMap) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
-
-      } else if (annotation instanceof Part) {
-        if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
-            }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
-            }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
-          }
-        }
-
-      } else if (annotation instanceof PartMap) {
-        if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
-        }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
-        }
-
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
-        }
-
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
-
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
-
-      } else if (annotation instanceof Body) {
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
-        }
-
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
-        }
-        gotBody = true;
-        return new ParameterHandler.Body<>(converter);
-      }
-
-      return null; // Not a Retrofit annotation.
-    }
-
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
-
-    private Converter<ResponseBody, T> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create converter for %s", responseType);
-      }
-    }
-
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw methodError(method,
+          "Method return type must not include a type variable or wildcard: %s", returnType);
     }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
-
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
+    if (returnType == void.class) {
+      throw methodError(method, "Service methods cannot return void.");
     }
 
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
+    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
   }
 
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
+  abstract @Nullable T invoke(Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/SkipCallbackExecutor.java b/retrofit/src/main/java/retrofit2/SkipCallbackExecutor.java
new file mode 100644
index 000000000..930827cc9
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/SkipCallbackExecutor.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Change the behavior of a {@code Call<BodyType>} return type to not use the
+ * {@linkplain Retrofit#callbackExecutor() callback executor} for invoking the
+ * {@link Callback#onResponse(Call, Response) onResponse} or
+ * {@link Callback#onFailure(Call, Throwable) onFailure} methods.
+ *
+ * <pre><code>
+ * &#64;SkipCallbackExecutor
+ * &#64;GET("user/{id}/token")
+ * Call&lt;String&gt; getToken(@Path("id") long id);
+ * </code></pre>
+ *
+ * This annotation can also be used when a {@link CallAdapter.Factory} <em>explicitly</em> delegates
+ * to the built-in factory for {@link Call} via
+ * {@link Retrofit#nextCallAdapter(CallAdapter.Factory, Type, Annotation[])} in order for the
+ * returned {@link Call} to skip the executor. (Note: by default, a {@link Call} supplied directly
+ * to a {@link CallAdapter} will already skip the callback executor. The annotation is only useful
+ * when looking up the built-in adapter.)
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface SkipCallbackExecutor {
+}
diff --git a/retrofit/src/main/java/retrofit2/SkipCallbackExecutorImpl.java b/retrofit/src/main/java/retrofit2/SkipCallbackExecutorImpl.java
new file mode 100644
index 000000000..4a3593b75
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/SkipCallbackExecutorImpl.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+
+// This class conforms to the annotation requirements documented on Annotation.
+final class SkipCallbackExecutorImpl implements SkipCallbackExecutor {
+  private static final SkipCallbackExecutor INSTANCE = new SkipCallbackExecutorImpl();
+
+  static Annotation[] ensurePresent(Annotation[] annotations) {
+    if (Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)) {
+      return annotations;
+    }
+
+    Annotation[] newAnnotations = new Annotation[annotations.length + 1];
+    // Place the skip annotation first since we're guaranteed to check for it in the call adapter.
+    newAnnotations[0] = SkipCallbackExecutorImpl.INSTANCE;
+    System.arraycopy(annotations, 0, newAnnotations, 1, annotations.length);
+    return newAnnotations;
+  }
+
+  @Override public Class<? extends Annotation> annotationType() {
+    return SkipCallbackExecutor.class;
+  }
+
+  @Override public boolean equals(Object obj) {
+    return obj instanceof SkipCallbackExecutor;
+  }
+
+  @Override public int hashCode() {
+    return 0;
+  }
+
+  @Override public String toString() {
+    return "@" + SkipCallbackExecutor.class.getName() + "()";
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 79bc788e4..25fdcbf5e 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -20,12 +20,14 @@
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
@@ -36,8 +38,31 @@ private Utils() {
     // No instances.
   }
 
+  static RuntimeException methodError(Method method, String message, Object... args) {
+    return methodError(method, null, message, args);
+  }
+
+  static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
+      Object... args) {
+    message = String.format(message, args);
+    return new IllegalArgumentException(message
+        + "\n    for method "
+        + method.getDeclaringClass().getSimpleName()
+        + "."
+        + method.getName(), cause);
+  }
+
+  static RuntimeException parameterError(Method method,
+      Throwable cause, int p, String message, Object... args) {
+    return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
+  }
+
+  static RuntimeException parameterError(Method method, int p, String message, Object... args) {
+    return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
+  }
+
   static Class<?> getRawType(Type type) {
-    if (type == null) throw new NullPointerException("type == null");
+    checkNotNull(type, "type == null");
 
     if (type instanceof Class<?>) {
       // Type is a normal class.
@@ -81,7 +106,9 @@ static boolean equals(Type a, Type b) {
       if (!(b instanceof ParameterizedType)) return false;
       ParameterizedType pa = (ParameterizedType) a;
       ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
+      Object ownerA = pa.getOwnerType();
+      Object ownerB = pb.getOwnerType();
+      return (ownerA == ownerB || (ownerA != null && ownerA.equals(ownerB)))
           && pa.getRawType().equals(pb.getRawType())
           && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
 
@@ -154,14 +181,6 @@ private static int indexOf(Object[] array, Object toFind) {
     throw new NoSuchElementException();
   }
 
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
   static String typeToString(Type type) {
     return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
   }
@@ -269,7 +288,7 @@ private static Type resolveTypeVariable(
    * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
    * a class.
    */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+  private static @Nullable Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
     GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
     return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
   }
@@ -280,7 +299,7 @@ static void checkNotPrimitive(Type type) {
     }
   }
 
-  static <T> T checkNotNull(T object, String message) {
+  static <T> T checkNotNull(@Nullable T object, String message) {
     if (object == null) {
       throw new NullPointerException(message);
     }
@@ -329,7 +348,15 @@ static Type getParameterUpperBound(int index, ParameterizedType type) {
     return paramType;
   }
 
-  static boolean hasUnresolvableType(Type type) {
+  static Type getParameterLowerBound(int index, ParameterizedType type) {
+    Type paramType = type.getActualTypeArguments()[index];
+    if (paramType instanceof WildcardType) {
+      return ((WildcardType) paramType).getLowerBounds()[0];
+    }
+    return paramType;
+  }
+
+  static boolean hasUnresolvableType(@Nullable Type type) {
     if (type instanceof Class<?>) {
       return false;
     }
@@ -356,34 +383,26 @@ static boolean hasUnresolvableType(Type type) {
         + "GenericArrayType, but <" + type + "> is of type " + className);
   }
 
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-    return getParameterUpperBound(0, (ParameterizedType) returnType);
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
+  static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final @Nullable Type ownerType;
     private final Type rawType;
     private final Type[] typeArguments;
 
-    ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+    ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
       // Require an owner type if the raw type needs it.
       if (rawType instanceof Class<?>
           && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
         throw new IllegalArgumentException();
       }
 
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
+      for (Type typeArgument : typeArguments) {
         checkNotNull(typeArgument, "typeArgument == null");
         checkNotPrimitive(typeArgument);
       }
+
+      this.ownerType = ownerType;
+      this.rawType = rawType;
+      this.typeArguments = typeArguments.clone();
     }
 
     @Override public Type[] getActualTypeArguments() {
@@ -394,7 +413,7 @@ static Type getCallResponseType(Type returnType) {
       return rawType;
     }
 
-    @Override public Type getOwnerType() {
+    @Override public @Nullable Type getOwnerType() {
       return ownerType;
     }
 
@@ -403,7 +422,9 @@ static Type getCallResponseType(Type returnType) {
     }
 
     @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+      return Arrays.hashCode(typeArguments)
+          ^ rawType.hashCode()
+          ^ (ownerType != null ? ownerType.hashCode() : 0);
     }
 
     @Override public String toString() {
@@ -450,7 +471,7 @@ static Type getCallResponseType(Type returnType) {
    */
   private static final class WildcardTypeImpl implements WildcardType {
     private final Type upperBound;
-    private final Type lowerBound;
+    private final @Nullable Type lowerBound;
 
     WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
       if (lowerBounds.length > 1) throw new IllegalArgumentException();
@@ -493,4 +514,16 @@ static Type getCallResponseType(Type returnType) {
       return "? extends " + typeToString(upperBound);
     }
   }
+
+  // https://github.com/ReactiveX/RxJava/blob/6a44e5d0543a48f1c378dc833a155f3f71333bc2/
+  // src/main/java/io/reactivex/exceptions/Exceptions.java#L66
+  static void throwIfFatal(Throwable t) {
+    if (t instanceof VirtualMachineError) {
+      throw (VirtualMachineError) t;
+    } else if (t instanceof ThreadDeath) {
+      throw (ThreadDeath) t;
+    } else if (t instanceof LinkageError) {
+      throw (LinkageError) t;
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 4dbd1bf11..06e369bc7 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,7 +28,9 @@
 /**
  * Named pair for a form-encoded request.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then form URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * field pair for each non-{@code null} item.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index aa1facd39..f758f3e1c 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -15,18 +15,23 @@
  */
 package retrofit2.http;
 
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
 import java.util.Map;
+import retrofit2.Retrofit;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Adds headers specified in the {@link Map}.
+ * Adds headers specified in the {@link Map} or {@link okhttp3.Headers}.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)}.
+ * Values in the map are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()}, if no
+ * matching string converter is installed).
  * <p>
  * Simple Example:
  * <pre>
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index 4d8c6f054..52af62511 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -15,16 +15,20 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Named replacement in a URL path segment. Values are converted to string using
- * {@link String#valueOf(Object)} and URL encoded.
+ * Named replacement in a URL path segment. Values are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()},
+ * if no matching string converter is installed) and then URL encoded.
  * <p>
  * Simple example:
  * <pre><code>
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 614795009..17c36c154 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,7 +28,9 @@
 /**
  * Query parameter appended to the URL.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * query parameter for each non-{@code null} item.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 119a59381..a9d7a30ea 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,7 +28,8 @@
 /**
  * Query parameter keys and values appended to the URL.
  * <p>
- * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
  * <p>
  * Simple Example:
  * <pre><code>
@@ -42,7 +46,7 @@
  * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * </code></pre>
  * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
- * {@code /search?group=coworker+bowling}.
+ * {@code /friends?group=coworker+bowling}.
  * <p>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
diff --git a/retrofit/src/main/java/retrofit2/http/Streaming.java b/retrofit/src/main/java/retrofit2/http/Streaming.java
index 4a87591df..23fc0e290 100644
--- a/retrofit/src/main/java/retrofit2/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit2/http/Streaming.java
@@ -18,13 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.ResponseBody;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
- * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link ResponseBody ResponseBody} as is,
+ * i.e. without converting the body to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Tag.java b/retrofit/src/main/java/retrofit2/http/Tag.java
new file mode 100644
index 000000000..d25c7af84
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/Tag.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Adds the argument instance as a request tag using the type as the key.
+ * <pre><code>
+ * &#64;GET("/")
+ * Call&lt;ResponseBody&gt; foo(@Tag String tag);
+ * </code></pre>
+ * Tag arguments may be {@code null} which will omit them from the request. Passing a parameterized
+ * type such as {@code List<String>} will use the raw type (i.e., {@code List.class}) as the key.
+ * Duplicate tag types are not allowed.
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Tag {
+}
diff --git a/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java b/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java
new file mode 100644
index 000000000..e3da90636
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull {
+}
diff --git a/retrofit/src/main/java/retrofit2/package-info.java b/retrofit/src/main/java/retrofit2/package-info.java
index 44f5b357a..2638c2e96 100644
--- a/retrofit/src/main/java/retrofit2/package-info.java
+++ b/retrofit/src/main/java/retrofit2/package-info.java
@@ -9,4 +9,5 @@
  * }
  * </pre>
  */
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2;
diff --git a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
new file mode 100644
index 000000000..67a4d45f2
--- /dev/null
+++ b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
@@ -0,0 +1,28 @@
+# Retrofit does reflection on generic parameters. InnerClasses is required to use Signature and
+# EnclosingMethod is required to use InnerClasses.
+-keepattributes Signature, InnerClasses, EnclosingMethod
+
+# Retrofit does reflection on method and parameter annotations.
+-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations
+
+# Retain service method parameters when optimizing.
+-keepclassmembers,allowshrinking,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+
+# Ignore JSR 305 annotations for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.
+-dontwarn kotlin.Unit
+
+# Top-level functions that can only be used by Kotlin.
+-dontwarn retrofit2.KotlinExtensions
+
+# With R8 full mode, it sees no subtypes of Retrofit interfaces since they are created with a Proxy
+# and replaces all potential values with null. Explicitly keeping the interfaces prevents this.
+-if interface * { @retrofit2.http.* <methods>; }
+-keep,allowobfuscation interface <1>
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index fffd43c1f..a99bf3646 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.Interceptor;
@@ -46,8 +47,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static retrofit2.TestingUtils.repeat;
 
 public final class CallTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -369,11 +369,11 @@
   }
 
   @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
+    final Converter<ResponseBody, String> converter = new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) {
+        throw new AssertionError();
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
@@ -391,15 +391,14 @@
     Response<String> response = example.getString().execute();
     assertThat(response.code()).isEqualTo(204);
     assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
   }
 
   @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
+    final Converter<ResponseBody, String> converter = new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) {
+        throw new AssertionError();
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
@@ -417,7 +416,31 @@
     Response<String> response = example.getString().execute();
     assertThat(response.code()).isEqualTo(205);
     assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void converterBodyDoesNotLeakContentInIntermediateBuffers() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                String prefix = value.source().readUtf8(2);
+                value.source().skip(20_000 - 4);
+                String suffix = value.source().readUtf8();
+                return prefix + suffix;
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody(repeat('a', 10_000) + repeat('b', 10_000)));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("aabb");
   }
 
   @Test public void executeCallOnce() throws IOException {
@@ -768,6 +791,41 @@
     assertThat(writeCount.get()).isEqualTo(1);
   }
 
+  @Test public void requestThrowingNonFatalErrorBeforeExecuteFailsExecute() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
   @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -828,6 +886,41 @@
     assertThat(writeCount.get()).isEqualTo(1);
   }
 
+  @Test public void requestAfterExecuteThrowingAlsoThrowsForNonFatalErrors() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
   @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -903,6 +996,47 @@
     assertTrue(latch.await(10, SECONDS));
   }
 
+  @Test public void requestThrowingNonFatalErrorBeforeEnqueueFailsEnqueue()
+      throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(Error.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
   @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
       InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
@@ -978,4 +1112,159 @@
     }
     assertThat(writeCount.get()).isEqualTo(1);
   }
+
+  @Test public void requestAfterEnqueueFailingThrowsForNonFatalErrors() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new Error("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(Error.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    try {
+      call.request();
+      fail();
+    } catch (Error e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void fatalErrorsAreNotCaughtRequest() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new OutOfMemoryError("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(2);
+  }
+
+  @Test public void fatalErrorsAreNotCaughtEnqueue() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new OutOfMemoryError("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      final AtomicBoolean callsFailureSynchronously = new AtomicBoolean();
+      call.enqueue(new Callback<String>() {
+        @Override public void onResponse(Call<String> call, Response<String> response) {
+        }
+
+        @Override public void onFailure(Call<String> call, Throwable t) {
+          callsFailureSynchronously.set(true); // Will not be called for fatal errors.
+        }
+      });
+      assertThat(callsFailureSynchronously.get()).isFalse();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(2);
+  }
+
+  @Test public void fatalErrorsAreNotCaughtExecute() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new OutOfMemoryError("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (OutOfMemoryError e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(2);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureAndroidTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureAndroidTest.java
new file mode 100644
index 000000000..b2eff2369
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureAndroidTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.NONE;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = NEWEST_SDK, manifest = NONE)
+public final class CompletableFutureAndroidTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> endpoint();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Config(sdk = 24)
+  @Test public void completableFutureApi24() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.endpoint();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Config(sdk = 21)
+  @Test public void completableFuturePreApi24() {
+    try {
+      service.endpoint();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create call adapter for java.util.concurrent.CompletableFuture<java.lang.String>\n"
+              + "    for method Service.endpoint");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
new file mode 100644
index 000000000..feaacc929
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = CompletableFutureCallAdapterFactory.INSTANCE;
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
new file mode 100644
index 000000000..bf44dfd55
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/DefaultCallAdapterFactoryTest.java
similarity index 62%
rename from retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
rename to retrofit/src/test/java/retrofit2/DefaultCallAdapterFactoryTest.java
index 6f1480d23..e23a5d3c1 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/DefaultCallAdapterFactoryTest.java
@@ -21,31 +21,27 @@
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Request;
+import org.jetbrains.annotations.NotNull;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @SuppressWarnings("unchecked")
-public final class ExecutorCallAdapterFactoryTest {
+public final class DefaultCallAdapterFactoryTest {
   private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
   private final Retrofit retrofit = new Retrofit.Builder()
       .baseUrl("http://localhost:1")
       .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
+  private final CallAdapter.Factory factory = new DefaultCallAdapterFactory(new Executor() {
+    @Override public void execute(@NotNull Runnable command) {
+      command.run();
     }
   });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
 
   @Test public void rawTypeThrows() {
     try {
@@ -74,68 +70,42 @@
         (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
+      @Override public Response<String> execute() {
         return response;
       }
     });
     assertThat(call.execute()).isSameAs(response);
   }
 
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(call, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+  @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter<String, Call<String>> adapter =
         (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
+    final AtomicBoolean cloned = new AtomicBoolean();
+    Call<String> delegate = new EmptyCall() {
+      @Override public Call<String> clone() {
+        cloned.set(true);
+        return this;
       }
     };
-    Call<String> call = adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(call, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
     Call<String> call = adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
+    assertThat(call.clone()).isNotSameAs(call);
+    assertTrue(cloned.get());
   }
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter<String, Call<String>> adapter =
         (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
+    final AtomicBoolean canceled = new AtomicBoolean();
+    Call<String> delegate = new EmptyCall() {
+      @Override public void cancel() {
+        canceled.set(true);
+      }
+    };
     Call<String> call = adapter.adapt(delegate);
     call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
+    assertTrue(canceled.get());
   }
 
   static class EmptyCall implements Call<String> {
diff --git a/retrofit/src/test/java/retrofit2/InvocationTest.java b/retrofit/src/test/java/retrofit2/InvocationTest.java
new file mode 100644
index 000000000..0dda742ba
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/InvocationTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.http.Body;
+import retrofit2.http.POST;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class InvocationTest {
+  interface Example {
+    @POST("/{p1}") //
+    Call<ResponseBody> postMethod(
+        @Path("p1") String p1, @Query("p2") String p2, @Body RequestBody body);
+  }
+
+  @Test public void invocationObjectOnCallAndRequestTag() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(new OkHttpClient())
+        .build();
+
+    Example example = retrofit.create(Example.class);
+    RequestBody requestBody = RequestBody.create(MediaType.get("text/plain"), "three");
+    Call<ResponseBody> call = example.postMethod("one", "two", requestBody);
+
+    Invocation invocation = call.request().tag(Invocation.class);
+    Method method = invocation.method();
+    assertThat(method.getName()).isEqualTo("postMethod");
+    assertThat(method.getDeclaringClass()).isEqualTo(Example.class);
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two", requestBody));
+  }
+
+  @Test public void nullMethod() {
+    try {
+      Invocation.of(null, Arrays.asList("one", "two"));
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("method == null");
+    }
+  }
+
+  @Test public void nullArguments() {
+    try {
+      Invocation.of(Example.class.getDeclaredMethods()[0], null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("arguments == null");
+    }
+  }
+
+  @Test public void argumentsAreImmutable() {
+    List<String> mutableList = new ArrayList<>(Arrays.asList("one", "two"));
+    Invocation invocation = Invocation.of(Example.class.getDeclaredMethods()[0], mutableList);
+    mutableList.add("three");
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two"));
+    try {
+      invocation.arguments().clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
index 8333969c6..501c909e4 100644
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -39,7 +39,7 @@
   //
   //  Response<String> response = example.user().execute();
   //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
+  //  Response<String> response2 = example.user("Hi").execute();
+  //  assertThat(response2.body()).isEqualTo("Hi");
   //}
 }
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultStaticMethodsInValidationTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultStaticMethodsInValidationTest.java
new file mode 100644
index 000000000..bc2521d5a
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultStaticMethodsInValidationTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
+public final class Java8DefaultStaticMethodsInValidationTest {
+  //@Rule public final MockWebServer server = new MockWebServer();
+  //
+  //interface Example {
+  //  @GET("/") Call<String> user(@Query("name") String name);
+  //
+  //  default Call<String> user() {
+  //    return user("hey");
+  //  }
+  //
+  //  static String staticMethod() {
+  //    return "Hi";
+  //  }
+  //}
+  //
+  //@Test public void test() throws IOException {
+  //  Retrofit retrofit = new Retrofit.Builder()
+  //      .baseUrl(server.url("/"))
+  //      .addConverterFactory(new ToStringConverterFactory())
+  //      .validateEagerly(true)
+  //      .build();
+  //  Example example = retrofit.create(Example.class);
+  //}
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
new file mode 100644
index 000000000..b8196c7e6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import okhttp3.mockwebserver.MockWebServer
+import org.junit.Assert.assertNotNull
+import org.junit.Rule
+import org.junit.Test
+
+class KotlinExtensionsTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Empty
+
+  @Test fun reifiedCreate() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build()
+
+    assertNotNull(retrofit.create<Empty>())
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendRawTest.java b/retrofit/src/test/java/retrofit2/KotlinSuspendRawTest.java
new file mode 100644
index 000000000..d6fbbe0c7
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendRawTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import kotlin.coroutines.Continuation;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * This code path can only be tested from Java because Kotlin does not allow you specify a raw
+ * Response type. Win! We still test this codepath for completeness.
+ */
+public final class KotlinSuspendRawTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Object body(Continuation<? super Response> response);
+  }
+
+  @Test public void raw() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    try {
+      service.body(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Response must include generic type (e.g., Response<String>)\n"
+          + "    for method Service.body");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
new file mode 100644
index 000000000..629b02624
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.async
+import kotlinx.coroutines.runBlocking
+import okhttp3.OkHttpClient
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST
+import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Ignore
+import org.junit.Rule
+import org.junit.Test
+import retrofit2.helpers.ToStringConverterFactory
+import retrofit2.http.GET
+import retrofit2.http.Path
+import java.io.IOException
+import java.lang.reflect.ParameterizedType
+import java.lang.reflect.Type
+
+class KotlinSuspendTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Service {
+    @GET("/") suspend fun body(): String
+    @GET("/") suspend fun bodyNullable(): String?
+    @GET("/") suspend fun response(): Response<String>
+
+    @GET("/{a}/{b}/{c}")
+    suspend fun params(
+        @Path("a") a: String,
+        @Path("b") b: String,
+        @Path("c") c: String
+    ): String
+  }
+
+  @Test fun body() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("Hi")
+  }
+
+  @Test fun body404() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(404))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: HttpException) {
+      assertThat(e.code()).isEqualTo(404)
+    }
+  }
+
+  @Test fun bodyFailure() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: IOException) {
+    }
+  }
+
+  @Test fun bodyThrowsOnNull() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(204))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: KotlinNullPointerException) {
+      // Coroutines wraps exceptions with a synthetic trace so fall back to cause message.
+      val message = e.message ?: (e.cause as KotlinNullPointerException).message
+      assertThat(message).isEqualTo(
+          "Response from retrofit2.KotlinSuspendTest\$Service.body was null but response body type was declared as non-null")
+    }
+  }
+
+  @Ignore("Not working yet")
+  @Test fun bodyNullable() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(204))
+
+    val body = runBlocking { example.bodyNullable() }
+    assertThat(body).isNull()
+  }
+
+  @Test fun response() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val response = runBlocking { example.response() }
+    assertThat(response.code()).isEqualTo(200)
+    assertThat(response.body()).isEqualTo("Hi")
+  }
+
+  @Test fun response404() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(404))
+
+    val response = runBlocking { example.response() }
+    assertThat(response.code()).isEqualTo(404)
+  }
+
+  @Test fun responseFailure() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST))
+
+    try {
+      runBlocking { example.response() }
+      fail()
+    } catch (e: IOException) {
+    }
+  }
+
+  @Test fun params() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse())
+
+    runBlocking { example.params("1", "2", "3") }
+    val request = server.takeRequest()
+    assertThat(request.path).isEqualTo("/1/2/3")
+  }
+
+  @Test fun cancelationWorks() {
+    lateinit var call: okhttp3.Call
+
+    val okHttpClient = OkHttpClient()
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callFactory {
+          val newCall = okHttpClient.newCall(it)
+          call = newCall
+          newCall
+        }
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    // This leaves the connection open indefinitely allowing us to cancel without racing a body.
+    server.enqueue(MockResponse().setSocketPolicy(NO_RESPONSE))
+
+    val deferred = GlobalScope.async { example.body() }
+
+    // This will block until the server has received the request ensuring it's in flight.
+    server.takeRequest()
+
+    deferred.cancel()
+    assertTrue(call.isCanceled)
+  }
+
+  @Test fun doesNotUseCallbackExecutor() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor { fail() }
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("Hi")
+  }
+
+  @Test fun usesCallAdapterForCall() {
+    val callAdapterFactory = object : CallAdapter.Factory() {
+      override fun get(returnType: Type, annotations: Array<Annotation>,
+          retrofit: Retrofit): CallAdapter<*, *>? {
+        if (getRawType(returnType) != Call::class.java) {
+          return null
+        }
+        if (getParameterUpperBound(0, returnType as ParameterizedType) != String::class.java) {
+          return null
+        }
+        return object : CallAdapter<String, Call<String>> {
+          override fun responseType() = String::class.java
+          override fun adapt(call: Call<String>): Call<String> {
+            return object : Call<String> by call {
+              override fun enqueue(callback: Callback<String>) {
+                call.enqueue(object : Callback<String> by callback {
+                  override fun onResponse(call: Call<String>, response: Response<String>) {
+                    if (response.isSuccessful) {
+                      callback.onResponse(call, Response.success(response.body()?.repeat(5)))
+                    } else {
+                      callback.onResponse(call, response)
+                    }
+                  }
+                })
+              }
+            }
+          }
+        }
+      }
+    }
+
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(callAdapterFactory)
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("HiHiHiHiHi")
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinUnitTest.java b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
new file mode 100644
index 000000000..e73f223c7
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import kotlin.Unit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class KotlinUnitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Call<Unit> empty();
+  }
+
+  @Test public void unitOnClasspath() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Unit> response = example.empty().execute();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(Unit.INSTANCE);
+  }
+
+  @Ignore("This is implicitly tested by integration tests of the adapters and converters")
+  @Test public void unitMissingFromClasspath() {
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/OptionalConverterFactoryAndroidTest.java b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryAndroidTest.java
new file mode 100644
index 000000000..de9e37e3f
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryAndroidTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import retrofit2.helpers.ObjectInstanceConverterFactory;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.NONE;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = NEWEST_SDK, manifest = NONE)
+public final class OptionalConverterFactoryAndroidTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ObjectInstanceConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Config(sdk = 24)
+  @Test public void optionalApi24() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+
+  @Config(sdk = 21)
+  @Test public void optionalPreApi24() {
+    try {
+      service.optional();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create converter for java.util.Optional<java.lang.Object>\n"
+              + "    for method Service.optional");
+    }
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..e7925f7a6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ObjectInstanceConverterFactory;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ObjectInstanceConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.get()).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isSameAs(ObjectInstanceConverterFactory.VALUE);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
similarity index 86%
rename from retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
rename to retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
index 63fa57b6c..4e0b38de2 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryAndroidTest.java
@@ -21,15 +21,19 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import retrofit2.http.GET;
 import retrofit2.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit2.RequestBuilderTest.buildRequest;
+import static org.robolectric.annotation.Config.NEWEST_SDK;
+import static org.robolectric.annotation.Config.NONE;
+import static retrofit2.RequestFactoryTest.buildRequest;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(sdk = NEWEST_SDK, manifest = NONE)
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderAndroidTest {
+public final class RequestFactoryAndroidTest {
   @Test public void getWithAndroidUriUrl() {
     class Example {
       @GET
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryBuilderTest.java
similarity index 90%
rename from retrofit/src/test/java/retrofit2/ServiceMethodTest.java
rename to retrofit/src/test/java/retrofit2/RequestFactoryBuilderTest.java
index c9c48f31e..f2bd3791d 100644
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryBuilderTest.java
@@ -20,7 +20,8 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class ServiceMethodTest {
+// TODO this test is far too white box, migrate to black box.
+public final class RequestFactoryBuilderTest {
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
@@ -41,7 +42,7 @@
   }
 
   private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
+    Set<String> calculated = RequestFactory.Builder.parsePathParameters(path);
     assertThat(calculated).containsExactly(expected);
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
similarity index 81%
rename from retrofit/src/test/java/retrofit2/RequestBuilderTest.java
rename to retrofit/src/test/java/retrofit2/RequestFactoryTest.java
index a2ef1376b..dd7f3a675 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
@@ -25,7 +25,6 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.MultipartBody;
@@ -33,8 +32,8 @@
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okio.Buffer;
-import org.junit.Ignore;
 import org.junit.Test;
+import retrofit2.helpers.NullObjectConverterFactory;
 import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
@@ -58,15 +57,18 @@
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
 import retrofit2.http.QueryName;
+import retrofit2.http.Tag;
 import retrofit2.http.Url;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
-public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+public final class RequestFactoryTest {
+  private static final MediaType TEXT_PLAIN = MediaType.get("text/plain");
 
   @Test public void customMethodNoBody() {
     class Example {
@@ -82,7 +84,6 @@
     assertThat(request.body()).isNull();
   }
 
-  @Ignore("https://github.com/square/okhttp/issues/229")
   @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
@@ -91,7 +92,7 @@
       }
     }
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
@@ -490,7 +491,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
+      assertThat(e).hasMessage("Query map was null (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -510,7 +512,8 @@
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
+      assertThat(e).hasMessage("Query map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -530,7 +533,8 @@
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+      assertThat(e).hasMessage("Query map contained null value for key 'kit'. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -603,7 +607,8 @@
       buildRequest(Example.class, (Map<String, String>) null);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null.");
+      assertThat(e).hasMessage("Header map was null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -623,7 +628,8 @@
       buildRequest(Example.class, headers);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key.");
+      assertThat(e).hasMessage("Header map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -643,7 +649,72 @@
       buildRequest(Example.class, headers);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'. (parameter #1)\n" +
+              "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithHeaders() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap okhttp3.Headers headers) {
+        throw new AssertionError();
+      }
+    }
+
+    okhttp3.Headers headers = new okhttp3.Headers.Builder()
+        .add("Accept", "text/plain")
+        .add("Accept", "application/json")
+        .add("Accept-Charset", "utf-8")
+        .build();
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(3);
+    assertThat(request.headers("Accept")).isEqualTo(asList("text/plain", "application/json"));
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void getWithHeadersAndHeaderMap() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap okhttp3.Headers headers,
+          @HeaderMap Map<String, Object> headerMap) {
+        throw new AssertionError();
+      }
+    }
+
+    okhttp3.Headers headers = new okhttp3.Headers.Builder()
+        .add("Accept", "text/plain")
+        .add("Accept-Charset", "utf-8")
+        .build();
+    Map<String, String> headerMap = Collections.singletonMap("Accept", "application/json");
+
+    Request request = buildRequest(Example.class, headers, headerMap);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(3);
+    assertThat(request.headers("Accept")).isEqualTo(asList("text/plain", "application/json"));
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void headersRejectsNull() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap okhttp3.Headers headers) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (okhttp3.Headers) null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Headers parameter must not be null. (parameter #1)\n" +
+          "    for method Example.method");
     }
   }
 
@@ -744,7 +815,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -759,7 +830,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
@@ -774,7 +845,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
@@ -880,6 +951,88 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void pathParametersAndPathTraversal() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping") String ping) {
+        return null;
+      }
+    }
+
+    assertMalformedRequest(Example.class, ".");
+    assertMalformedRequest(Example.class, "..");
+
+    assertThat(buildRequest(Example.class, "./a").url().encodedPath())
+        .isEqualTo("/foo/bar/.%2Fa/");
+    assertThat(buildRequest(Example.class, "a/.").url().encodedPath())
+        .isEqualTo("/foo/bar/a%2F./");
+    assertThat(buildRequest(Example.class, "a/..").url().encodedPath())
+        .isEqualTo("/foo/bar/a%2F../");
+    assertThat(buildRequest(Example.class, "../a").url().encodedPath())
+        .isEqualTo("/foo/bar/..%2Fa/");
+    assertThat(buildRequest(Example.class, "..\\..").url().encodedPath())
+        .isEqualTo("/foo/bar/..%5C../");
+
+    assertThat(buildRequest(Example.class, "%2E").url().encodedPath())
+        .isEqualTo("/foo/bar/%252E/");
+    assertThat(buildRequest(Example.class, "%2E%2E").url().encodedPath())
+        .isEqualTo("/foo/bar/%252E%252E/");
+  }
+
+  @Test public void encodedPathParametersAndPathTraversal() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+
+    assertMalformedRequest(Example.class, ".");
+    assertMalformedRequest(Example.class, "%2E");
+    assertMalformedRequest(Example.class, "%2e");
+    assertMalformedRequest(Example.class, "..");
+    assertMalformedRequest(Example.class, "%2E.");
+    assertMalformedRequest(Example.class, "%2e.");
+    assertMalformedRequest(Example.class, ".%2E");
+    assertMalformedRequest(Example.class, ".%2e");
+    assertMalformedRequest(Example.class, "%2E%2e");
+    assertMalformedRequest(Example.class, "%2e%2E");
+    assertMalformedRequest(Example.class, "./a");
+    assertMalformedRequest(Example.class, "a/.");
+    assertMalformedRequest(Example.class, "../a");
+    assertMalformedRequest(Example.class, "a/..");
+    assertMalformedRequest(Example.class, "a/../b");
+    assertMalformedRequest(Example.class, "a/%2e%2E/b");
+
+    assertThat(buildRequest(Example.class, "...").url().encodedPath())
+        .isEqualTo("/foo/bar/.../");
+    assertThat(buildRequest(Example.class, "a..b").url().encodedPath())
+        .isEqualTo("/foo/bar/a..b/");
+    assertThat(buildRequest(Example.class, "a..").url().encodedPath())
+        .isEqualTo("/foo/bar/a../");
+    assertThat(buildRequest(Example.class, "a..b").url().encodedPath())
+        .isEqualTo("/foo/bar/a..b/");
+    assertThat(buildRequest(Example.class, "..b").url().encodedPath())
+        .isEqualTo("/foo/bar/..b/");
+    assertThat(buildRequest(Example.class, "..\\..").url().encodedPath())
+        .isEqualTo("/foo/bar/..%5C../");
+  }
+
+  @Test public void dotDotsOkayWhenNotFullPathSegment() {
+    class Example {
+      @GET("/foo{ping}bar/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+
+    assertMalformedRequest(Example.class, "/./");
+    assertMalformedRequest(Example.class, "/../");
+
+    assertThat(buildRequest(Example.class, ".").url().encodedPath()).isEqualTo("/foo.bar/");
+    assertThat(buildRequest(Example.class, "..").url().encodedPath()).isEqualTo("/foo..bar/");
+  }
+
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
@@ -891,7 +1044,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -1007,6 +1161,40 @@
     }
   }
 
+  @Test public void getWithQueryNameThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@QueryName String kit, @Path("ping") String ping) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "kat", "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @QueryName. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryMapThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Path("ping") String ping) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @QueryMap. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
@@ -1018,7 +1206,8 @@
     Request request = buildRequest(Example.class, "pong?", "kat?");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+    assertThat(request.url().toString())
+        .isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
     assertThat(request.body()).isNull();
   }
 
@@ -1323,10 +1512,10 @@
       }
     }
 
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    Request request = buildRequest(Example.class, HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.url()).isEqualTo(HttpUrl.get("http://example.com/foo/bar/"));
     assertThat(request.body()).isNull();
   }
 
@@ -1341,8 +1530,9 @@
     try {
       buildRequest(Example.class, (HttpUrl) null);
       fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("@Url parameter is null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -1445,7 +1635,41 @@
       buildRequest(Example.class, "hey", "foo/bar/");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+      assertThat(e).hasMessage("A @Url parameter must not come after a @Query. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryNameThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@QueryName String name, @Url String url) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @QueryName. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryMapThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Url String url) {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.singletonMap("kit", "kat"), "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @QueryMap. (parameter #2)\n"
           + "    for method Example.method");
     }
   }
@@ -1461,7 +1685,7 @@
     Request request = buildRequest(Example.class, "foo/bar/", "hey!");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey%21");
   }
 
   @Test public void postWithUrl() {
@@ -1471,7 +1695,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
@@ -1508,7 +1732,6 @@
     assertBody(request.body(), "");
   }
 
-  @Ignore("https://github.com/square/okhttp/issues/229")
   @Test public void customMethodEmptyBody() {
     class Example {
       @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
@@ -1534,7 +1757,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -1563,12 +1787,14 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
+    assertThat(body.contentType().toString()).startsWith("multipart/form-data; boundary=");
+
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
@@ -1728,7 +1954,7 @@
 
     MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
     MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+    Request request = buildRequest(Example.class, asList(part1, part2));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1818,7 +2044,7 @@
       }
     }
 
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+    Request request = buildRequest(Example.class, asList("pong1", "pong2"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -1888,7 +2114,7 @@
     }
 
     Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
+        TEXT_PLAIN, "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
@@ -2032,7 +2258,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
+      assertThat(e).hasMessage("Part map was null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2053,7 +2280,8 @@
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
+      assertThat(e).hasMessage("Part map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2074,7 +2302,8 @@
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+      assertThat(e).hasMessage("Part map contained null value for key 'kit'. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2088,7 +2317,7 @@
     }
 
     try {
-      buildRequest(Example.class, Collections.emptyList());
+      buildRequest(Example.class, emptyList());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
@@ -2168,7 +2397,9 @@
       }
     }
     Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
+    RequestBody body = request.body();
+    assertBody(body, "foo=bar&ping=pong");
+    assertThat(body.contentType().toString()).isEqualTo("application/x-www-form-urlencoded");
   }
 
   @Test public void formEncodedWithEncodedNameFieldParam() {
@@ -2285,7 +2516,8 @@
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
+      assertThat(e).hasMessage("Field map was null. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2306,7 +2538,8 @@
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
+      assertThat(e).hasMessage("Field map contained null key. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2327,7 +2560,8 @@
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+      assertThat(e).hasMessage("Field map contained null value for key 'foo'. (parameter #1)\n" +
+              "    for method Example.method");
     }
   }
 
@@ -2390,6 +2624,28 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void headersDoNotOverwriteEachOther() {
+    class Example {
+      @GET("/foo/bar/")
+      @Headers({
+          "ping: pong",
+          "kit: kat",
+          "kit: -kat",
+      })
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    okhttp3.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(3);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.values("kit")).containsOnly("kat", "-kat");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
@@ -2431,7 +2687,7 @@
         return null;
       }
     }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+    Request request = buildRequest(Example.class, asList("bar", null, "baz"));
     assertThat(request.method()).isEqualTo("GET");
     okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
@@ -2464,11 +2720,41 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void contentTypeAnnotationHeaderOverridesFormEncoding() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", "pong");
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
+  @Test public void contentTypeAnnotationHeaderOverridesMultipart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        TEXT_PLAIN, "kat"));
+
+    RequestBody body = request.body();
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
   @Test public void malformedContentTypeHeaderThrows() {
     class Example {
       @POST("/") //
@@ -2477,13 +2763,14 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!\n"
           + "    for method Example.method");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2506,7 +2793,7 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Plain");
     Request request = buildRequest(Example.class, "text/not-plain", body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
@@ -2518,12 +2805,13 @@
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
     try {
       buildRequest(Example.class, "hello, world!", body);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Malformed content type: hello, world!");
+      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.
     }
   }
 
@@ -2578,6 +2866,141 @@
     assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
   }
 
+  @Test public void queryParamsSkippedIfConvertedToNull() throws Exception {
+    class Example {
+      @GET("/query") Call<ResponseBody> queryPath(@Query("a") Object a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Request request = buildRequest(Example.class, retrofitBuilder, "Ignored");
+
+    assertThat(request.url().toString()).doesNotContain("Ignored");
+  }
+
+  @Test public void queryParamMapsConvertedToNullShouldError() throws Exception {
+    class Example {
+      @GET("/query") Call<ResponseBody> queryPath(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Map<String, String> queryMap = Collections.singletonMap("kit", "kat");
+
+    try {
+      buildRequest(Example.class, retrofitBuilder, queryMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining(
+          "Query map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.");
+    }
+  }
+
+  @Test public void fieldParamsSkippedIfConvertedToNull() throws Exception {
+    class Example {
+      @FormUrlEncoded
+      @POST("/query") Call<ResponseBody> queryPath(@Field("a") Object a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Request request = buildRequest(Example.class, retrofitBuilder, "Ignored");
+
+    assertThat(request.url().toString()).doesNotContain("Ignored");
+  }
+
+  @Test public void fieldParamMapsConvertedToNullShouldError() throws Exception {
+    class Example {
+      @FormUrlEncoded
+      @POST("/query") Call<ResponseBody> queryPath(@FieldMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Map<String, String> queryMap = Collections.singletonMap("kit", "kat");
+
+    try {
+      buildRequest(Example.class, retrofitBuilder, queryMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining(
+          "Field map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.");
+    }
+  }
+
+  @Test public void tag() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag String tag) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "tagValue");
+    assertThat(request.tag(String.class)).isEqualTo("tagValue");
+  }
+
+  @Test public void tagGeneric() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag List<String> tag) {
+        return null;
+      }
+    }
+
+    List<String> strings = asList("tag", "value");
+    Request request = buildRequest(Example.class, strings);
+    assertThat(request.tag(List.class)).isSameAs(strings);
+  }
+
+  @Test public void tagDuplicateFails() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag String one, @Tag String two) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "one", "two");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Tag type java.lang.String is duplicate of parameter #1 and would always overwrite its value. (parameter #2)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void tagGenericDuplicateFails() {
+    class Example {
+      @GET("/") Call<ResponseBody> method(@Tag List<String> one, @Tag List<Long> two) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, emptyList(), emptyList());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Tag type java.util.List is duplicate of parameter #1 and would always overwrite its value. (parameter #2)\n"
+              + "    for method Example.method");
+    }
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
@@ -2589,36 +3012,38 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  static <T> Request buildRequest(Class<T> cls, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
+  static <T> Request buildRequest(Class<T> cls, Retrofit.Builder builder, Object... args) {
     okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
       @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
         throw new UnsupportedOperationException("Not implemented");
       }
     };
 
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
+    Retrofit retrofit = builder.callFactory(callFactory).build();
 
     Method method = TestingUtils.onlyMethod(cls);
-    //noinspection unchecked
-    ServiceMethod<T, Call<T>> serviceMethod =
-        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
-    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<T> call = serviceMethod.callAdapter.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
+    try {
+      return RequestFactory.parseAnnotations(retrofit, method).create(args);
     } catch (RuntimeException e) {
       throw e;
     } catch (Exception e) {
       throw new AssertionError(e);
     }
   }
+
+  static <T> Request buildRequest(Class<T> cls, Object... args) {
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory());
+
+    return buildRequest(cls, retrofitBuilder, args);
+  }
+
+  static void assertMalformedRequest(Class<?> cls, Object... args) {
+    try {
+      Request request = buildRequest(cls, args);
+      fail("expected a malformed request but was " + request);
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 3d059b8ad..02ab96677 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -77,6 +77,17 @@
     }
   }
 
+  @Test public void successWithStatusCode() {
+    Object body = new Object();
+    Response<Object> response = Response.success(204, body);
+    assertThat(response.code()).isEqualTo(204);
+    assertThat(response.message()).isEqualTo("Response.success()");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
   @Test public void successWithRawResponse() {
     Object body = new Object();
     Response<Object> response = Response.success(body, successResponse);
@@ -112,7 +123,7 @@
     Response<?> response = Response.error(400, errorBody);
     assertThat(response.raw()).isNotNull();
     assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
+    assertThat(response.message()).isEqualTo("Response.error()");
     assertThat(response.headers().size()).isZero();
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.body()).isNull();
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 92dfb74ca..7b7240dc6 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -39,6 +40,7 @@
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import org.jetbrains.annotations.NotNull;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit2.helpers.DelegatingCallAdapterFactory;
@@ -54,15 +56,10 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class RetrofitTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -75,6 +72,9 @@
     @GET("/") Call<okhttp3.Response> badType2();
 
     @GET("/") Call<ResponseBody> getResponseBody();
+    @SkipCallbackExecutor
+    @GET("/") Call<ResponseBody> getResponseBodySkippedExecutor();
+
     @GET("/") Call<Void> getVoid();
     @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
     @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
@@ -142,11 +142,24 @@
   }
 
   @Test public void cloneSharesStatefulInstances() {
-    CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
-    Converter.Factory converter = mock(Converter.Factory.class);
+    CallAdapter.Factory callAdapter = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory converter = new Converter.Factory() {};
     HttpUrl baseUrl = server.url("/");
-    Executor executor = mock(Executor.class);
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+    Executor executor = new Executor() {
+      @Override public void execute(@NotNull Runnable command) {
+        command.run();
+      }
+    };
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        throw new AssertionError();
+      }
+    };
 
     Retrofit one = new Retrofit.Builder()
         .addCallAdapterFactory(callAdapter)
@@ -156,8 +169,13 @@
         .callFactory(callFactory)
         .build();
 
-    CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
-    Converter.Factory converter2 = mock(Converter.Factory.class);
+    CallAdapter.Factory callAdapter2 = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory converter2 = new Converter.Factory() {};
     Retrofit two = one.newBuilder()
         .addCallAdapterFactory(callAdapter2)
         .addConverterFactory(converter2)
@@ -171,6 +189,14 @@
     assertSame(callFactory, two.callFactory());
   }
 
+  @Test public void builtInConvertersAbsentInCloneBuilder() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    assertEquals(0, retrofit.newBuilder().converterFactories().size());
+  }
+
   @Test public void responseTypeCannotBeRetrofitResponse() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -181,7 +207,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+          "Response must include generic type (e.g., Response<String>)\n"
               + "    for method CallMethod.badType1");
     }
   }
@@ -262,8 +288,8 @@
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<?, ?> get(
+          final Type returnType, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         if (getRawType(returnType) != Call.class) {
           return null;
@@ -293,8 +319,8 @@
 
   @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<Object, String> get(
+          Type returnType, Annotation[] annotations, Retrofit retrofit) {
         if (getRawType(returnType) != String.class) {
           return null;
         }
@@ -322,8 +348,8 @@
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<?, ?> get(
+          Type returnType, Annotation[] annotations, Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
       }
@@ -355,6 +381,7 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
           + "  Tried:\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
@@ -433,8 +460,8 @@
   @Test public void stringConverterCalledForString() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable Converter<?, String> stringConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -452,8 +479,8 @@
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable Converter<?, String> stringConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -483,7 +510,8 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate RequestBody converter for class java.lang.String.\n"
           + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -505,7 +533,8 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -557,7 +586,7 @@
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    RequestBody body = RequestBody.create(MediaType.get("text/plain"), "Hey");
     Response<ResponseBody> response = example.postRequestBody(body).execute();
     assertThat(response.body().string()).isEqualTo("Hi");
 
@@ -684,8 +713,7 @@
     try {
       new Retrofit.Builder().baseUrl("ftp://foo/bar");
       fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    } catch (IllegalArgumentException ignored) {
     }
   }
 
@@ -696,7 +724,7 @@
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
     }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+    HttpUrl parsed = HttpUrl.get("http://example.com/api");
     try {
       new Retrofit.Builder().baseUrl(parsed);
       fail();
@@ -710,11 +738,11 @@
         .baseUrl("http://example.com/")
         .build();
     HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    assertThat(baseUrl).isEqualTo(HttpUrl.get("http://example.com/"));
   }
 
   @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
+    HttpUrl url = HttpUrl.get("http://example.com/");
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(url)
         .build();
@@ -738,7 +766,11 @@
   }
 
   @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        throw new AssertionError();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .callFactory(callFactory)
@@ -756,11 +788,13 @@
   }
 
   @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+    final AtomicBoolean called = new AtomicBoolean();
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
       @Override public okhttp3.Call newCall(Request request) {
+        called.set(true);
         return new OkHttpClient().newCall(request);
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .callFactory(callFactory)
@@ -770,8 +804,7 @@
 
     CallMethod service = retrofit.create(CallMethod.class);
     service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
+    assertTrue(called.get());
   }
 
   @Test public void callFactoryReturningNullThrows() throws IOException {
@@ -835,32 +868,52 @@
         .baseUrl("http://example.com/")
         .build();
     List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories).hasSize(2);
     assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
   }
 
-  @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
+  @Test public void builtInConvertersFirstInClone() {
+    Converter.Factory factory = new Converter.Factory() {
+      @Nullable @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        throw new AssertionError("User converter factory shouldn't be called for built-in types");
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
+        .build()
+        .newBuilder() // Do a newBuilder().builder() dance to force the internal list to clone.
         .build();
 
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
+    assertNotNull(retrofit.responseBodyConverter(Void.class, new Annotation[0]));
+  }
 
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
+  @Test public void requestConverterFactoryQueried() {
+    final Converter<?, RequestBody> expectedAdapter = new Converter<Object, RequestBody>() {
+      @Nullable @Override public RequestBody convert(Object value) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory factory = new Converter.Factory() {
+      @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return String.class.equals(type)
+            ? expectedAdapter
+            : null;
+      }
+    };
 
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    Converter<?, RequestBody> actualAdapter =
+        retrofit.requestBodyConverter(String.class, new Annotation[0], new Annotation[0]);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
   }
 
   @Test public void requestConverterFactoryNoMatchThrows() {
@@ -882,7 +935,8 @@
           + "Could not locate RequestBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory.called).isTrue();
@@ -911,7 +965,8 @@
           + "   * retrofit2.BuiltInConverters\n"
           + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
           + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory1.called).isFalse();
@@ -919,24 +974,29 @@
   }
 
   @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
+    final Converter<ResponseBody, ?> expectedAdapter = new Converter<ResponseBody, Object>() {
+      @Nullable @Override public Object convert(ResponseBody value) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory factory = new Converter.Factory() {
+      @Nullable @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        return String.class.equals(type)
+            ? expectedAdapter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+    Converter<ResponseBody, ?> actualAdapter =
+        retrofit.responseBodyConverter(String.class, new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
   }
 
   @Test public void responseConverterFactoryNoMatchThrows() {
@@ -958,7 +1018,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory.called).isTrue();
@@ -987,7 +1048,8 @@
           + "   * retrofit2.BuiltInConverters\n"
           + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
           + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory1.called).isFalse();
@@ -995,28 +1057,33 @@
   }
 
   @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
+    final Converter<?, String> expectedConverter = new Converter<Object, String>() {
+      @Nullable @Override public String convert(Object value) {
+        throw new AssertionError();
+      }
+    };
+    Converter.Factory factory = new Converter.Factory() {
+      @Nullable @Override
+      public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        return Object.class.equals(type)
+            ? expectedConverter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
+    Converter<?, String> actualConverter =
+        retrofit.stringConverter(Object.class, new Annotation[0]);
+    assertThat(actualConverter).isSameAs(expectedConverter);
   }
 
   @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
+    Converter.Factory factory = new Converter.Factory() {};
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(factory)
@@ -1041,7 +1108,12 @@
   }
 
   @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addCallAdapterFactory(factory)
@@ -1050,38 +1122,55 @@
   }
 
   @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    final CallAdapter<?, ?> expectedAdapter = new CallAdapter<Object, Object>() {
+      @Override public Type responseType() {
+        throw new AssertionError();
+      }
+      @Override public Object adapt(Call<Object> call) {
+        throw new AssertionError();
+      }
+    };
+    CallAdapter.Factory factory = new CallAdapter.Factory() {
+      @Nullable @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return String.class.equals(returnType)
+            ? expectedAdapter
+            : null;
+      }
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addCallAdapterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(String.class, new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
   }
 
   @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+    final CallAdapter<?, ?> expectedAdapter = new CallAdapter<Object, Object>() {
+      @Override public Type responseType() {
+        throw new AssertionError();
+      }
+      @Override public Object adapt(Call<Object> call) {
+        throw new AssertionError();
+      }
+    };
+    CallAdapter.Factory factory2 = new CallAdapter.Factory() {
       @Override
       public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return expectedAdapter;
+      }
+    };
+    final AtomicBoolean factory1called = new AtomicBoolean();
+    CallAdapter.Factory factory1 = new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        factory1called.set(true);
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
-    });
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
@@ -1089,35 +1178,45 @@
         .addCallAdapterFactory(factory2)
         .build();
 
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(String.class, new Annotation[0]);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
+    assertTrue(factory1called.get());
   }
 
   @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+    final CallAdapter<?, ?> expectedAdapter = new CallAdapter<Object, Object>() {
+      @Override public Type responseType() {
+        throw new AssertionError();
+      }
+      @Override public Object adapt(Call<Object> call) {
+        throw new AssertionError();
+      }
+    };
+    CallAdapter.Factory factory3 = new CallAdapter.Factory() {
       @Override
       public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return expectedAdapter;
+      }
+    };
+    final AtomicBoolean factory2called = new AtomicBoolean();
+    CallAdapter.Factory factory2 = new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        factory2called.set(true);
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+    };
+    final AtomicBoolean factory1called = new AtomicBoolean();
+    CallAdapter.Factory factory1 = new CallAdapter.Factory() {
       @Override
       public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        factory1called.set(true);
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
-    });
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
@@ -1126,17 +1225,10 @@
         .addCallAdapterFactory(factory3)
         .build();
 
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
     CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
+    assertTrue(factory1called.get());
+    assertTrue(factory2called.get());
   }
 
   @Test public void callAdapterFactoryNoMatchThrows() {
@@ -1158,6 +1250,7 @@
           + "Could not locate call adapter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
@@ -1190,6 +1283,7 @@
           + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
@@ -1198,6 +1292,14 @@
     assertThat(nonMatchingFactory.called).isTrue();
   }
 
+  @Test public void platformAwareAdapterAbsentInCloneBuilder() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    assertEquals(0, retrofit.newBuilder().callAdapterFactories().size());
+  }
+
   @Test public void callbackExecutorNullThrows() {
     try {
       new Retrofit.Builder().callbackExecutor(null);
@@ -1228,7 +1330,11 @@
   }
 
   @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
+    Executor executor = new Executor() {
+      @Override public void execute(@NotNull Runnable command) {
+        throw new AssertionError();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .callbackExecutor(executor)
@@ -1237,11 +1343,50 @@
   }
 
   @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
+    final CountDownLatch runnableLatch = new CountDownLatch(1);
+    final AtomicReference<Runnable> runnableRef = new AtomicReference<>();
+    Executor executor = new Executor() {
       @Override public void execute(Runnable command) {
-        command.run();
+        runnableRef.set(command);
+        runnableLatch.countDown();
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch callbackLatch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+        callbackLatch.countDown();
+      }
+
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
+        t.printStackTrace();
       }
     });
+
+    assertTrue(runnableLatch.await(2, TimeUnit.SECONDS));
+    assertEquals(1, callbackLatch.getCount()); // Callback not run yet.
+
+    runnableRef.get().run();
+    assertTrue(callbackLatch.await(2, TimeUnit.SECONDS));
+  }
+
+  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
+    final CountDownLatch runnableLatch = new CountDownLatch(1);
+    final AtomicReference<Runnable> runnableRef = new AtomicReference<>();
+    Executor executor = new Executor() {
+      @Override public void execute(Runnable command) {
+        runnableRef.set(command);
+        runnableLatch.countDown();
+      }
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .callbackExecutor(executor)
@@ -1249,6 +1394,39 @@
     CallMethod service = retrofit.create(CallMethod.class);
     Call<ResponseBody> call = service.getResponseBody();
 
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+    final CountDownLatch callbackLatch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
+        callbackLatch.countDown();
+      }
+    });
+
+    assertTrue(runnableLatch.await(2, TimeUnit.SECONDS));
+    assertEquals(1, callbackLatch.getCount()); // Callback not run yet.
+
+    runnableRef.get().run();
+    assertTrue(callbackLatch.await(2, TimeUnit.SECONDS));
+  }
+
+  @Test public void skippedCallbackExecutorNotUsedForSuccess() throws InterruptedException {
+    Executor executor = new Executor() {
+      @Override public void execute(Runnable command) {
+        fail();
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBodySkippedExecutor();
+
     server.enqueue(new MockResponse());
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -1262,23 +1440,20 @@
       }
     });
     assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
   }
 
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
+  @Test public void skippedCallbackExecutorNotUsedForFailure() throws InterruptedException {
+    Executor executor = new Executor() {
       @Override public void execute(Runnable command) {
-        command.run();
+        fail();
       }
-    });
+    };
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .callbackExecutor(executor)
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
+    Call<ResponseBody> call = service.getResponseBodySkippedExecutor();
 
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
@@ -1293,9 +1468,6 @@
       }
     });
     assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
   }
 
   /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 3847509ea..f68b724cf 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -16,13 +16,20 @@
 package retrofit2;
 
 import java.lang.reflect.Method;
+import java.util.Arrays;
 
-public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
+final class TestingUtils {
+  static Method onlyMethod(Class c) {
     Method[] declaredMethods = c.getDeclaredMethods();
     if (declaredMethods.length == 1) {
       return declaredMethods[0];
     }
     throw new IllegalArgumentException("More than one method declared.");
   }
+
+  static String repeat(char c, int times) {
+    char[] cs = new char[times];
+    Arrays.fill(cs, c);
+    return new String(cs);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 3f44ddff8..76dfbf51f 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -17,14 +17,15 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
   public boolean called;
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
index 343839944..28c4dfb77 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -25,21 +26,20 @@
 public final class NonMatchingConverterFactory extends Converter.Factory {
   public boolean called;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     called = true;
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<?, String> stringConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java
new file mode 100644
index 000000000..d34988d1f
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/** Always converts to null. */
+public final class NullObjectConverterFactory extends Converter.Factory {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<Object, String>() {
+      @Override public String convert(Object value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/ObjectInstanceConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ObjectInstanceConverterFactory.java
new file mode 100644
index 000000000..bf3134696
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/ObjectInstanceConverterFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public final class ObjectInstanceConverterFactory extends Converter.Factory {
+  public static final Object VALUE = new Object();
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (type != Object.class) {
+      return null;
+    }
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) {
+        return VALUE;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..c267d3356 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,11 +26,10 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+  static final MediaType MEDIA_TYPE = MediaType.get("text/plain");
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<ResponseBody, String>() {
         @Override public String convert(ResponseBody value) throws IOException {
@@ -40,7 +40,7 @@
     return null;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<String, RequestBody>() {
diff --git a/samples/pom.xml b/samples/pom.xml
index 84de4c276..cd3997811 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -52,6 +52,11 @@
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>org.jsoup</groupId>
       <artifactId>jsoup</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
index 0664d3482..d4b86d56b 100644
--- a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -22,6 +22,7 @@
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -67,9 +68,8 @@ public AnnotatedConverterFactory build() {
       this.factories = new LinkedHashMap<>(factories);
     }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         Converter.Factory factory = factories.get(annotation.annotationType());
         if (factory != null) {
@@ -79,7 +79,7 @@ public AnnotatedConverterFactory build() {
       return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       for (Annotation annotation : parameterAnnotations) {
         Converter.Factory factory = factories.get(annotation.annotationType());
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 790675975..1a2bde63a 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -48,8 +49,7 @@
    * present on {@code @Body} params.
    */
   static class ChunkingConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       boolean isBody = false;
       boolean isChunked = false;
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index b8e20a1b1..d2e1da916 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nullable;
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
 import okhttp3.HttpUrl;
@@ -77,7 +78,7 @@ public void crawlPage(HttpUrl url) {
         // Enqueue its links for visiting.
         for (String link : page.links) {
           HttpUrl linkUrl = base.resolve(link);
-          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+          if (linkUrl != null && fetchedUrls.add(linkUrl)) {
             crawlPage(linkUrl);
           }
         }
@@ -100,7 +101,7 @@ public static void main(String... args) throws Exception {
         .build();
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
+        .baseUrl(HttpUrl.get("https://example.com/"))
         .addConverterFactory(PageAdapter.FACTORY)
         .client(okHttpClient)
         .build();
@@ -108,7 +109,7 @@ public static void main(String... args) throws Exception {
     PageService pageService = retrofit.create(PageService.class);
 
     Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
+    crawler.crawlPage(HttpUrl.get(args[0]));
   }
 
   interface PageService {
@@ -127,7 +128,7 @@ public static void main(String... args) throws Exception {
 
   static final class PageAdapter implements Converter<ResponseBody, Page> {
     static final Converter.Factory FACTORY = new Converter.Factory() {
-      @Override public Converter<ResponseBody, ?> responseBodyConverter(
+      @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
           Type type, Annotation[] annotations, Retrofit retrofit) {
         if (type == Page.class) return new PageAdapter();
         return null;
diff --git a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
index 7507b840a..bbe28ae57 100644
--- a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
+++ b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
@@ -67,7 +67,7 @@ public static void main(String... args) throws IOException {
         .build();
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://www.coca-cola.com/")
+        .baseUrl("http://www.github.com/")
         .callFactory(okHttpClient)
         .build();
 
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 28e8521ac..03dc55029 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -59,8 +60,8 @@
   }
 
   public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable CallAdapter<?, ?> get(
+        Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (getRawType(returnType) != MyCall.class) {
         return null;
       }
@@ -180,7 +181,7 @@ public static void main(String... args) {
       }
 
       @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
+        System.err.println("NETWORK ERROR " + e.getMessage());
       }
 
       @Override public void unexpectedError(Throwable t) {
diff --git a/samples/src/main/java/com/example/retrofit/InvocationMetrics.java b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
new file mode 100644
index 000000000..49ac30481
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Invocation;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+/**
+ * This example prints HTTP call metrics with the initiating method names and arguments.
+ */
+public final class InvocationMetrics {
+  public interface Browse {
+    @GET("/robots.txt")
+    Call<ResponseBody> robots();
+
+    @GET("/favicon.ico")
+    Call<ResponseBody> favicon();
+
+    @GET("/")
+    Call<ResponseBody> home();
+
+    @GET
+    Call<ResponseBody> page(@Url String path);
+  }
+
+  static final class InvocationLogger implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      long startNanos = System.nanoTime();
+      Response response = chain.proceed(request);
+      long elapsedNanos = System.nanoTime() - startNanos;
+
+      Invocation invocation = request.tag(Invocation.class);
+      if (invocation != null) {
+        System.out.printf("%s.%s %s HTTP %s (%.0f ms)%n",
+            invocation.method().getDeclaringClass().getSimpleName(),
+            invocation.method().getName(),
+            invocation.arguments(),
+            response.code(),
+            elapsedNanos / 1_000_000.0);
+      }
+
+      return response;
+    }
+  }
+
+  public static void main(String... args) throws IOException {
+    InvocationLogger invocationLogger = new InvocationLogger();
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .addInterceptor(invocationLogger)
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("https://square.com/")
+        .callFactory(okHttpClient)
+        .build();
+
+    Browse browse = retrofit.create(Browse.class);
+
+    browse.robots().execute();
+    browse.favicon().execute();
+    browse.home().execute();
+    browse.page("sitemap.xml").execute();
+    browse.page("notfound").execute();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
index 2163f3dec..354e901c3 100644
--- a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -60,9 +61,8 @@
       this.xmlFactory = xmlFactory;
     }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         if (annotation instanceof Json) {
           return jsonFactory.responseBodyConverter(type, annotations, retrofit);
@@ -74,7 +74,7 @@
       return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       for (Annotation annotation : parameterAnnotations) {
         if (annotation instanceof Json) {
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index 724c75fb2..35489272a 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -47,8 +48,8 @@
       this.delegateFactory = delegateFactory;
     }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<?, String> stringConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         if (annotation instanceof Json) {
           // NOTE: If you also have a JSON converter factory installed in addition to this factory,
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
index 6c4fec40d..4e7a2d636 100644
--- a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -48,8 +49,8 @@ public static void main(String... args) {
       this.scheduler = scheduler;
     }
 
-    @Override
-    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    @Override public @Nullable CallAdapter<?, ?> get(
+        Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (getRawType(returnType) != Observable.class) {
         return null; // Ignore non-Observable types.
       }
diff --git a/samples/src/main/java/com/example/retrofit/package-info.java b/samples/src/main/java/com/example/retrofit/package-info.java
new file mode 100644
index 000000000..5ec8c5bac
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/package-info.java
@@ -0,0 +1,2 @@
+@javax.annotation.ParametersAreNonnullByDefault
+package com.example.retrofit;
diff --git a/website/index.html b/website/index.html
index fa15e43f0..c34bd1687 100644
--- a/website/index.html
+++ b/website/index.html
@@ -22,8 +22,8 @@ <h1>Retrofit</h1>
             <menu>
               <ul>
                 <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/retrofit" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+                <li><a href="https://github.com/square/retrofit" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
               </ul>
             </menu>
           </div>
@@ -120,6 +120,9 @@ <h4>Header Manipulation</h4>
               <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
               <pre class="prettyprint">@GET("user")
 Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
+              <p>Similar to query parameters, for complex header combinations, a <code>Map</code> can be used.
+			  <pre class="prettyprint">@GET("user")
+Call&lt;User> getUser(@HeaderMap Map&lt;String, String&gt; headers)</pre>
               <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
 
               <h4>Synchronous vs. Asynchronous</h4>
@@ -157,7 +160,7 @@ <h4>Custom Converters</h4>
             <section id="download">
               <h3>Download</h3>
               <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+              <p>The source code to the Retrofit, its samples, and this website is <a href="https://github.com/square/retrofit">available on GitHub</a>.</p>
               <h4>Maven</h4>
               <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit2&lt;/groupId>
@@ -166,30 +169,20 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
               <h4>Gradle</h4>
               <pre class="prettyprint">
-compile 'com.squareup.retrofit2:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
+implementation 'com.squareup.retrofit2:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
               <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-              <h4>ProGuard</h4>
-              <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
-              <pre class="prettyprint">
-# Platform calls Class.forName on types which do not exist on Android to determine platform.
--dontnote retrofit2.Platform
-# Platform used when running on Java 8 VMs. Will not be used at runtime.
--dontwarn retrofit2.Platform$Java8
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
-# Retain declared checked exceptions for use by a Proxy instance.
--keepattributes Exceptions
-</pre>
-            <p>Retrofit uses <a href="https://github.com/square/okio">Okio</a> under the hood, so you may want to look at its <a href="https://github.com/square/okio#proguard">ProGuard rules</a> as well.</p>
+              <h4>R8 / ProGuard</h4>
+              <p>If you are using R8 or ProGuard add the options from <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro">this file</a>.</p>
+              <p>You might also need rules for OkHttp and Okio which are dependencies of this library.</p>
             </section>
 
             <section id="contributing">
               <h3>Contributing</h3>
               <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
               <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+              <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
             </section>
 
             <section id="license">
@@ -221,7 +214,7 @@ <h3>License</h3>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="2.x/retrofit/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
+                <li><a href="https://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
index 08a0304fe..0cb624ff6 100644
--- a/website/static/jquery-maven-artifact.min.js
+++ b/website/static/jquery-maven-artifact.min.js
@@ -5,4 +5,4 @@
  * Author: Jake Wharton
  * License: Apache 2.0
  */
-(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"http://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
\ No newline at end of file
+(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"https://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='https://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='https://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
