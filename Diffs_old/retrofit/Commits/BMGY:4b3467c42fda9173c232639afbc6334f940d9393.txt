diff --git a/retrofit/src/main/java/retrofit/Config.java b/retrofit/src/main/java/retrofit/Config.java
new file mode 100644
index 000000000..2299b469c
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Config.java
@@ -0,0 +1,19 @@
+package retrofit;
+
+import java.io.Serializable;
+
+public class Config implements Serializable {
+
+	private static String _charset = "UTF-8";
+
+	public static String getCharset() {
+		return _charset;
+	}
+
+	public static void setCharset(String charset) {
+		if (charset.equals("") || charset == null)
+			return;
+		_charset = charset;
+	}
+
+}
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 939d72c56..41d9ad958 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -42,364 +42,367 @@
 import retrofit.mime.TypedString;
 
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
-  private final Converter converter;
-  private final Annotation[] paramAnnotations;
-  private final String requestMethod;
-  private final boolean isSynchronous;
-  private final boolean isObservable;
-  private final String apiUrl;
-
-  private final FormUrlEncodedTypedOutput formBody;
-  private final MultipartTypedOutput multipartBody;
-  private TypedOutput body;
-
-  private String relativeUrl;
-  private StringBuilder queryParams;
-  private List<Header> headers;
-  private String contentTypeHeader;
-
-  RequestBuilder(String apiUrl, RestMethodInfo methodInfo, Converter converter) {
-    this.apiUrl = apiUrl;
-    this.converter = converter;
-
-    paramAnnotations = methodInfo.requestParamAnnotations;
-    requestMethod = methodInfo.requestMethod;
-    isSynchronous = methodInfo.isSynchronous;
-    isObservable = methodInfo.isObservable;
-
-    if (methodInfo.headers != null) {
-      headers = new ArrayList<Header>(methodInfo.headers);
-    }
-    contentTypeHeader = methodInfo.contentTypeHeader;
-
-    relativeUrl = methodInfo.requestUrl;
-
-    String requestQuery = methodInfo.requestQuery;
-    if (requestQuery != null) {
-      queryParams = new StringBuilder().append('?').append(requestQuery);
-    }
-
-    switch (methodInfo.requestType) {
-      case FORM_URL_ENCODED:
-        formBody = new FormUrlEncodedTypedOutput();
-        multipartBody = null;
-        body = formBody;
-        break;
-      case MULTIPART:
-        formBody = null;
-        multipartBody = new MultipartTypedOutput();
-        body = multipartBody;
-        break;
-      case SIMPLE:
-        formBody = null;
-        multipartBody = null;
-        // If present, 'body' will be set in 'setArguments' call.
-        break;
-      default:
-        throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
-    }
-  }
-
-  @Override public void addHeader(String name, String value) {
-    if (name == null) {
-      throw new IllegalArgumentException("Header name must not be null.");
-    }
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      contentTypeHeader = value;
-      return;
-    }
-
-    List<Header> headers = this.headers;
-    if (headers == null) {
-      this.headers = headers = new ArrayList<Header>(2);
-    }
-    headers.add(new Header(name, value));
-  }
-
-  @Override public void addPathParam(String name, String value) {
-    addPathParam(name, value, true);
-  }
-
-  @Override public void addEncodedPathParam(String name, String value) {
-    addPathParam(name, value, false);
-  }
-
-  private void addPathParam(String name, String value, boolean urlEncodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Path replacement name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException(
-          "Path replacement \"" + name + "\" value must not be null.");
-    }
-    try {
-      if (urlEncodeValue) {
-        String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
-        // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
-        // encode spaces rather than +. Query encoding difference specified in HTML spec.
-        // Any remaining plus signs represent spaces as already URLEncoded.
-        encodedValue = encodedValue.replace("+", "%20");
-        relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
-      } else {
-        relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
-      }
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
-    }
-  }
-
-  @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, false, true);
-  }
-
-  @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false, false);
-  }
-
-  private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
-    if (value instanceof Iterable) {
-      for (Object iterableValue : (Iterable<?>) value) {
-        if (iterableValue != null) { // Skip null values
-          addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
-        }
-      }
-    } else if (value.getClass().isArray()) {
-      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-        Object arrayValue = Array.get(value, x);
-        if (arrayValue != null) { // Skip null values
-          addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
-        }
-      }
-    } else {
-      addQueryParam(name, value.toString(), encodeName, encodeValue);
-    }
-  }
-
-  private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Query param name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
-    }
-    try {
-      StringBuilder queryParams = this.queryParams;
-      if (queryParams == null) {
-        this.queryParams = queryParams = new StringBuilder();
-      }
-
-      queryParams.append(queryParams.length() > 0 ? '&' : '?');
-
-      if (encodeName) {
-        name = URLEncoder.encode(name, "UTF-8");
-      }
-      if (encodeValue) {
-        value = URLEncoder.encode(value, "UTF-8");
-      }
-      queryParams.append(name).append('=').append(value);
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
-    }
-  }
-
-  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames,
-      boolean encodeValues) {
-    for (Map.Entry<?, ?> entry : map.entrySet()) {
-      Object entryKey = entry.getKey();
-      if (entryKey == null) {
-        throw new IllegalArgumentException(
-            "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
-      }
-      Object entryValue = entry.getValue();
-      if (entryValue != null) { // Skip null values.
-        addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
-      }
-    }
-  }
-
-  void setArguments(Object[] args) {
-    if (args == null) {
-      return;
-    }
-    int count = args.length;
-    if (!isSynchronous && !isObservable) {
-      count -= 1;
-    }
-    for (int i = 0; i < count; i++) {
-      Object value = args[i];
-
-      Annotation annotation = paramAnnotations[i];
-      Class<? extends Annotation> annotationType = annotation.annotationType();
-      if (annotationType == Path.class) {
-        Path path = (Path) annotation;
-        String name = path.value();
-        if (value == null) {
-          throw new IllegalArgumentException(
-              "Path parameter \"" + name + "\" value must not be null.");
-        }
-        addPathParam(name, value.toString(), path.encode());
-      } else if (annotationType == Query.class) {
-        if (value != null) { // Skip null values.
-          Query query = (Query) annotation;
-          addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
-        }
-      } else if (annotationType == QueryMap.class) {
-        if (value != null) { // Skip null values.
-          QueryMap queryMap = (QueryMap) annotation;
-          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
-        }
-      } else if (annotationType == retrofit.http.Header.class) {
-        if (value != null) { // Skip null values.
-          String name = ((retrofit.http.Header) annotation).value();
-          addHeader(name, value.toString());
-        }
-      } else if (annotationType == Field.class) {
-        String name = ((Field) annotation).value();
-        if (value != null) { // Skip null values.
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                formBody.addField(name, iterableValue.toString());
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                formBody.addField(name, arrayValue.toString());
-              }
-            }
-          } else {
-            formBody.addField(name, value.toString());
-          }
-        }
-      } else if (annotationType == FieldMap.class) {
-        if (value != null) { // Skip null values.
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " field map contained null key.");
-            }
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              formBody.addField(entryKey.toString(), entryValue.toString());
-            }
-          }
-        }
-      } else if (annotationType == Part.class) {
-        String name = ((Part) annotation).value();
-        if (value != null) { // Skip null values.
-          String transferEncoding = ((Part) annotation).encoding();
-          if (value instanceof TypedOutput) {
-            multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-          } else if (value instanceof String) {
-            multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-          } else {
-            multipartBody.addPart(name, transferEncoding, converter.toBody(value));
-          }
-        }
-      } else if (annotationType == PartMap.class) {
-        if (value != null) { // Skip null values.
-          String transferEncoding = ((PartMap) annotation).encoding();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " part map contained null key.");
-            }
-            String entryName = entryKey.toString();
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              if (entryValue instanceof TypedOutput) {
-                multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-              } else if (entryValue instanceof String) {
-                multipartBody.addPart(entryName, transferEncoding,
-                    new TypedString((String) entryValue));
-              } else {
-                multipartBody.addPart(entryName, transferEncoding, converter.toBody(entryValue));
-              }
-            }
-          }
-        }
-      } else if (annotationType == Body.class) {
-        if (value == null) {
-          throw new IllegalArgumentException("Body parameter value must not be null.");
-        }
-        if (value instanceof TypedOutput) {
-          body = (TypedOutput) value;
-        } else {
-          body = converter.toBody(value);
-        }
-      } else {
-        throw new IllegalArgumentException(
-            "Unknown annotation: " + annotationType.getCanonicalName());
-      }
-    }
-  }
-
-  Request build() throws UnsupportedEncodingException {
-    if (multipartBody != null && multipartBody.getPartCount() == 0) {
-      throw new IllegalStateException("Multipart requests must contain at least one part.");
-    }
-
-    String apiUrl = this.apiUrl;
-    StringBuilder url = new StringBuilder(apiUrl);
-    if (apiUrl.endsWith("/")) {
-      // We require relative paths to start with '/'. Prevent a double-slash.
-      url.deleteCharAt(url.length() - 1);
-    }
-
-    url.append(relativeUrl);
-
-    StringBuilder queryParams = this.queryParams;
-    if (queryParams != null) {
-      url.append(queryParams);
-    }
-
-    TypedOutput body = this.body;
-    List<Header> headers = this.headers;
-    if (contentTypeHeader != null) {
-      if (body != null) {
-        body = new MimeOverridingTypedOutput(body, contentTypeHeader);
-      } else {
-        Header header = new Header("Content-Type", contentTypeHeader);
-        if (headers == null) {
-          headers = Collections.singletonList(header);
-        } else {
-          headers.add(header);
-        }
-      }
-    }
-
-    return new Request(requestMethod, url.toString(), headers, body);
-  }
-
-  private static class MimeOverridingTypedOutput implements TypedOutput {
-    private final TypedOutput delegate;
-    private final String mimeType;
-
-    MimeOverridingTypedOutput(TypedOutput delegate, String mimeType) {
-      this.delegate = delegate;
-      this.mimeType = mimeType;
-    }
-
-    @Override public String fileName() {
-      return delegate.fileName();
-    }
-
-    @Override public String mimeType() {
-      return mimeType;
-    }
-
-    @Override public long length() {
-      return delegate.length();
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      delegate.writeTo(out);
-    }
-  }
+	private final Converter converter;
+	private final Annotation[] paramAnnotations;
+	private final String requestMethod;
+	private final boolean isSynchronous;
+	private final boolean isObservable;
+	private final String apiUrl;
+
+	private final FormUrlEncodedTypedOutput formBody;
+	private final MultipartTypedOutput multipartBody;
+	private TypedOutput body;
+
+	private String relativeUrl;
+	private StringBuilder queryParams;
+	private List<Header> headers;
+	private String contentTypeHeader;
+
+	RequestBuilder(String apiUrl, RestMethodInfo methodInfo, Converter converter) {
+		this.apiUrl = apiUrl;
+		this.converter = converter;
+
+		paramAnnotations = methodInfo.requestParamAnnotations;
+		requestMethod = methodInfo.requestMethod;
+		isSynchronous = methodInfo.isSynchronous;
+		isObservable = methodInfo.isObservable;
+
+		if (methodInfo.headers != null) {
+			headers = new ArrayList<Header>(methodInfo.headers);
+		}
+		contentTypeHeader = methodInfo.contentTypeHeader;
+
+		relativeUrl = methodInfo.requestUrl;
+
+		String requestQuery = methodInfo.requestQuery;
+		if (requestQuery != null) {
+			queryParams = new StringBuilder().append('?').append(requestQuery);
+		}
+
+		switch (methodInfo.requestType) {
+		case FORM_URL_ENCODED:
+			formBody = new FormUrlEncodedTypedOutput();
+			multipartBody = null;
+			body = formBody;
+			break;
+		case MULTIPART:
+			formBody = null;
+			multipartBody = new MultipartTypedOutput();
+			body = multipartBody;
+			break;
+		case SIMPLE:
+			formBody = null;
+			multipartBody = null;
+			// If present, 'body' will be set in 'setArguments' call.
+			break;
+		default:
+			throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
+		}
+	}
+
+	@Override
+	public void addHeader(String name, String value) {
+		if (name == null) {
+			throw new IllegalArgumentException("Header name must not be null.");
+		}
+		if ("Content-Type".equalsIgnoreCase(name)) {
+			contentTypeHeader = value;
+			return;
+		}
+
+		List<Header> headers = this.headers;
+		if (headers == null) {
+			this.headers = headers = new ArrayList<Header>(2);
+		}
+		headers.add(new Header(name, value));
+	}
+
+	@Override
+	public void addPathParam(String name, String value) {
+		addPathParam(name, value, true);
+	}
+
+	@Override
+	public void addEncodedPathParam(String name, String value) {
+		addPathParam(name, value, false);
+	}
+
+	private void addPathParam(String name, String value, boolean urlEncodeValue) {
+		if (name == null) {
+			throw new IllegalArgumentException("Path replacement name must not be null.");
+		}
+		if (value == null) {
+			throw new IllegalArgumentException("Path replacement \"" + name + "\" value must not be null.");
+		}
+		try {
+			if (urlEncodeValue) {
+				String encodedValue = URLEncoder.encode(String.valueOf(value), Config.getCharset());
+				// URLEncoder encodes for use as a query parameter. Path
+				// encoding uses %20 to
+				// encode spaces rather than +. Query encoding difference
+				// specified in HTML spec.
+				// Any remaining plus signs represent spaces as already
+				// URLEncoded.
+				encodedValue = encodedValue.replace("+", "%20");
+				relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
+			} else {
+				relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
+			}
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException("Unable to convert path parameter \"" + name + "\" value to "+Config.getCharset()+":" + value, e);
+		}
+	}
+
+	@Override
+	public void addQueryParam(String name, String value) {
+		addQueryParam(name, value, false, true);
+	}
+
+	@Override
+	public void addEncodedQueryParam(String name, String value) {
+		addQueryParam(name, value, false, false);
+	}
+
+	private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
+		if (value instanceof Iterable) {
+			for (Object iterableValue : (Iterable<?>) value) {
+				if (iterableValue != null) { // Skip null values
+					addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
+				}
+			}
+		} else if (value.getClass().isArray()) {
+			for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+				Object arrayValue = Array.get(value, x);
+				if (arrayValue != null) { // Skip null values
+					addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
+				}
+			}
+		} else {
+			addQueryParam(name, value.toString(), encodeName, encodeValue);
+		}
+	}
+
+	private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
+		if (name == null) {
+			throw new IllegalArgumentException("Query param name must not be null.");
+		}
+		if (value == null) {
+			throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
+		}
+		try {
+			StringBuilder queryParams = this.queryParams;
+			if (queryParams == null) {
+				this.queryParams = queryParams = new StringBuilder();
+			}
+
+			queryParams.append(queryParams.length() > 0 ? '&' : '?');
+
+			if (encodeName) {
+				name = URLEncoder.encode(name, Config.getCharset());
+			}
+			if (encodeValue) {
+				value = URLEncoder.encode(value, Config.getCharset());
+			}
+			queryParams.append(name).append('=').append(value);
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException("Unable to convert query parameter \"" + name + "\" value to "+Config.getCharset()+": " + value, e);
+		}
+	}
+
+	private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames, boolean encodeValues) {
+		for (Map.Entry<?, ?> entry : map.entrySet()) {
+			Object entryKey = entry.getKey();
+			if (entryKey == null) {
+				throw new IllegalArgumentException("Parameter #" + (parameterNumber + 1) + " query map contained null key.");
+			}
+			Object entryValue = entry.getValue();
+			if (entryValue != null) { // Skip null values.
+				addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
+			}
+		}
+	}
+
+	void setArguments(Object[] args) {
+		if (args == null) {
+			return;
+		}
+		int count = args.length;
+		if (!isSynchronous && !isObservable) {
+			count -= 1;
+		}
+		for (int i = 0; i < count; i++) {
+			Object value = args[i];
+
+			Annotation annotation = paramAnnotations[i];
+			Class<? extends Annotation> annotationType = annotation.annotationType();
+			if (annotationType == Path.class) {
+				Path path = (Path) annotation;
+				String name = path.value();
+				if (value == null) {
+					throw new IllegalArgumentException("Path parameter \"" + name + "\" value must not be null.");
+				}
+				addPathParam(name, value.toString(), path.encode());
+			} else if (annotationType == Query.class) {
+				if (value != null) { // Skip null values.
+					Query query = (Query) annotation;
+					addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
+				}
+			} else if (annotationType == QueryMap.class) {
+				if (value != null) { // Skip null values.
+					QueryMap queryMap = (QueryMap) annotation;
+					addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
+				}
+			} else if (annotationType == retrofit.http.Header.class) {
+				if (value != null) { // Skip null values.
+					String name = ((retrofit.http.Header) annotation).value();
+					addHeader(name, value.toString());
+				}
+			} else if (annotationType == Field.class) {
+				String name = ((Field) annotation).value();
+				if (value != null) { // Skip null values.
+					if (value instanceof Iterable) {
+						for (Object iterableValue : (Iterable<?>) value) {
+							if (iterableValue != null) { // Skip null values.
+								formBody.addField(name, iterableValue.toString());
+							}
+						}
+					} else if (value.getClass().isArray()) {
+						for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+							Object arrayValue = Array.get(value, x);
+							if (arrayValue != null) { // Skip null values.
+								formBody.addField(name, arrayValue.toString());
+							}
+						}
+					} else {
+						formBody.addField(name, value.toString());
+					}
+				}
+			} else if (annotationType == FieldMap.class) {
+				if (value != null) { // Skip null values.
+					for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+						Object entryKey = entry.getKey();
+						if (entryKey == null) {
+							throw new IllegalArgumentException("Parameter #" + (i + 1) + " field map contained null key.");
+						}
+						Object entryValue = entry.getValue();
+						if (entryValue != null) { // Skip null values.
+							formBody.addField(entryKey.toString(), entryValue.toString());
+						}
+					}
+				}
+			} else if (annotationType == Part.class) {
+				String name = ((Part) annotation).value();
+				if (value != null) { // Skip null values.
+					String transferEncoding = ((Part) annotation).encoding();
+					if (value instanceof TypedOutput) {
+						multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
+					} else if (value instanceof String) {
+						multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
+					} else {
+						multipartBody.addPart(name, transferEncoding, converter.toBody(value));
+					}
+				}
+			} else if (annotationType == PartMap.class) {
+				if (value != null) { // Skip null values.
+					String transferEncoding = ((PartMap) annotation).encoding();
+					for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+						Object entryKey = entry.getKey();
+						if (entryKey == null) {
+							throw new IllegalArgumentException("Parameter #" + (i + 1) + " part map contained null key.");
+						}
+						String entryName = entryKey.toString();
+						Object entryValue = entry.getValue();
+						if (entryValue != null) { // Skip null values.
+							if (entryValue instanceof TypedOutput) {
+								multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
+							} else if (entryValue instanceof String) {
+								multipartBody.addPart(entryName, transferEncoding, new TypedString((String) entryValue));
+							} else {
+								multipartBody.addPart(entryName, transferEncoding, converter.toBody(entryValue));
+							}
+						}
+					}
+				}
+			} else if (annotationType == Body.class) {
+				if (value == null) {
+					throw new IllegalArgumentException("Body parameter value must not be null.");
+				}
+				if (value instanceof TypedOutput) {
+					body = (TypedOutput) value;
+				} else {
+					body = converter.toBody(value);
+				}
+			} else {
+				throw new IllegalArgumentException("Unknown annotation: " + annotationType.getCanonicalName());
+			}
+		}
+	}
+
+	Request build() throws UnsupportedEncodingException {
+		if (multipartBody != null && multipartBody.getPartCount() == 0) {
+			throw new IllegalStateException("Multipart requests must contain at least one part.");
+		}
+
+		String apiUrl = this.apiUrl;
+		StringBuilder url = new StringBuilder(apiUrl);
+		if (apiUrl.endsWith("/")) {
+			// We require relative paths to start with '/'. Prevent a
+			// double-slash.
+			url.deleteCharAt(url.length() - 1);
+		}
+
+		url.append(relativeUrl);
+
+		StringBuilder queryParams = this.queryParams;
+		if (queryParams != null) {
+			url.append(queryParams);
+		}
+
+		TypedOutput body = this.body;
+		List<Header> headers = this.headers;
+		if (contentTypeHeader != null) {
+			if (body != null) {
+				body = new MimeOverridingTypedOutput(body, contentTypeHeader);
+			} else {
+				Header header = new Header("Content-Type", contentTypeHeader);
+				if (headers == null) {
+					headers = Collections.singletonList(header);
+				} else {
+					headers.add(header);
+				}
+			}
+		}
+
+		return new Request(requestMethod, url.toString(), headers, body);
+	}
+
+	private static class MimeOverridingTypedOutput implements TypedOutput {
+		private final TypedOutput delegate;
+		private final String mimeType;
+
+		MimeOverridingTypedOutput(TypedOutput delegate, String mimeType) {
+			this.delegate = delegate;
+			this.mimeType = mimeType;
+		}
+
+		@Override
+		public String fileName() {
+			return delegate.fileName();
+		}
+
+		@Override
+		public String mimeType() {
+			return mimeType;
+		}
+
+		@Override
+		public long length() {
+			return delegate.length();
+		}
+
+		@Override
+		public void writeTo(OutputStream out) throws IOException {
+			delegate.writeTo(out);
+		}
+	}
 }
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index a5486249e..70ff2df34 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -26,6 +26,7 @@
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
+
 import retrofit.client.Client;
 import retrofit.client.Header;
 import retrofit.client.Request;
@@ -40,605 +41,652 @@
 /**
  * Adapts a Java interface to a REST API.
  * <p>
- * API endpoints are defined as methods on an interface with annotations providing metadata about
- * the form in which the HTTP call should be made.
+ * API endpoints are defined as methods on an interface with annotations
+ * providing metadata about the form in which the HTTP call should be made.
  * <p>
- * The relative path for a given method is obtained from an annotation on the method describing
- * the request type. The built-in methods are {@link retrofit.http.GET GET},
- * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.HEAD HEAD},
- * and {@link retrofit.http.DELETE DELETE}. You can define your own HTTP method by creating an
- * annotation that takes a {code String} value and itself is annotated with
- * {@link retrofit.http.RestMethod @RestMethod}.
+ * The relative path for a given method is obtained from an annotation on the
+ * method describing the request type. The built-in methods are
+ * {@link retrofit.http.GET GET}, {@link retrofit.http.PUT PUT},
+ * {@link retrofit.http.POST POST}, {@link retrofit.http.HEAD HEAD}, and
+ * {@link retrofit.http.DELETE DELETE}. You can define your own HTTP method by
+ * creating an annotation that takes a {code String} value and itself is
+ * annotated with {@link retrofit.http.RestMethod @RestMethod}.
  * <p>
- * Method parameters can be used to replace parts of the URL by annotating them with
- * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
- * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}.
+ * Method parameters can be used to replace parts of the URL by annotating them
+ * with {@link retrofit.http.Path @Path}. Replacement sections are denoted by an
+ * identifier surrounded by curly braces (e.g., "{foo}"). To add items to the
+ * query string of a URL use {@link retrofit.http.Query @Query}.
  * <p>
  * HTTP requests happen in one of two ways:
  * <ul>
- * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
- * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
- * response will be converted to the callback's parameter type using the specified
- * {@link retrofit.converter.Converter Converter}. If the callback parameter type uses a wildcard,
- * the lower bound will be used as the conversion type.
- * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
- * response will be converted to the method's return type using the specified
- * {@link retrofit.converter.Converter Converter}.
+ * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the
+ * callback {@link Executor}. The last method parameter should be of type
+ * {@link Callback}. The HTTP response will be converted to the callback's
+ * parameter type using the specified {@link retrofit.converter.Converter
+ * Converter}. If the callback parameter type uses a wildcard, the lower bound
+ * will be used as the conversion type.
+ * <li>On the current thread returning the response or throwing a
+ * {@link RetrofitError}. The HTTP response will be converted to the method's
+ * return type using the specified {@link retrofit.converter.Converter
+ * Converter}.
  * </ul>
  * <p>
- * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
- * will be converted to request representation by a call to
- * {@link retrofit.converter.Converter#toBody(Object) toBody} on the supplied
- * {@link retrofit.converter.Converter Converter} for this instance. The body can also be a
- * {@link TypedOutput} where it will be used directly.
+ * The body of a request is denoted by the {@link retrofit.http.Body @Body}
+ * annotation. The object will be converted to request representation by a call
+ * to {@link retrofit.converter.Converter#toBody(Object) toBody} on the supplied
+ * {@link retrofit.converter.Converter Converter} for this instance. The body
+ * can also be a {@link TypedOutput} where it will be used directly.
  * <p>
- * Alternative request body formats are supported by method annotations and corresponding parameter
- * annotations:
+ * Alternative request body formats are supported by method annotations and
+ * corresponding parameter annotations:
  * <ul>
- * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
- * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
- * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
- * specified by the {@link retrofit.http.Part @Part} parameter annotation.
+ * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data
+ * with key-value pairs specified by the {@link retrofit.http.Field @Field}
+ * parameter annotation.
+ * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant
+ * multi-part data with parts specified by the {@link retrofit.http.Part @Part}
+ * parameter annotation.
  * </ul>
  * <p>
  * Additional static headers can be added for an endpoint using the
- * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
- * annotate a parameter with {@link Header @Header}.
+ * {@link retrofit.http.Headers @Headers} method annotation. For per-request
+ * control over a header annotate a parameter with {@link Header @Header}.
  * <p>
  * For example:
+ * 
  * <pre>
  * public interface MyApi {
- *   &#64;POST("/category/{cat}") // Asynchronous execution.
- *   void categoryList(@Path("cat") String a, @Query("page") int b,
- *                     Callback&lt;List&lt;Item&gt;&gt; cb);
- *   &#64;POST("/category/{cat}") // Synchronous execution.
- *   List&lt;Item&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+ * 	&#064;POST(&quot;/category/{cat}&quot;)
+ * 	// Asynchronous execution.
+ * 	void categoryList(@Path(&quot;cat&quot;) String a, @Query(&quot;page&quot;) int b, Callback&lt;List&lt;Item&gt;&gt; cb);
+ * 
+ * 	&#064;POST(&quot;/category/{cat}&quot;)
+ * 	// Synchronous execution.
+ * 	List&lt;Item&gt; categoryList(@Path(&quot;cat&quot;) String a, @Query(&quot;page&quot;) int b);
  * }
  * </pre>
  * <p>
- * Calling {@link #create(Class)} with {@code MyApi.class} will validate and create a new
- * implementation of the API.
- *
+ * Calling {@link #create(Class)} with {@code MyApi.class} will validate and
+ * create a new implementation of the API.
+ * 
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  static final String THREAD_PREFIX = "Retrofit-";
-  static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
-
-  /** Simple logging abstraction for debug messages. */
-  public interface Log {
-    /** Log a debug message to the appropriate console. */
-    void log(String message);
-
-    /** A {@link Log} implementation which does not log anything. */
-    Log NONE = new Log() {
-      @Override public void log(String message) {
-      }
-    };
-  }
-
-  /** Controls the level of logging. */
-  public enum LogLevel {
-    /** No logging. */
-    NONE,
-    /** Log only the request method and URL and the response status code and execution time. */
-    BASIC,
-    /** Log the basic information along with request and response headers. */
-    HEADERS,
-    /** Log the basic information along with request and response objects via toString(). */
-    HEADERS_AND_ARGS,
-    /**
-     * Log the headers, body, and metadata for both requests and responses.
-     * <p>
-     * Note: This requires that the entire request and response body be buffered in memory!
-     */
-    FULL;
-
-    public boolean log() {
-      return this != NONE;
-    }
-  }
-
-  private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
-
-  final Endpoint server;
-  final Executor httpExecutor;
-  final Executor callbackExecutor;
-  final RequestInterceptor requestInterceptor;
-  final Converter converter;
-  final Log log;
-  final ErrorHandler errorHandler;
-
-  private final Client client;
-  private RxSupport rxSupport;
-
-  volatile LogLevel logLevel;
-
-  private RestAdapter(Endpoint server, Client client, Executor httpExecutor,
-      Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
-      ErrorHandler errorHandler, Log log, LogLevel logLevel) {
-    this.server = server;
-    this.client = client;
-    this.httpExecutor = httpExecutor;
-    this.callbackExecutor = callbackExecutor;
-    this.requestInterceptor = requestInterceptor;
-    this.converter = converter;
-    this.errorHandler = errorHandler;
-    this.log = log;
-    this.logLevel = logLevel;
-  }
-
-  /** Change the level of logging. */
-  public void setLogLevel(LogLevel loglevel) {
-    if (logLevel == null) {
-      throw new NullPointerException("Log level may not be null.");
-    }
-    this.logLevel = loglevel;
-  }
-
-  /** The current logging level. */
-  public LogLevel getLogLevel() {
-    return logLevel;
-  }
-
-  /** Create an implementation of the API defined by the specified {@code service} interface. */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler(getMethodInfoCache(service)));
-  }
-
-  Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
-    synchronized (serviceMethodInfoCache) {
-      Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
-      if (methodInfoCache == null) {
-        methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
-        serviceMethodInfoCache.put(service, methodInfoCache);
-      }
-      return methodInfoCache;
-    }
-  }
-
-  static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
-    synchronized (cache) {
-      RestMethodInfo methodInfo = cache.get(method);
-      if (methodInfo == null) {
-        methodInfo = new RestMethodInfo(method);
-        cache.put(method, methodInfo);
-      }
-      return methodInfo;
-    }
-  }
-
-  private class RestHandler implements InvocationHandler {
-    private final Map<Method, RestMethodInfo> methodDetailsCache;
-
-    RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
-      this.methodDetailsCache = methodDetailsCache;
-    }
-
-    @SuppressWarnings("unchecked") //
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      // Load or create the details cache for the current method.
-      final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-
-      if (methodInfo.isSynchronous) {
-        try {
-          return invokeRequest(requestInterceptor, methodInfo, args);
-        } catch (RetrofitError error) {
-          Throwable newError = errorHandler.handleError(error);
-          if (newError == null) {
-            throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
-          }
-          throw newError;
-        }
-      }
-
-      if (httpExecutor == null || callbackExecutor == null) {
-        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
-      }
-
-      if (methodInfo.isObservable) {
-        if (rxSupport == null) {
-          if (Platform.HAS_RX_JAVA) {
-            rxSupport = new RxSupport(httpExecutor, errorHandler, requestInterceptor);
-          } else {
-            throw new IllegalStateException("Observable method found but no RxJava on classpath.");
-          }
-        }
-        return rxSupport.createRequestObservable(new RxSupport.Invoker() {
-          @Override public ResponseWrapper invoke(RequestInterceptor requestInterceptor) {
-            return (ResponseWrapper) invokeRequest(requestInterceptor, methodInfo, args);
-          }
-        });
-      }
-
-      // Apply the interceptor synchronously, recording the interception so we can replay it later.
-      // This way we still defer argument serialization to the background thread.
-      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-      requestInterceptor.intercept(interceptorTape);
-
-      Callback<?> callback = (Callback<?>) args[args.length - 1];
-      httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor, errorHandler) {
-        @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
-        }
-      });
-      return null; // Asynchronous methods should have return type of void.
-    }
-
-    /**
-     * Execute an HTTP request.
-     *
-     * @return HTTP response object of specified {@code type} or {@code null}.
-     * @throws RetrofitError if any error occurs during the HTTP request.
-     */
-    private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo,
-        Object[] args) {
-      String url = null;
-      try {
-        methodInfo.init(); // Ensure all relevant method information has been loaded.
-
-        String serverUrl = server.getUrl();
-        RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
-        requestBuilder.setArguments(args);
-
-        requestInterceptor.intercept(requestBuilder);
-
-        Request request = requestBuilder.build();
-        url = request.getUrl();
-
-        if (!methodInfo.isSynchronous) {
-          // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
-        }
-
-        if (logLevel.log()) {
-          // Log the request data.
-          request = logAndReplaceRequest("HTTP", request, args);
-        }
-
-        long start = System.nanoTime();
-        Response response = client.execute(request);
-        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
-
-        if (logLevel.log()) {
-          // Log the response data.
-          response = logAndReplaceResponse(url, response, elapsedTime);
-        }
-
-        Type type = methodInfo.responseObjectType;
-
-        int statusCode = response.getStatus();
-        if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-          // Caller requested the raw Response object directly.
-          if (type.equals(Response.class)) {
-            if (!methodInfo.isStreaming) {
-              // Read the entire stream and replace with one backed by a byte[].
-              response = Utils.readBodyToBytesIfNecessary(response);
-            }
-
-            if (methodInfo.isSynchronous) {
-              return response;
-            }
-            return new ResponseWrapper(response, response);
-          }
-
-          TypedInput body = response.getBody();
-          if (body == null) {
-            if (methodInfo.isSynchronous) {
-              return null;
-            }
-            return new ResponseWrapper(response, null);
-          }
-
-          ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
-          try {
-            Object convert = converter.fromBody(wrapped, type);
-            logResponseBody(body, convert);
-            if (methodInfo.isSynchronous) {
-              return convert;
-            }
-            return new ResponseWrapper(response, convert);
-          } catch (ConversionException e) {
-            // If the underlying input stream threw an exception, propagate that rather than
-            // indicating that it was a conversion exception.
-            if (wrapped.threwException()) {
-              throw wrapped.getThrownException();
-            }
-
-            // The response body was partially read by the converter. Replace it with null.
-            response = Utils.replaceResponseBody(response, null);
-
-            throw RetrofitError.conversionError(url, response, converter, type, e);
-          }
-        }
-
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(url, response, converter, type);
-      } catch (RetrofitError e) {
-        throw e; // Pass through our own errors.
-      } catch (IOException e) {
-        if (logLevel.log()) {
-          logException(e, url);
-        }
-        throw RetrofitError.networkError(url, e);
-      } catch (Throwable t) {
-        if (logLevel.log()) {
-          logException(t, url);
-        }
-        throw RetrofitError.unexpectedError(url, t);
-      } finally {
-        if (!methodInfo.isSynchronous) {
-          Thread.currentThread().setName(IDLE_THREAD_NAME);
-        }
-      }
-    }
-  }
-
-  /** Log request headers and body. Consumes request body and returns identical replacement. */
-  Request logAndReplaceRequest(String name, Request request, Object[] args) throws IOException {
-    log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : request.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      String bodySize = "no";
-      TypedOutput body = request.getBody();
-      if (body != null) {
-        String bodyMime = body.mimeType();
-        if (bodyMime != null) {
-          log.log("Content-Type: " + bodyMime);
-        }
-
-        long bodyLength = body.length();
-        bodySize = bodyLength + "-byte";
-        if (bodyLength != -1) {
-          log.log("Content-Length: " + bodyLength);
-        }
-
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!request.getHeaders().isEmpty()) {
-            log.log("");
-          }
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body to we can log it and replace the original response
-            request = Utils.readBodyToBytesIfNecessary(request);
-            body = request.getBody();
-          }
-
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          String bodyCharset = MimeUtil.parseCharset(body.mimeType(), "UTF-8");
-          log.log(new String(bodyBytes, bodyCharset));
-        } else if (logLevel.ordinal() >= LogLevel.HEADERS_AND_ARGS.ordinal()) {
-          if (!request.getHeaders().isEmpty()) {
-            log.log("---> REQUEST:");
-          }
-          for (int i = 0; i < args.length; i++) {
-            log.log("#" + i + ": " + args[i]);
-          }
-        }
-      }
-
-      log.log(String.format("---> END %s (%s body)", name, bodySize));
-    }
-
-    return request;
-  }
-
-  /** Log response headers and body. Consumes response body and returns identical replacement. */
-  private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
-      throws IOException {
-    log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : response.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      long bodySize = 0;
-      TypedInput body = response.getBody();
-      if (body != null) {
-        bodySize = body.length();
-
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!response.getHeaders().isEmpty()) {
-            log.log("");
-          }
-
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body so we can log it and replace the original response
-            response = Utils.readBodyToBytesIfNecessary(response);
-            body = response.getBody();
-          }
-
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          bodySize = bodyBytes.length;
-          String bodyMime = body.mimeType();
-          String bodyCharset = MimeUtil.parseCharset(bodyMime, "UTF-8");
-          log.log(new String(bodyBytes, bodyCharset));
-        }
-      }
-
-      log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
-    }
-
-    return response;
-  }
-
-  private void logResponseBody(TypedInput body, Object convert) {
-    if (logLevel.ordinal() == LogLevel.HEADERS_AND_ARGS.ordinal()) {
-      log.log("<--- BODY:");
-      log.log(convert.toString());
-    }
-  }
-
-  /** Log an exception that occurred during the processing of a request or response. */
-  void logException(Throwable t, String url) {
-    log.log(String.format("---- ERROR %s", url != null ? url : ""));
-    StringWriter sw = new StringWriter();
-    t.printStackTrace(new PrintWriter(sw));
-    log.log(sw.toString());
-    log.log("---- END ERROR");
-  }
-
-  /**
-   * Build a new {@link RestAdapter}.
-   * <p>
-   * Calling {@link #setEndpoint} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static class Builder {
-    private Endpoint endpoint;
-    private Client client;
-    private Executor httpExecutor;
-    private Executor callbackExecutor;
-    private RequestInterceptor requestInterceptor;
-    private Converter converter;
-    private ErrorHandler errorHandler;
-    private Log log;
-    private LogLevel logLevel = LogLevel.NONE;
-
-    /** API endpoint URL. */
-    public Builder setEndpoint(String endpoint) {
-      if (endpoint == null || endpoint.trim().length() == 0) {
-        throw new NullPointerException("Endpoint may not be blank.");
-      }
-      this.endpoint = Endpoints.newFixedEndpoint(endpoint);
-      return this;
-    }
-
-    /** API endpoint. */
-    public Builder setEndpoint(Endpoint endpoint) {
-      if (endpoint == null) {
-        throw new NullPointerException("Endpoint may not be null.");
-      }
-      this.endpoint = endpoint;
-      return this;
-    }
-
-    /** The HTTP client used for requests. */
-    public Builder setClient(Client client) {
-      if (client == null) {
-        throw new NullPointerException("Client may not be null.");
-      }
-      this.client = client;
-      return this;
-    }
-
-    /**
-     * Executors used for asynchronous HTTP client downloads and callbacks.
-     *
-     * @param httpExecutor Executor on which HTTP client calls will be made.
-     * @param callbackExecutor Executor on which any {@link Callback} methods will be invoked. If
-     * this argument is {@code null} then callback methods will be run on the same thread as the
-     * HTTP client.
-     */
-    public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
-      if (httpExecutor == null) {
-        throw new NullPointerException("HTTP executor may not be null.");
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = new Utils.SynchronousExecutor();
-      }
-      this.httpExecutor = httpExecutor;
-      this.callbackExecutor = callbackExecutor;
-      return this;
-    }
-
-    /** A request interceptor for adding data to every request. */
-    public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
-      if (requestInterceptor == null) {
-        throw new NullPointerException("Request interceptor may not be null.");
-      }
-      this.requestInterceptor = requestInterceptor;
-      return this;
-    }
-
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder setConverter(Converter converter) {
-      if (converter == null) {
-        throw new NullPointerException("Converter may not be null.");
-      }
-      this.converter = converter;
-      return this;
-    }
-
-    /**
-     * The error handler allows you to customize the type of exception thrown for errors on
-     * synchronous requests.
-     */
-    public Builder setErrorHandler(ErrorHandler errorHandler) {
-      if (errorHandler == null) {
-        throw new NullPointerException("Error handler may not be null.");
-      }
-      this.errorHandler = errorHandler;
-      return this;
-    }
-
-    /** Configure debug logging mechanism. */
-    public Builder setLog(Log log) {
-      if (log == null) {
-        throw new NullPointerException("Log may not be null.");
-      }
-      this.log = log;
-      return this;
-    }
-
-    /** Change the level of logging. */
-    public Builder setLogLevel(LogLevel logLevel) {
-      if (logLevel == null) {
-        throw new NullPointerException("Log level may not be null.");
-      }
-      this.logLevel = logLevel;
-      return this;
-    }
-
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
-      if (endpoint == null) {
-        throw new IllegalArgumentException("Endpoint may not be null.");
-      }
-      ensureSaneDefaults();
-      return new RestAdapter(endpoint, client, httpExecutor, callbackExecutor,
-          requestInterceptor, converter, errorHandler, log, logLevel);
-    }
-
-    private void ensureSaneDefaults() {
-      if (converter == null) {
-        converter = Platform.get().defaultConverter();
-      }
-      if (client == null) {
-        client = Platform.get().defaultClient();
-      }
-      if (httpExecutor == null) {
-        httpExecutor = Platform.get().defaultHttpExecutor();
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = Platform.get().defaultCallbackExecutor();
-      }
-      if (errorHandler == null) {
-        errorHandler = ErrorHandler.DEFAULT;
-      }
-      if (log == null) {
-        log = Platform.get().defaultLog();
-      }
-      if (requestInterceptor == null) {
-        requestInterceptor = RequestInterceptor.NONE;
-      }
-    }
-  }
+	static final String THREAD_PREFIX = "Retrofit-";
+	static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
+
+	/** Simple logging abstraction for debug messages. */
+	public interface Log {
+		/** Log a debug message to the appropriate console. */
+		void log(String message);
+
+		/** A {@link Log} implementation which does not log anything. */
+		Log NONE = new Log() {
+			@Override
+			public void log(String message) {
+			}
+		};
+	}
+
+	/** Controls the level of logging. */
+	public enum LogLevel {
+		/** No logging. */
+		NONE,
+		/**
+		 * Log only the request method and URL and the response status code and
+		 * execution time.
+		 */
+		BASIC,
+		/** Log the basic information along with request and response headers. */
+		HEADERS,
+		/**
+		 * Log the basic information along with request and response objects via
+		 * toString().
+		 */
+		HEADERS_AND_ARGS,
+		/**
+		 * Log the headers, body, and metadata for both requests and responses.
+		 * <p>
+		 * Note: This requires that the entire request and response body be
+		 * buffered in memory!
+		 */
+		FULL;
+
+		public boolean log() {
+			return this != NONE;
+		}
+	}
+
+	private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache = new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
+
+	final Endpoint server;
+	final Executor httpExecutor;
+	final Executor callbackExecutor;
+	final RequestInterceptor requestInterceptor;
+	final Converter converter;
+	final Log log;
+	final ErrorHandler errorHandler;
+
+	private final Client client;
+	private RxSupport rxSupport;
+
+	volatile LogLevel logLevel;
+
+	private RestAdapter(Endpoint server, Client client, Executor httpExecutor, Executor callbackExecutor, RequestInterceptor requestInterceptor,
+			Converter converter, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
+		this.server = server;
+		this.client = client;
+		this.httpExecutor = httpExecutor;
+		this.callbackExecutor = callbackExecutor;
+		this.requestInterceptor = requestInterceptor;
+		this.converter = converter;
+		this.errorHandler = errorHandler;
+		this.log = log;
+		this.logLevel = logLevel;
+	}
+
+	/** Change the level of logging. */
+	public void setLogLevel(LogLevel loglevel) {
+		if (logLevel == null) {
+			throw new NullPointerException("Log level may not be null.");
+		}
+		this.logLevel = loglevel;
+	}
+
+	/** The current logging level. */
+	public LogLevel getLogLevel() {
+		return logLevel;
+	}
+
+	/**
+	 * Create an implementation of the API defined by the specified
+	 * {@code service} interface.
+	 */
+	@SuppressWarnings("unchecked")
+	public <T> T create(Class<T> service) {
+		Utils.validateServiceClass(service);
+		return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service }, new RestHandler(getMethodInfoCache(service)));
+	}
+
+	Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
+		synchronized (serviceMethodInfoCache) {
+			Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
+			if (methodInfoCache == null) {
+				methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
+				serviceMethodInfoCache.put(service, methodInfoCache);
+			}
+			return methodInfoCache;
+		}
+	}
+
+	static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
+		synchronized (cache) {
+			RestMethodInfo methodInfo = cache.get(method);
+			if (methodInfo == null) {
+				methodInfo = new RestMethodInfo(method);
+				cache.put(method, methodInfo);
+			}
+			return methodInfo;
+		}
+	}
+
+	private class RestHandler implements InvocationHandler {
+		private final Map<Method, RestMethodInfo> methodDetailsCache;
+
+		RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
+			this.methodDetailsCache = methodDetailsCache;
+		}
+
+		@SuppressWarnings("unchecked")
+		//
+		@Override
+		public Object invoke(Object proxy, Method method, final Object[] args) throws Throwable {
+			// If the method is a method from Object then defer to normal
+			// invocation.
+			if (method.getDeclaringClass() == Object.class) {
+				return method.invoke(this, args);
+			}
+
+			// Load or create the details cache for the current method.
+			final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
+
+			if (methodInfo.isSynchronous) {
+				try {
+					return invokeRequest(requestInterceptor, methodInfo, args);
+				} catch (RetrofitError error) {
+					Throwable newError = errorHandler.handleError(error);
+					if (newError == null) {
+						throw new IllegalStateException("Error handler returned null for wrapped exception.", error);
+					}
+					throw newError;
+				}
+			}
+
+			if (httpExecutor == null || callbackExecutor == null) {
+				throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
+			}
+
+			if (methodInfo.isObservable) {
+				if (rxSupport == null) {
+					if (Platform.HAS_RX_JAVA) {
+						rxSupport = new RxSupport(httpExecutor, errorHandler, requestInterceptor);
+					} else {
+						throw new IllegalStateException("Observable method found but no RxJava on classpath.");
+					}
+				}
+				return rxSupport.createRequestObservable(new RxSupport.Invoker() {
+					@Override
+					public ResponseWrapper invoke(RequestInterceptor requestInterceptor) {
+						return (ResponseWrapper) invokeRequest(requestInterceptor, methodInfo, args);
+					}
+				});
+			}
+
+			// Apply the interceptor synchronously, recording the interception
+			// so we can replay it later.
+			// This way we still defer argument serialization to the background
+			// thread.
+			final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
+			requestInterceptor.intercept(interceptorTape);
+
+			Callback<?> callback = (Callback<?>) args[args.length - 1];
+			httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor, errorHandler) {
+				@Override
+				public ResponseWrapper obtainResponse() {
+					return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
+				}
+			});
+			return null; // Asynchronous methods should have return type of
+							// void.
+		}
+
+		/**
+		 * Execute an HTTP request.
+		 * 
+		 * @return HTTP response object of specified {@code type} or
+		 *         {@code null}.
+		 * @throws RetrofitError
+		 *             if any error occurs during the HTTP request.
+		 */
+		private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo, Object[] args) {
+			String url = null;
+			try {
+				methodInfo.init(); // Ensure all relevant method information has
+									// been loaded.
+
+				String serverUrl = server.getUrl();
+				RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
+				requestBuilder.setArguments(args);
+
+				requestInterceptor.intercept(requestBuilder);
+
+				Request request = requestBuilder.build();
+				url = request.getUrl();
+
+				if (!methodInfo.isSynchronous) {
+					// If we are executing asynchronously then update the
+					// current thread with a useful name.
+					Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
+				}
+
+				if (logLevel.log()) {
+					// Log the request data.
+					request = logAndReplaceRequest("HTTP", request, args);
+				}
+
+				long start = System.nanoTime();
+				Response response = client.execute(request);
+				long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
+
+				if (logLevel.log()) {
+					// Log the response data.
+					response = logAndReplaceResponse(url, response, elapsedTime);
+				}
+
+				Type type = methodInfo.responseObjectType;
+
+				int statusCode = response.getStatus();
+				if (statusCode >= 200 && statusCode < 300) { // 2XX ==
+																// successful
+																// request
+					// Caller requested the raw Response object directly.
+					if (type.equals(Response.class)) {
+						if (!methodInfo.isStreaming) {
+							// Read the entire stream and replace with one
+							// backed by a byte[].
+							response = Utils.readBodyToBytesIfNecessary(response);
+						}
+
+						if (methodInfo.isSynchronous) {
+							return response;
+						}
+						return new ResponseWrapper(response, response);
+					}
+
+					TypedInput body = response.getBody();
+					if (body == null) {
+						if (methodInfo.isSynchronous) {
+							return null;
+						}
+						return new ResponseWrapper(response, null);
+					}
+
+					ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
+					try {
+						Object convert = converter.fromBody(wrapped, type);
+						logResponseBody(body, convert);
+						if (methodInfo.isSynchronous) {
+							return convert;
+						}
+						return new ResponseWrapper(response, convert);
+					} catch (ConversionException e) {
+						// If the underlying input stream threw an exception,
+						// propagate that rather than
+						// indicating that it was a conversion exception.
+						if (wrapped.threwException()) {
+							throw wrapped.getThrownException();
+						}
+
+						// The response body was partially read by the
+						// converter. Replace it with null.
+						response = Utils.replaceResponseBody(response, null);
+
+						throw RetrofitError.conversionError(url, response, converter, type, e);
+					}
+				}
+
+				response = Utils.readBodyToBytesIfNecessary(response);
+				throw RetrofitError.httpError(url, response, converter, type);
+			} catch (RetrofitError e) {
+				throw e; // Pass through our own errors.
+			} catch (IOException e) {
+				if (logLevel.log()) {
+					logException(e, url);
+				}
+				throw RetrofitError.networkError(url, e);
+			} catch (Throwable t) {
+				if (logLevel.log()) {
+					logException(t, url);
+				}
+				throw RetrofitError.unexpectedError(url, t);
+			} finally {
+				if (!methodInfo.isSynchronous) {
+					Thread.currentThread().setName(IDLE_THREAD_NAME);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Log request headers and body. Consumes request body and returns identical
+	 * replacement.
+	 */
+	Request logAndReplaceRequest(String name, Request request, Object[] args) throws IOException {
+		log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
+
+		if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
+			for (Header header : request.getHeaders()) {
+				log.log(header.toString());
+			}
+
+			String bodySize = "no";
+			TypedOutput body = request.getBody();
+			if (body != null) {
+				String bodyMime = body.mimeType();
+				if (bodyMime != null) {
+					log.log("Content-Type: " + bodyMime);
+				}
+
+				long bodyLength = body.length();
+				bodySize = bodyLength + "-byte";
+				if (bodyLength != -1) {
+					log.log("Content-Length: " + bodyLength);
+				}
+
+				if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+					if (!request.getHeaders().isEmpty()) {
+						log.log("");
+					}
+					if (!(body instanceof TypedByteArray)) {
+						// Read the entire response body to we can log it and
+						// replace the original response
+						request = Utils.readBodyToBytesIfNecessary(request);
+						body = request.getBody();
+					}
+
+					byte[] bodyBytes = ((TypedByteArray) body).getBytes();
+					String bodyCharset = MimeUtil.parseCharset(body.mimeType(), Config.getCharset());
+					log.log(new String(bodyBytes, bodyCharset));
+				} else if (logLevel.ordinal() >= LogLevel.HEADERS_AND_ARGS.ordinal()) {
+					if (!request.getHeaders().isEmpty()) {
+						log.log("---> REQUEST:");
+					}
+					for (int i = 0; i < args.length; i++) {
+						log.log("#" + i + ": " + args[i]);
+					}
+				}
+			}
+
+			log.log(String.format("---> END %s (%s body)", name, bodySize));
+		}
+
+		return request;
+	}
+
+	/**
+	 * Log response headers and body. Consumes response body and returns
+	 * identical replacement.
+	 */
+	private Response logAndReplaceResponse(String url, Response response, long elapsedTime) throws IOException {
+		log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
+
+		if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
+			for (Header header : response.getHeaders()) {
+				log.log(header.toString());
+			}
+
+			long bodySize = 0;
+			TypedInput body = response.getBody();
+			if (body != null) {
+				bodySize = body.length();
+
+				if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+					if (!response.getHeaders().isEmpty()) {
+						log.log("");
+					}
+
+					if (!(body instanceof TypedByteArray)) {
+						// Read the entire response body so we can log it and
+						// replace the original response
+						response = Utils.readBodyToBytesIfNecessary(response);
+						body = response.getBody();
+					}
+
+					byte[] bodyBytes = ((TypedByteArray) body).getBytes();
+					bodySize = bodyBytes.length;
+					String bodyMime = body.mimeType();
+					String bodyCharset = MimeUtil.parseCharset(bodyMime, Config.getCharset());
+					log.log(new String(bodyBytes, bodyCharset));
+				}
+			}
+
+			log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
+		}
+
+		return response;
+	}
+
+	private void logResponseBody(TypedInput body, Object convert) {
+		if (logLevel.ordinal() == LogLevel.HEADERS_AND_ARGS.ordinal()) {
+			log.log("<--- BODY:");
+			log.log(convert.toString());
+		}
+	}
+
+	/**
+	 * Log an exception that occurred during the processing of a request or
+	 * response.
+	 */
+	void logException(Throwable t, String url) {
+		log.log(String.format("---- ERROR %s", url != null ? url : ""));
+		StringWriter sw = new StringWriter();
+		t.printStackTrace(new PrintWriter(sw));
+		log.log(sw.toString());
+		log.log("---- END ERROR");
+	}
+
+	/**
+	 * Build a new {@link RestAdapter}.
+	 * <p>
+	 * Calling {@link #setEndpoint} is required before calling {@link #build()}.
+	 * All other methods are optional.
+	 */
+	public static class Builder {
+		private Endpoint endpoint;
+		private Client client;
+		private Executor httpExecutor;
+		private Executor callbackExecutor;
+		private RequestInterceptor requestInterceptor;
+		private Converter converter;
+		private ErrorHandler errorHandler;
+		private Log log;
+		private LogLevel logLevel = LogLevel.NONE;
+
+		/** API endpoint URL. */
+		public Builder setEndpoint(String endpoint) {
+			if (endpoint == null || endpoint.trim().length() == 0) {
+				throw new NullPointerException("Endpoint may not be blank.");
+			}
+			this.endpoint = Endpoints.newFixedEndpoint(endpoint);
+			return this;
+		}
+
+		/** API endpoint. */
+		public Builder setEndpoint(Endpoint endpoint) {
+			if (endpoint == null) {
+				throw new NullPointerException("Endpoint may not be null.");
+			}
+			this.endpoint = endpoint;
+			return this;
+		}
+
+		/** The HTTP client used for requests. */
+		public Builder setClient(Client client) {
+			if (client == null) {
+				throw new NullPointerException("Client may not be null.");
+			}
+			this.client = client;
+			return this;
+		}
+
+		/**
+		 * Executors used for asynchronous HTTP client downloads and callbacks.
+		 * 
+		 * @param httpExecutor
+		 *            Executor on which HTTP client calls will be made.
+		 * @param callbackExecutor
+		 *            Executor on which any {@link Callback} methods will be
+		 *            invoked. If this argument is {@code null} then callback
+		 *            methods will be run on the same thread as the HTTP client.
+		 */
+		public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
+			if (httpExecutor == null) {
+				throw new NullPointerException("HTTP executor may not be null.");
+			}
+			if (callbackExecutor == null) {
+				callbackExecutor = new Utils.SynchronousExecutor();
+			}
+			this.httpExecutor = httpExecutor;
+			this.callbackExecutor = callbackExecutor;
+			return this;
+		}
+
+		/** A request interceptor for adding data to every request. */
+		public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
+			if (requestInterceptor == null) {
+				throw new NullPointerException("Request interceptor may not be null.");
+			}
+			this.requestInterceptor = requestInterceptor;
+			return this;
+		}
+
+		/** The converter used for serialization and deserialization of objects. */
+		public Builder setConverter(Converter converter) {
+			if (converter == null) {
+				throw new NullPointerException("Converter may not be null.");
+			}
+			this.converter = converter;
+			return this;
+		}
+
+		/** Set the charset which to be used by retrofit */
+		public Builder setCharset(String charset) {
+			Config.setCharset(charset);
+			return this;
+		}
+
+		/**
+		 * The error handler allows you to customize the type of exception
+		 * thrown for errors on synchronous requests.
+		 */
+		public Builder setErrorHandler(ErrorHandler errorHandler) {
+			if (errorHandler == null) {
+				throw new NullPointerException("Error handler may not be null.");
+			}
+			this.errorHandler = errorHandler;
+			return this;
+		}
+
+		/** Configure debug logging mechanism. */
+		public Builder setLog(Log log) {
+			if (log == null) {
+				throw new NullPointerException("Log may not be null.");
+			}
+			this.log = log;
+			return this;
+		}
+
+		/** Change the level of logging. */
+		public Builder setLogLevel(LogLevel logLevel) {
+			if (logLevel == null) {
+				throw new NullPointerException("Log level may not be null.");
+			}
+			this.logLevel = logLevel;
+			return this;
+		}
+
+		/** Create the {@link RestAdapter} instances. */
+		public RestAdapter build() {
+			if (endpoint == null) {
+				throw new IllegalArgumentException("Endpoint may not be null.");
+			}
+			ensureSaneDefaults();
+			return new RestAdapter(endpoint, client, httpExecutor, callbackExecutor, requestInterceptor, converter, errorHandler, log, logLevel);
+		}
+
+		private void ensureSaneDefaults() {
+			if (converter == null) {
+				converter = Platform.get().defaultConverter();
+			}
+			if (client == null) {
+				client = Platform.get().defaultClient();
+			}
+			if (httpExecutor == null) {
+				httpExecutor = Platform.get().defaultHttpExecutor();
+			}
+			if (callbackExecutor == null) {
+				callbackExecutor = Platform.get().defaultCallbackExecutor();
+			}
+			if (errorHandler == null) {
+				errorHandler = ErrorHandler.DEFAULT;
+			}
+			if (log == null) {
+				log = Platform.get().defaultLog();
+			}
+			if (requestInterceptor == null) {
+				requestInterceptor = RequestInterceptor.NONE;
+			}
+		}
+	}
 }
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
index 83308d4a2..bee7aca15 100644
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
@@ -17,95 +17,108 @@
 
 import com.google.gson.Gson;
 import com.google.gson.JsonParseException;
+
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
+
 import retrofit.mime.MimeUtil;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
+import retrofit.Config;
 
 /**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- *
+ * A {@link Converter} which uses GSON for serialization and deserialization of
+ * entities.
+ * 
  * @author Jake Wharton (jw@squareup.com)
  */
 public class GsonConverter implements Converter {
-  private final Gson gson;
-  private String charset;
+	private final Gson gson;
+	private String charset;
+
+	/**
+	 * Create an instance using the supplied {@link Gson} object for conversion.
+	 * Encoding to JSON and decoding from JSON (when no charset is specified by
+	 * a header) will use GBK.
+	 */
+	public GsonConverter(Gson gson) {
 
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, "UTF-8");
-  }
+		this(gson, Config.getCharset());
+	}
 
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
-   */
-  public GsonConverter(Gson gson, String charset) {
-    this.gson = gson;
-    this.charset = charset;
-  }
+	/**
+	 * Create an instance using the supplied {@link Gson} object for conversion.
+	 * Encoding to JSON and decoding from JSON (when no charset is specified by
+	 * a header) will use the specified charset.
+	 */
+	public GsonConverter(Gson gson, String charset) {
+		this.gson = gson;
+		this.charset = charset;
+	}
 
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
-    String charset = this.charset;
-    if (body.mimeType() != null) {
-      charset = MimeUtil.parseCharset(body.mimeType(), charset);
-    }
-    InputStreamReader isr = null;
-    try {
-      isr = new InputStreamReader(body.in(), charset);
-      return gson.fromJson(isr, type);
-    } catch (IOException e) {
-      throw new ConversionException(e);
-    } catch (JsonParseException e) {
-      throw new ConversionException(e);
-    } finally {
-      if (isr != null) {
-        try {
-          isr.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-  }
+	@Override
+	public Object fromBody(TypedInput body, Type type) throws ConversionException {
+		String charset = this.charset;
+		if (body.mimeType() != null) {
+			charset = MimeUtil.parseCharset(body.mimeType(), charset);
+		}
+		InputStreamReader isr = null;
+		try {
+			isr = new InputStreamReader(body.in(), charset);
+			return gson.fromJson(isr, type);
+		} catch (IOException e) {
+			throw new ConversionException(e);
+		} catch (JsonParseException e) {
+			throw new ConversionException(e);
+		} finally {
+			if (isr != null) {
+				try {
+					isr.close();
+				} catch (IOException ignored) {
+				}
+			}
+		}
+	}
 
-  @Override public TypedOutput toBody(Object object) {
-    try {
-      return new JsonTypedOutput(gson.toJson(object).getBytes(charset), charset);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
+	@Override
+	public TypedOutput toBody(Object object) {
+		try {
+			return new JsonTypedOutput(gson.toJson(object).getBytes(charset), charset);
+		} catch (UnsupportedEncodingException e) {
+			throw new AssertionError(e);
+		}
+	}
 
-  private static class JsonTypedOutput implements TypedOutput {
-    private final byte[] jsonBytes;
-    private final String mimeType;
+	private static class JsonTypedOutput implements TypedOutput {
+		private final byte[] jsonBytes;
+		private final String mimeType;
 
-    JsonTypedOutput(byte[] jsonBytes, String encode) {
-      this.jsonBytes = jsonBytes;
-      this.mimeType = "application/json; charset=" + encode;
-    }
+		JsonTypedOutput(byte[] jsonBytes, String encode) {
+			this.jsonBytes = jsonBytes;
+			this.mimeType = "application/json; charset=" + encode;
+		}
 
-    @Override public String fileName() {
-      return null;
-    }
+		@Override
+		public String fileName() {
+			return null;
+		}
 
-    @Override public String mimeType() {
-      return mimeType;
-    }
+		@Override
+		public String mimeType() {
+			return mimeType;
+		}
 
-    @Override public long length() {
-      return jsonBytes.length;
-    }
+		@Override
+		public long length() {
+			return jsonBytes.length;
+		}
 
-    @Override public void writeTo(OutputStream out) throws IOException {
-      out.write(jsonBytes);
-    }
-  }
+		@Override
+		public void writeTo(OutputStream out) throws IOException {
+			out.write(jsonBytes);
+		}
+	}
 }
diff --git a/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java b/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
index 74c34ea3b..9e855a86a 100644
--- a/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
+++ b/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
@@ -27,7 +27,7 @@
  * parameters and annotated with {@link Field @Field}.
  * <p>
  * Requests made with this annotation will have {@code application/x-www-form-urlencoded} MIME
- * type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to
+ * type. Field names and values will be GBK encoded before being URI-encoded in accordance to
  * <a href="http://tools.ietf.org/html/rfc3986">RFC-3986</a>.
  */
 @Documented
diff --git a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java b/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
index d807195a2..a2bab9277 100644
--- a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
+++ b/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
@@ -20,6 +20,8 @@
 import java.io.OutputStream;
 import java.net.URLEncoder;
 
+import retrofit.Config;
+
 public final class FormUrlEncodedTypedOutput implements TypedOutput {
   final ByteArrayOutputStream content = new ByteArrayOutputStream();
 
@@ -34,12 +36,12 @@ public void addField(String name, String value) {
       content.write('&');
     }
     try {
-      name = URLEncoder.encode(name, "UTF-8");
-      value = URLEncoder.encode(value, "UTF-8");
+      name = URLEncoder.encode(name, Config.getCharset());
+      value = URLEncoder.encode(value, Config.getCharset());
 
-      content.write(name.getBytes("UTF-8"));
+      content.write(name.getBytes(Config.getCharset()));
       content.write('=');
-      content.write(value.getBytes("UTF-8"));
+      content.write(value.getBytes(Config.getCharset()));
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
@@ -50,7 +52,7 @@ public void addField(String name, String value) {
   }
 
   @Override public String mimeType() {
-    return "application/x-www-form-urlencoded; charset=UTF-8";
+    return "application/x-www-form-urlencoded; charset="+Config.getCharset();
   }
 
   @Override public long length() {
diff --git a/retrofit/src/main/java/retrofit/mime/MimeUtil.java b/retrofit/src/main/java/retrofit/mime/MimeUtil.java
index d96b57a3c..934abbdd1 100644
--- a/retrofit/src/main/java/retrofit/mime/MimeUtil.java
+++ b/retrofit/src/main/java/retrofit/mime/MimeUtil.java
@@ -18,19 +18,20 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import retrofit.Config;
 import static java.util.regex.Pattern.CASE_INSENSITIVE;
 
 public final class MimeUtil {
   private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
 
   /**
-   * Parse the MIME type from a {@code Content-Type} header value or default to "UTF-8".
+   * Parse the MIME type from a {@code Content-Type} header value or default to "GBK".
    *
    * @deprecated Use {@link #parseCharset(String, String)}.
    */
   @Deprecated
   public static String parseCharset(String mimeType) {
-    return parseCharset(mimeType, "UTF-8");
+    return parseCharset(mimeType, Config.getCharset());
   }
 
   /** Parse the MIME type from a {@code Content-Type} header value. */
diff --git a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
index 8067cfdd7..d1f51dafa 100644
--- a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
+++ b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
@@ -24,6 +24,8 @@
 import java.util.List;
 import java.util.UUID;
 
+import retrofit.Config;
+
 public final class MultipartTypedOutput implements TypedOutput {
   public static final String DEFAULT_TRANSFER_ENCODING = "binary";
 
@@ -160,7 +162,7 @@ public int getPartCount() {
         sb.append("--");
       }
       sb.append("\r\n");
-      return sb.toString().getBytes("UTF-8");
+      return sb.toString().getBytes(Config.getCharset());
     } catch (IOException ex) {
       throw new RuntimeException("Unable to write multipart boundary", ex);
     }
@@ -192,7 +194,7 @@ public int getPartCount() {
       headers.append(transferEncoding);
       headers.append("\r\n\r\n");
 
-      return headers.toString().getBytes("UTF-8");
+      return headers.toString().getBytes(Config.getCharset());
     } catch (IOException ex) {
       throw new RuntimeException("Unable to write multipart header", ex);
     }
diff --git a/retrofit/src/main/java/retrofit/mime/TypedString.java b/retrofit/src/main/java/retrofit/mime/TypedString.java
index 087caa870..fdec0b144 100644
--- a/retrofit/src/main/java/retrofit/mime/TypedString.java
+++ b/retrofit/src/main/java/retrofit/mime/TypedString.java
@@ -17,25 +17,28 @@
 
 import java.io.UnsupportedEncodingException;
 
+import retrofit.Config;
+
 public class TypedString extends TypedByteArray {
 
-  public TypedString(String string) {
-    super("text/plain; charset=UTF-8", convertToBytes(string));
-  }
+	public TypedString(String string) {
+		super("text/plain; charset=" + Config.getCharset(), convertToBytes(string));
+	}
 
-  private static byte[] convertToBytes(String string) {
-    try {
-      return string.getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
-    }
-  }
+	private static byte[] convertToBytes(String string) {
+		try {
+			return string.getBytes(Config.getCharset());
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException(e);
+		}
+	}
 
-  @Override public String toString() {
-    try {
-      return "TypedString[" + new String(getBytes(), "UTF-8") + "]";
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError("Must be able to decode UTF-8");
-    }
-  }
+	@Override
+	public String toString() {
+		try {
+			return "TypedString[" + new String(getBytes(), Config.getCharset()) + "]";
+		} catch (UnsupportedEncodingException e) {
+			throw new AssertionError("Must be able to decode " + Config.getCharset());
+		}
+	}
 }
