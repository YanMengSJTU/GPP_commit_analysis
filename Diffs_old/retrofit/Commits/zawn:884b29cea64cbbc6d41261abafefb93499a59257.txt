diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f7..72dffbe13 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.CacheControl;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -51,7 +53,7 @@
     return delegate.request();
   }
 
-  @Override public void enqueue(final Callback<T> callback) {
+  @Override public void enqueue(final Callback<T> callback, CacheControl cacheControl) {
     if (callback == null) throw new NullPointerException("callback == null");
 
     synchronized (this) {
@@ -98,11 +100,15 @@ boolean delaySleep() {
     });
   }
 
+  @Override public void enqueue(Callback<T> callback) {
+    enqueue(callback, null);
+  }
+
   @Override public synchronized boolean isExecuted() {
     return executed;
   }
 
-  @Override public Response<T> execute() throws IOException {
+  @Override public Response<T> execute(CacheControl cacheControl) throws IOException {
     final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
@@ -130,6 +136,10 @@ boolean delaySleep() {
     throw new RuntimeException(failure);
   }
 
+  @Override public Response<T> execute() throws IOException {
+    return execute(null);
+  }
+
   @Override public void cancel() {
     canceled = true;
     Future<?> task = this.task;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490aee..e5dd85b9f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -15,12 +15,14 @@
  */
 package retrofit2.mock;
 
-import java.io.IOException;
+import okhttp3.CacheControl;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
 
+import java.io.IOException;
+
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
   public static <T> Call<T> response(T successValue) {
@@ -33,7 +35,17 @@
         return response;
       }
 
+      @Override
+      public Response<T> execute(CacheControl cacheControl) throws IOException {
+        return response;
+      }
+
       @Override public void enqueue(Callback<T> callback) {
+       callback.onResponse(this, response);
+      }
+
+      @Override
+      public void enqueue(Callback<T> callback, CacheControl cacheControl) {
         callback.onResponse(this, response);
       }
 
@@ -65,10 +77,20 @@
         throw failure;
       }
 
+      @Override
+      public Response<T> execute(CacheControl cacheControl) throws IOException {
+        throw failure;
+      }
+
       @Override public void enqueue(Callback<T> callback) {
         callback.onFailure(this, failure);
       }
 
+      @Override
+      public void enqueue(Callback<T> callback, CacheControl cacheControl) {
+        callback.onFailure(this, failure);
+      }
+
       @Override public boolean isExecuted() {
         return false;
       }
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..da0d4ea11 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,6 +16,8 @@
 package retrofit2;
 
 import java.io.IOException;
+
+import okhttp3.CacheControl;
 import okhttp3.Request;
 
 /**
@@ -41,12 +43,27 @@
    */
   Response<T> execute() throws IOException;
 
+  /**
+   * Synchronously send the request with custom {@link CacheControl} and return its response.
+   * @param cacheControl Cache policy specified for http requests.
+   * @return
+   * @throws IOException
+   */
+  Response<T> execute(CacheControl cacheControl) throws IOException;
+
   /**
    * Asynchronously send the request and notify {@code callback} of its response or if an error
    * occurred talking to the server, creating the request, or processing the response.
    */
   void enqueue(Callback<T> callback);
 
+  /**
+   * Asynchronously send the request with custom {@link CacheControl} and notify {@code callback}
+   * of its response or if an error occurred talking to the server, creating the request,
+   * or processing the response.
+   */
+  void enqueue(Callback<T> callback, CacheControl cacheControl);
+
   /**
    * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
    * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 0c44243c6..c5e228501 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -15,11 +15,13 @@
  */
 package retrofit2;
 
+import okhttp3.CacheControl;
+import okhttp3.Request;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
-import okhttp3.Request;
 
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
@@ -55,8 +57,13 @@
     }
 
     @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
-
+      enqueue(callback, null);
+    }
+	
+    @Override public void enqueue(final Callback<T> callback, CacheControl cacheControl) {
+	
+	   if (callback == null) throw new NullPointerException("callback == null");
+	   
       delegate.enqueue(new Callback<T>() {
         @Override public void onResponse(Call<T> call, final Response<T> response) {
           callbackExecutor.execute(new Runnable() {
@@ -78,7 +85,7 @@
             }
           });
         }
-      });
+      }, cacheControl);
     }
 
     @Override public boolean isExecuted() {
@@ -86,7 +93,12 @@
     }
 
     @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
+      return delegate.execute(null);
+    }
+
+    @Override
+    public Response<T> execute(CacheControl cacheControl) throws IOException {
+      return delegate.execute(cacheControl);
     }
 
     @Override public void cancel() {
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5aa102db2..0331d69ad 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -15,7 +15,7 @@
  */
 package retrofit2;
 
-import java.io.IOException;
+import okhttp3.CacheControl;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -24,6 +24,8 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+import java.io.IOException;
+
 final class OkHttpCall<T> implements Call<T> {
   private final ServiceMethod<T> serviceMethod;
   private final Object[] args;
@@ -58,7 +60,7 @@
       }
     }
     try {
-      return (rawCall = createRawCall()).request();
+      return (rawCall = createRawCall(null)).request();
     } catch (RuntimeException e) {
       creationFailure = e;
       throw e;
@@ -69,6 +71,10 @@
   }
 
   @Override public void enqueue(final Callback<T> callback) {
+    enqueue(callback, null);
+  }
+
+  @Override public void enqueue(final Callback<T> callback, CacheControl cacheControl) {
     if (callback == null) throw new NullPointerException("callback == null");
 
     okhttp3.Call call;
@@ -82,7 +88,7 @@
       failure = creationFailure;
       if (call == null && failure == null) {
         try {
-          call = rawCall = createRawCall();
+          call = rawCall = createRawCall(cacheControl);
         } catch (Throwable t) {
           failure = creationFailure = t;
         }
@@ -142,6 +148,10 @@ private void callSuccess(Response<T> response) {
   }
 
   @Override public Response<T> execute() throws IOException {
+    return execute(null);
+  }
+
+  @Override public Response<T> execute(CacheControl cacheControl) throws IOException {
     okhttp3.Call call;
 
     synchronized (this) {
@@ -159,7 +169,7 @@ private void callSuccess(Response<T> response) {
       call = rawCall;
       if (call == null) {
         try {
-          call = rawCall = createRawCall();
+          call = rawCall = createRawCall(cacheControl);
         } catch (IOException | RuntimeException e) {
           creationFailure = e;
           throw e;
@@ -174,8 +184,11 @@ private void callSuccess(Response<T> response) {
     return parseResponse(call.execute());
   }
 
-  private okhttp3.Call createRawCall() throws IOException {
+  private okhttp3.Call createRawCall(final CacheControl cacheControl) throws IOException {
     Request request = serviceMethod.toRequest(args);
+    if (cacheControl != null) {
+      request = request.newBuilder().cacheControl(cacheControl).build();
+    }
     okhttp3.Call call = serviceMethod.callFactory.newCall(request);
     if (call == null) {
       throw new NullPointerException("Call.Factory returned null.");
diff --git a/retrofit/src/main/java/retrofit2/ParamProvider.java b/retrofit/src/main/java/retrofit2/ParamProvider.java
new file mode 100644
index 000000000..26f066e12
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/ParamProvider.java
@@ -0,0 +1,13 @@
+package retrofit2;
+
+/**
+ * Created by ZhangZhenli on 2015/11/25.
+ */
+public interface ParamProvider {
+
+  Object getHeaderParam(String paramName);
+
+  Object getUrlParam(String paramName);
+
+  Object getQueryParam(String paramName);
+}
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..1d83a9394 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -16,8 +16,13 @@
 package retrofit2;
 
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Array;
+import java.net.URLEncoder;
+import java.util.Iterator;
 import java.util.Map;
+import java.util.Set;
+
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
@@ -301,4 +306,164 @@ private RawPart() {
       builder.setBody(body);
     }
   }
+
+  static final class ParamQuery<T> extends ParameterHandler<T> {
+    public final String key;
+    private final String name;
+    private final String value;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    ParamQuery(String query, Converter<T, String> valueConverter, boolean encoded) {
+      String[] split = query.split("=");
+      if (split.length != 2) {
+        throw new IllegalArgumentException("@ParamQuerys Configuration errors,at " + query);
+      }
+      this.name = checkNotNull(split[0], "name == null");
+      this.value = checkNotNull(split[1], "query value null");
+      Set<String> set = ServiceMethod.parsePathParameters(this.value);
+      if (set.size() > 1) {
+        throw new IllegalArgumentException("@ParamQuerys Configuration errors,at "
+            + name
+            + ", You can only "
+            + "have a maximum of one parameter");
+      } else if (set.size() == 1) {
+        Iterator<String> iterator = set.iterator();
+        key = iterator.next();
+      } else {
+        key = null;
+      }
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      String rValue = null;
+      String resultValue = this.value;
+      if (key != null) {
+        rValue = valueConverter.convert(value);
+        if (rValue != null && !"".equals(rValue)) {
+          resultValue = this.value.replace("{" + key + "}", rValue);
+        }
+      }
+      if (rValue != null && !"".equals(rValue)) {
+        builder.addQueryParam(name, resultValue, encoded);
+      }
+    }
+  }
+
+  static final class ParamHeader<T> extends ParameterHandler<T> {
+    private final static String UTF_8 = "utf-8";
+    public final String key;
+    private final String name;
+    private final String value;
+    private final Converter<T, String> valueConverter;
+
+    ParamHeader(String header, Converter<T, String> valueConverter) {
+      int index = header.indexOf(":");
+      this.name = checkNotNull(header.substring(0, index), "name == null");
+      this.value = checkNotNull(header.substring(index + 1), "query value null");
+      Set<String> set = ServiceMethod.parseHeaderParameters(this.value);
+      if (set.size() > 1) {
+        throw new IllegalArgumentException("@ParamQuerys Configuration errors,at "
+            + name
+            + ", You can only have"
+            + " a maximum of one parameter");
+      } else if (set.size() == 1) {
+        Iterator<String> iterator = set.iterator();
+        key = iterator.next();
+      } else {
+        key = null;
+      }
+      this.valueConverter = valueConverter;
+    }
+
+    @Override
+    void apply(RequestBuilder builder, T value) throws IOException {
+      String rValue = null;
+      String resultValue = this.value;
+      if (key != null) {
+        rValue = extactValid(valueConverter.convert(value));
+        if (rValue != null && !"".equals(rValue)) {
+          resultValue = this.value.replace("{" + key + "}", rValue);
+        }
+      }
+      if (rValue != null && !"".equals(rValue)) {
+        builder.addHeader(name, resultValue);
+      }
+    }
+
+    String extactValid(String value) {
+      if (value == null || "".equals(value)) {
+        return null;
+      }
+
+      String result = null;
+      StringBuffer buffer = new StringBuffer("");
+      if (value.indexOf(";") != -1) { // 组合Value
+        String[] strs = value.split(";");
+        if (null != strs && strs.length > 0) {
+          for (String str : strs) {
+            if (str.indexOf("=") != -1 && str.lastIndexOf("=") != str.length() - 1) {
+              String key = str.substring(0, str.indexOf("="));
+              String val = str.substring(str.indexOf("=") + 1);
+              if (key != null && !"".equals(key) && val != null && !"".equals(val)) {
+                buffer.append(encode(key, UTF_8)).append("=").append(encode(val, UTF_8)
+                ).append(";");
+              }
+            }
+          }
+          if (buffer.length() > 0 && buffer.toString().endsWith(";")) {
+            result = buffer.deleteCharAt(buffer.length() - 1).toString();
+          }
+        }
+        return result;
+      } else { // 单个Value
+        return encode(value, UTF_8);
+      }
+    }
+
+    String encode(String content, String charset) {
+      if (key == content || "".equals(content)) {
+        return null;
+      }
+      try {
+        return URLEncoder.encode(content,
+            charset != null ? charset : UTF_8);
+      } catch (UnsupportedEncodingException ex) {
+        return null;
+      }
+    }
+  }
+
+  public static class ParamUrl<T> extends ParameterHandler<T> {
+
+    private final String url;
+
+    public final String key;
+
+    public ParamUrl(String url) {
+      this.url = url;
+      Set<String> set = ServiceMethod.parsePathParameters(this.url);
+      if (set.size() > 1) {
+        throw new IllegalArgumentException("@ParamQuerys Configuration errors,at "
+            + url
+            + ", You can only have"
+            + " a maximum of one parameter");
+      } else if (set.size() == 1) {
+        Iterator<String> iterator = set.iterator();
+        key = iterator.next();
+      } else {
+        key = null;
+      }
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      String resultValue = this.url;
+      if (url != null) {
+        resultValue = this.url.replace("{" + key + "}", value == null ? "" : value.toString());
+      }
+      builder.setServiceUrl(resultValue);
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 1303418d3..b0200a64d 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -15,7 +15,6 @@
  */
 package retrofit2;
 
-import java.io.IOException;
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -26,6 +25,8 @@
 import okio.Buffer;
 import okio.BufferedSink;
 
+import java.io.IOException;
+
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
@@ -34,6 +35,7 @@
   private final String method;
 
   private final HttpUrl baseUrl;
+  private String serviceUrl;
   private String relativeUrl;
   private HttpUrl.Builder urlBuilder;
 
@@ -81,6 +83,14 @@ void addHeader(String name, String value) {
     }
   }
 
+  void setHeader(String name, String value) {
+    if ("Content-Type".equalsIgnoreCase(name)) {
+      contentType = MediaType.parse(value);
+    } else {
+      requestBuilder.header(name, value);
+    }
+  }
+
   void addPathParam(String name, String value, boolean encoded) {
     if (relativeUrl == null) {
       // The relative URL is cleared when the first query parameter is set.
@@ -139,14 +149,8 @@ private static void canonicalizeForPath(Buffer out, String input, int pos, int l
   }
 
   void addQueryParam(String name, String value, boolean encoded) {
-    if (relativeUrl != null) {
-      // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.newBuilder(relativeUrl);
-      if (urlBuilder == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
-      relativeUrl = null;
+    if (urlBuilder == null) {
+      buildHttpUrl();
     }
 
     if (encoded) {
@@ -176,19 +180,36 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  private HttpUrl buildHttpUrl() {
     HttpUrl url;
-    HttpUrl.Builder urlBuilder = this.urlBuilder;
-    if (urlBuilder != null) {
-      url = urlBuilder.build();
-    } else {
-      // No query parameters triggered builder creation, just combine the relative URL and base URL.
-      url = baseUrl.resolve(relativeUrl);
-      if (url == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+    if (urlBuilder == null) {
+      url = baseUrl;
+      if (serviceUrl != null) {
+        url = url.resolve(serviceUrl);
+        serviceUrl = null;
+      }
+      if (relativeUrl != null) {
+        url = url.resolve(relativeUrl);
+        if (url == null) {
+          throw new IllegalArgumentException(
+              "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+        }
+        relativeUrl = null;
       }
+      this.urlBuilder = url.newBuilder();
+    } else {
+      url = this.urlBuilder.build();
     }
+    return url;
+  }
+
+  public void setServiceUrl(String serviceUrl) {
+    this.serviceUrl = serviceUrl;
+  }
+
+  Request build() {
+    HttpUrl url;
+    url = buildHttpUrl();
 
     RequestBody body = this.body;
     if (body == null) {
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index b194d4ed5..ed9103c1e 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -15,6 +15,15 @@
  */
 package retrofit2;
 
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.GET;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.Url;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -25,14 +34,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.http.GET;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.Url;
 
 import static java.util.Collections.unmodifiableList;
 import static retrofit2.Utils.checkNotNull;
@@ -58,6 +59,7 @@
  */
 public final class Retrofit {
   private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
+  private final Map<Type, ParameterHandler[]> typeCommonHandlersCache = new LinkedHashMap<>();
 
   private final okhttp3.Call.Factory callFactory;
   private final HttpUrl baseUrl;
@@ -65,6 +67,7 @@
   private final List<CallAdapter.Factory> adapterFactories;
   private final Executor callbackExecutor;
   private final boolean validateEagerly;
+  private ParamProvider paramProvider;
 
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
       List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
@@ -77,6 +80,14 @@
     this.validateEagerly = validateEagerly;
   }
 
+  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+           List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+           Executor callbackExecutor, boolean validateEagerly, ParamProvider paramProvider) {
+    this(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor,
+        validateEagerly);
+    this.paramProvider = paramProvider;
+  }
+
   /**
    * Create an implementation of the API endpoints defined by the {@code service} interface.
    * <p>
@@ -129,6 +140,9 @@
     if (validateEagerly) {
       eagerlyValidateMethods(service);
     }
+
+    loadTypeCommonActions(service);
+
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
@@ -158,6 +172,24 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
+  void loadTypeCommonActions(Class service) {
+    synchronized (typeCommonHandlersCache) {
+      ParameterHandler[] requestActions = typeCommonHandlersCache.get(service);
+      if (requestActions == null) {
+        requestActions = ServiceParser.parseClassAnnotations(service, this);
+        typeCommonHandlersCache.put(service, requestActions);
+      }
+    }
+  }
+
+  ParamProvider getParamProvider(Type serivce) {
+    return paramProvider;
+  }
+
+  ParameterHandler[] getTypeCommonHandlers(Type serivce) {
+    return typeCommonHandlersCache.get(serivce);
+  }
+
   ServiceMethod loadServiceMethod(Method method) {
     ServiceMethod result;
     synchronized (serviceMethodCache) {
@@ -390,6 +422,7 @@ public Executor callbackExecutor() {
     private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
     private Executor callbackExecutor;
     private boolean validateEagerly;
+    private ParamProvider paramProvider;
 
     Builder(Platform platform) {
       this.platform = platform;
@@ -514,6 +547,14 @@ public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
       return this;
     }
 
+    /**
+     * Add Common Param Provider.
+     */
+    public Builder setParamProvider(ParamProvider paramProvider) {
+      this.paramProvider = checkNotNull(paramProvider, "paramProvider == null");
+      return this;
+    }
+
     /**
      * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
      * your service method.
@@ -564,7 +605,7 @@ public Retrofit build() {
       List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
 
       return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+          callbackExecutor, validateEagerly, paramProvider);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index facede01f..cc0dc2114 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -15,17 +15,6 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.net.URI;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -55,12 +44,25 @@
 import retrofit2.http.QueryMap;
 import retrofit2.http.Url;
 
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class ServiceMethod<T> {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
   static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+  static final Pattern PARAM_HEADER_REGEX = Pattern.compile("\\{([^}]+)\\}");
 
   final okhttp3.Call.Factory callFactory;
   final CallAdapter<?> callAdapter;
@@ -75,6 +77,8 @@
   private final boolean isFormEncoded;
   private final boolean isMultipart;
   private final ParameterHandler<?>[] parameterHandlers;
+  private final ParameterHandler<?>[] typeCommonHandlers;
+  private final ParamProvider paramProvider;
 
   ServiceMethod(Builder<T> builder) {
     this.callFactory = builder.retrofit.callFactory();
@@ -89,6 +93,8 @@
     this.isFormEncoded = builder.isFormEncoded;
     this.isMultipart = builder.isMultipart;
     this.parameterHandlers = builder.parameterHandlers;
+    this.typeCommonHandlers = builder.typeCommonHandlers;
+    this.paramProvider = builder.paramProvider;
   }
 
   /** Builds an HTTP request from method arguments. */
@@ -96,6 +102,30 @@ Request toRequest(Object... args) throws IOException {
     RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
         contentType, hasBody, isFormEncoded, isMultipart);
 
+    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+    ParameterHandler<Object>[] typeHandlers = (ParameterHandler<Object>[]) typeCommonHandlers;
+    if (typeHandlers != null && typeHandlers.length > 0) {
+      if (paramProvider == null) {
+        throw new IllegalArgumentException("Use type parameters must be set ParamProvider");
+      }
+      for (int i = 0; i < typeHandlers.length; i++) {
+        final ParameterHandler<Object> parameterHandler = typeHandlers[i];
+        Object value = null;
+        if (parameterHandler instanceof ParameterHandler.ParamUrl) {
+          String paramName = ((ParameterHandler.ParamUrl) parameterHandler).key;
+          value = (paramName == null) ? null : paramProvider.getUrlParam(paramName);
+        } else if (parameterHandler instanceof ParameterHandler.ParamHeader) {
+          String paramName = ((ParameterHandler.ParamHeader) parameterHandler).key;
+          value = (paramName == null) ? null : paramProvider.getHeaderParam(paramName);
+        } else if (parameterHandler instanceof ParameterHandler.ParamQuery) {
+          String paramName = ((ParameterHandler.ParamQuery) parameterHandler).key;
+          value = (paramName == null) ? null : paramProvider.getQueryParam(paramName);
+        }
+        if (value != null)
+          parameterHandler.apply(requestBuilder, value);
+      }
+    }
+
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
@@ -128,6 +158,8 @@ T toResponse(ResponseBody body) throws IOException {
     final Annotation[] methodAnnotations;
     final Annotation[][] parameterAnnotationsArray;
     final Type[] parameterTypes;
+    final ParamProvider paramProvider;
+    final ParameterHandler[] typeCommonHandlers;
 
     Type responseType;
     boolean gotField;
@@ -154,6 +186,9 @@ public Builder(Retrofit retrofit, Method method) {
       this.methodAnnotations = method.getAnnotations();
       this.parameterTypes = method.getGenericParameterTypes();
       this.parameterAnnotationsArray = method.getParameterAnnotations();
+
+      this.typeCommonHandlers = retrofit.getTypeCommonHandlers(method.getDeclaringClass());
+      this.paramProvider = retrofit.getParamProvider(method.getDeclaringClass());
     }
 
     public ServiceMethod build() {
@@ -739,6 +774,15 @@ private RuntimeException parameterError(int p, String message, Object... args) {
     return patterns;
   }
 
+  static Set<String> parseHeaderParameters(String header) {
+    Matcher m = PARAM_HEADER_REGEX.matcher(header);
+    Set<String> patterns = new LinkedHashSet<>();
+    while (m.find()) {
+      patterns.add(m.group(1));
+    }
+    return patterns;
+  }
+
   static Class<?> boxIfPrimitive(Class<?> type) {
     if (boolean.class == type) return Boolean.class;
     if (byte.class == type) return Byte.class;
diff --git a/retrofit/src/main/java/retrofit2/ServiceParser.java b/retrofit/src/main/java/retrofit2/ServiceParser.java
new file mode 100644
index 000000000..d300769ad
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/ServiceParser.java
@@ -0,0 +1,57 @@
+package retrofit2;
+
+import retrofit2.http.ParamHeaders;
+import retrofit2.http.ParamQuerys;
+import retrofit2.http.ParamUrl;
+
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+
+import static retrofit2.Utils.typeError;
+
+/**
+ * Created by ZhangZhenli on 2015/11/26.
+ */
+public class ServiceParser {
+
+  static ParameterHandler[] parseClassAnnotations(Class service, Retrofit retrofit) {
+    ArrayList<ParameterHandler> requestActions = new ArrayList<>();
+    Annotation[] annotations = service.getAnnotations();
+    for (Annotation annotation : annotations) {
+      ParameterHandler<?> action;
+      if (annotation instanceof ParamHeaders) {
+        ParamHeaders headers = (ParamHeaders) annotation;
+        String[] headerStrings = headers.value();
+        if (headerStrings.length == 0) {
+          throw typeError(service, "@Headers annotation is empty.");
+        }
+        for (int i = 0; i < headerStrings.length; i++) {
+          String name = headerStrings[i];
+          Converter<?, String> valueConverter =
+              retrofit.stringConverter(String.class, new Annotation[]{annotation});
+          action = new ParameterHandler.ParamHeader<>(name, valueConverter);
+          requestActions.add(action);
+        }
+      } else if (annotation instanceof ParamQuerys) {
+        ParamQuerys querys = (ParamQuerys) annotation;
+        String[] queryStrings = querys.value();
+        if (queryStrings.length == 0) {
+          throw typeError(service, "@ParamQuerys annotation is empty.");
+        }
+        for (int i = 0; i < queryStrings.length; i++) {
+          String name = queryStrings[i];
+          Converter<?, String> valueConverter =
+              retrofit.stringConverter(String.class, new Annotation[]{annotation});
+          action = new ParameterHandler.ParamQuery<>(name, valueConverter, querys.encoded());
+          requestActions.add(action);
+        }
+      } else if (annotation instanceof ParamUrl) {
+        ParamUrl baseUrl = (ParamUrl) annotation;
+        String value = baseUrl.value();
+        action = new ParameterHandler.ParamUrl<>(value);
+        requestActions.add(action);
+      }
+    }
+    return requestActions.toArray(new ParameterHandler[requestActions.size()]);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 09ab09064..3d99eb0b6 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -493,4 +493,13 @@ public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
       return "? extends " + typeToString(upperBound);
     }
   }
+
+  static RuntimeException typeError(Type type, String message, Object... args) {
+    message = String.format(message, args);
+    IllegalArgumentException e = new IllegalArgumentException(message
+        + "\n    for Type " + type.toString());
+    e.initCause(null);
+    return e;
+  }
+
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Param.java b/retrofit/src/main/java/retrofit2/http/Param.java
new file mode 100644
index 000000000..e0f3a3cfb
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/Param.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Named replacement in the Headers/ParamQuerys ,Values are converted to string using
+ * {@link String#valueOf(Object)} and URL encoded.
+ * <p>
+ * Simple example:
+ * <pre>
+ * &#64;GET("/image/{id}")
+ * void example(@Path("id") int id);
+ * </pre>
+ * Calling with {@code foo.example(1)} yields {@code /image/1}.
+ * <p>
+ * Values are URL encoded by default. Disable with {@code encode=false}.
+ * <pre>
+ * &#64;GET("/user/{name}")
+ * void encoded(@Path("name") String name);
+ *
+ * &#64;GET("/user/{name}")
+ * void notEncoded(@Path(value="name", encode=false) String name);
+ * </pre>
+ * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
+ * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
+ * <p>
+ * Path parameters may not be {@code null}.
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Param {
+  String value();
+
+  /**
+   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit/src/main/java/retrofit2/http/ParamHeaders.java b/retrofit/src/main/java/retrofit2/http/ParamHeaders.java
new file mode 100644
index 000000000..6a90bc33c
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/ParamHeaders.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Adds headers literally supplied in the {@code value}.
+ * <p>
+ * <pre>
+ * &#64;Headers("Cache-Control: max-age=640000")
+ * &#64;GET("/")
+ * ...
+ *
+ * &#64;Headers({
+ *   "X-Foo: Bar",
+ *   "X-Ping: Pong"
+ * })
+ * &#64;GET("/")
+ * ...
+ * </pre>
+ * <p>
+ * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
+ * be included in the request.
+ *
+ * @author Adrian Cole (adrianc@netflix.com)
+ */
+@Documented
+@Target({TYPE})
+@Retention(RUNTIME)
+public @interface ParamHeaders {
+    String[] value();
+}
diff --git a/retrofit/src/main/java/retrofit2/http/ParamQuerys.java b/retrofit/src/main/java/retrofit2/http/ParamQuerys.java
new file mode 100644
index 000000000..a4b343923
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/ParamQuerys.java
@@ -0,0 +1,24 @@
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Created by ZhangZhenli on 2015/11/25.
+ */
+@Documented
+@Target({TYPE})
+@Retention(RUNTIME)
+public @interface ParamQuerys {
+
+    String[] value();
+
+    /**
+     * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
+}
diff --git a/retrofit/src/main/java/retrofit2/http/ParamUrl.java b/retrofit/src/main/java/retrofit2/http/ParamUrl.java
new file mode 100644
index 000000000..76bfff341
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/ParamUrl.java
@@ -0,0 +1,18 @@
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Created by ZhangZhenli on 2015/11/27.
+ */
+@Documented
+@Target({TYPE})
+@Retention(RUNTIME)
+public @interface ParamUrl {
+  String value();
+}
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index 24b871052..a719e8a24 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -21,6 +21,8 @@
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+
+import okhttp3.CacheControl;
 import okhttp3.Request;
 import org.junit.Test;
 
@@ -74,7 +76,7 @@
         (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
+      @Override public Response<String> execute(CacheControl cacheControl) throws IOException {
         return response;
       }
     });
@@ -87,7 +89,7 @@
         (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
+      @Override public void enqueue(Callback<String> callback,CacheControl cacheControl) {
         callback.onResponse(this, response);
       }
     };
@@ -103,7 +105,7 @@
         (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
     EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
+      @Override public void enqueue(Callback<String> callback,CacheControl cacheControl) {
         callback.onFailure(this, throwable);
       }
     };
@@ -143,6 +145,10 @@
       throw new UnsupportedOperationException();
     }
 
+    @Override public void enqueue(Callback<String> callback, CacheControl cacheControl) {
+      throw new UnsupportedOperationException();
+    }
+
     @Override public boolean isExecuted() {
       return false;
     }
@@ -151,6 +157,10 @@
       throw new UnsupportedOperationException();
     }
 
+    @Override public Response<String> execute(CacheControl cacheControl) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
     @Override public void cancel() {
       throw new UnsupportedOperationException();
     }
