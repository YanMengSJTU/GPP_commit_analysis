diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index ccbfe1ab2..a89ba54eb 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -207,6 +207,8 @@ private void callSuccess(Response<T> response) {
       return Response.success(null, rawResponse);
     }
 
+    //通过serviceMethod对ResponseBody进行转化，
+    // 然后返回，转化实际上就是通过responseConverter的convert方法
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
       T body = serviceMethod.toResponse(catchingBody);
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 8633de4af..15ac84da9 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -25,6 +25,7 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -55,531 +56,569 @@
  *
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
+ *         <p>
+ *         掌握一个大体的原理和执行流程
+ *         1.首先构造retrofit，几个核心的参数呢，主要就是baseurl,callFactory(默认okhttpclient),
+ *         converterFactories,adapterFactories,excallbackExecutor。
+ *         2.通过create方法拿到接口的实现类，这里利用Java的Proxy类完成动态代理的相关代理
+ *         3.在invoke方法内部，拿到我们所声明的注解以及实参等，构造ServiceMethod，ServiceMethod中解析了大量的信息，最痛可以通过toRequest构造出okhttp3.Request对象。有了okhttp3.Request对象就可以很自然的构建出okhttp3.call，最后calladapter对Call进行装饰返回。
+ *         4.拿到Call就可以执行enqueue或者execute方法了
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
-
-  final okhttp3.Call.Factory callFactory;
-  final HttpUrl baseUrl;
-  final List<Converter.Factory> converterFactories;
-  final List<CallAdapter.Factory> adapterFactories;
-  final Executor callbackExecutor;
-  final boolean validateEagerly;
-
-  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
-    this.callFactory = callFactory;
-    this.baseUrl = baseUrl;
-    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
-    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
-    this.callbackExecutor = callbackExecutor;
-    this.validateEagerly = validateEagerly;
-  }
-
-  /**
-   * Create an implementation of the API endpoints defined by the {@code service} interface.
-   * <p>
-   * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
-   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
-   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
-   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
-   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
-   * parameter with {@link Url @Url}.
-   * <p>
-   * Method parameters can be used to replace parts of the URL by annotating them with
-   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
-   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
-   * {@link retrofit2.http.Query @Query}.
-   * <p>
-   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
-   * object will be converted to request representation by one of the {@link Converter.Factory}
-   * instances. A {@link RequestBody} can also be used for a raw representation.
-   * <p>
-   * Alternative request body formats are supported by method annotations and corresponding
-   * parameter annotations:
-   * <ul>
-   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
-   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
-   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
-   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
-   * </ul>
-   * <p>
-   * Additional static headers can be added for an endpoint using the
-   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
-   * header annotate a parameter with {@link Header @Header}.
-   * <p>
-   * By default, methods return a {@link Call} which represents the HTTP request. The generic
-   * parameter of the call is the response body type and will be converted by one of the
-   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
-   * representation. {@link Void} can be used if you do not care about the body contents.
-   * <p>
-   * For example:
-   * <pre>
-   * public interface CategoryService {
-   *   &#64;POST("category/{cat}/")
-   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
-   * }
-   * </pre>
-   */
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new InvocationHandler() {
-          private final Platform platform = Platform.get();
-
-          @Override public Object invoke(Object proxy, Method method, Object... args)
-              throws Throwable {
-            // If the method is a method from Object then defer to normal invocation.
-            if (method.getDeclaringClass() == Object.class) {
-              return method.invoke(this, args);
-            }
-            if (platform.isDefaultMethod(method)) {
-              return platform.invokeDefaultMethod(method, service, proxy, args);
-            }
-            ServiceMethod<Object, Object> serviceMethod =
-                (ServiceMethod<Object, Object>) loadServiceMethod(method);
-            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.callAdapter.adapt(okHttpCall);
-          }
-        });
-  }
-
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
-        loadServiceMethod(method);
-      }
-    }
-  }
-
-  ServiceMethod<?, ?> loadServiceMethod(Method method) {
-    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
-    if (result != null) return result;
-
-    synchronized (serviceMethodCache) {
-      result = serviceMethodCache.get(method);
-      if (result == null) {
-        result = new ServiceMethod.Builder<>(this, method).build();
-        serviceMethodCache.put(method, result);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
-   * Typically an instance of {@link OkHttpClient}.
-   */
-  public okhttp3.Call.Factory callFactory() {
-    return callFactory;
-  }
-
-  /** The API base URL. */
-  public HttpUrl baseUrl() {
-    return baseUrl;
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
-   */
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return adapterFactories;
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
-    return nextCallAdapter(null, returnType, annotations);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
-      Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
-      if (adapter != null) {
-        return adapter;
-      }
+    private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+
+    final okhttp3.Call.Factory callFactory;
+    final HttpUrl baseUrl;
+    final List<Converter.Factory> converterFactories;
+    final List<CallAdapter.Factory> adapterFactories;
+    final Executor callbackExecutor;
+    final boolean validateEagerly;
+
+    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+             List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+             Executor callbackExecutor, boolean validateEagerly) {
+        this.callFactory = callFactory;
+        this.baseUrl = baseUrl;
+        //unmodifiableList一个不可修改的List  修改会throws java.lang.UnsupportedOperationException
+        this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
+        this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
+        this.callbackExecutor = callbackExecutor;
+        this.validateEagerly = validateEagerly;
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(returnType)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
-   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
-   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
-   */
-  public List<Converter.Factory> converterFactories() {
-    return converterFactories;
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
-    checkNotNull(methodAnnotations, "methodAnnotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter.Factory factory = converterFactories.get(i);
-      Converter<?, RequestBody> converter =
-          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, RequestBody>) converter;
-      }
+    /**
+     * Create an implementation of the API endpoints defined by the {@code service} interface.
+     * <p>
+     * The relative path for a given method is obtained from an annotation on the method describing
+     * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+     * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+     * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+     * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+     * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+     * parameter with {@link Url @Url}.
+     * <p>
+     * Method parameters can be used to replace parts of the URL by annotating them with
+     * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+     * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+     * {@link retrofit2.http.Query @Query}.
+     * <p>
+     * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+     * object will be converted to request representation by one of the {@link Converter.Factory}
+     * instances. A {@link RequestBody} can also be used for a raw representation.
+     * <p>
+     * Alternative request body formats are supported by method annotations and corresponding
+     * parameter annotations:
+     * <ul>
+     * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+     * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+     * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+     * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+     * </ul>
+     * <p>
+     * Additional static headers can be added for an endpoint using the
+     * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+     * header annotate a parameter with {@link Header @Header}.
+     * <p>
+     * By default, methods return a {@link Call} which represents the HTTP request. The generic
+     * parameter of the call is the response body type and will be converted by one of the
+     * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+     * representation. {@link Void} can be used if you do not care about the body contents.
+     * <p>
+     * For example:
+     * <pre>
+     * public interface CategoryService {
+     *   &#64;POST("category/{cat}/")
+     *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+     * }
+     * </pre>
+     */
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> T create(final Class<T> service) {
+        Utils.validateServiceInterface(service);
+        if (validateEagerly) {
+            eagerlyValidateMethods(service);
+        }
+        //java的动态代理 返回service的代理 现在的java动态代理只能代理接口 不能代理普通类
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
+                new InvocationHandler() {
+                    private final Platform platform = Platform.get();
+                    //当接口service调用其里面的方法时会触发此invoke函数 也即是动态代理了这个方法的整个过程
+                    //在invoke函数里 可hook接口service方法的实现
+                    @Override
+                    public Object invoke(Object proxy, Method method, Object... args)
+                            throws Throwable {
+                        // If the method is a method from Object then defer to normal invocation.
+                        //method.getDeclaringClass()
+                        // 返回表示声明由此 Method 对象表示的方法的类或接口的 Class 对象。即方法定义所在的类
+                        //这里安卓要求必须是接口 不能是普通类
+                        if (method.getDeclaringClass() == Object.class) {
+                            return method.invoke(this, args);
+                        }
+                        if (platform.isDefaultMethod(method)) {
+                            return platform.invokeDefaultMethod(method, service, proxy, args);
+                        }
+                        //判断缓存 未命中 建造者模式构建ServiceMethod
+                        //此类构造函数主要处理method方法中注解 参数 等信息的封装
+                        ServiceMethod<Object, Object> serviceMethod =
+                                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+                        //通过serviceMethod和参数构造出OkHttpCall
+                        //OkHttpCall是对okhttp3.Call rawCall;的封装
+                        OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+                        //返回method的返回值 实际上应该是一个封装好的okhttp3.Call任务
+                        //通过serviceMethod.callAdapter.adapt()方法，将OkHttpCall进行代理包装
+                        return serviceMethod.callAdapter.adapt(okHttpCall);
+                    }
+                });
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
-    return nextResponseBodyConverter(null, type, annotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).responseBodyConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<ResponseBody, T>) converter;
-      }
+    private void eagerlyValidateMethods(Class<?> service) {
+        Platform platform = Platform.get();
+        for (Method method : service.getDeclaredMethods()) {
+            if (!platform.isDefaultMethod(method)) {
+                loadServiceMethod(method);
+            }
+        }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+    ServiceMethod<?, ?> loadServiceMethod(Method method) {
+        //缓存是否命中
+        ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+        if (result != null) return result;
+
+        synchronized (serviceMethodCache) {
+            result = serviceMethodCache.get(method);
+            if (result == null) {
+                //使用建造者模式来构建ServiceMethod
+                result = new ServiceMethod.Builder<>(this, method).build();
+                serviceMethodCache.put(method, result);
+            }
+        }
+        return result;
     }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link String} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, String>) converter;
-      }
+
+    /**
+     * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+     * Typically an instance of {@link OkHttpClient}.
+     */
+    public okhttp3.Call.Factory callFactory() {
+        return callFactory;
     }
 
-    // Nothing matched. Resort to default converter which just calls toString().
-    //noinspection unchecked
-    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
-  }
-
-  /**
-   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
-   * in which case callbacks should be made synchronously on the background thread.
-   */
-  public Executor callbackExecutor() {
-    return callbackExecutor;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Build a new {@link Retrofit}.
-   * <p>
-   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static final class Builder {
-    private final Platform platform;
-    private okhttp3.Call.Factory callFactory;
-    private HttpUrl baseUrl;
-    private final List<Converter.Factory> converterFactories = new ArrayList<>();
-    private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
-    private boolean validateEagerly;
-
-    Builder(Platform platform) {
-      this.platform = platform;
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
+    /**
+     * The API base URL.
+     */
+    public HttpUrl baseUrl() {
+        return baseUrl;
     }
 
-    public Builder() {
-      this(Platform.get());
+    /**
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+     */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+        return adapterFactories;
     }
 
-    Builder(Retrofit retrofit) {
-      platform = Platform.get();
-      callFactory = retrofit.callFactory;
-      baseUrl = retrofit.baseUrl;
-      converterFactories.addAll(retrofit.converterFactories);
-      adapterFactories.addAll(retrofit.adapterFactories);
-      // Remove the default, platform-aware call adapter added by build().
-      adapterFactories.remove(adapterFactories.size() - 1);
-      callbackExecutor = retrofit.callbackExecutor;
-      validateEagerly = retrofit.validateEagerly;
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
+     */
+    public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
+        return nextCallAdapter(null, returnType, annotations);
     }
 
     /**
-     * The HTTP client used for requests.
-     * <p>
-     * This is a convenience method for calling {@link #callFactory}.
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
      */
-    public Builder client(OkHttpClient client) {
-      return callFactory(checkNotNull(client, "client == null"));
+    public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+                                             Annotation[] annotations) {
+        checkNotNull(returnType, "returnType == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = adapterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+            if (adapter != null) {
+                return adapter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+                .append(returnType)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * Specify a custom call factory for creating {@link Call} instances.
-     * <p>
-     * Note: Calling {@link #client} automatically sets this value.
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+     * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+     * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
      */
-    public Builder callFactory(okhttp3.Call.Factory factory) {
-      this.callFactory = checkNotNull(factory, "factory == null");
-      return this;
+    public List<Converter.Factory> converterFactories() {
+        return converterFactories;
     }
 
     /**
-     * Set the API base URL.
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories}.
      *
-     * @see #baseUrl(HttpUrl)
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+    public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
     }
 
     /**
-     * Set the API base URL.
-     * <p>
-     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
-     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
-     * {@code <a href="">} link on a website resolving on the current URL.
-     * <p>
-     * <b>Base URLs should always end in {@code /}.</b>
-     * <p>
-     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
-     * append themselves to a base which has path components.
-     * <p>
-     * <b>Correct:</b><br>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/api/foo/bar/
-     * <p>
-     * <b>Incorrect:</b><br>
-     * Base URL: http://example.com/api<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * This method enforces that {@code baseUrl} has a trailing {@code /}.
-     * <p>
-     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
-     * <p>
-     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
-     * components.
-     * <p>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * <b>Endpoint values may be a full URL.</b>
-     * <p>
-     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
-     * replace the scheme of {@code baseUrl}.
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: https://github.com/square/retrofit/<br>
-     * Result: https://github.com/square/retrofit/
-     * <p>
-     * Base URL: http://example.com<br>
-     * Endpoint: //github.com/square/retrofit/<br>
-     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      List<String> pathSegments = baseUrl.pathSegments();
-      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
-        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
-      }
-      this.baseUrl = baseUrl;
-      return this;
+    public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
+                                                                  Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+        checkNotNull(methodAnnotations, "methodAnnotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter.Factory factory = converterFactories.get(i);
+            Converter<?, RequestBody> converter =
+                    factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, RequestBody>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
-    /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory factory) {
-      converterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    /**
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
+     */
+    public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+        return nextResponseBodyConverter(null, type, annotations);
     }
 
     /**
-     * Add a call adapter factory for supporting service method return types other than {@link
-     * Call}.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
+                                                                    Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter<ResponseBody, ?> converter =
+                    converterFactories.get(i).responseBodyConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<ResponseBody, T>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
-     * your service method.
-     * <p>
-     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
-     * return types}.
+     * Returns a {@link Converter} for {@code type} to {@link String} from the available
+     * {@linkplain #converterFactories() factories}.
      */
-    public Builder callbackExecutor(Executor executor) {
-      this.callbackExecutor = checkNotNull(executor, "executor == null");
-      return this;
+    public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<?, String> converter =
+                    converterFactories.get(i).stringConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, String>) converter;
+            }
+        }
+
+        // Nothing matched. Resort to default converter which just calls toString().
+        //noinspection unchecked
+        return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
     }
 
     /**
-     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
-     * the configuration of all methods in the supplied interface.
+     * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+     * in which case callbacks should be made synchronously on the background thread.
      */
-    public Builder validateEagerly(boolean validateEagerly) {
-      this.validateEagerly = validateEagerly;
-      return this;
+    public Executor callbackExecutor() {
+        return callbackExecutor;
+    }
+
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
     /**
-     * Create the {@link Retrofit} instance using the configured values.
+     * Build a new {@link Retrofit}.
      * <p>
-     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
-     * OkHttpClient} will be created and used.
+     * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+     * are optional.
      */
-    public Retrofit build() {
-      if (baseUrl == null) {
-        throw new IllegalStateException("Base URL required.");
-      }
-
-      okhttp3.Call.Factory callFactory = this.callFactory;
-      if (callFactory == null) {
-        callFactory = new OkHttpClient();
-      }
-
-      Executor callbackExecutor = this.callbackExecutor;
-      if (callbackExecutor == null) {
-        callbackExecutor = platform.defaultCallbackExecutor();
-      }
-
-      // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
-
-      // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
-
-      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+    public static final class Builder {
+        //平台的确定 这里主要关注安卓平台 得到安卓平台 可以拿到主线程Handler
+        private final Platform platform;
+        //默认直接new OkHttpClient()，可见如果你需要对okhttpclient进行详细的设置，
+        // 需要构建OkHttpClient对象，然后传入
+        private okhttp3.Call.Factory callFactory;
+        //baseUrl必须指定
+        private HttpUrl baseUrl;
+        //Converter.Factory，该对象用于转化数据，例如将返回的responseBody转化为对象等；
+        // 当然不仅仅是针对返回的数据，还能用于一般备注解的参数的转化例如@Body标识的对象做一些操作
+        private final List<Converter.Factory> converterFactories = new ArrayList<>();
+        //CallAdapter.Factory这个对象主要用于对Call进行转化
+        private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+        //这个想一想大概是用来将回调传递到UI线程了，当然这里设计的比较巧妙，
+        // 利用platform对象，对平台进行判断，判断主要是利用Class.forName("")进行查找，
+        // 具体代码已经被放到文末，如果是Android平台，会自定义一个Executor对象，
+        // 并且利用Looper.getMainLooper()实例化一个handler对象，在Executor内部通过handler.post(runnable)
+        private Executor callbackExecutor;
+        private boolean validateEagerly;
+
+        Builder(Platform platform) {
+            this.platform = platform;
+            // Add the built-in converter factory first. This prevents overriding its behavior but also
+            // ensures correct behavior when using converters that consume all types.
+            converterFactories.add(new BuiltInConverters());
+        }
+
+        //建造者模式
+        public Builder() {
+            this(Platform.get());
+        }
+
+        Builder(Retrofit retrofit) {
+            platform = Platform.get();
+            callFactory = retrofit.callFactory;
+            baseUrl = retrofit.baseUrl;
+            converterFactories.addAll(retrofit.converterFactories);
+            adapterFactories.addAll(retrofit.adapterFactories);
+            // Remove the default, platform-aware call adapter added by build().
+            adapterFactories.remove(adapterFactories.size() - 1);
+            callbackExecutor = retrofit.callbackExecutor;
+            validateEagerly = retrofit.validateEagerly;
+        }
+
+        /**
+         * The HTTP client used for requests.
+         * <p>
+         * This is a convenience method for calling {@link #callFactory}.
+         */
+        public Builder client(OkHttpClient client) {
+            return callFactory(checkNotNull(client, "client == null"));
+        }
+
+        /**
+         * Specify a custom call factory for creating {@link Call} instances.
+         * <p>
+         * Note: Calling {@link #client} automatically sets this value.
+         */
+        public Builder callFactory(okhttp3.Call.Factory factory) {
+            this.callFactory = checkNotNull(factory, "factory == null");
+            return this;
+        }
+
+        /**
+         * Set the API base URL.
+         *
+         * @see #baseUrl(HttpUrl)
+         */
+        public Builder baseUrl(String baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+            if (httpUrl == null) {
+                throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+            }
+            return baseUrl(httpUrl);
+        }
+
+        /**
+         * Set the API base URL.
+         * <p>
+         * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+         * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+         * {@code <a href="">} link on a website resolving on the current URL.
+         * <p>
+         * <b>Base URLs should always end in {@code /}.</b>
+         * <p>
+         * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+         * append themselves to a base which has path components.
+         * <p>
+         * <b>Correct:</b><br>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/api/foo/bar/
+         * <p>
+         * <b>Incorrect:</b><br>
+         * Base URL: http://example.com/api<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * This method enforces that {@code baseUrl} has a trailing {@code /}.
+         * <p>
+         * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+         * <p>
+         * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+         * components.
+         * <p>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * <b>Endpoint values may be a full URL.</b>
+         * <p>
+         * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+         * replace the scheme of {@code baseUrl}.
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: https://github.com/square/retrofit/<br>
+         * Result: https://github.com/square/retrofit/
+         * <p>
+         * Base URL: http://example.com<br>
+         * Endpoint: //github.com/square/retrofit/<br>
+         * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+         */
+        public Builder baseUrl(HttpUrl baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            List<String> pathSegments = baseUrl.pathSegments();
+            if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+                throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+            }
+            this.baseUrl = baseUrl;
+            return this;
+        }
+
+        /**
+         * Add converter factory for serialization and deserialization of objects.
+         */
+        public Builder addConverterFactory(Converter.Factory factory) {
+            converterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * Add a call adapter factory for supporting service method return types other than {@link
+         * Call}.
+         */
+        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+            adapterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+         * your service method.
+         * <p>
+         * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+         * return types}.
+         */
+        public Builder callbackExecutor(Executor executor) {
+            this.callbackExecutor = checkNotNull(executor, "executor == null");
+            return this;
+        }
+
+        /**
+         * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+         * the configuration of all methods in the supplied interface.
+         */
+        public Builder validateEagerly(boolean validateEagerly) {
+            this.validateEagerly = validateEagerly;
+            return this;
+        }
+
+        /**
+         * Create the {@link Retrofit} instance using the configured values.
+         * <p>
+         * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+         * OkHttpClient} will be created and used.
+         */
+        public Retrofit build() {
+            if (baseUrl == null) {
+                throw new IllegalStateException("Base URL required.");
+            }
+
+            okhttp3.Call.Factory callFactory = this.callFactory;
+            if (callFactory == null) {
+                callFactory = new OkHttpClient();
+            }
+
+            Executor callbackExecutor = this.callbackExecutor;
+            if (callbackExecutor == null) {
+                callbackExecutor = platform.defaultCallbackExecutor();
+            }
+
+            // Make a defensive copy of the adapters and add the default Call adapter.
+            List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+            adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+
+            // Make a defensive copy of the converters.
+            List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+            return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
+                    callbackExecutor, validateEagerly);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index a32f8101a..47fd6f3f1 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -77,6 +77,12 @@
   private final boolean isMultipart;
   private final ParameterHandler<?>[] parameterHandlers;
 
+  /**
+   * ServiceMethod主要用于将我们接口中的方法转化为一个Request对象，
+   * 于是根据我们的接口返回值确定了responseConverter,解析我们方法上的注解拿到初步的url,
+   * 解析我们参数上的注解拿到构建RequestBody所需的各种信息，最终调用toRequest的方法完成Request的构建
+   *
+   */
   ServiceMethod(Builder<R, T> builder) {
     this.callFactory = builder.retrofit.callFactory();
     this.callAdapter = builder.callAdapter;
@@ -126,8 +132,11 @@ R toResponse(ResponseBody body) throws IOException {
   static final class Builder<T, R> {
     final Retrofit retrofit;
     final Method method;
+    //获取方法上的注解
     final Annotation[] methodAnnotations;
+    //方法参数——注解
     final Annotation[][] parameterAnnotationsArray;
+    //方法参数——泛型
     final Type[] parameterTypes;
 
     Type responseType;
@@ -158,23 +167,36 @@ R toResponse(ResponseBody body) throws IOException {
     }
 
     public ServiceMethod build() {
+      //callAdapter最终拿到的是我们在构建retrofit里面时adapterFactories时添加的，
+      // 即为：new ExecutorCallbackCall<>(callbackExecutor, call)，
+      // 该ExecutorCallbackCall唯一做的事情就是将原本call的回调转发至UI线程。
       callAdapter = createCallAdapter();
+      //callAdapter.responseType()返回的是我们方法的实际类型，
+      // 例如:Call<User>,则返回User类型，然后对该类型进行判断
       responseType = callAdapter.responseType();
+      //method返回的类型不能是Response.class 或者 okhttp3.Response.class
       if (responseType == Response.class || responseType == okhttp3.Response.class) {
         throw methodError("'"
             + Utils.getRawType(responseType).getName()
             + "' is not a valid response body type. Did you mean ResponseBody?");
       }
+      //createResponseConverter拿到responseConverter对象，
+      // 其当然也是根据我们构建retrofit时,addConverterFactory添加的ConverterFactory对象来寻找一个合适的返回，
+      // 寻找的依据主要看该converter能否处理你编写方法的返回值类型，默认实现为BuiltInConverters，
+      // 仅仅支持返回值的实际类型为ResponseBody和Void，也就说明了默认情况下，是不支持Call<User>这类类型的。
       responseConverter = createResponseConverter();
 
       for (Annotation annotation : methodAnnotations) {
+        //处理method的注解
+        //对注解进行解析了，主要是对方法上的注解进行解析，
+        // 那么可以拿到httpMethod以及初步的url（包含占位符）。
         parseMethodAnnotation(annotation);
       }
 
       if (httpMethod == null) {
         throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
       }
-
+      //delete get heaader 这些不传递httpbody的注解请求不能添加isMultipart 以及isFormEncoded注解
       if (!hasBody) {
         if (isMultipart) {
           throw methodError(
@@ -186,6 +208,8 @@ public ServiceMethod build() {
         }
       }
 
+      //对方法中参数中的注解进行解析，这一步会拿到很多的ParameterHandler对象，
+      // 该对象在toRequest()构造Request的时候调用其apply方法
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
@@ -215,7 +239,7 @@ public ServiceMethod build() {
       if (isMultipart && !gotPart) {
         throw methodError("Multipart method must contain at least one @Part.");
       }
-
+      //初始化完method信息封装在builder中传递给ServiceMethod构造函数
       return new ServiceMethod<>(this);
     }
 
@@ -237,6 +261,7 @@ public ServiceMethod build() {
       }
     }
 
+    //解析method方法注解信息
     private void parseMethodAnnotation(Annotation annotation) {
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
@@ -277,6 +302,12 @@ private void parseMethodAnnotation(Annotation annotation) {
       }
     }
 
+    /**
+     * 解析method方法注解信息
+     * @param httpMethod
+     * @param value
+     * @param hasBody
+     */
     private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
       if (this.httpMethod != null) {
         throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
@@ -293,6 +324,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       int question = value.indexOf('?');
       if (question != -1 && question < value.length() - 1) {
         // Ensure the query string does not have any named parameters.
+        //如果注解url中包含了“?” 那么就不能使用 {xxx}的方式 可以使用dynamic query parameters use @Query来代替
         String queryParams = value.substring(question + 1);
         Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
         if (queryParamMatcher.find()) {
@@ -328,6 +360,13 @@ private Headers parseHeaders(String[] headers) {
       return builder.build();
     }
 
+    /**
+     * 每一个参数注解对应一个ParameterHandler参数处理类
+     * @param p
+     * @param parameterType
+     * @param annotations
+     * @return
+     */
     private ParameterHandler<?> parseParameter(
         int p, Type parameterType, Annotation[] annotations) {
       ParameterHandler<?> result = null;
@@ -353,6 +392,14 @@ private Headers parseHeaders(String[] headers) {
       return result;
     }
 
+    /**
+     * 解析参数注解 生成各种不同的对应ParameterHandler对象 专门处理注解信息
+     * @param p method中的第几个参数
+     * @param type 参数返回值类型
+     * @param annotations 参数的注解数组
+     * @param annotation 解析当前注解数组中的具体的注解
+     * @return
+     */
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
