diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index f729383a3..3bae4b57d 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -22,7 +22,17 @@
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
+/**
+ * 转换工厂
+ */
 final class BuiltInConverters extends Converter.Factory {
+  /**
+   * 响应体转换工厂
+   * @param type
+   * @param annotations
+   * @param retrofit
+   * @return
+   */
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
@@ -37,6 +47,14 @@
     return null;
   }
 
+  /**
+   * 请求体转换工厂
+   * @param type
+   * @param parameterAnnotations
+   * @param methodAnnotations
+   * @param retrofit
+   * @return
+   */
   @Override
   public Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
@@ -55,6 +73,9 @@
     }
   }
 
+  /**
+   * 返回本身
+   */
   static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
     static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
@@ -63,6 +84,9 @@
     }
   }
 
+  /**
+   * 返回本身
+   */
   static final class StreamingResponseBodyConverter
       implements Converter<ResponseBody, ResponseBody> {
     static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
@@ -72,6 +96,9 @@
     }
   }
 
+  /**
+   * 返回buffer
+   */
   static final class BufferingResponseBodyConverter
       implements Converter<ResponseBody, ResponseBody> {
     static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..7154e98ee 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -23,17 +23,20 @@
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
  * to retry a failed call.
+ * 调用的改造方法,发送一个请求到网络服务器,并返回一个响应。每次调用收益率自己的HTTP请求和响应。使用{ @link #克隆}让多个调用相同的参数相同的网络服务器;这可能是用于实现轮询或重试失败的电话
  *
  * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
  * working as designed.
+ * 电话可以同步执行{ @link #执行},{ @link #排队}或异步。在这两种情况下的调用可以在任何时候被取消{ @link #取消}。电话正忙着写请求或阅读其响应可能会收到一个{ @link IOException };这是设计工作
  *
  * @param <T> Successful response body type.
  */
 public interface Call<T> extends Cloneable {
   /**
    * Synchronously send the request and return its response.
+   * 同步请求
    *
    * @throws IOException if a problem occurred talking to the server.
    * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
@@ -44,18 +47,21 @@
   /**
    * Asynchronously send the request and notify {@code callback} of its response or if an error
    * occurred talking to the server, creating the request, or processing the response.
+   * 异步请求
    */
   void enqueue(Callback<T> callback);
 
   /**
    * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
    * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+   * 是否已执行
    */
   boolean isExecuted();
 
   /**
    * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
    * yet been executed it never will be.
+   *
    */
   void cancel();
 
@@ -65,6 +71,7 @@
   /**
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
+   * 创建一个新的,相同的调用这个队列或即使已经执行
    */
   Call<T> clone();
 
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 927540bf4..a660c86a1 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -24,6 +24,7 @@
  * created by {@linkplain Factory a factory} which is
  * {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into the {@link Retrofit}
  * instance.
+ * call 适配器: call() -> Observerble()
  */
 public interface CallAdapter<R, T> {
   /**
@@ -33,6 +34,7 @@
    * <p>
    * Note: This is typically not the same type as the {@code returnType} provided to this call
    * adapter's factory.
+   * 需要转换的数据类型
    */
   Type responseType();
 
@@ -70,6 +72,7 @@
     /**
      * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
      * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     * 获取参数泛型里面的类型
      */
     protected static Type getParameterUpperBound(int index, ParameterizedType type) {
       return Utils.getParameterUpperBound(index, type);
@@ -78,6 +81,7 @@ protected static Type getParameterUpperBound(int index, ParameterizedType type)
     /**
      * Extract the raw class type from {@code type}. For example, the type representing
      * {@code List<? extends Runnable>} returns {@code List.class}.
+     * 获取参数的类型
      */
     protected static Class<?> getRawType(Type type) {
       return Utils.getRawType(type);
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 62c93a621..9b7331015 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -27,6 +27,7 @@
  * </ul>
  *
  * @param <T> Successful response body type.
+ * call 异步执行回调
  */
 public interface Callback<T> {
   /**
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 880eea9b8..baa93240f 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -57,6 +57,8 @@
      * {@code type} cannot be handled by this factory. This is used to create converters for types
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
+     *
+     * 用来转换请求参数{@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      */
     public Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
@@ -69,6 +71,8 @@
      * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
      * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
      * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
+     *
+     * 用来转换请求参数
      */
     public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
         Retrofit retrofit) {
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..eb6a4147b 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -22,6 +22,8 @@
  * Creates call adapters for that uses the same thread for both I/O and application-level
  * callbacks. For synchronous calls this is the application thread making the request; for
  * asynchronous calls this is a thread provided by OkHttp's dispatcher.
+ *
+ * 默认的call适配器, 直接返回原来的call
  */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
   static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
@@ -32,6 +34,7 @@
       return null;
     }
 
+    // 获取响应类型
     final Type responseType = Utils.getCallResponseType(returnType);
     return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index a633d60e8..930bd1f83 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -21,6 +21,9 @@
 import java.util.concurrent.Executor;
 import okhttp3.Request;
 
+/**
+ * 修改异步回调线程
+ */
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
@@ -30,9 +33,11 @@
 
   @Override
   public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    // 原始类型必须为call
     if (getRawType(returnType) != Call.class) {
       return null;
     }
+    // 响应类型
     final Type responseType = Utils.getCallResponseType(returnType);
     return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
@@ -45,6 +50,10 @@
     };
   }
 
+  /**
+   * 将Call的异步执行回调转换线程
+   * @param <T>
+   */
   static final class ExecutorCallbackCall<T> implements Call<T> {
     final Executor callbackExecutor;
     final Call<T> delegate;
@@ -57,7 +66,13 @@
     @Override public void enqueue(final Callback<T> callback) {
       if (callback == null) throw new NullPointerException("callback == null");
 
+      // 执行原始Call
       delegate.enqueue(new Callback<T>() {
+        /**
+         * success
+         * @param call
+         * @param response
+         */
         @Override public void onResponse(Call<T> call, final Response<T> response) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
@@ -71,6 +86,11 @@
           });
         }
 
+        /**
+         * failure
+         * @param call
+         * @param t
+         */
         @Override public void onFailure(Call<T> call, final Throwable t) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5b9a196ff..377381114 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -24,8 +24,14 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+/**
+ * retrofit只定义接口, 实际的同异步请求有子类自行实现, 这里是OKHTTP的实现
+ * @param <T>
+ */
 final class OkHttpCall<T> implements Call<T> {
+  /**  */
   private final ServiceMethod<T, ?> serviceMethod;
+  /** 方法参数 */
   private final Object[] args;
 
   private volatile boolean canceled;
@@ -174,7 +180,13 @@ private void callSuccess(Response<T> response) {
     return parseResponse(call.execute());
   }
 
+  /**
+   * 创建okhttp call
+   * @return
+   * @throws IOException
+   */
   private okhttp3.Call createRawCall() throws IOException {
+    /** 创建okhttp请求 */
     Request request = serviceMethod.toRequest(args);
     okhttp3.Call call = serviceMethod.callFactory.newCall(request);
     if (call == null) {
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..b040e480b 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -24,6 +24,10 @@
 
 import static retrofit2.Utils.checkNotNull;
 
+/**
+ * 解析注解参数, 保存到RequestBuilder
+ * @param <T>
+ */
 abstract class ParameterHandler<T> {
   abstract void apply(RequestBuilder builder, T value) throws IOException;
 
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index e67159bff..fa163fe3d 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,138 +18,170 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+/**
+ * 平台配置
+ */
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("org.robovm.apple.foundation.NSObject");
-      return new IOS();
-    } catch (ClassNotFoundException ignored) {
-    }
-    return new Platform();
-  }
+    private static final Platform PLATFORM = findPlatform();
 
-  Executor defaultCallbackExecutor() {
-    return null;
-  }
+    static Platform get() {
+        return PLATFORM;
+    }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    /**
+     * 寻找平台
+     *
+     * @return
+     */
+    private static Platform findPlatform() {
+        try {
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("org.robovm.apple.foundation.NSObject");
+            return new IOS();
+        } catch (ClassNotFoundException ignored) {
+        }
+        return new Platform();
     }
-    return DefaultCallAdapterFactory.INSTANCE;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
+
+    Executor defaultCallbackExecutor() {
+        return null;
     }
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
+    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+        if (callbackExecutor != null) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+        return DefaultCallAdapterFactory.INSTANCE;
     }
-  }
 
-  static class Android extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+            throws Throwable {
+        throw new UnsupportedOperationException();
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
 
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                   Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                    .unreflectSpecial(method, declaringClass)
+                    .bindTo(object)
+                    .invokeWithArguments(args);
+        }
     }
-  }
 
-  static class IOS extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
+    /**
+     * Android平台
+     */
+    static class Android extends Platform {
+        /**
+         * 异步回调在主线程
+         *
+         * @return
+         */
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
-    }
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
+
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }        /**
+         * 修改异步回调线程
+         *
+         * @param callbackExecutor
+         * @return
+         */
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
 
-    static class MainThreadExecutor implements Executor {
-      private static Object queue;
-      private static Method addOperation;
 
-      static {
-        try {
-          // queue = NSOperationQueue.getMainQueue();
-          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
-          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
-          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
-        } catch (Exception e) {
-          throw new AssertionError(e);
+    }
+
+    static class IOS extends Platform {
+        static class MainThreadExecutor implements Executor {
+            private static Object queue;
+            private static Method addOperation;
+
+            static {
+                try {
+                    // queue = NSOperationQueue.getMainQueue();
+                    Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
+                    queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
+                    addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
+                } catch (Exception e) {
+                    throw new AssertionError(e);
+                }
+            }
+
+            @Override
+            public void execute(Runnable r) {
+                try {
+                    // queue.addOperation(r);
+                    addOperation.invoke(queue, r);
+                } catch (IllegalArgumentException | IllegalAccessException e) {
+                    throw new AssertionError(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    if (cause instanceof RuntimeException) {
+                        throw (RuntimeException) cause;
+                    } else if (cause instanceof Error) {
+                        throw (Error) cause;
+                    }
+                    throw new RuntimeException(cause);
+                }
+            }
+        }        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
         }
-      }
 
-      @Override public void execute(Runnable r) {
-        try {
-          // queue.addOperation(r);
-          addOperation.invoke(queue, r);
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-          throw new AssertionError(e);
-        } catch (InvocationTargetException e) {
-          Throwable cause = e.getCause();
-          if (cause instanceof RuntimeException) {
-            throw (RuntimeException) cause;
-          } else if (cause instanceof Error) {
-            throw (Error) cause;
-          }
-          throw new RuntimeException(cause);
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
         }
-      }
+
+
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 3a25b6f53..3d91088d2 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -26,7 +26,11 @@
 import okio.Buffer;
 import okio.BufferedSink;
 
+/**
+ * 保存请求相关数据
+ */
 final class RequestBuilder {
+  /** 十六进制字符 */
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
   private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
@@ -45,6 +49,17 @@
   private FormBody.Builder formBuilder;
   private RequestBody body;
 
+  /**
+   * 构造函数
+   * @param method
+   * @param baseUrl
+   * @param relativeUrl
+   * @param headers
+   * @param contentType
+   * @param hasBody
+   * @param isFormEncoded
+   * @param isMultipart
+   */
   RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
       MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
@@ -73,6 +88,12 @@ void setRelativeUrl(Object relativeUrl) {
     this.relativeUrl = relativeUrl.toString();
   }
 
+  /**
+   * 添加请求头
+   * Content-Type特殊处理
+   * @param name
+   * @param value
+   */
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
       MediaType type = MediaType.parse(value);
@@ -85,6 +106,12 @@ void addHeader(String name, String value) {
     }
   }
 
+  /**
+   * 添加path参数, 从相对URL中替换
+   * @param name
+   * @param value
+   * @param encoded
+   */
   void addPathParam(String name, String value, boolean encoded) {
     if (relativeUrl == null) {
       // The relative URL is cleared when the first query parameter is set.
@@ -93,6 +120,12 @@ void addPathParam(String name, String value, boolean encoded) {
     relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
   }
 
+  /**
+   * 规范化路径string
+   * @param input
+   * @param alreadyEncoded
+   * @return
+   */
   private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
     int codePoint;
     for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
@@ -112,6 +145,14 @@ private static String canonicalizeForPath(String input, boolean alreadyEncoded)
     return input;
   }
 
+  /**
+   * 规范化路径
+   * @param out
+   * @param input
+   * @param pos
+   * @param limit
+   * @param alreadyEncoded
+   */
   private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
       boolean alreadyEncoded) {
     Buffer utf8Buffer = null; // Lazily allocated.
@@ -142,6 +183,12 @@ private static void canonicalizeForPath(Buffer out, String input, int pos, int l
     }
   }
 
+  /**
+   * @get 参数解析, 将参数拼接到URL
+   * @param name
+   * @param value
+   * @param encoded
+   */
   void addQueryParam(String name, String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
@@ -160,6 +207,12 @@ void addQueryParam(String name, String value, boolean encoded) {
     }
   }
 
+  /**
+   * 添加表单字段
+   * @param name
+   * @param value
+   * @param encoded
+   */
   void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
       formBuilder.addEncoded(name, value);
@@ -180,6 +233,10 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
+  /**
+   * 建造
+   * @return
+   */
   Request build() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index a0efab014..55177f053 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -19,6 +19,9 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
+/**
+ * 封装响应数据
+ */
 
 /** An HTTP response. */
 public final class Response<T> {
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index e7659c5cd..3354502e8 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -61,11 +61,23 @@
 
   private final okhttp3.Call.Factory callFactory;
   private final HttpUrl baseUrl;
+  /** 数据转换: 响应, 请求, 参数 */
   private final List<Converter.Factory> converterFactories;
+  /** call适配器转换 */
   private final List<CallAdapter.Factory> adapterFactories;
+  /** 线程执行 */
   private final Executor callbackExecutor;
   private final boolean validateEagerly;
 
+  /**
+   * 构造函数
+   * @param callFactory
+   * @param baseUrl
+   * @param converterFactories
+   * @param adapterFactories
+   * @param callbackExecutor
+   * @param validateEagerly
+   */
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
       List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
       Executor callbackExecutor, boolean validateEagerly) {
@@ -122,43 +134,73 @@
    *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
    * }
    * </pre>
+   *
+   *
+   * 创建接口代理:
    */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
+    // 检查service是否合法: 是否接口; 是否继承其他接口(猜测)
     Utils.validateServiceInterface(service);
+
+    // 解析接口方法, 并保存结果到map集合中
     if (validateEagerly) {
       eagerlyValidateMethods(service);
     }
+
+    // 开始创建接口代理类
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
+          // 获取平台配置
           private final Platform platform = Platform.get();
 
           @Override public Object invoke(Object proxy, Method method, Object... args)
               throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
+            // 如果这个方法是object类中的方法, 按照正常调用
             if (method.getDeclaringClass() == Object.class) {
               return method.invoke(this, args);
             }
+
+            // 安卓平台默认false
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
+
+            // 获取方法解析后的数据
             ServiceMethod<Object, Object> serviceMethod =
                 (ServiceMethod<Object, Object>) loadServiceMethod(method);
+
+            // 创建Call对象, 用OKHTTP实现
             OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+
             return serviceMethod.callAdapter.adapt(okHttpCall);
           }
         });
   }
 
+  /**
+   * 读取接口方法, 并解析
+   * @param service
+   */
   private void eagerlyValidateMethods(Class<?> service) {
+    // 获取当前平台
     Platform platform = Platform.get();
+
+    // getDeclaredMethods: 获取类中的所有方法, 包括private
     for (Method method : service.getDeclaredMethods()) {
+      // 安卓平台默认为false
       if (!platform.isDefaultMethod(method)) {
         loadServiceMethod(method);
       }
     }
   }
 
+  /**
+   * 解析接口方法, 并保存到map集合中
+   * @param method
+   * @return
+   */
   ServiceMethod<?, ?> loadServiceMethod(Method method) {
     ServiceMethod<?, ?> result = serviceMethodCache.get(method);
     if (result != null) return result;
@@ -176,6 +218,8 @@ private void eagerlyValidateMethods(Class<?> service) {
   /**
    * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
    * Typically an instance of {@link OkHttpClient}.
+   *
+   * 获取OKHTTP客户端
    */
   public okhttp3.Call.Factory callFactory() {
     return callFactory;
@@ -189,6 +233,8 @@ public HttpUrl baseUrl() {
   /**
    * Returns a list of the factories tried when creating a
    * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+   *
+   * call适配器集合
    */
   public List<CallAdapter.Factory> callAdapterFactories() {
     return adapterFactories;
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 3a4325a7e..105b065c0 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -56,6 +56,7 @@
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
+/** 接口方法转换到HTTP调用的适配器 */
 final class ServiceMethod<R, T> {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
@@ -106,6 +107,7 @@ Request toRequest(Object... args) throws IOException {
     }
 
     for (int p = 0; p < argumentCount; p++) {
+      /** 解析方法参数, 并保存到requestBuilder */
       handlers[p].apply(requestBuilder, args[p]);
     }
 
@@ -121,12 +123,18 @@ R toResponse(ResponseBody body) throws IOException {
    * Inspects the annotations on an interface method to construct a reusable service method. This
    * requires potentially-expensive reflection so it is best to build each service method only once
    * and reuse it. Builders cannot be reused.
+   *
+   * 检查接口的注释方法构建一个可重用的服务方法。这需要很可能代价昂贵的反射,所以最好是构建每个服务方法只有一次和重用它。建筑商不能重用
    */
   static final class Builder<T, R> {
     final Retrofit retrofit;
+    /** 接口方法 */
     final Method method;
+    /** 方法注解 */
     final Annotation[] methodAnnotations;
+    /** 方法参数注解 */
     final Annotation[][] parameterAnnotationsArray;
+    /** 方法参数类型 */
     final Type[] parameterTypes;
 
     Type responseType;
@@ -156,6 +164,11 @@ public Builder(Retrofit retrofit, Method method) {
       this.parameterAnnotationsArray = method.getParameterAnnotations();
     }
 
+    /**
+     * 创建call adapter
+     * 解析方法参数
+     * @return
+     */
     public ServiceMethod build() {
       callAdapter = createCallAdapter();
       responseType = callAdapter.responseType();
@@ -218,15 +231,23 @@ public ServiceMethod build() {
       return new ServiceMethod<>(this);
     }
 
+    /**
+     * call adapter
+     * @return
+     */
     private CallAdapter<T, R> createCallAdapter() {
+      // 返回类型
       Type returnType = method.getGenericReturnType();
+      // 检查返回类型是否class
       if (Utils.hasUnresolvableType(returnType)) {
         throw methodError(
             "Method return type must not include a type variable or wildcard: %s", returnType);
       }
+      // 不能返回void
       if (returnType == void.class) {
         throw methodError("Service methods cannot return void.");
       }
+      // 获取方法注解
       Annotation[] annotations = method.getAnnotations();
       try {
         //noinspection unchecked
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 98d1d8684..7718f12b3 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -32,6 +32,8 @@
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
+ *
+ * 使用该注释服务方法参数当你想直接控制POST或PUT请求的请求主体(而不是发送的请求参数或form-style请求主体)。对象将序列化使用{ @link翻新改造} { @link转换器转换器}实例和结果将直接作为请求体
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 4dbd1bf11..baf8fa717 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -51,6 +51,9 @@
  *
  * @see FormUrlEncoded
  * @see FieldMap
+ *
+ * post提交表单字段
+ * 需要加@FormUrlEncoded注解
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index a7eb1ee86..624abb534 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -38,6 +38,8 @@
  *
  * @see FormUrlEncoded
  * @see Field
+ *
+ * post表单提交
  */
 @Documented
 @Target(PARAMETER)
