diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
index b24212e08..03bdb6438 100644
--- a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -15,83 +15,56 @@
  */
 
 @file:JvmName("KotlinExtensions")
+@file:Suppress("BlockingMethodInNonBlockingContext")
 
 package retrofit2
 
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.launch
 import kotlinx.coroutines.suspendCancellableCoroutine
-import kotlin.coroutines.resume
-import kotlin.coroutines.resumeWithException
 
 inline fun <reified T> Retrofit.create(): T = create(T::class.java)
 
 suspend fun <T : Any> Call<T>.await(): T {
-  return suspendCancellableCoroutine { continuation ->
-    continuation.invokeOnCancellation {
-      cancel()
-    }
-    enqueue(object : Callback<T> {
-      override fun onResponse(call: Call<T>, response: Response<T>) {
-        if (response.isSuccessful) {
-          val body = response.body()
-          if (body == null) {
-            val invocation = call.request().tag(Invocation::class.java)!!
-            val method = invocation.method()
-            val e = KotlinNullPointerException("Response from " +
-                method.declaringClass.name +
-                '.' +
-                method.name +
-                " was null but response body type was declared as non-null")
-            continuation.resumeWithException(e)
-          } else {
-            continuation.resume(body)
-          }
-        } else {
-          continuation.resumeWithException(HttpException(response))
-        }
-      }
+  val response = executeAsync()
+  val isSuccessful = response.isSuccessful
+  val body = response.body()
 
-      override fun onFailure(call: Call<T>, t: Throwable) {
-        continuation.resumeWithException(t)
-      }
-    })
+  when {
+    isSuccessful && body != null -> return body
+    !isSuccessful                -> throw HttpException(response)
+    else                         -> {
+      val invocation = request().tag(Invocation::class.java)!!
+      val method = invocation.method()
+      val nullResponseMessage = "Response from ${method.declaringClass.name}.${method.name} was null but response body type was declared as non-null"
+      throw KotlinNullPointerException(nullResponseMessage)
+    }
   }
 }
 
 @JvmName("awaitNullable")
 suspend fun <T : Any> Call<T?>.await(): T? {
-  return suspendCancellableCoroutine { continuation ->
-    continuation.invokeOnCancellation {
-      cancel()
-    }
-    enqueue(object : Callback<T?> {
-      override fun onResponse(call: Call<T?>, response: Response<T?>) {
-        if (response.isSuccessful) {
-          continuation.resume(response.body())
-        } else {
-          continuation.resumeWithException(HttpException(response))
-        }
-      }
+  this.execute()
+  val response = executeAsync()
+  val body = response.body()
 
-      override fun onFailure(call: Call<T?>, t: Throwable) {
-        continuation.resumeWithException(t)
-      }
-    })
+  when {
+    response.isSuccessful -> throw HttpException(response)
+    else                  -> return body
   }
 }
 
-suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
+suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> = executeAsync()
+
+private suspend fun <T> Call<T>.executeAsync(): Response<T> {
+  val call = this
   return suspendCancellableCoroutine { continuation ->
-    continuation.invokeOnCancellation {
-      cancel()
-    }
-    enqueue(object : Callback<T> {
-      override fun onResponse(call: Call<T>, response: Response<T>) {
-        continuation.resume(response)
-      }
 
-      override fun onFailure(call: Call<T>, t: Throwable) {
-        continuation.resumeWithException(t)
-      }
-    })
+    continuation.invokeOnCancellation { call.cancel() }
+
+    CoroutineScope(continuation.context).launch {
+      val result = runCatching(call::execute)
+      continuation.resumeWith(result)
+    }
   }
-}
+}
\ No newline at end of file
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
index 629b02624..635313025 100644
--- a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -16,6 +16,7 @@
 package retrofit2
 
 import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.asContextElement
 import kotlinx.coroutines.async
 import kotlinx.coroutines.runBlocking
 import okhttp3.OkHttpClient
@@ -24,6 +25,7 @@ import okhttp3.mockwebserver.MockWebServer
 import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST
 import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
 import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert
 import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
 import org.junit.Ignore
@@ -244,16 +246,9 @@ class KotlinSuspendTest {
           override fun responseType() = String::class.java
           override fun adapt(call: Call<String>): Call<String> {
             return object : Call<String> by call {
-              override fun enqueue(callback: Callback<String>) {
-                call.enqueue(object : Callback<String> by callback {
-                  override fun onResponse(call: Call<String>, response: Response<String>) {
-                    if (response.isSuccessful) {
-                      callback.onResponse(call, Response.success(response.body()?.repeat(5)))
-                    } else {
-                      callback.onResponse(call, response)
-                    }
-                  }
-                })
+              override fun execute(): Response<String> {
+                val response = call.execute()
+                return Response.success(response.body()?.repeat(5))
               }
             }
           }
@@ -273,4 +268,35 @@ class KotlinSuspendTest {
     val body = runBlocking { example.body() }
     assertThat(body).isEqualTo("HiHiHiHiHi")
   }
+
+  @Test fun `ThreadContextElement works`() {
+    val threadLocal = ThreadLocal<String>()
+    val expectedValue = "1"
+    val threadLocalContextElement = threadLocal.asContextElement(expectedValue)
+    var interceptedValue: String? = null
+
+    val okHttpClient = OkHttpClient.Builder()
+      .addInterceptor { chain ->
+        interceptedValue = threadLocal.get()
+        chain.proceed(chain.request())
+      }
+      .build()
+    val retrofit = Retrofit.Builder()
+      .baseUrl(server.url("/"))
+      .client(okHttpClient)
+      .addConverterFactory(ToStringConverterFactory())
+      .build()
+    val example = retrofit.create(Service::class.java)
+
+    // This leaves the connection open indefinitely allowing us to cancel without racing a body.
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val deferred = GlobalScope.async(threadLocalContextElement) { example.body() }
+    runBlocking { deferred.await() }
+
+    // This will block until the server has received the request ensuring it's in flight.
+    server.takeRequest()
+
+    Assert.assertEquals(expectedValue, interceptedValue)
+  }
 }
