diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 14bc700b7..31a308629 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -15,7 +15,6 @@
  */
 package retrofit2;
 
-import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -24,6 +23,8 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+import java.io.IOException;
+
 import static retrofit2.Utils.checkNotNull;
 
 final class OkHttpCall<T> implements Call<T> {
@@ -70,6 +71,10 @@
     }
   }
 
+  /**
+   * 执行网络请求 异步
+   * @param callback
+   */
   @Override public void enqueue(final Callback<T> callback) {
     checkNotNull(callback, "callback == null");
 
@@ -143,9 +148,14 @@ private void callSuccess(Response<T> response) {
     return executed;
   }
 
+  /**
+   * 执行网络请求 同步
+   * @return
+   * @throws IOException
+   */
   @Override public Response<T> execute() throws IOException {
     okhttp3.Call call;
-
+    //如何已经在执行者不再执行
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed.");
       executed = true;
@@ -157,7 +167,7 @@ private void callSuccess(Response<T> response) {
           throw (RuntimeException) creationFailure;
         }
       }
-
+      //如果请求为空则创建请求
       call = rawCall;
       if (call == null) {
         try {
@@ -185,6 +195,12 @@ private void callSuccess(Response<T> response) {
     return call;
   }
 
+  /**
+   * 解析网络请求返回的数据
+   * @param rawResponse
+   * @return
+   * @throws IOException
+   */
   Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
     ResponseBody rawBody = rawResponse.body();
 
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 95ef273f1..62c54082d 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -15,6 +15,15 @@
  */
 package retrofit2;
 
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.GET;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.Url;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -25,14 +34,6 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.http.GET;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.Url;
 
 import static java.util.Collections.unmodifiableList;
 import static retrofit2.Utils.checkNotNull;
@@ -140,6 +141,7 @@
             if (method.getDeclaringClass() == Object.class) {
               return method.invoke(this, args);
             }
+            //如果是Java8引入的default方法，直接调用
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
@@ -161,12 +163,15 @@ private void eagerlyValidateMethods(Class<?> service) {
   }
 
   ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    //有缓存则返回缓存的方法
     ServiceMethod<?, ?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
+    //没缓存则创建方法，并存入缓存
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
+        //采用建造者模式创建服务方法,讲接口里的方法解析成请求体
         result = new ServiceMethod.Builder<>(this, method).build();
         serviceMethodCache.put(method, result);
       }
@@ -558,27 +563,28 @@ public Builder validateEagerly(boolean validateEagerly) {
      * OkHttpClient} will be created and used.
      */
     public Retrofit build() {
+      //没有传入baseUrl则报错
       if (baseUrl == null) {
         throw new IllegalStateException("Base URL required.");
       }
-
+      //没有传入HttpClient默认提供OkHttpClient
       okhttp3.Call.Factory callFactory = this.callFactory;
       if (callFactory == null) {
         callFactory = new OkHttpClient();
       }
-
+      //如果没有传入回调线程则默认为Android主线程,Java 没重写defaultCallbackExecutor方法，可能需要传入
       Executor callbackExecutor = this.callbackExecutor;
       if (callbackExecutor == null) {
         callbackExecutor = platform.defaultCallbackExecutor();
       }
-
+      //传入适配器工，初始化传入默认的适配器工厂，返回Call厂
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
       adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
-
+      //传入转换器工厂，在Builder构造方法中已经加入BuiltInConverters：converterFactories.add(new BuiltInConverters());
       // Make a defensive copy of the converters.
       List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
-
+      //validateEagerly有retrofit建造者设置
       return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
           callbackExecutor, validateEagerly);
     }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index a32f8101a..8c2f4c252 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -15,6 +15,10 @@
  */
 package retrofit2;
 
+import okhttp3.Headers;
+import okhttp3.*;
+import retrofit2.http.*;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
@@ -26,35 +30,6 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.HeaderMap;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.QueryName;
-import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class ServiceMethod<R, T> {
@@ -170,7 +145,7 @@ public ServiceMethod build() {
       for (Annotation annotation : methodAnnotations) {
         parseMethodAnnotation(annotation);
       }
-
+        //没有方法注解则报隐藏
       if (httpMethod == null) {
         throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
       }
@@ -290,6 +265,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       }
 
       // Get the relative URL path and existing query string, if present.
+        //如果是get请求，并且有传参数，获取参数
       int question = value.indexOf('?');
       if (question != -1 && question < value.length() - 1) {
         // Ensure the query string does not have any named parameters.
@@ -300,8 +276,9 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
               + "For dynamic query parameters use @Query.", queryParams);
         }
       }
-
+        //相对地址
       this.relativeUrl = value;
+        //占位符set
       this.relativeUrlParamNames = parsePathParameters(value);
     }
 
