diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..85c3e77b7
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/retrofit
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/6608b4713ad80988cdc9
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.gitignore b/.gitignore
index 133735f7b..846cab690 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+# Eclipse
 .classpath
 .project
 .settings
@@ -13,10 +14,12 @@ target
 pom.xml.*
 release.properties
 
+# Idea
 .idea
 *.iml
 classes
 
 obj
 
+#MacOS
 .DS_Store
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e2eb7feba..66db0d42d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,173 @@
 Change Log
 ==========
 
+Version 2.1.0 *(2016-06-15)*
+----------------------------
+
+ * New: `@HeaderMap` annotation and support for supplying an arbitrary number of headers to an endpoint.
+ * New: `@JsonAdapter` annotations on the `@Body` parameter and on the method will be propagated to Moshi
+   for creating the request and response adapters, respectively.
+ * Fix: Honor the `Content-Type` encoding of XML responses when deserializing response bodies.
+ * Fix: Remove the stacktrace from fake network exceptions created from retrofit-mock's `NetworkBehavior`.
+   They had the potential to be misleading and look like a library issue.
+ * Fix: Eagerly catch malformed `Content-Type` headers supplied via `@Header` or `@Headers`.
+
+
+Version 2.0.2 *(2016-04-14)*
+----------------------------
+
+ * New: `ProtoConverterFactory.createWithRegistry()` method accepts an extension registry to be used
+   when deserializing protos.
+ * Fix: Pass the correct `Call` instance to `Callback`'s `onResponse` and `onFailure` methods such
+   that calling `clone()` retains the correct threading behavior.
+ * Fix: Reduce the per-request allocation overhead for the RxJava call adapter.
+
+
+Version 2.0.1 *(2016-03-30)*
+----------------------------
+
+ * New: Support OkHttp's `HttpUrl` as a `@Url` parameter type.
+ * New: Support iterable and array `@Part` parameters using OkHttp's `MultipartBody.Part`.
+ * Fix: Honor backpressure in `Observable`s created from the RxJavaCallAdapterFactory.
+
+
+Version 2.0.0 *(2016-03-11)*
+----------------------------
+
+Retrofit 2 is a major release focused on extensibility. The API changes are numerous but solve
+shortcomings of the previous version and provide a path for future enhancement.
+
+Because the release includes breaking API changes, we're changing the project's package name from
+`retrofit` to `retrofit2`. This should make it possible for large applications and libraries to
+migrate incrementally. The Maven group ID is now `com.squareup.retrofit2`. For an explanation of
+this strategy, see Jake Wharton's post, [Java Interoperability Policy for Major Version
+Updates](http://jakewharton.com/java-interoperability-policy-for-major-version-updates/).
+
+ * **Service methods return `Call<T>`.** This allows them to be executed synchronously or
+   asynchronously using the same method definition. A `Call` instance represents a single
+   request/response pair so it can only be used once, but you can `clone()` it for re-use.
+   Invoking `cancel()` will cancel in-flight requests or prevent the request from even being
+   performed if it has not already.
+ 
+ * **Multiple converters for multiple serialization formats.** API calls returning different
+  formats (like JSON, protocol buffers, and plain text) no longer need to be separated into
+  separate service interfaces. Combine them together and add multiple converters. Converters are
+  chosen based on the response type you declare. Gson is no longer included by default, so you will
+  always need to add a converter for any serialization support. OkHttp's `RequestBody` and
+  `ResponseBody` types can always be used without adding one, however.
+   
+ * **Call adapters allow different execution mechanisms.** While `Call` is the built-in mechanism,
+   support for additional ones can be added similar to how different converters can be added.
+   RxJava's `Observable` support has moved into a separate artifact as a result, and support for
+   Java 8's `CompletableFuture` and Guava's `ListenableFuture` are also provided as additional
+   artifacts.
+   
+ * **Generic response type includes HTTP information and deserialized body.** You no longer have to
+   choose between the deserialized body and reading HTTP information. Every `Call` automatically
+   receives both via the `Response<T>` type and the RxJava, Guava, and Java 8 call adapters also
+   support it.
+   
+ * **@Url for hypermedia-like APIs.** When your API returns links for pagination, additional
+   resources, or updated content they can now be used with a service method whose first parameter
+   is annotated with `@Url`.
+
+Changes from beta 4:
+
+ * New: `RxJavaCallAdapterFactory` now supports service methods which return `Completable` which
+   ignores and discards response bodies, if any.
+ * New: `RxJavaCallAdapterFactory` supports supplying a default `Scheduler` which will be used
+   for `subscribeOn` on returned `Observable`, `Single`, and `Completable` instances.
+ * New: `MoshiConverterFactory` supports creating an instance which uses lenient parsing.
+ * New: `@Part` can omit the part name and use OkHttp's `MultipartBody.Part` type for supplying
+   parts. This lets you customize the headers, name, and filename and provide the part body in a
+   single argument.
+ * The `BaseUrl` interface and support for changeable base URLs was removed. This functionality
+   can be done using an OkHttp interceptor and a sample showcasing it was added.
+ * `Response.isSuccess()` was renamed to `Response.isSuccessful()` for parity with the name of
+   OkHttp's version of that method.
+ * Fix: Throw a more appropriate exception with a message when a resolved url (base URL + relative
+   URL) is malformed.
+ * Fix: `GsonConverterFactory` now honors settings on the `Gson` instance (like leniency).
+ * Fix: `ScalarsConverterFactory` now supports primitive scalar types in addition to boxed for
+   response body parsing.
+ * Fix: `Retrofit.callbackExecutor()` may now return an executor even when one was not explicitly
+   provided. This allows custom `CallAdapter.Factory` implementations to use it when triggering
+   callbacks to ensure they happen on the appropriate thread for the platform (e.g., Android).
+
+
+Version 2.0.0-beta4 *(2016-02-04)*
+----------------------------------
+
+ * New: `Call` instance is now passed to both `onResponse` and `onFailure` methods of `Callback`. This aids
+   in detecting when `onFailure` is called as a result of `Call.cancel()` by checking `Call.isCanceled()`.
+ * New: `Call.request()` returns (optionally creating) the `Request` object for the call. Note: If this is
+   called before `Call.execute()` or `Call.enqueue()` this will do relatively expensive work synchronously.
+   Doing so in performance-critical sections (like on the Android main thread) should be avoided.
+ * New: Support for the release version of OkHttp 3.0 and newer.
+ * New: `adapter-guava` module provides a `CallAdapter.Factory` for Guava's `ListenableFuture`.
+ * New: `adapter-java8` module provides a `CallAdapter.Factory` for Java 8's `CompleteableFuture`.
+ * New: `ScalarsConverterFactory` (from `converter-scalars` module) now supports parsing response bodies
+   into either `String`, the 8 primitive types, or the 8 boxed primitive types.
+ * New: Automatic support for sending callbacks to the iOS main thread when running via RoboVM.
+ * New: Method annotations are now passed to the factory for request body converters. This allows converters
+   to alter the structure of both request bodies and response bodies with a single method-level annotation.
+ * Each converter has been moved to its own package under `retrofit2.converter.<name>`. This prevents type
+   collisions when many converters are simultaneously in use.
+ * Fix: Exceptions thrown when unable to locate a `CallAdapter.Factory` for a method return type now
+   correctly list the `CallAdapter.Factory` instances checked.
+ * Fix: Ensure default methods on service interfaces can be invoked.
+ * Fix: Correctly resolve the generic parameter types of collection interfaces when subclasses of those
+   collections are used as method parameters.
+ * Fix: Do not encode `/` characters in `@Path` replacements when `encoded = true`.
+
+
+Version 2.0.0-beta3 *(2016-01-05)*
+----------------------------------
+
+ * New: All classes have been migrated to the `retrofit2.*` package name. The Maven groupId is now
+   `com.squareup.retrofit2`. This is in accordance with the
+   [Java Interoperability Policy for Major Version Updates](http://jakewharton.com/java-interoperability-policy-for-major-version-updates/).
+   With this change Retrofit 2.x can coexiest with Retrofit 1.x in the same project.
+ * New: Update to use the OkHttp 3 API and OkHttp 3.0.0-RC1 or newer is now required. Similar to the previous
+   point, OkHttp has a new package name (`okhttp3.*`) and Maven groupId (`com.squareup.okhttp3`) which allow
+   it to coexist with OkHttp 2.x in the same project.
+ * New: String converters allow for custom serialization of parameters that end up as strings (such as `@Path`,
+   `@Query`, `@Header`, etc.). `Converter.Factory` has a new `stringConverter` method which receives the
+   parameter type and annotations and can return a converter for that type. This allows providing custom
+   rendering of types like `Date`, `User`, etc. to a string before being used for its purpose. A default
+   converter will call `toString()` for any type which retains the mimics the previous behavior.
+ * New: OkHttp's `Call.Factory` type is now used as the HTTP client rather than using the `OkHttpClient` type
+   directly (`OkHttpClient` does implement `Call.Factory`). A `callFactory` method has been added to both
+   `Retrofit.Builder` and `Retrofit` to allow supplying alternate implementations of an HTTP client. The
+   `client(OkHttpClient)` method on `Retrofit.Builder` still exists as a convenience.
+ * New: `isExecuted()` method returns whether a `Call` has been synchronously or asynchronously executed.
+ * New: `isCanceled()` method returns whether a `Call` has been canceled. Use this in `onFailure` to determine
+   whether the callback was invoked from cancellation or actual transport failure.
+ * New: `converter-scalars` module provides a `Converter.Factory` for converting `String`, the 8 primitive
+   types, and the 8 boxed primitive types as `text/plain` bodies. Install this before your normal converter
+   to avoid passing these simple scalars through, for example, a JSON converter.
+ * New: `Converter.Factory` methods now receive a `Retrofit` instance which also now has methods for querying
+   the next converter for a given type. This allows implementations to delegate to others and provide
+   additional behavior without complete reimplementation.
+ * New: `@OPTIONS` annotation more easily allows for making OPTIONS requests.
+ * New: `@Part` annotation now supports `List` and array types.
+ * New: The `@Url` annotation now allows using `java.net.URI` or `android.net.Uri` (in addition to `String`)
+   as parameter types for providing relative or absolute endpoint URLs dynamically.
+ * New: The `retrofit-mock` module has been rewritten with a new `BehaviorDelegate` class for implementing
+   fake network behavior in a local mock implementation of your service endpoints. Documentation and more
+   tests are forthcoming, but the `SimpleMockService` demonstrates its use for now.
+ * Fix: Forbid Retrofit's `Response` type and OkHttp's `Response` type as the response body type given to
+   a `Call` (i.e., `Call<Response>`). OkHttp's `ResponseBody` type is the correct one to use when the raw
+   body contents are desired.
+ * Fix: The Gson converter now respects settings on the supplied `Gson` instance (such as `serializeNulls`).
+   This requires Gson 2.4 or newer.
+ * The Wire converter has been updated to the Wire 2.0 API.
+ * The change in 2.0.0-beta2 which provided the `Retrofit` instance to the `onResponse` callback of `Callback`
+   has been reverted. There are too many edge cases around providing the `Retrofit` object in order to allow
+   deserialization of the error body. To accommodate this use case, pass around the `Retrofit` response
+   manually or implement a custom `CallAdapter.Factory` does so automatically.
+
+
 Version 2.0.0-beta2 *(2015-09-28)*
 ----------------------------------
 
diff --git a/README.md b/README.md
index 5bbcdc582..026930a7b 100644
--- a/README.md
+++ b/README.md
@@ -12,14 +12,14 @@ Download
 Download [the latest JAR][2] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.retrofit</groupId>
+  <groupId>com.squareup.retrofit2</groupId>
   <artifactId>retrofit</artifactId>
-  <version>2.0.0-beta2</version>
+  <version>2.1.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
+compile 'com.squareup.retrofit2:retrofit:2.1.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/checkstyle.xml b/checkstyle.xml
index ceb1d5cdf..a729c26a7 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -4,7 +4,9 @@
     "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
 
 <module name="Checker">
-    <module name="NewlineAtEndOfFile"/>
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf" />
+    </module>
     <module name="FileLength"/>
     <module name="FileTabCharacter"/>
 
diff --git a/pom.xml b/pom.xml
index 3d4ce896e..96b732dbf 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.0.0-SNAPSHOT</version>
+  <version>2.1.1-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -49,26 +49,29 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <android.platform>16</android.platform>
-    <okhttp.version>2.5.0</okhttp.version>
+    <okhttp.version>3.4.1</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.14</rxjava.version>
+    <rxjava.version>1.2.0</rxjava.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.4</gson.version>
-    <protobuf.version>2.5.0</protobuf.version>
-    <jackson.version>2.4.3</jackson.version>
-    <wire.version>2.0.0</wire.version>
+    <gson.version>2.7</gson.version>
+    <protobuf.version>3.0.0</protobuf.version>
+    <jackson.version>2.7.2</jackson.version>
+    <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.0.0</moshi.version>
+    <moshi.version>1.2.0</moshi.version>
+
+    <!-- Sample Dependencies -->
+    <jsoup.version>1.7.3</jsoup.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>18.0</guava.version>
+    <guava.version>19.0</guava.version>
+    <robolectric.version>3.0</robolectric.version>
   </properties>
 
   <scm>
@@ -108,7 +111,7 @@
         <version>${animal.sniffer.version}</version>
       </dependency>
       <dependency>
-        <groupId>com.squareup.okhttp</groupId>
+        <groupId>com.squareup.okhttp3</groupId>
         <artifactId>okhttp</artifactId>
         <version>${okhttp.version}</version>
       </dependency>
@@ -170,10 +173,15 @@
         <version>${guava.version}</version>
       </dependency>
       <dependency>
-        <groupId>com.squareup.okhttp</groupId>
+        <groupId>com.squareup.okhttp3</groupId>
         <artifactId>mockwebserver</artifactId>
         <version>${okhttp.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.robolectric</groupId>
+        <artifactId>robolectric</artifactId>
+        <version>${robolectric.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
diff --git a/retrofit-adapters/README.md b/retrofit-adapters/README.md
index 2dd0b7d47..34e18813b 100644
--- a/retrofit-adapters/README.md
+++ b/retrofit-adapters/README.md
@@ -1,4 +1,14 @@
 Retrofit Adapters
 =================
 
-TODO
+Retrofit ships with a default adapter for executing `Call` instances. The child modules contained
+herein are additional adapters for other popular execution mechanisms.
+
+To use, supply an instance of your desired adapter when building your `Retrofit` instance.
+
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.example.com")
+    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+    .build();
+```
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
new file mode 100644
index 000000000..ae5632642
--- /dev/null
+++ b/retrofit-adapters/guava/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.1.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-guava</artifactId>
+  <name>Adapter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
new file mode 100644
index 000000000..b3624fc3a
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Guava futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link ListenableFuture} from service
+ * methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   ListenableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code ListenableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code ListenableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link HttpException} errors for non-2XX responses, and sets {@link IOException}
+ * for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code ListenableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+public final class GuavaCallAdapterFactory extends CallAdapter.Factory {
+  public static GuavaCallAdapterFactory create() {
+    return new GuavaCallAdapterFactory();
+  }
+
+  private GuavaCallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != ListenableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("ListenableFuture return type must be parameterized"
+          + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, ListenableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public ListenableFuture<R> adapt(final Call<R> call) {
+      return new AbstractFuture<R>() {
+        {
+          call.enqueue(new Callback<R>() {
+            @Override public void onResponse(Call<R> call, Response<R> response) {
+              if (response.isSuccessful()) {
+                set(response.body());
+              } else {
+                setException(new HttpException(response));
+              }
+            }
+
+            @Override public void onFailure(Call<R> call, Throwable t) {
+              setException(t);
+            }
+          });
+        }
+
+        @Override protected void interruptTask() {
+          call.cancel();
+        }
+      };
+    }
+  }
+
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, ListenableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public ListenableFuture<Response<R>> adapt(final Call<R> call) {
+      return new AbstractFuture<Response<R>>() {
+        {
+          call.enqueue(new Callback<R>() {
+            @Override public void onResponse(Call<R> call, Response<R> response) {
+              set(response);
+            }
+
+            @Override public void onFailure(Call<R> call, Throwable t) {
+              setException(t);
+            }
+          });
+        }
+
+        @Override protected void interruptTask() {
+          call.cancel();
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
new file mode 100644
index 000000000..f18a81955
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import retrofit2.Response;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..c8abdf1c2
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class GuavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<ListenableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<ListenableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
new file mode 100644
index 000000000..fb3ccb3da
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ListenableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") ListenableFuture<String> body();
+    @GET("/") ListenableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    ListenableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    ListenableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    ListenableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    ListenableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    ListenableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    ListenableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
new file mode 100644
index 000000000..bb9ccf189
--- /dev/null
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.guava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
new file mode 100644
index 000000000..4ca8fa229
--- /dev/null
+++ b/retrofit-adapters/java8/pom.xml
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.1.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-java8</artifactId>
+  <name>Adapter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
new file mode 100644
index 000000000..022fa9848
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import retrofit2.Response;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
new file mode 100644
index 000000000..fd905475d
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   CompletableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code CompletableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code CompletableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link HttpException} errors for non-2XX responses, and sets {@link IOException}
+ * for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code CompletableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+public final class Java8CallAdapterFactory extends CallAdapter.Factory {
+  public static Java8CallAdapterFactory create() {
+    return new Java8CallAdapterFactory();
+  }
+
+  private Java8CallAdapterFactory() {
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccessful()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
new file mode 100644
index 000000000..d4a00a1dc
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(Java8CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
new file mode 100644
index 000000000..283268881
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class Java8CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
new file mode 100644
index 000000000..de4b63e61
--- /dev/null
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 8a677d359..c66902ccc 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -15,6 +15,8 @@
   <packaging>pom</packaging>
 
   <modules>
+    <module>guava</module>
+    <module>java8</module>
     <module>rxjava</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index bb9e273e2..249156122 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -40,7 +40,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java
deleted file mode 100644
index e389697d9..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/RxJavaCallAdapterFactory.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import rx.Observable;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-import rx.functions.Action0;
-import rx.functions.Func1;
-import rx.subscriptions.Subscriptions;
-
-/**
- * TODO docs
- */
-public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
-  /**
-   * TODO
-   */
-  public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory();
-  }
-
-  private RxJavaCallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = Utils.getRawType(returnType);
-    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
-    if (rawType != Observable.class && !isSingle) {
-      return null;
-    }
-    if (!(returnType instanceof ParameterizedType)) {
-      String name = isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
-    }
-
-    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType);
-    if (isSingle) {
-      // Add Single-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      return SingleHelper.makeSingle(callAdapter);
-    }
-    return callAdapter;
-  }
-
-  private CallAdapter<Observable<?>> getCallAdapter(Type returnType) {
-    Type observableType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = Utils.getRawType(observableType);
-    if (rawObservableType == Response.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Response must be parameterized"
-            + " as Response<Foo> or Response<? extends Foo>");
-      }
-      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResponseCallAdapter(responseType);
-    }
-
-    if (rawObservableType == Result.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Result must be parameterized"
-            + " as Result<Foo> or Result<? extends Foo>");
-      }
-      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResultCallAdapter(responseType);
-    }
-
-    return new SimpleCallAdapter(observableType);
-  }
-
-  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
-    private final Call<T> originalCall;
-
-    private CallOnSubscribe(Call<T> originalCall) {
-      this.originalCall = originalCall;
-    }
-
-    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
-      // Since Call is a one-shot type, clone it for each new subscriber.
-      final Call<T> call = originalCall.clone();
-
-      // Attempt to cancel the call if it is still in-flight on unsubscription.
-      subscriber.add(Subscriptions.create(new Action0() {
-        @Override public void call() {
-          call.cancel();
-        }
-      }));
-
-      try {
-        Response<T> response = call.execute();
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onNext(response);
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onError(t);
-        }
-        return;
-      }
-
-      if (!subscriber.isUnsubscribed()) {
-        subscriber.onCompleted();
-      }
-    }
-  }
-
-  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call));
-    }
-  }
-
-  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-
-    SimpleCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<R> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call)) //
-          .flatMap(new Func1<Response<R>, Observable<R>>() {
-            @Override public Observable<R> call(Response<R> response) {
-              if (response.isSuccess()) {
-                return Observable.just(response.body());
-              }
-              return Observable.error(new HttpException(response));
-            }
-          });
-    }
-  }
-
-  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-
-    ResultCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
-      return Observable.create(new CallOnSubscribe<>(call)) //
-          .map(new Func1<Response<R>, Result<R>>() {
-            @Override public Result<R> call(Response<R> response) {
-              return Result.response(response);
-            }
-          })
-          .onErrorReturn(new Func1<Throwable, Result<R>>() {
-            @Override public Result<R> call(Throwable throwable) {
-              return Result.error(throwable);
-            }
-          });
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
new file mode 100644
index 000000000..88e5c5e4e
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.Callable;
+import retrofit2.Response;
+
+final class BodyCallable<R> implements Callable<R> {
+  private final Callable<Response<R>> responseCallable;
+
+  BodyCallable(Callable<Response<R>> responseCallable) {
+    this.responseCallable = responseCallable;
+  }
+
+  @Override public R call() throws Exception {
+    Response<R> response = responseCallable.call();
+    if (response.isSuccessful()) {
+      return response.body();
+    }
+    throw new HttpException(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
similarity index 69%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
index d8d199766..2e501e121 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/HttpException.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -1,13 +1,20 @@
-package retrofit2;
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
+  private static String getMessage(Response<?> response) {
+    if (response == null) throw new NullPointerException("response == null");
+    return "HTTP " + response.code() + " " + response.message();
+  }
+
   private final int code;
   private final String message;
   private final transient Response<?> response;
 
   public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
+    super(getMessage(response));
     this.code = response.code();
     this.message = response.message();
     this.response = response;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
new file mode 100644
index 000000000..7d075e71b
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import retrofit2.Call;
+import retrofit2.Response;
+
+final class ResponseCallable<T> implements Callable<Response<T>> {
+  private final Call<T> call;
+
+  ResponseCallable(Call<T> call) {
+    this.call = call;
+  }
+
+  @Override public Response<T> call() throws IOException {
+    // Since Call is a one-shot type, clone it for each new caller.
+    return call.clone().execute();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
similarity index 76%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 751b629da..49abfae2b 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -13,26 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
-
-import static retrofit2.Utils.checkNotNull;
+import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
   public static <T> Result<T> error(Throwable error) {
-    return new Result<>(null, checkNotNull(error, "error == null"));
+    if (error == null) throw new NullPointerException("error == null");
+    return new Result<>(null, error);
   }
 
   public static <T> Result<T> response(Response<T> response) {
-    return new Result<>(checkNotNull(response, "response == null"), null);
+    if (response == null) throw new NullPointerException("response == null");
+    return new Result<>(response, null);
   }
 
   private final Response<T> response;
   private final Throwable error;
 
-  Result(Response<T> response, Throwable error) {
+  private Result(Response<T> response, Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -61,4 +62,11 @@ public Throwable error() {
   public boolean isError() {
     return error != null;
   }
+
+  @Override public String toString() {
+    if (error != null) {
+      return "Result{isError=true, error=\"" + error + "\"}";
+    }
+    return "Result{isError=false, response=" + response + '}';
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
new file mode 100644
index 000000000..ea9e37c25
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.Callable;
+import retrofit2.Response;
+
+final class ResultCallable<R> implements Callable<Result<R>> {
+  private final Callable<Response<R>> responseCallable;
+
+  ResultCallable(Callable<Response<R>> responseCallable) {
+    this.responseCallable = responseCallable;
+  }
+
+  @Override public Result<R> call() {
+    try {
+      return Result.response(responseCallable.call());
+    } catch (Throwable t) {
+      return Result.error(t);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
new file mode 100644
index 000000000..19cf184ad
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import rx.Observable;
+import rx.Scheduler;
+
+final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
+  private final Type responseType;
+  private final Scheduler scheduler;
+  private final boolean isResult;
+  private final boolean isBody;
+  private final boolean isSingle;
+  private final boolean isCompletable;
+
+  RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
+      boolean isSingle, boolean isCompletable) {
+    this.responseType = responseType;
+    this.scheduler = scheduler;
+    this.isResult = isResult;
+    this.isBody = isBody;
+    this.isSingle = isSingle;
+    this.isCompletable = isCompletable;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Object adapt(Call<R> call) {
+    ResponseCallable<R> resultCallable = new ResponseCallable<>(call);
+
+    Observable<?> observable;
+    if (isResult) {
+      observable = Observable.fromCallable(new ResultCallable<>(resultCallable));
+    } else if (isBody) {
+      observable = Observable.fromCallable(new BodyCallable<>(resultCallable));
+    } else {
+      observable = Observable.fromCallable(resultCallable);
+    }
+
+    if (scheduler != null) {
+      observable = observable.subscribeOn(scheduler);
+    }
+
+    if (isSingle) {
+      return observable.toSingle();
+    }
+    if (isCompletable) {
+      return CompletableHelper.toCompletable(observable);
+    }
+    return observable;
+  }
+
+  /**
+   * Separate static class defers classloading and bytecode verification since Completable is not an
+   * RxJava stable API yet.
+   */
+  private static final class CompletableHelper {
+    static Object toCompletable(Observable<?> observable) {
+      return observable.toCompletable();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
new file mode 100644
index 000000000..283451679
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import rx.Completable;
+import rx.Observable;
+import rx.Scheduler;
+import rx.Single;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable}, {@link Single},
+ * or {@link Completable} from service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Observable&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are three configurations supported for the {@code Observable} or {@code Single} type
+ * parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
+ * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
+ * {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Observable<Response<User>>}) calls {@code onNext}
+ * with a {@link Response} object for all HTTP responses and calls {@code onError} with
+ * {@link IOException} for network errors</li>
+ * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
+ * {@link Result} object for all HTTP responses and errors.</li>
+ * </ul>
+ * <p>
+ * <em>Note:</em> Support for {@link Single} and {@link Completable} is experimental and subject
+ * to backwards-incompatible changes at any time since both of these types are not considered
+ * stable by RxJava.
+ */
+public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
+  /**
+   * Returns an instance which creates synchronous observables that do not operate on any scheduler
+   * by default.
+   */
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory(null);
+  }
+
+  /**
+   * Returns an instance which creates synchronous observables that
+   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+   */
+  public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
+    if (scheduler == null) throw new NullPointerException("scheduler == null");
+    return new RxJavaCallAdapterFactory(scheduler);
+  }
+
+  private final Scheduler scheduler;
+
+  private RxJavaCallAdapterFactory(Scheduler scheduler) {
+    this.scheduler = scheduler;
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = getRawType(returnType);
+    boolean isSingle = rawType == Single.class;
+    boolean isCompletable = "rx.Completable".equals(rawType.getCanonicalName());
+    if (rawType != Observable.class && !isSingle && !isCompletable) {
+      return null;
+    }
+
+    if (isCompletable) {
+      return new RxJavaCallAdapter(Void.class, scheduler, false, true, false, true);
+    }
+
+    boolean isResult = false;
+    boolean isBody = false;
+    Type responseType;
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+    } else if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      isResult = true;
+    } else {
+      responseType = observableType;
+      isBody = true;
+    }
+
+    return new RxJavaCallAdapter(responseType, scheduler, isResult, isBody, isSingle, false);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java
deleted file mode 100644
index 17d14dae7..000000000
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/RxJavaCallAdapterFactoryTest.java
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.google.common.reflect.TypeToken;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.http.GET;
-import rx.Observable;
-import rx.Single;
-import rx.observables.BlockingObservable;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-
-public final class RxJavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Observable<String> observableBody();
-    @GET("/") Observable<Response<String>> observableResponse();
-    @GET("/") Observable<Result<String>> observableResult();
-    @GET("/") Single<String> singleBody();
-    @GET("/") Single<Response<String>> singleResponse();
-    @GET("/") Single<Result<String>> singleResult();
-  }
-
-  private Retrofit retrofit;
-  private Service service;
-
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    assertThat(o.first()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 OK");
-    }
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<String> o = service.observableBody().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
-
-  @Test public void responseType() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type classType = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
-
-  @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
-
-  @Test public void rawTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
-    }
-  }
-
-  @Test public void rawObservableResponseTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Response>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-  }
-
-  @Test public void rawResultTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Result>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-  }
-
-  @Test public void single() {
-    // TODO Better tests here. Why is there no toBlocking() on Single?
-    assertNotNull(service.singleBody());
-    assertNotNull(service.singleResponse());
-    assertNotNull(service.singleResult());
-  }
-
-  static class StringConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
-        }
-      };
-    }
-
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] annotations, Retrofit retrofit) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MediaType.parse("text/plain"), value);
-        }
-      };
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
new file mode 100644
index 000000000..b10ab34af
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+
+public final class CompletableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void completableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void completableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Void> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
new file mode 100644
index 000000000..02c4778b1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.schedulers.TestScheduler;
+
+public final class CompletableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.completable().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
new file mode 100644
index 000000000..d32d6f6ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import rx.Subscriber;
+
+abstract class ForwardingSubscriber<T> extends Subscriber<T> {
+  private final Subscriber<T> delegate;
+
+  ForwardingSubscriber(Subscriber<T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onNext(T value) {
+    delegate.onNext(value);
+  }
+
+  @Override public void onCompleted() {
+    delegate.onCompleted();
+  }
+
+  @Override public void onError(Throwable throwable) {
+    delegate.onError(throwable);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
new file mode 100644
index 000000000..2e77f06c1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import org.junit.Test;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class HttpExceptionTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    HttpException exception = new HttpException(response);
+    assertThat(exception.code()).isEqualTo(200);
+    assertThat(exception.message()).isEqualTo("OK");
+    assertThat(exception.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      new HttpException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
new file mode 100644
index 000000000..53dcc0770
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue("Hi").assertCompleted();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.body().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.requestMore(1);
+    subscriber.assertAnyValue().assertCompleted();
+
+    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.requestMore(1);
+    subscriber.assertAnyValue().assertCompleted();
+
+    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.requestMore(1);
+    subscriber.assertAnyValue().assertCompleted();
+
+    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
new file mode 100644
index 000000000..3cf00cd7a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.schedulers.TestScheduler;
+
+public final class ObservableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
new file mode 100644
index 000000000..4919ddcd5
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.Notification;
+import rx.Subscriber;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> extends Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onStart() {
+    request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onCompleted() {
+    events.add(Notification.<T>createOnCompleted());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .overridingErrorMessage("Expected onNext event but was %s", notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .overridingErrorMessage("Expected onError event but was %s", notification)
+        .isTrue();
+    return notification.getThrowable();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertCompleted() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnCompleted())
+        .overridingErrorMessage("Expected onCompleted event but was %s", notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public void requestMore(long amount) {
+    request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
similarity index 94%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
index 935a2b9f7..7c62c14ad 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/ResultTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
@@ -13,10 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
 import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.adapter.rxjava.Result;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..674575f74
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import rx.Observable;
+import rx.Single;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class RxJavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJavaCallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
new file mode 100644
index 000000000..dfe336f07
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import rx.plugins.RxJavaPlugins;
+
+/** A JUnit @Rule which resets RxJava's plugins before and after each test. */
+final class RxJavaPluginsResetRule implements TestRule {
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        RxJavaPlugins.getInstance().reset();
+        try {
+          base.evaluate();
+        } finally {
+          RxJavaPlugins.getInstance().reset();
+        }
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
new file mode 100644
index 000000000..c4c35ab45
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertValue("Hi").assertCompleted();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+    subscriber.assertCompleted();
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
new file mode 100644
index 000000000..5188c0ed9
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.schedulers.TestScheduler;
+
+public final class SingleWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().unsafeSubscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertCompleted();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
new file mode 100644
index 000000000..c44038d02
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/README.md b/retrofit-converters/README.md
index 1e440adef..041f7a4b9 100644
--- a/retrofit-converters/README.md
+++ b/retrofit-converters/README.md
@@ -1,14 +1,15 @@
 Retrofit Converters
 ===================
 
-Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
-agnostic. The child modules contained herein are additional converters for other popular formats.
+Retrofit ships with support for OkHttp's `RequestBody` and `ResponseBody` types but the library is
+content-format agnostic. The child modules contained herein are additional converters for other
+popular formats.
 
 To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
 Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.example.com")
-    .converter(new ProtoConverter())
+    .addConverterFactory(GsonConverterFactory.create())
     .build();
 ```
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index 15b9a716f..31f5c1983 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,7 +30,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
similarity index 88%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index 5208314b9..e6c702705 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
@@ -59,12 +61,12 @@ private GsonConverterFactory(Gson gson) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonResponseBodyConverter<>(adapter);
+    return new GsonResponseBodyConverter<>(gson, adapter);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
     return new GsonRequestBodyConverter<>(gson, adapter);
   }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
similarity index 85%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 1d3d6e75a..2e30a4478 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -13,18 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonWriter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.nio.charset.Charset;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
@@ -42,12 +43,8 @@
     Buffer buffer = new Buffer();
     Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
     JsonWriter jsonWriter = gson.newJsonWriter(writer);
-    try {
-      adapter.write(jsonWriter, value);
-      jsonWriter.flush();
-    } catch (IOException e) {
-      throw new AssertionError(e); // Writing to Buffer does no I/O.
-    }
+    adapter.write(jsonWriter, value);
+    jsonWriter.close();
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
similarity index 69%
rename from retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
index f12075d00..bd9509a18 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/GsonResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -13,31 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
+import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
-import com.squareup.okhttp.ResponseBody;
+import com.google.gson.stream.JsonReader;
 import java.io.IOException;
-import java.io.Reader;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final Gson gson;
   private final TypeAdapter<T> adapter;
 
-  GsonResponseBodyConverter(TypeAdapter<T> adapter) {
+  GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
     this.adapter = adapter;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    Reader reader = value.charStream();
+    JsonReader jsonReader = gson.newJsonReader(value.charStream());
     try {
-      return adapter.fromJson(reader);
+      return adapter.read(jsonReader);
     } finally {
-      if (reader != null) {
-        try {
-          reader.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
similarity index 88%
rename from retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java
rename to retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
index 2ea8c3f49..5f584ec85 100644
--- a/retrofit-converters/gson/src/test/java/retrofit2/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.gson;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
@@ -21,13 +21,16 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
@@ -86,6 +89,7 @@
   @Before public void setUp() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .setLenient()
         .create();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -129,4 +133,12 @@
     assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
+
+  @Test public void deserializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
+
+    Response<AnImplementation> response =
+        service.anImplementation(new AnImplementation("value")).execute();
+    assertThat(response.body().getName()).isNull();
+  }
 }
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index cccbce5cf..e6afa44ee 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,7 +30,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
similarity index 87%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index 756790901..4b224bd97 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -13,16 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Jackson.
@@ -54,15 +56,15 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectReader reader = mapper.reader(javaType);
+    ObjectReader reader = mapper.readerFor(javaType);
     return new JacksonResponseBodyConverter<>(reader);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectWriter writer = mapper.writerFor(javaType);
     return new JacksonRequestBodyConverter<>(writer);
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
similarity index 90%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index af46a60fd..bd20a0ae0 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectWriter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
similarity index 77%
rename from retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java
rename to retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
index b22b87406..f51fde7df 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/JacksonResponseBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectReader;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.Reader;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final ObjectReader adapter;
@@ -28,16 +28,10 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    Reader reader = value.charStream();
     try {
-      return adapter.readValue(reader);
+      return adapter.readValue(value.charStream());
     } finally {
-      if (reader != null) {
-        try {
-          reader.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
similarity index 94%
rename from retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java
rename to retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
index e28812e7b..19c18538e 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit2/JacksonConverterFactoryTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.annotation.JsonAutoDetect;
 import com.fasterxml.jackson.core.JsonGenerator;
@@ -26,13 +26,17 @@
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.jackson.JacksonConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
 
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 2ce692676..76cd1aaed 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,12 @@
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
     </dependency>
+    <!-- TODO remove this dependency once Moshi ships with 1.9.0 or newer. -->
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.9.0</version>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -30,7 +36,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java
deleted file mode 100644
index 2f04ab12f..000000000
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiConverterFactory.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.moshi.JsonAdapter;
-import com.squareup.moshi.Moshi;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
- * <p>
- * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
- * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
- * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
- * last to allow the other converters a chance to see their types.
- */
-public final class MoshiConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Moshi} instance for conversion. */
-  public static MoshiConverterFactory create() {
-    return create(new Moshi.Builder().build());
-  }
-
-  /** Create an instance using {@code moshi} for conversion. */
-  public static MoshiConverterFactory create(Moshi moshi) {
-    return new MoshiConverterFactory(moshi);
-  }
-
-  private final Moshi moshi;
-
-  private MoshiConverterFactory(Moshi moshi) {
-    if (moshi == null) throw new NullPointerException("moshi == null");
-    this.moshi = moshi;
-  }
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
-    return new MoshiResponseBodyConverter<>(adapter);
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
-    return new MoshiRequestBodyConverter<>(adapter);
-  }
-}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
new file mode 100644
index 000000000..60e5f1bfd
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.moshi;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonQualifier;
+import com.squareup.moshi.Moshi;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+import static java.util.Collections.unmodifiableSet;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
+ * <p>
+ * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ * <p>
+ * Any {@link JsonQualifier @JsonQualifier}-annotated annotations on the parameter will be used
+ * when looking up a request body converter and those on the method will be used when looking up a
+ * response body converter.
+ */
+public final class MoshiConverterFactory extends Converter.Factory {
+  /** Create an instance using a default {@link Moshi} instance for conversion. */
+  public static MoshiConverterFactory create() {
+    return create(new Moshi.Builder().build());
+  }
+
+  /** Create an instance using {@code moshi} for conversion. */
+  public static MoshiConverterFactory create(Moshi moshi) {
+    if (moshi == null) throw new NullPointerException("moshi == null");
+    return new MoshiConverterFactory(moshi, false, false);
+  }
+
+  private final Moshi moshi;
+  private final boolean lenient;
+  private final boolean serializeNulls;
+
+  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean serializeNulls) {
+    this.moshi = moshi;
+    this.lenient = lenient;
+    this.serializeNulls = serializeNulls;
+  }
+
+  /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
+  public MoshiConverterFactory asLenient() {
+    return new MoshiConverterFactory(moshi, true, serializeNulls);
+  }
+
+  /** Return a new factory which includes null values into the serialized JSON. */
+  public MoshiConverterFactory withNullSerialization() {
+    return new MoshiConverterFactory(moshi, lenient, true);
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(annotations));
+    if (lenient) {
+      adapter = adapter.lenient();
+    }
+    return new MoshiResponseBodyConverter<>(adapter);
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(parameterAnnotations));
+    if (lenient) {
+      adapter = adapter.lenient();
+    }
+    return new MoshiRequestBodyConverter<>(adapter, serializeNulls);
+  }
+
+  private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
+    Set<Annotation> result = null;
+    for (Annotation annotation : annotations) {
+      if (annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+        if (result == null) result = new LinkedHashSet<>();
+        result.add(annotation);
+      }
+    }
+    return result != null ? unmodifiableSet(result) : Collections.<Annotation>emptySet();
+  }
+}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
similarity index 71%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index fae968f69..5e59b17fe 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -13,30 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
+import com.squareup.moshi.JsonWriter;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
+  private final boolean serializeNulls;
 
-  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
+  MoshiRequestBodyConverter(JsonAdapter<T> adapter, boolean serializeNulls) {
     this.adapter = adapter;
+    this.serializeNulls = serializeNulls;
   }
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
-    try {
-      adapter.toJson(buffer, value);
-    } catch (IOException e) {
-      throw new AssertionError(e); // Writing to Buffer does no I/O.
-    }
+    JsonWriter writer = JsonWriter.of(buffer);
+    writer.setSerializeNulls(serializeNulls);
+    adapter.toJson(writer, value);
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
similarity index 69%
rename from retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index 3aa83f0b9..199776ff2 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -13,14 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okhttp3.ResponseBody;
 import okio.BufferedSource;
+import okio.ByteString;
+import retrofit2.Converter;
 
 final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private static final ByteString UTF8_BOM = ByteString.decodeHex("EFBBBF");
+
   private final JsonAdapter<T> adapter;
 
   MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
@@ -30,14 +34,14 @@
   @Override public T convert(ResponseBody value) throws IOException {
     BufferedSource source = value.source();
     try {
+      // Moshi has no document-level API so the responsibility of BOM skipping falls to whatever
+      // is delegating to it. Since it's a UTF-8-only library as well we only honor the UTF-8 BOM.
+      if (source.rangeEquals(0, UTF8_BOM)) {
+        source.skip(UTF8_BOM.size());
+      }
       return adapter.fromJson(source);
     } finally {
-      if (source != null) {
-        try {
-          source.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java
deleted file mode 100644
index 6984e4834..000000000
--- a/retrofit-converters/moshi/src/test/java/retrofit2/MoshiConverterFactoryTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.moshi.FromJson;
-import com.squareup.moshi.JsonReader;
-import com.squareup.moshi.JsonWriter;
-import com.squareup.moshi.Moshi;
-import com.squareup.moshi.ToJson;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.IOException;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.http.Body;
-import retrofit2.http.POST;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class MoshiConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
-
-  static class AnImplementation implements AnInterface {
-    private final String theName;
-
-    AnImplementation(String name) {
-      theName = name;
-    }
-
-    @Override public String getName() {
-      return theName;
-    }
-  }
-
-  static class AnInterfaceAdapter {
-    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
-    }
-
-    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
-
-      String name = null;
-      while (jsonReader.hasNext()) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
-
-      jsonReader.endObject();
-      return new AnImplementation(name);
-    }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Moshi moshi = new Moshi.Builder()
-        .add(new AnInterfaceAdapter())
-        .build();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(MoshiConverterFactory.create(moshi))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-}
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
new file mode 100644
index 000000000..d22c37267
--- /dev/null
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.moshi;
+
+import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonQualifier;
+import com.squareup.moshi.JsonReader;
+import com.squareup.moshi.JsonWriter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.nio.charset.Charset;
+import java.util.Set;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.Body;
+import retrofit2.http.POST;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class MoshiConverterFactoryTest {
+  @Retention(RUNTIME)
+  @JsonQualifier
+  @interface Qualifier {}
+
+  @Retention(RUNTIME)
+  @interface NonQualifer {}
+
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class Adapters {
+    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.hasNext()) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+
+    @ToJson public void write(JsonWriter writer, @Qualifier String value) throws IOException {
+      writer.value("qualified!");
+    }
+
+    @FromJson @Qualifier public String readQualified(JsonReader reader) throws IOException {
+      String string = reader.nextString();
+      if (string.equals("qualified!")) {
+        return "it worked!";
+      }
+      throw new AssertionError("Found: " + string);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+
+    @POST("/") @Qualifier @NonQualifer //
+    Call<String> annotations(@Body @Qualifier @NonQualifer String body);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+  private Service serviceLenient;
+  private Service serviceNulls;
+
+  @Before public void setUp() {
+    Moshi moshi = new Moshi.Builder()
+        .add(new JsonAdapter.Factory() {
+          @Override public JsonAdapter<?> create(Type type, Set<? extends Annotation> annotations,
+              Moshi moshi) {
+            for (Annotation annotation : annotations) {
+              if (!annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+                throw new AssertionError("Non-@JsonQualifier annotation: " + annotation);
+              }
+            }
+            return null;
+          }
+        })
+        .add(new Adapters())
+        .build();
+    MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
+    MoshiConverterFactory factoryLenient = factory.asLenient();
+    MoshiConverterFactory factoryNulls = factory.withNullSerialization();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factory)
+        .build();
+    Retrofit retrofitLenient = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryLenient)
+        .build();
+    Retrofit retrofitNulls = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryNulls)
+        .build();
+    service = retrofit.create(Service.class);
+    serviceLenient = retrofitLenient.create(Service.class);
+    serviceNulls = retrofitNulls.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void annotations() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("\"qualified!\""));
+
+    Call<String> call = service.annotations("value");
+    Response<String> response = call.execute();
+    assertThat(response.body()).isEqualTo("it worked!");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("\"qualified!\"");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void asLenient() throws IOException, InterruptedException {
+    MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
+    server.enqueue(malformedResponse);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertEquals(e.getMessage(),
+          "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+    }
+
+    Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call2.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+  }
+
+  @Test public void withNulls() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    Call<AnImplementation> call = serviceNulls.anImplementation(new AnImplementation(null));
+    call.execute();
+    assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Test public void utf8BomSkipped() throws IOException {
+    Buffer responseBody = new Buffer()
+        .write(ByteString.decodeHex("EFBBBF"))
+        .writeUtf8("{\"theName\":\"value\"}");
+    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+  }
+
+  @Test public void nonUtf8BomIsNotSkipped() throws IOException {
+    Buffer responseBody = new Buffer()
+        .write(ByteString.decodeHex("FEFF"))
+        .writeString("{\"theName\":\"value\"}", Charset.forName("UTF-16"));
+    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+    server.enqueue(malformedResponse);
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+}
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 64adb3892..3fbbbf17b 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 5d2c876b7..761238f28 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,7 +30,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
similarity index 52%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index 1a5e2bad1..ec2aac452 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -13,15 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
@@ -31,7 +36,18 @@
  */
 public final class ProtoConverterFactory extends Converter.Factory {
   public static ProtoConverterFactory create() {
-    return new ProtoConverterFactory();
+    return new ProtoConverterFactory(null);
+  }
+
+  /** Create an instance which uses {@code registry} when deserializing. */
+  public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
+    return new ProtoConverterFactory(registry);
+  }
+
+  private final ExtensionRegistryLite registry;
+
+  private ProtoConverterFactory(ExtensionRegistryLite registry) {
+    this.registry = registry;
   }
 
   @Override
@@ -47,19 +63,29 @@ public static ProtoConverterFactory create() {
 
     Parser<MessageLite> parser;
     try {
-      Field field = c.getDeclaredField("PARSER");
+      Method method = c.getDeclaredMethod("parser");
       //noinspection unchecked
-      parser = (Parser<MessageLite>) field.get(null);
-    } catch (NoSuchFieldException | IllegalAccessException e) {
-      throw new IllegalArgumentException(
-          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
+      parser = (Parser<MessageLite>) method.invoke(null);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    } catch (NoSuchMethodException | IllegalAccessException ignored) {
+      // If the method is missing, fall back to original static field for pre-3.0 support.
+      try {
+        Field field = c.getDeclaredField("PARSER");
+        //noinspection unchecked
+        parser = (Parser<MessageLite>) field.get(null);
+      } catch (NoSuchFieldException | IllegalAccessException e) {
+        throw new IllegalArgumentException("Found a protobuf message but "
+            + c.getName()
+            + " had no parser() method or PARSER field.");
+      }
     }
-    return new ProtoResponseBodyConverter<>(parser);
+    return new ProtoResponseBodyConverter<>(parser, registry);
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
similarity index 89%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 4dc0c42cb..814dc326b 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
 import com.google.protobuf.MessageLite;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
similarity index 75%
rename from retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index 3e37f1f63..324199458 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -13,36 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
     implements Converter<ResponseBody, T> {
   private final Parser<T> parser;
+  private final ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser) {
+  ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
     this.parser = parser;
+    this.registry = registry;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    InputStream is = value.byteStream();
     try {
-      return parser.parseFrom(is);
+      return parser.parseFrom(value.byteStream(), registry);
     } catch (InvalidProtocolBufferException e) {
       throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
-      if (is != null) {
-        try {
-          is.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java
deleted file mode 100644
index e75ba0979..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/PhoneProtos.java
+++ /dev/null
@@ -1,523 +0,0 @@
-// Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: protos/phone.proto
-
-package retrofit2;
-
-import com.google.protobuf.AbstractMessage;
-
-public final class PhoneProtos {
-  private PhoneProtos() {}
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistry registry) {
-  }
-  public interface PhoneOrBuilder
-      extends com.google.protobuf.MessageOrBuilder {
-
-    // optional string number = 1;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    boolean hasNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    java.lang.String getNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    com.google.protobuf.ByteString
-        getNumberBytes();
-  }
-  /**
-   * Protobuf type {@code retrofit2.Phone}
-   */
-  public static final class Phone extends
-      com.google.protobuf.GeneratedMessage
-      implements PhoneOrBuilder {
-    // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
-      super(builder);
-      this.unknownFields = builder.getUnknownFields();
-    }
-    private Phone(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
-
-    private static final Phone defaultInstance;
-    public static Phone getDefaultInstance() {
-      return defaultInstance;
-    }
-
-    public Phone getDefaultInstanceForType() {
-      return defaultInstance;
-    }
-
-    private final com.google.protobuf.UnknownFieldSet unknownFields;
-    @java.lang.Override
-    public final com.google.protobuf.UnknownFieldSet
-        getUnknownFields() {
-      return this.unknownFields;
-    }
-    private Phone(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      initFields();
-      int mutable_bitField0_ = 0;
-      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
-          com.google.protobuf.UnknownFieldSet.newBuilder();
-      try {
-        boolean done = false;
-        while (!done) {
-          int tag = input.readTag();
-          switch (tag) {
-            case 0:
-              done = true;
-              break;
-            default: {
-              if (!parseUnknownField(input, unknownFields,
-                                     extensionRegistry, tag)) {
-                done = true;
-              }
-              break;
-            }
-            case 10: {
-              bitField0_ |= 0x00000001;
-              number_ = input.readBytes();
-              break;
-            }
-          }
-        }
-      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-        throw e.setUnfinishedMessage(this);
-      } catch (java.io.IOException e) {
-        throw new com.google.protobuf.InvalidProtocolBufferException(
-            e.getMessage()).setUnfinishedMessage(this);
-      } finally {
-        this.unknownFields = unknownFields.build();
-        makeExtensionsImmutable();
-      }
-    }
-    public static final com.google.protobuf.Descriptors.Descriptor
-        getDescriptor() {
-      return PhoneProtos.internal_static_retrofit_Phone_descriptor;
-    }
-
-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-        internalGetFieldAccessorTable() {
-      return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
-          .ensureFieldAccessorsInitialized(
-              PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
-    }
-
-    public static com.google.protobuf.Parser<Phone> PARSER =
-        new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-        return new Phone(input, extensionRegistry);
-      }
-    };
-
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
-    }
-
-    private int bitField0_;
-    // optional string number = 1;
-    public static final int NUMBER_FIELD_NUMBER = 1;
-    private java.lang.Object number_;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public boolean hasNumber() {
-      return ((bitField0_ & 0x00000001) == 0x00000001);
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public java.lang.String getNumber() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        return (java.lang.String) ref;
-      } else {
-        com.google.protobuf.ByteString bs =
-            (com.google.protobuf.ByteString) ref;
-        java.lang.String s = bs.toStringUtf8();
-        if (bs.isValidUtf8()) {
-          number_ = s;
-        }
-        return s;
-      }
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public com.google.protobuf.ByteString
-        getNumberBytes() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b =
-            com.google.protobuf.ByteString.copyFromUtf8(
-                (java.lang.String) ref);
-        number_ = b;
-        return b;
-      } else {
-        return (com.google.protobuf.ByteString) ref;
-      }
-    }
-
-    private void initFields() {
-      number_ = "";
-    }
-    private byte memoizedIsInitialized = -1;
-    public final boolean isInitialized() {
-      byte isInitialized = memoizedIsInitialized;
-      if (isInitialized != -1) return isInitialized == 1;
-
-      memoizedIsInitialized = 1;
-      return true;
-    }
-
-    public void writeTo(com.google.protobuf.CodedOutputStream output)
-                        throws java.io.IOException {
-      getSerializedSize();
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        output.writeBytes(1, getNumberBytes());
-      }
-      getUnknownFields().writeTo(output);
-    }
-
-    private int memoizedSerializedSize = -1;
-    public int getSerializedSize() {
-      int size = memoizedSerializedSize;
-      if (size != -1) return size;
-
-      size = 0;
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.CodedOutputStream
-          .computeBytesSize(1, getNumberBytes());
-      }
-      size += getUnknownFields().getSerializedSize();
-      memoizedSerializedSize = size;
-      return size;
-    }
-
-    private static final long serialVersionUID = 0L;
-    @java.lang.Override
-    protected java.lang.Object writeReplace()
-        throws java.io.ObjectStreamException {
-      return super.writeReplace();
-    }
-
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseFrom(byte[] data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        byte[] data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input);
-    }
-    public static PhoneProtos.Phone parseDelimitedFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input, extensionRegistry);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input);
-    }
-    public static PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
-    }
-
-    public static Builder newBuilder() { return Builder.create(); }
-    public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(PhoneProtos.Phone prototype) {
-      return newBuilder().mergeFrom(prototype);
-    }
-    public Builder toBuilder() { return newBuilder(this); }
-
-    @java.lang.Override
-    protected Builder newBuilderForType(
-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-      Builder builder = new Builder(parent);
-      return builder;
-    }
-    /**
-     * Protobuf type {@code retrofit2.Phone}
-     */
-    public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements PhoneProtos.PhoneOrBuilder {
-      public static final com.google.protobuf.Descriptors.Descriptor
-          getDescriptor() {
-        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
-      }
-
-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-          internalGetFieldAccessorTable() {
-        return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
-            .ensureFieldAccessorsInitialized(
-                PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
-      }
-
-      // Construct using retrofit2.PhoneProtos.Phone.newBuilder()
-      private Builder() {
-        maybeForceBuilderInitialization();
-      }
-
-      private Builder(
-          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-        super(parent);
-        maybeForceBuilderInitialization();
-      }
-      private void maybeForceBuilderInitialization() {
-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-        }
-      }
-      private static Builder create() {
-        return new Builder();
-      }
-
-      public Builder clear() {
-        super.clear();
-        number_ = "";
-        bitField0_ = (bitField0_ & ~0x00000001);
-        return this;
-      }
-
-      public Builder clone() {
-        return create().mergeFrom(buildPartial());
-      }
-
-      public com.google.protobuf.Descriptors.Descriptor
-          getDescriptorForType() {
-        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
-      }
-
-      public PhoneProtos.Phone getDefaultInstanceForType() {
-        return PhoneProtos.Phone.getDefaultInstance();
-      }
-
-      public PhoneProtos.Phone build() {
-        PhoneProtos.Phone result = buildPartial();
-        if (!result.isInitialized()) {
-          throw AbstractMessage.Builder.newUninitializedMessageException(result);
-        }
-        return result;
-      }
-
-      public PhoneProtos.Phone buildPartial() {
-        PhoneProtos.Phone result = new PhoneProtos.Phone(this);
-        int from_bitField0_ = bitField0_;
-        int to_bitField0_ = 0;
-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
-          to_bitField0_ |= 0x00000001;
-        }
-        result.number_ = number_;
-        result.bitField0_ = to_bitField0_;
-        onBuilt();
-        return result;
-      }
-
-      public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof PhoneProtos.Phone) {
-          return mergeFrom((PhoneProtos.Phone)other);
-        } else {
-          super.mergeFrom(other);
-          return this;
-        }
-      }
-
-      public Builder mergeFrom(PhoneProtos.Phone other) {
-        if (other == PhoneProtos.Phone.getDefaultInstance()) return this;
-        if (other.hasNumber()) {
-          bitField0_ |= 0x00000001;
-          number_ = other.number_;
-          onChanged();
-        }
-        this.mergeUnknownFields(other.getUnknownFields());
-        return this;
-      }
-
-      public final boolean isInitialized() {
-        return true;
-      }
-
-      public Builder mergeFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws java.io.IOException {
-        PhoneProtos.Phone parsedMessage = null;
-        try {
-          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
-        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e;
-        } finally {
-          if (parsedMessage != null) {
-            mergeFrom(parsedMessage);
-          }
-        }
-        return this;
-      }
-      private int bitField0_;
-
-      // optional string number = 1;
-      private java.lang.Object number_ = "";
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public boolean hasNumber() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public java.lang.String getNumber() {
-        java.lang.Object ref = number_;
-        if (!(ref instanceof java.lang.String)) {
-          java.lang.String s = ((com.google.protobuf.ByteString) ref)
-              .toStringUtf8();
-          number_ = s;
-          return s;
-        } else {
-          return (java.lang.String) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public com.google.protobuf.ByteString
-          getNumberBytes() {
-        java.lang.Object ref = number_;
-        if (ref instanceof String) {
-          com.google.protobuf.ByteString b =
-              com.google.protobuf.ByteString.copyFromUtf8(
-                  (java.lang.String) ref);
-          number_ = b;
-          return b;
-        } else {
-          return (com.google.protobuf.ByteString) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumber(
-          java.lang.String value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder clearNumber() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        number_ = getDefaultInstance().getNumber();
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumberBytes(
-          com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-
-      // @@protoc_insertion_point(builder_scope:retrofit2.Phone)
-    }
-
-    static {
-      defaultInstance = new Phone(true);
-      defaultInstance.initFields();
-    }
-
-    // @@protoc_insertion_point(class_scope:retrofit2.Phone)
-  }
-
-  private static com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit_Phone_descriptor;
-  private static
-    com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit_Phone_fieldAccessorTable;
-
-  public static com.google.protobuf.Descriptors.FileDescriptor
-      getDescriptor() {
-    return descriptor;
-  }
-  private static com.google.protobuf.Descriptors.FileDescriptor
-      descriptor;
-  static {
-    java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\010retrofit\"\027\n\005Phone\022" +
-      "\016\n\006number\030\001 \001(\tB!\n\022retrofit.converterB\013P" +
-      "honeProtos"
-    };
-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
-        public com.google.protobuf.ExtensionRegistry assignDescriptors(
-            com.google.protobuf.Descriptors.FileDescriptor root) {
-          descriptor = root;
-          internal_static_retrofit_Phone_descriptor =
-            getDescriptor().getMessageTypes().get(0);
-          internal_static_retrofit_Phone_fieldAccessorTable = new
-            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-              internal_static_retrofit_Phone_descriptor,
-              new java.lang.String[] { "Number", });
-          return null;
-        }
-      };
-    com.google.protobuf.Descriptors.FileDescriptor
-      .internalBuildGeneratedFileFrom(descriptorData,
-        new com.google.protobuf.Descriptors.FileDescriptor[] {
-        }, assigner);
-  }
-
-  // @@protoc_insertion_point(outer_class_scope)
-}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
new file mode 100644
index 000000000..b37ab55bc
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.protobuf;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import java.lang.annotation.Annotation;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.protobuf.PhoneProtos.Phone;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FallbackParserFinderTest {
+  @Test public void converterFactoryFallsBackToParserField() {
+    Retrofit retrofit = new Retrofit.Builder().baseUrl("http://localhost/").build();
+    ProtoConverterFactory factory = ProtoConverterFactory.create();
+    Converter<ResponseBody, ?> converter =
+        factory.responseBodyConverter(FakePhone.class, new Annotation[0], retrofit);
+    assertThat(converter).isNotNull();
+  }
+
+  @SuppressWarnings("unused") // Used reflectively.
+  public static abstract class FakePhone implements MessageLite {
+    public static final Parser<Phone> PARSER = Phone.parser();
+  }
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
new file mode 100644
index 000000000..3ad1bb0f6
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
@@ -0,0 +1,656 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: protos/phone.proto
+
+package retrofit2.converter.protobuf;
+
+public final class PhoneProtos {
+  private PhoneProtos() {}
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistryLite registry) {
+    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
+  }
+
+  public static void registerAllExtensions(
+      com.google.protobuf.ExtensionRegistry registry) {
+    registerAllExtensions(
+        (com.google.protobuf.ExtensionRegistryLite) registry);
+  }
+  public interface PhoneOrBuilder extends
+      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
+      com.google.protobuf.GeneratedMessage.
+          ExtendableMessageOrBuilder<Phone> {
+
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    boolean hasNumber();
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    java.lang.String getNumber();
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    com.google.protobuf.ByteString
+        getNumberBytes();
+  }
+  /**
+   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+   */
+  public  static final class Phone extends
+      com.google.protobuf.GeneratedMessage.ExtendableMessage<
+        Phone> implements
+      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
+      PhoneOrBuilder {
+    // Use Phone.newBuilder() to construct.
+    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
+      super(builder);
+    }
+    private Phone() {
+      number_ = "";
+    }
+
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+    getUnknownFields() {
+      return this.unknownFields;
+    }
+    private Phone(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      this();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 10: {
+              com.google.protobuf.ByteString bs = input.readBytes();
+              bitField0_ |= 0x00000001;
+              number_ = bs;
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e).setUnfinishedMessage(this);
+      } finally {
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+    }
+
+    private int bitField0_;
+    public static final int NUMBER_FIELD_NUMBER = 1;
+    private volatile java.lang.Object number_;
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    public boolean hasNumber() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    public java.lang.String getNumber() {
+      java.lang.Object ref = number_;
+      if (ref instanceof java.lang.String) {
+        return (java.lang.String) ref;
+      } else {
+        com.google.protobuf.ByteString bs = 
+            (com.google.protobuf.ByteString) ref;
+        java.lang.String s = bs.toStringUtf8();
+        if (bs.isValidUtf8()) {
+          number_ = s;
+        }
+        return s;
+      }
+    }
+    /**
+     * <code>optional string number = 1;</code>
+     */
+    public com.google.protobuf.ByteString
+        getNumberBytes() {
+      java.lang.Object ref = number_;
+      if (ref instanceof java.lang.String) {
+        com.google.protobuf.ByteString b = 
+            com.google.protobuf.ByteString.copyFromUtf8(
+                (java.lang.String) ref);
+        number_ = b;
+        return b;
+      } else {
+        return (com.google.protobuf.ByteString) ref;
+      }
+    }
+
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized == 1) return true;
+      if (isInitialized == 0) return false;
+
+      if (!extensionsAreInitialized()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      com.google.protobuf.GeneratedMessage
+        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
+          extensionWriter = newExtensionWriter();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
+      }
+      extensionWriter.writeUntil(3, output);
+      unknownFields.writeTo(output);
+    }
+
+    public int getSerializedSize() {
+      int size = memoizedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
+      }
+      size += extensionsSerializedSize();
+      size += unknownFields.getSerializedSize();
+      memoizedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    public boolean equals(final java.lang.Object obj) {
+      if (obj == this) {
+       return true;
+      }
+      if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
+        return super.equals(obj);
+      }
+      retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
+
+      boolean result = true;
+      result = result && (hasNumber() == other.hasNumber());
+      if (hasNumber()) {
+        result = result && getNumber()
+            .equals(other.getNumber());
+      }
+      result = result && unknownFields.equals(other.unknownFields);
+      result = result &&
+          getExtensionFields().equals(other.getExtensionFields());
+      return result;
+    }
+
+    @java.lang.Override
+    public int hashCode() {
+      if (memoizedHashCode != 0) {
+        return memoizedHashCode;
+      }
+      int hash = 41;
+      hash = (19 * hash) + getDescriptorForType().hashCode();
+      if (hasNumber()) {
+        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
+        hash = (53 * hash) + getNumber().hashCode();
+      }
+      hash = hashFields(hash, getExtensionFields());
+      hash = (29 * hash) + unknownFields.hashCode();
+      memoizedHashCode = hash;
+      return hash;
+    }
+
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseDelimitedWithIOException(PARSER, input);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input);
+    }
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return com.google.protobuf.GeneratedMessage
+          .parseWithIOException(PARSER, input, extensionRegistry);
+    }
+
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder() {
+      return DEFAULT_INSTANCE.toBuilder();
+    }
+    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
+      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() {
+      return this == DEFAULT_INSTANCE
+          ? new Builder() : new Builder().mergeFrom(this);
+    }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
+          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
+        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
+        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+      }
+
+      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+        }
+      }
+      public Builder clear() {
+        super.clear();
+        number_ = "";
+        bitField0_ = (bitField0_ & ~0x00000001);
+        return this;
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+      }
+
+      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
+      }
+
+      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
+        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
+        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        result.number_ = number_;
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder clone() {
+        return (Builder) super.clone();
+      }
+      public Builder setField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          Object value) {
+        return (Builder) super.setField(field, value);
+      }
+      public Builder clearField(
+          com.google.protobuf.Descriptors.FieldDescriptor field) {
+        return (Builder) super.clearField(field);
+      }
+      public Builder clearOneof(
+          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+        return (Builder) super.clearOneof(oneof);
+      }
+      public Builder setRepeatedField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          int index, Object value) {
+        return (Builder) super.setRepeatedField(field, index, value);
+      }
+      public Builder addRepeatedField(
+          com.google.protobuf.Descriptors.FieldDescriptor field,
+          Object value) {
+        return (Builder) super.addRepeatedField(field, value);
+      }
+      public <Type> Builder setExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
+          Type value) {
+        return (Builder) super.setExtension(extension, value);
+      }
+      public <Type> Builder setExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+          int index, Type value) {
+        return (Builder) super.setExtension(extension, index, value);
+      }
+      public <Type> Builder addExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+          Type value) {
+        return (Builder) super.addExtension(extension, value);
+      }
+      public <Type> Builder clearExtension(
+          com.google.protobuf.GeneratedMessage.GeneratedExtension<
+              retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
+        return (Builder) super.clearExtension(extension);
+      }
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
+          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
+        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
+        if (other.hasNumber()) {
+          bitField0_ |= 0x00000001;
+          number_ = other.number_;
+          onChanged();
+        }
+        this.mergeExtensionFields(other);
+        this.mergeUnknownFields(other.unknownFields);
+        onChanged();
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        if (!extensionsAreInitialized()) {
+          return false;
+        }
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
+          throw e.unwrapIOException();
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      private java.lang.Object number_ = "";
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public boolean hasNumber() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public java.lang.String getNumber() {
+        java.lang.Object ref = number_;
+        if (!(ref instanceof java.lang.String)) {
+          com.google.protobuf.ByteString bs =
+              (com.google.protobuf.ByteString) ref;
+          java.lang.String s = bs.toStringUtf8();
+          if (bs.isValidUtf8()) {
+            number_ = s;
+          }
+          return s;
+        } else {
+          return (java.lang.String) ref;
+        }
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public com.google.protobuf.ByteString
+          getNumberBytes() {
+        java.lang.Object ref = number_;
+        if (ref instanceof String) {
+          com.google.protobuf.ByteString b = 
+              com.google.protobuf.ByteString.copyFromUtf8(
+                  (java.lang.String) ref);
+          number_ = b;
+          return b;
+        } else {
+          return (com.google.protobuf.ByteString) ref;
+        }
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public Builder setNumber(
+          java.lang.String value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000001;
+        number_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public Builder clearNumber() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        number_ = getDefaultInstance().getNumber();
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional string number = 1;</code>
+       */
+      public Builder setNumberBytes(
+          com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000001;
+        number_ = value;
+        onChanged();
+        return this;
+      }
+      public final Builder setUnknownFields(
+          final com.google.protobuf.UnknownFieldSet unknownFields) {
+        return super.setUnknownFields(unknownFields);
+      }
+
+      public final Builder mergeUnknownFields(
+          final com.google.protobuf.UnknownFieldSet unknownFields) {
+        return super.mergeUnknownFields(unknownFields);
+      }
+
+
+      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
+    }
+
+    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
+    private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
+    static {
+      DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
+    }
+
+    public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
+      return DEFAULT_INSTANCE;
+    }
+
+    @java.lang.Deprecated public static final com.google.protobuf.Parser<Phone>
+        PARSER = new com.google.protobuf.AbstractParser<Phone>() {
+      public Phone parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+          return new Phone(input, extensionRegistry);
+      }
+    };
+
+    public static com.google.protobuf.Parser<Phone> parser() {
+      return PARSER;
+    }
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<Phone> getParserForType() {
+      return PARSER;
+    }
+
+    public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+      return DEFAULT_INSTANCE;
+    }
+
+  }
+
+  public static final int VOICEMAIL_FIELD_NUMBER = 2;
+  /**
+   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
+   */
+  public static final
+    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+      retrofit2.converter.protobuf.PhoneProtos.Phone,
+      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
+          .newFileScopedGeneratedExtension(
+        java.lang.Boolean.class,
+        null);
+  private static final com.google.protobuf.Descriptors.Descriptor
+    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+  private static final 
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
+
+  public static com.google.protobuf.Descriptors.FileDescriptor
+      getDescriptor() {
+    return descriptor;
+  }
+  private static  com.google.protobuf.Descriptors.FileDescriptor
+      descriptor;
+  static {
+    java.lang.String[] descriptorData = {
+      "\n\022protos/phone.proto\022\034retrofit2.converte" +
+      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
+      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
+      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
+      ".protobufB\013PhoneProtos"
+    };
+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
+        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
+          public com.google.protobuf.ExtensionRegistry assignDescriptors(
+              com.google.protobuf.Descriptors.FileDescriptor root) {
+            descriptor = root;
+            return null;
+          }
+        };
+    com.google.protobuf.Descriptors.FileDescriptor
+      .internalBuildGeneratedFileFrom(descriptorData,
+        new com.google.protobuf.Descriptors.FileDescriptor[] {
+        }, assigner);
+    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
+      getDescriptor().getMessageTypes().get(0);
+    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
+      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
+        new java.lang.String[] { "Number", });
+    voicemail.internalInit(descriptor.getExtensions().get(0));
+  }
+
+  // @@protoc_insertion_point(outer_class_scope)
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
similarity index 63%
rename from retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java
rename to retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 421899b20..5a585b21f 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -13,26 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.protobuf;
 
+import com.google.protobuf.ExtensionRegistry;
 import com.google.protobuf.InvalidProtocolBufferException;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static retrofit2.PhoneProtos.Phone;
+import static retrofit2.converter.protobuf.PhoneProtos.Phone;
 
 public final class ProtoConverterFactoryTest {
   interface Service {
@@ -41,10 +45,14 @@
     @GET("/") Call<String> wrongClass();
     @GET("/") Call<List<String>> wrongType();
   }
+  interface ServiceWithRegistry {
+    @GET("/") Call<Phone> get();
+  }
 
   @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
+  private ServiceWithRegistry serviceWithRegistry;
 
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
@@ -52,6 +60,14 @@
         .addConverterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
+
+    ExtensionRegistry registry = ExtensionRegistry.newInstance();
+    PhoneProtos.registerAllExtensions(registry);
+    Retrofit retrofitWithRegistry = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
+        .build();
+    serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
   }
 
   @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
@@ -77,6 +93,17 @@
     assertThat(body.hasNumber()).isFalse();
   }
 
+  @Test public void deserializeUsesRegistry() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = serviceWithRegistry.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+    assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
+  }
+
   @Test public void deserializeWrongClass() throws IOException {
     ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
     server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
@@ -85,12 +112,14 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ProtoConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
     }
   }
 
@@ -102,12 +131,14 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for java.util.List<java.lang.String>\n"
           + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ProtoConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 00fb8e133..02e4b9268 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,8 +1,14 @@
-package retrofit2;
+package retrofit2.converter.protobuf;
 
-option java_package = "retrofit2";
+option java_package = "retrofit2.converter.protobuf";
 option java_outer_classname = "PhoneProtos";
 
 message Phone {
   optional string number = 1;
+
+  extensions 2;
+}
+
+extend Phone {
+  optional bool voicemail = 2;
 }
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index f7fefc015..52ce81b6a 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -26,7 +26,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java
deleted file mode 100644
index 24f7e201b..000000000
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarsConverterFactory.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.RequestBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A {@linkplain Converter.Factory converter} for strings and both primitives and their boxed types
- * to {@code text/plain} bodies.
- */
-public final class ScalarsConverterFactory extends Converter.Factory {
-  public static ScalarsConverterFactory create() {
-    return new ScalarsConverterFactory();
-  }
-
-  private ScalarsConverterFactory() {
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class
-        || type == boolean.class
-        || type == Boolean.class
-        || type == byte.class
-        || type == Byte.class
-        || type == char.class
-        || type == Character.class
-        || type == double.class
-        || type == Double.class
-        || type == float.class
-        || type == Float.class
-        || type == int.class
-        || type == Integer.class
-        || type == long.class
-        || type == Long.class
-        || type == short.class
-        || type == Short.class) {
-      return ScalarRequestBodyConverter.INSTANCE;
-    }
-    return null;
-  }
-}
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
similarity index 90%
rename from retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java
rename to retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index 133e5fd54..fd65200d4 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import retrofit2.Converter;
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
   static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
new file mode 100644
index 000000000..a91d87c82
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class ScalarResponseBodyConverters {
+  private ScalarResponseBodyConverters() {
+  }
+
+  static final class StringResponseBodyConverter implements Converter<ResponseBody, String> {
+    static final StringResponseBodyConverter INSTANCE = new StringResponseBodyConverter();
+
+    @Override public String convert(ResponseBody value) throws IOException {
+      return value.string();
+    }
+  }
+
+  static final class BooleanResponseBodyConverter implements Converter<ResponseBody, Boolean> {
+    static final BooleanResponseBodyConverter INSTANCE = new BooleanResponseBodyConverter();
+
+    @Override public Boolean convert(ResponseBody value) throws IOException {
+      return Boolean.valueOf(value.string());
+    }
+  }
+
+  static final class ByteResponseBodyConverter implements Converter<ResponseBody, Byte> {
+    static final ByteResponseBodyConverter INSTANCE = new ByteResponseBodyConverter();
+
+    @Override public Byte convert(ResponseBody value) throws IOException {
+      return Byte.valueOf(value.string());
+    }
+  }
+
+  static final class CharacterResponseBodyConverter implements Converter<ResponseBody, Character> {
+    static final CharacterResponseBodyConverter INSTANCE = new CharacterResponseBodyConverter();
+
+    @Override public Character convert(ResponseBody value) throws IOException {
+      String body = value.string();
+      if (body.length() != 1) {
+        throw new IOException(
+            "Expected body of length 1 for Character conversion but was " + body.length());
+      }
+      return body.charAt(0);
+    }
+  }
+
+  static final class DoubleResponseBodyConverter implements Converter<ResponseBody, Double> {
+    static final DoubleResponseBodyConverter INSTANCE = new DoubleResponseBodyConverter();
+
+    @Override public Double convert(ResponseBody value) throws IOException {
+      return Double.valueOf(value.string());
+    }
+  }
+
+  static final class FloatResponseBodyConverter implements Converter<ResponseBody, Float> {
+    static final FloatResponseBodyConverter INSTANCE = new FloatResponseBodyConverter();
+
+    @Override public Float convert(ResponseBody value) throws IOException {
+      return Float.valueOf(value.string());
+    }
+  }
+
+  static final class IntegerResponseBodyConverter implements Converter<ResponseBody, Integer> {
+    static final IntegerResponseBodyConverter INSTANCE = new IntegerResponseBodyConverter();
+
+    @Override public Integer convert(ResponseBody value) throws IOException {
+      return Integer.valueOf(value.string());
+    }
+  }
+
+  static final class LongResponseBodyConverter implements Converter<ResponseBody, Long> {
+    static final LongResponseBodyConverter INSTANCE = new LongResponseBodyConverter();
+
+    @Override public Long convert(ResponseBody value) throws IOException {
+      return Long.valueOf(value.string());
+    }
+  }
+
+  static final class ShortResponseBodyConverter implements Converter<ResponseBody, Short> {
+    static final ShortResponseBodyConverter INSTANCE = new ShortResponseBodyConverter();
+
+    @Override public Short convert(ResponseBody value) throws IOException {
+      return Short.valueOf(value.string());
+    }
+  }
+}
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
new file mode 100644
index 000000000..5bf838fe9
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.BooleanResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.ByteResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.CharacterResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.DoubleResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.FloatResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.IntegerResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.LongResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.ShortResponseBodyConverter;
+import retrofit2.converter.scalars.ScalarResponseBodyConverters.StringResponseBodyConverter;
+
+/**
+ * A {@linkplain Converter.Factory converter} for strings and both primitives and their boxed types
+ * to {@code text/plain} bodies.
+ */
+public final class ScalarsConverterFactory extends Converter.Factory {
+  public static ScalarsConverterFactory create() {
+    return new ScalarsConverterFactory();
+  }
+
+  private ScalarsConverterFactory() {
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (type == String.class
+        || type == boolean.class
+        || type == Boolean.class
+        || type == byte.class
+        || type == Byte.class
+        || type == char.class
+        || type == Character.class
+        || type == double.class
+        || type == Double.class
+        || type == float.class
+        || type == Float.class
+        || type == int.class
+        || type == Integer.class
+        || type == long.class
+        || type == Long.class
+        || type == short.class
+        || type == Short.class) {
+      return ScalarRequestBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (type == String.class) {
+      return StringResponseBodyConverter.INSTANCE;
+    }
+    if (type == Boolean.class || type == boolean.class) {
+      return BooleanResponseBodyConverter.INSTANCE;
+    }
+    if (type == Byte.class || type == byte.class) {
+      return ByteResponseBodyConverter.INSTANCE;
+    }
+    if (type == Character.class || type == char.class) {
+      return CharacterResponseBodyConverter.INSTANCE;
+    }
+    if (type == Double.class || type == double.class) {
+      return DoubleResponseBodyConverter.INSTANCE;
+    }
+    if (type == Float.class || type == float.class) {
+      return FloatResponseBodyConverter.INSTANCE;
+    }
+    if (type == Integer.class || type == int.class) {
+      return IntegerResponseBodyConverter.INSTANCE;
+    }
+    if (type == Long.class || type == long.class) {
+      return LongResponseBodyConverter.INSTANCE;
+    }
+    if (type == Short.class || type == short.class) {
+      return ShortResponseBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+}
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
similarity index 66%
rename from retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java
rename to retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index 31880a9d2..cc19d4fbc 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -13,17 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.scalars;
 
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.scalars.ScalarsConverterFactory;
 import retrofit2.http.Body;
+import retrofit2.http.GET;
 import retrofit2.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -50,6 +55,18 @@
       @POST("/") Call<ResponseBody> longObject(@Body Long body);
       @POST("/") Call<ResponseBody> shortPrimitive(@Body short body);
       @POST("/") Call<ResponseBody> shortObject(@Body Short body);
+
+      @GET("/") Call<Object> object();
+
+      @GET("/") Call<String> stringObject();
+      @GET("/") Call<Boolean> booleanObject();
+      @GET("/") Call<Byte> byteObject();
+      @GET("/") Call<Character> charObject();
+      @GET("/") Call<Double> doubleObject();
+      @GET("/") Call<Float> floatObject();
+      @GET("/") Call<Integer> integerObject();
+      @GET("/") Call<Long> longObject();
+      @GET("/") Call<Short> shortObject();
   }
 
   @Rule public final MockWebServer server = new MockWebServer();
@@ -64,22 +81,23 @@
     service = retrofit.create(Service.class);
   }
 
-  @Test public void unsupportedTypesNotMatched() {
+  @Test public void unsupportedRequestTypesNotMatched() {
     try {
       service.object(null);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
-              + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate RequestBody converter for class java.lang.Object. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.ScalarsConverterFactory");
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
+          + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.Object.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
     }
   }
 
-  @Test public void supportedTypes() throws IOException, InterruptedException {
+  @Test public void supportedRequestTypes() throws IOException, InterruptedException {
     RecordedRequest request;
 
     server.enqueue(new MockResponse());
@@ -201,4 +219,72 @@
     assertThat(request.getHeader("Content-Length")).isEqualTo("2");
     assertThat(request.getBody().readUtf8()).isEqualTo("11");
   }
+
+  @Test public void unsupportedResponseTypesNotMatched() {
+    try {
+      service.object();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.Object\n"
+          + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.Object.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+    }
+  }
+
+  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("test"));
+    Response<String> stringResponse = service.stringObject().execute();
+    assertThat(stringResponse.body()).isEqualTo("test");
+
+    server.enqueue(new MockResponse().setBody("true"));
+    Response<Boolean> booleanResponse = service.booleanObject().execute();
+    assertThat(booleanResponse.body()).isTrue();
+
+    server.enqueue(new MockResponse().setBody("5"));
+    Response<Byte> byteResponse = service.byteObject().execute();
+    assertThat(byteResponse.body()).isEqualTo((byte) 5);
+
+    server.enqueue(new MockResponse().setBody("b"));
+    Response<Character> characterResponse = service.charObject().execute();
+    assertThat(characterResponse.body()).isEqualTo('b');
+
+    server.enqueue(new MockResponse().setBody(""));
+    try {
+      service.charObject().execute();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+    }
+
+    server.enqueue(new MockResponse().setBody("bb"));
+    try {
+      service.charObject().execute();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    }
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    Response<Double> doubleResponse = service.doubleObject().execute();
+    assertThat(doubleResponse.body()).isEqualTo(13.13);
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    Response<Float> floatResponse = service.floatObject().execute();
+    assertThat(floatResponse.body()).isEqualTo(13.13f);
+
+    server.enqueue(new MockResponse().setBody("13"));
+    Response<Integer> integerResponse = service.integerObject().execute();
+    assertThat(integerResponse.body()).isEqualTo(13);
+
+    server.enqueue(new MockResponse().setBody("1347"));
+    Response<Long> longResponse = service.longObject().execute();
+    assertThat(longResponse.body()).isEqualTo(1347L);
+
+    server.enqueue(new MockResponse().setBody("134"));
+    Response<Short> shortResponse = service.shortObject().execute();
+    assertThat(shortResponse.body()).isEqualTo((short) 134);
+  }
 }
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
new file mode 100644
index 000000000..8145bde2d
--- /dev/null
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.scalars;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ScalarsConverterPrimitivesFactoryTest {
+  interface Service {
+    @GET("/") boolean booleanPrimitive();
+    @GET("/") byte bytePrimitive();
+    @GET("/") char charPrimitive();
+    @GET("/") double doublePrimitive();
+    @GET("/") float floatPrimitive();
+    @GET("/") int integerPrimitive();
+    @GET("/") long longPrimitive();
+    @GET("/") short shortPrimitive();
+  }
+
+  static class DirectCallIOException extends RuntimeException {
+    DirectCallIOException(String message, IOException e) {
+      super(message, e);
+    }
+  }
+
+  static class DirectCallAdapterFactory extends CallAdapter.Factory {
+    @Override
+    public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      return new CallAdapter<Object, Object>() {
+        @Override public Type responseType() {
+          return returnType;
+        }
+
+        @Override public Object adapt(Call call) {
+          try {
+            return call.execute().body();
+          } catch (IOException e) {
+            throw new DirectCallIOException(e.getMessage(), e);
+          }
+        }
+      };
+    }
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ScalarsConverterFactory.create())
+        .addCallAdapterFactory(new DirectCallAdapterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("true"));
+    boolean booleanResponse = service.booleanPrimitive();
+    assertThat(booleanResponse).isTrue();
+
+    server.enqueue(new MockResponse().setBody("5"));
+    byte byteResponse = service.bytePrimitive();
+    assertThat(byteResponse).isEqualTo((byte) 5);
+
+    server.enqueue(new MockResponse().setBody("b"));
+    char characterResponse = service.charPrimitive();
+    assertThat(characterResponse).isEqualTo('b');
+
+    server.enqueue(new MockResponse().setBody(""));
+    try {
+      service.charPrimitive();
+    } catch (DirectCallIOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+    }
+
+    server.enqueue(new MockResponse().setBody("bb"));
+    try {
+      service.charPrimitive();
+    } catch (DirectCallIOException e) {
+      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    }
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    double doubleResponse = service.doublePrimitive();
+    assertThat(doubleResponse).isEqualTo(13.13);
+
+    server.enqueue(new MockResponse().setBody("13.13"));
+    float floatResponse = service.floatPrimitive();
+    assertThat(floatResponse).isEqualTo(13.13f);
+
+    server.enqueue(new MockResponse().setBody("13"));
+    int integerResponse = service.integerPrimitive();
+    assertThat(integerResponse).isEqualTo(13);
+
+    server.enqueue(new MockResponse().setBody("1347"));
+    long longResponse = service.longPrimitive();
+    assertThat(longResponse).isEqualTo(1347L);
+
+    server.enqueue(new MockResponse().setBody("134"));
+    short shortResponse = service.shortPrimitive();
+    assertThat(shortResponse).isEqualTo((short) 134);
+  }
+}
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index ed3714d3b..d23c79a59 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,7 +30,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
similarity index 91%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index eac944102..b7563455e 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
@@ -73,8 +75,8 @@ public boolean isStrict() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class)) {
       return null;
     }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
similarity index 92%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index 997379170..06aeee1e6 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
 import org.simpleframework.xml.Serializer;
+import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
similarity index 84%
rename from retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
index 5303a0c5d..01759f449 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/SimpleXmlResponseBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
+import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
+import retrofit2.Converter;
 
 final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final Class<T> cls;
@@ -32,9 +32,8 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    InputStream is = value.byteStream();
     try {
-      T read = serializer.read(cls, is, strict);
+      T read = serializer.read(cls, value.charStream(), strict);
       if (read == null) {
         throw new IllegalStateException("Could not deserialize body as " + cls);
       }
@@ -44,10 +43,7 @@
     } catch (Exception e) {
       throw new RuntimeException(e);
     } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
similarity index 97%
rename from retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java
rename to retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
index 3730b9544..18d2e146f 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/MyObject.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
similarity index 75%
rename from retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java
rename to retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
index e6da9e2d9..7ad58b22d 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/SimpleXmlConverterFactoryTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
@@ -13,12 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.simplexml;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
+import java.nio.charset.Charset;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -27,6 +29,9 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -66,11 +71,25 @@
     assertThat(body.getCount()).isEqualTo(10);
 
     RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo(
-        "<my-object><message>hello world</message><count>10</count></my-object>");
+    assertThat(request.getBody().readUtf8()).isIn(
+        "<my-object><message>hello world</message><count>10</count></my-object>",
+        "<my-object><count>10</count><message>hello world</message></my-object>");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
   }
 
+  @Test public void honorsCharacterEncoding() throws IOException {
+    Buffer buffer = new Buffer().writeString(
+        "<my-object><message>你好，世界</message><count>10</count></my-object>",
+        Charset.forName("GBK"));
+    server.enqueue(
+        new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
+
+    Call<MyObject> call = service.get();
+    Response<MyObject> response = call.execute();
+    MyObject body = response.body();
+    assertThat(body.getMessage()).isEqualTo("你好，世界");
+  }
+
   @Test public void deserializeWrongValue() throws IOException {
     server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
 
@@ -80,7 +99,7 @@
       fail();
     } catch (RuntimeException e) {
       assertThat(e.getCause()).isInstanceOf(ElementException.class)
-          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.MyObject");
+          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
     }
   }
 
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 8357bc0de..497eb41aa 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -41,7 +41,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
similarity index 89%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index b084c6e7b..fbaaeac4a 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
@@ -51,8 +53,8 @@ private WireConverterFactory() {
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
similarity index 91%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index 193be4dbb..d388a944c 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.Buffer;
+import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
similarity index 76%
rename from retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
index 974df6357..5ab321381 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/WireResponseBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
-import okio.BufferedSource;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
 
 final class WireResponseBodyConverter<T extends Message<T, ?>>
     implements Converter<ResponseBody, T> {
@@ -30,17 +30,10 @@
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    BufferedSource source = null;
     try {
-      source = value.source();
-      return adapter.decode(source);
+      return adapter.decode(value.source());
     } finally {
-      if (source != null) {
-        try {
-          source.close();
-        } catch (IOException ignored) {
-        }
-      }
+      value.close();
     }
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/Phone.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
similarity index 83%
rename from retrofit-converters/wire/src/test/java/retrofit2/Phone.java
rename to retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
index 078a4c80a..c085094bb 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
@@ -1,12 +1,14 @@
 // Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: test.proto at 2:1
-package retrofit2;
+// Source file: phone.proto at 6:1
+package retrofit2.converter.wire;
 
 import com.squareup.wire.FieldEncoding;
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
 import com.squareup.wire.ProtoReader;
 import com.squareup.wire.ProtoWriter;
+import com.squareup.wire.WireField;
+import com.squareup.wire.internal.Internal;
 import java.io.IOException;
 import java.lang.Object;
 import java.lang.Override;
@@ -15,49 +17,16 @@
 import okio.ByteString;
 
 public final class Phone extends Message<Phone, Phone.Builder> {
-  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter<Phone>(FieldEncoding.LENGTH_DELIMITED, Phone.class) {
-    @Override
-    public int encodedSize(Phone value) {
-      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
-          + value.unknownFields().size();
-    }
-
-    @Override
-    public void encode(ProtoWriter writer, Phone value) throws IOException {
-      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
-      writer.writeBytes(value.unknownFields());
-    }
-
-    @Override
-    public Phone decode(ProtoReader reader) throws IOException {
-      Builder builder = new Builder();
-      long token = reader.beginMessage();
-      for (int tag; (tag = reader.nextTag()) != -1;) {
-        switch (tag) {
-          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
-          default: {
-            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
-            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
-            builder.addUnknownField(tag, fieldEncoding, value);
-          }
-        }
-      }
-      reader.endMessage(token);
-      return builder.build();
-    }
-
-    @Override
-    public Phone redact(Phone value) {
-      Builder builder = value.newBuilder();
-      builder.clearUnknownFields();
-      return builder.build();
-    }
-  };
+  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
 
   private static final long serialVersionUID = 0L;
 
   public static final String DEFAULT_NUMBER = "";
 
+  @WireField(
+      tag = 1,
+      adapter = "com.squareup.wire.ProtoAdapter#STRING"
+  )
   public final String number;
 
   public Phone(String number) {
@@ -65,7 +34,7 @@ public Phone(String number) {
   }
 
   public Phone(String number, ByteString unknownFields) {
-    super(unknownFields);
+    super(ADAPTER, unknownFields);
     this.number = number;
   }
 
@@ -82,8 +51,8 @@ public boolean equals(Object other) {
     if (other == this) return true;
     if (!(other instanceof Phone)) return false;
     Phone o = (Phone) other;
-    return equals(unknownFields(), o.unknownFields())
-        && equals(number, o.number);
+    return Internal.equals(unknownFields(), o.unknownFields())
+        && Internal.equals(number, o.number);
   }
 
   @Override
@@ -104,7 +73,7 @@ public String toString() {
     return builder.replace(0, 2, "Phone{").append('}').toString();
   }
 
-  public static final class Builder extends com.squareup.wire.Message.Builder<Phone, Builder> {
+  public static final class Builder extends Message.Builder<Phone, Builder> {
     public String number;
 
     public Builder() {
@@ -120,4 +89,47 @@ public Phone build() {
       return new Phone(number, buildUnknownFields());
     }
   }
+
+  private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
+    ProtoAdapter_Phone() {
+      super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+    }
+
+    @Override
+    public int encodedSize(Phone value) {
+      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+          + value.unknownFields().size();
+    }
+
+    @Override
+    public void encode(ProtoWriter writer, Phone value) throws IOException {
+      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+      writer.writeBytes(value.unknownFields());
+    }
+
+    @Override
+    public Phone decode(ProtoReader reader) throws IOException {
+      Builder builder = new Builder();
+      long token = reader.beginMessage();
+      for (int tag; (tag = reader.nextTag()) != -1;) {
+        switch (tag) {
+          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
+          default: {
+            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+            builder.addUnknownField(tag, fieldEncoding, value);
+          }
+        }
+      }
+      reader.endMessage(token);
+      return builder.build();
+    }
+
+    @Override
+    public Phone redact(Phone value) {
+      Builder builder = value.newBuilder();
+      builder.clearUnknownFields();
+      return builder.build();
+    }
+  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
similarity index 77%
rename from retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java
rename to retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index a1da24435..e972d5287 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -13,19 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.converter.wire;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -84,12 +87,14 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.WireConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.wire.WireConverterFactory");
     }
   }
 
@@ -101,12 +106,14 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for java.util.List<java.lang.String>\n"
           + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.WireConverterFactory");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.converter.wire.WireConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 9a5e881a1..9d741819b 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index 7913d0752..cfc92c5f7 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -16,11 +16,11 @@
 package retrofit2.mock;
 
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
@@ -28,12 +28,12 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 final class BehaviorCall<T> implements Call<T> {
-  private final NetworkBehavior behavior;
-  private final ExecutorService backgroundExecutor;
-  private final Call<T> delegate;
+  final NetworkBehavior behavior;
+  final ExecutorService backgroundExecutor;
+  final Call<T> delegate;
 
   private volatile Future<?> task;
-  private volatile boolean canceled;
+  volatile boolean canceled;
   private volatile boolean executed;
 
   BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
@@ -47,19 +47,25 @@
     return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
   }
 
+  @Override public Request request() {
+    return delegate.request();
+  }
+
   @Override public void enqueue(final Callback<T> callback) {
+    if (callback == null) throw new NullPointerException("callback == null");
+
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
       executed = true;
     }
     task = backgroundExecutor.submit(new Runnable() {
-      private boolean delaySleep() {
+      boolean delaySleep() {
         long sleepMs = behavior.calculateDelay(MILLISECONDS);
         if (sleepMs > 0) {
           try {
             Thread.sleep(sleepMs);
           } catch (InterruptedException e) {
-            callback.onFailure(new InterruptedIOException("canceled"));
+            callback.onFailure(BehaviorCall.this, new IOException("canceled"));
             return false;
           }
         }
@@ -68,22 +74,22 @@ private boolean delaySleep() {
 
       @Override public void run() {
         if (canceled) {
-          callback.onFailure(new InterruptedIOException("canceled"));
+          callback.onFailure(BehaviorCall.this, new IOException("canceled"));
         } else if (behavior.calculateIsFailure()) {
           if (delaySleep()) {
-            callback.onFailure(behavior.failureException());
+            callback.onFailure(BehaviorCall.this, behavior.failureException());
           }
         } else {
           delegate.enqueue(new Callback<T>() {
-            @Override public void onResponse(final Response<T> response) {
+            @Override public void onResponse(Call<T> call, Response<T> response) {
               if (delaySleep()) {
-                callback.onResponse(response);
+                callback.onResponse(call, response);
               }
             }
 
-            @Override public void onFailure(final Throwable t) {
+            @Override public void onFailure(Call<T> call, Throwable t) {
               if (delaySleep()) {
-                callback.onFailure(t);
+                callback.onFailure(call, t);
               }
             }
           });
@@ -101,12 +107,12 @@ private boolean delaySleep() {
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     enqueue(new Callback<T>() {
-      @Override public void onResponse(Response<T> response) {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<T> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -114,7 +120,7 @@ private boolean delaySleep() {
     try {
       latch.await();
     } catch (InterruptedException e) {
-      throw new InterruptedIOException("canceled");
+      throw new IOException("canceled");
     }
     Response<T> response = responseRef.get();
     if (response != null) return response;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index b1b875dcd..21af3a6d3 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
+import java.util.concurrent.ExecutorService;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -32,13 +33,16 @@
  * @see MockRetrofit#create(Class)
  */
 public final class BehaviorDelegate<T> {
-  private final Retrofit retrofit;
+  final Retrofit retrofit;
   private final NetworkBehavior behavior;
+  private final ExecutorService executor;
   private final Class<T> service;
 
-  BehaviorDelegate(Retrofit retrofit, NetworkBehavior behavior, Class<T> service) {
+  BehaviorDelegate(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor,
+      Class<T> service) {
     this.retrofit = retrofit;
     this.behavior = behavior;
+    this.executor = executor;
     this.service = service;
   }
 
@@ -47,16 +51,16 @@ public T returningResponse(Object response) {
   }
 
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public T returning(Call<?> call) {
-    final Call<?> behaviorCall =
-        new BehaviorCall<>(behavior, retrofit.client().getDispatcher().getExecutorService(), call);
+  public <R> T returning(Call<R> call) {
+    final Call<R> behaviorCall = new BehaviorCall<>(behavior, executor, call);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
         new InvocationHandler() {
           @Override
-          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+          public T invoke(Object proxy, Method method, Object[] args) throws Throwable {
             Type returnType = method.getGenericReturnType();
             Annotation[] methodAnnotations = method.getAnnotations();
-            CallAdapter<?> callAdapter = retrofit.callAdapter(returnType, methodAnnotations);
+            CallAdapter<R, T> callAdapter =
+                (CallAdapter<R, T>) retrofit.callAdapter(returnType, methodAnnotations);
             return callAdapter.adapt(behaviorCall);
           }
         });
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index d89fd512a..49b490aee 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,6 +16,7 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
@@ -33,7 +34,7 @@
       }
 
       @Override public void enqueue(Callback<T> callback) {
-        callback.onResponse(response);
+        callback.onResponse(this, response);
       }
 
       @Override public boolean isExecuted() {
@@ -51,6 +52,10 @@
       @Override public Call<T> clone() {
         return this;
       }
+
+      @Override public Request request() {
+        return response.raw().request();
+      }
     };
   }
 
@@ -61,7 +66,7 @@
       }
 
       @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(failure);
+        callback.onFailure(this, failure);
       }
 
       @Override public boolean isExecuted() {
@@ -79,6 +84,10 @@
       @Override public Call<T> clone() {
         return this;
       }
+
+      @Override public Request request() {
+        return new Request.Builder().url("http://localhost").build();
+      }
     };
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index b7562f8f4..3c75b47a2 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -15,23 +15,20 @@
  */
 package retrofit2.mock;
 
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import retrofit2.Retrofit;
 
 public final class MockRetrofit {
-  public static MockRetrofit create(Retrofit retrofit) {
-    return create(retrofit, NetworkBehavior.create());
-  }
-
-  public static MockRetrofit create(Retrofit retrofit, NetworkBehavior behavior) {
-    return new MockRetrofit(retrofit, behavior);
-  }
-
   private final Retrofit retrofit;
   private final NetworkBehavior behavior;
+  private final ExecutorService executor;
 
-  public MockRetrofit(Retrofit retrofit, NetworkBehavior behavior) {
+  MockRetrofit(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor) {
     this.retrofit = retrofit;
     this.behavior = behavior;
+    this.executor = executor;
   }
 
   public Retrofit retrofit() {
@@ -42,8 +39,41 @@ public NetworkBehavior networkBehavior() {
     return behavior;
   }
 
+  public Executor backgroundExecutor() {
+    return executor;
+  }
+
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> BehaviorDelegate<T> create(Class<T> service) {
-    return new BehaviorDelegate<>(retrofit, behavior, service);
+    return new BehaviorDelegate<>(retrofit, behavior, executor, service);
+  }
+
+  public static final class Builder {
+    private final Retrofit retrofit;
+    private NetworkBehavior behavior;
+    private ExecutorService executor;
+
+    public Builder(Retrofit retrofit) {
+      if (retrofit == null) throw new NullPointerException("retrofit == null");
+      this.retrofit = retrofit;
+    }
+
+    public Builder networkBehavior(NetworkBehavior behavior) {
+      if (behavior == null) throw new NullPointerException("behavior == null");
+      this.behavior = behavior;
+      return this;
+    }
+
+    public Builder backgroundExecutor(ExecutorService executor) {
+      if (executor == null) throw new NullPointerException("executor == null");
+      this.executor = executor;
+      return this;
+    }
+
+    public MockRetrofit build() {
+      if (behavior == null) behavior = NetworkBehavior.create();
+      if (executor == null) executor = Executors.newCachedThreadPool();
+      return new MockRetrofit(retrofit, behavior, executor);
+    }
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index d182862cb..8108c1d63 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -69,10 +69,13 @@ public static NetworkBehavior create(Random random) {
   private volatile long delayMs = DEFAULT_DELAY_MS;
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile Throwable failureException = new IOException("Mock failure!");
+  private volatile Throwable failureException;
 
   private NetworkBehavior(Random random) {
     this.random = random;
+
+    failureException = new IOException("Mock failure!");
+    failureException.setStackTrace(new StackTraceElement[0]);
   }
 
   /** Set the network round trip delay. */
@@ -114,7 +117,12 @@ public int failurePercent() {
     return failurePercent;
   }
 
-  /** Set the exception to be used when a failure is triggered. */
+  /**
+   * Set the exception to be used when a failure is triggered.
+   * <p>
+   * It is a best practice to remove the stack trace from {@code t} since it can misleadingly
+   * point to code unrelated to this class.
+   */
   public void setFailureException(Throwable t) {
     if (t == null) {
       throw new NullPointerException("t == null");
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
new file mode 100644
index 000000000..7199da059
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit2.mock;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class BehaviorDelegateTest {
+  interface DoWorkService {
+    Call<String> response();
+    Call<String> failure();
+  }
+
+  private final IOException mockFailure = new IOException("Timeout!");
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+  private DoWorkService service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+        .networkBehavior(behavior)
+        .build();
+    final BehaviorDelegate<DoWorkService> delegate = mockRetrofit.create(DoWorkService.class);
+
+    service = new DoWorkService() {
+      @Override public Call<String> response() {
+        Call<String> response = Calls.response("Response!");
+        return delegate.returning(response).response();
+      }
+
+      @Override public Call<String> failure() {
+        Call<String> failure = Calls.failure(mockFailure);
+        return delegate.returning(failure).failure();
+      }
+    };
+  }
+
+  @Test public void syncFailureThrowsAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Call<String> call = service.response();
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(e).isSameAs(behavior.failureException());
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    }
+  }
+
+  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Call<String> call = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void syncSuccessReturnsAfterDelay() throws IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.response();
+
+    long startNanos = System.nanoTime();
+    Response<String> response = call.execute();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+
+    assertThat(response.body()).isEqualTo("Response!");
+    assertThat(tookMs).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(response.body());
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        throw new AssertionError();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Response!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void syncFailureThrownAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.failure();
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+      assertThat(e).isSameAs(mockFailure);
+    }
+  }
+
+  @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.failure();
+
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    final long startNanos = System.nanoTime();
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(failureRef.get()).isSameAs(mockFailure);
+  }
+
+  @Test public void syncCanBeCanceled() throws IOException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    new Thread(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(100);
+          call.cancel();
+        } catch (InterruptedException ignored) {
+        }
+      }
+    }).start();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+    }
+  }
+
+  @Test public void asyncCanBeCanceled() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // TODO we shouldn't need to sleep
+    Thread.sleep(100); // Ensure the task has started.
+    call.cancel();
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+  }
+
+  @Test public void syncCanceledBeforeStart() throws IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+    }
+  }
+
+  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+    call.cancel();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
index a2767792d..3599cc972 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
@@ -1,298 +1,73 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 package retrofit2.mock;
 
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.Before;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import org.junit.Test;
-import retrofit2.Call;
-import retrofit2.Callback;
-import retrofit2.Response;
 import retrofit2.Retrofit;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class MockRetrofitTest {
-  interface DoWorkService {
-    Call<String> response();
-    Call<String> failure();
-  }
-
-  private final IOException mockFailure = new IOException("Timeout!");
-  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
-  private DoWorkService service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-
-    MockRetrofit mockRetrofit = MockRetrofit.create(retrofit, behavior);
-    final BehaviorDelegate<DoWorkService> delegate = mockRetrofit.create(DoWorkService.class);
-
-    service = new DoWorkService() {
-      @Override public Call<String> response() {
-        Call<String> response = Calls.response("Response!");
-        return delegate.returning(response).response();
-      }
+  private final Retrofit retrofit = new Retrofit.Builder().baseUrl("http://example.com").build();
+  private final NetworkBehavior behavior = NetworkBehavior.create();
+  private final ExecutorService executor = Executors.newSingleThreadExecutor();
 
-      @Override public Call<String> failure() {
-        Call<String> failure = Calls.failure(mockFailure);
-        return delegate.returning(failure).failure();
-      }
-    };
-  }
-
-  @Test public void syncFailureThrowsAfterDelay() {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Call<String> call = service.response();
-
-    long startNanos = System.nanoTime();
+  @Test public void retrofitNullThrows() {
     try {
-      call.execute();
+      new MockRetrofit.Builder(null);
       fail();
-    } catch (IOException e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(e).isSameAs(behavior.failureException());
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("retrofit == null");
     }
   }
 
-  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Call<String> call = service.response();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Throwable t) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(failureRef.get()).isSameAs(behavior.failureException());
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  @Test public void retrofitPropagated() {
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+    assertThat(mockRetrofit.retrofit()).isSameAs(retrofit);
   }
 
-  @Test public void syncSuccessReturnsAfterDelay() throws IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.response();
-
-    long startNanos = System.nanoTime();
-    Response<String> response = call.execute();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-
-    assertThat(response.body()).isEqualTo("Response!");
-    assertThat(tookMs).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.response();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<String> actual = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(response.body());
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Throwable t) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(actual.get()).isEqualTo("Response!");
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void syncFailureThrownAfterDelay() {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.failure();
-
-    long startNanos = System.nanoTime();
+  @Test public void networkBehaviorNullThrows() {
+    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
     try {
-      call.execute();
+      builder.networkBehavior(null);
       fail();
-    } catch (IOException e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e).isSameAs(mockFailure);
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("behavior == null");
     }
   }
 
-  @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.failure();
-
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    final long startNanos = System.nanoTime();
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Throwable t) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(failureRef.get()).isSameAs(mockFailure);
-  }
-
-  @Test public void syncCanBeCanceled() throws IOException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    new Thread(new Runnable() {
-      @Override public void run() {
-        try {
-          Thread.sleep(100);
-          call.cancel();
-        } catch (InterruptedException ignored) {
-        }
-      }
-    }).start();
-
-    try {
-      call.execute();
-      fail();
-    } catch (InterruptedIOException e) {
-      assertThat(e).hasMessage("canceled");
-    }
+  @Test public void networkBehaviorDefault() {
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+    assertThat(mockRetrofit.networkBehavior()).isNotNull();
   }
 
-  @Test public void asyncCanBeCanceled() throws InterruptedException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    // TODO we shouldn't need to sleep
-    Thread.sleep(100); // Ensure the task has started.
-    call.cancel();
-
-    assertTrue(latch.await(1, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  @Test public void networkBehaviorPropagated() {
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+        .networkBehavior(behavior)
+        .build();
+    assertThat(mockRetrofit.networkBehavior()).isSameAs(behavior);
   }
 
-  @Test public void syncCanceledBeforeStart() throws IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    call.cancel();
+  @Test public void backgroundExecutorNullThrows() {
+    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
     try {
-      call.execute();
+      builder.backgroundExecutor(null);
       fail();
-    } catch (InterruptedIOException e) {
-      assertThat(e).hasMessage("canceled");
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("executor == null");
     }
   }
 
-  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-    call.cancel();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
+  @Test public void backgroundExecutorDefault() {
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+    assertThat(mockRetrofit.backgroundExecutor()).isNotNull();
+  }
 
-    assertTrue(latch.await(1, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  @Test public void backgroundExecutorPropagated() {
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+        .backgroundExecutor(executor)
+        .build();
+    assertThat(mockRetrofit.backgroundExecutor()).isSameAs(executor);
   }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 7ccccc0df..180737826 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -15,6 +15,7 @@
  */
 package retrofit2.mock;
 
+import java.io.IOException;
 import java.util.Random;
 import org.junit.Test;
 
@@ -26,6 +27,12 @@
 public final class NetworkBehaviorTest {
   private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
+  @Test public void defaultThrowable() {
+    Throwable t = behavior.failureException();
+    assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage("Mock failure!");
+    assertThat(t.getStackTrace()).isEmpty();
+  }
+
   @Test public void delayMustBePositive() {
     try {
       behavior.setDelay(-1, SECONDS);
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 2aab54992..314c96636 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -15,7 +15,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
     </dependency>
 
@@ -52,9 +52,14 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.robolectric</groupId>
+      <artifactId>robolectric</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BaseUrl.java b/retrofit/src/main/java/retrofit2/BaseUrl.java
deleted file mode 100644
index 2c7fda391..000000000
--- a/retrofit/src/main/java/retrofit2/BaseUrl.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package retrofit2;
-
-import com.squareup.okhttp.HttpUrl;
-
-/** The base URL of the remote service. */
-public interface BaseUrl {
-  /**
-   * The base URL.
-   * <p>
-   * Consumers will call this method every time they need to create a request allowing values
-   * to change over time.
-   */
-  HttpUrl url();
-}
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 52ff5f0ba..f729383a3 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -15,11 +15,11 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
@@ -27,10 +27,9 @@
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     if (type == ResponseBody.class) {
-      if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
-        return StreamingResponseBodyConverter.INSTANCE;
-      }
-      return BufferingResponseBodyConverter.INSTANCE;
+      return Utils.isAnnotationPresent(annotations, Streaming.class)
+          ? StreamingResponseBodyConverter.INSTANCE
+          : BufferingResponseBodyConverter.INSTANCE;
     }
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
@@ -39,29 +38,14 @@
   }
 
   @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
       return RequestBodyConverter.INSTANCE;
     }
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
-    if (type == String.class) {
-      return StringConverter.INSTANCE;
-    }
-    return null;
-  }
-
-  static final class StringConverter implements Converter<String, String> {
-    static final StringConverter INSTANCE = new StringConverter();
-
-    @Override public String convert(String value) throws IOException {
-      return value;
-    }
-  }
-
   static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
     static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
@@ -95,9 +79,9 @@
     @Override public ResponseBody convert(ResponseBody value) throws IOException {
       try {
         // Buffer the entire body to avoid future I/O.
-        return Utils.readBodyToBytesIfNecessary(value);
+        return Utils.buffer(value);
       } finally {
-        Utils.closeQuietly(value);
+        value.close();
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 873bb0c6f..171d9e0c4 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+import okhttp3.Request;
 
 /**
  * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
@@ -66,4 +67,7 @@
    * has already been.
    */
   Call<T> clone();
+
+  /** The original HTTP request. */
+  Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index e6e94a5a4..927540bf4 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -16,29 +16,71 @@
 package retrofit2;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 
-/** Adapts a {@link Call} into the type of {@code T}. */
-public interface CallAdapter<T> {
+/**
+ * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
+ * created by {@linkplain Factory a factory} which is
+ * {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into the {@link Retrofit}
+ * instance.
+ */
+public interface CallAdapter<R, T> {
   /**
    * Returns the value type that this adapter uses when converting the HTTP response body to a Java
    * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
    * is used to prepare the {@code call} passed to {@code #adapt}.
-   *
-   * <p>Note that this is typically not the same type as the {@code returnType} provided to
-   * this call adapter's factory.
+   * <p>
+   * Note: This is typically not the same type as the {@code returnType} provided to this call
+   * adapter's factory.
    */
   Type responseType();
 
-  /** Returns an instance of the {@code T} which adapts the execution of {@code call}. */
-  <R> T adapt(Call<R> call);
+  /**
+   * Returns an instance of {@code T} which delegates to {@code call}.
+   * <p>
+   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+   * return a new {@code Async<R>} which invoked {@code call} when run.
+   * <pre><code>
+   * &#64;Override
+   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
+   *     &#64;Override
+   *     public Response&lt;R&gt; call() throws Exception {
+   *       return call.execute();
+   *     }
+   *   });
+   * }
+   * </code></pre>
+   */
+  T adapt(Call<R> call);
 
-  /** Creates {@link CallAdapter} instances based on a desired type. */
-  interface Factory {
+  /**
+   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+   * Retrofit#create(Class) the service interface} methods.
+   */
+  abstract class Factory {
     /**
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
+    public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit);
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 251f9a389..62c93a621 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -33,13 +33,13 @@
    * Invoked for a received HTTP response.
    * <p>
    * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
-   * Call {@link Response#isSuccess()} to determine if the response indicates success.
+   * Call {@link Response#isSuccessful()} to determine if the response indicates success.
    */
-  void onResponse(Response<T> response);
+  void onResponse(Call<T> call, Response<T> response);
 
   /**
    * Invoked when a network exception occurred talking to the server or when an unexpected
    * exception occurred creating the request or processing the response.
    */
-  void onFailure(Throwable t);
+  void onFailure(Call<T> call, Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 1f87253e4..880eea9b8 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -15,15 +15,16 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import retrofit2.http.Body;
 import retrofit2.http.Field;
 import retrofit2.http.FieldMap;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Part;
 import retrofit2.http.PartMap;
 import retrofit2.http.Path;
@@ -31,8 +32,9 @@
 import retrofit2.http.QueryMap;
 
 /**
- * Convert objects to and from their representation in HTTP. Register a converter with Retrofit
- * using {@link Retrofit.Builder#addConverterFactory(Factory)}.
+ * Convert objects to and from their representation in HTTP. Instances are created by {@linkplain
+ * Factory a factory} which is {@linkplain Retrofit.Builder#addConverterFactory(Factory) installed}
+ * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
   T convert(F value) throws IOException;
@@ -56,8 +58,8 @@
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
      */
-    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       return null;
     }
 
@@ -65,10 +67,11 @@
      * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
      * {@code type} cannot be handled by this factory. This is used to create converters for types
      * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
-     * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
-     * {@link QueryMap @QueryMap} values.
+     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
       return null;
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java
deleted file mode 100644
index 96408ac61..000000000
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapter.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-
-/**
- * A call adapter that uses the same thread for both I/O and application-level callbacks. For
- * synchronous calls this is the application thread making the request; for asynchronous calls this
- * is a thread provided by OkHttp's dispatcher.
- */
-final class DefaultCallAdapter implements CallAdapter<Call<?>> {
-  static final Factory FACTORY = new Factory() {
-    @Override
-    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      if (Utils.getRawType(returnType) != Call.class) {
-        return null;
-      }
-      Type responseType = Utils.getCallResponseType(returnType);
-      return new DefaultCallAdapter(responseType);
-    }
-  };
-
-  private final Type responseType;
-
-  DefaultCallAdapter(Type responseType) {
-    this.responseType = responseType;
-  }
-
-  @Override public Type responseType() {
-    return responseType;
-  }
-
-  @Override public <R> Call<R> adapt(Call<R> call) {
-    return call;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
new file mode 100644
index 000000000..c0f114cf3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * Creates call adapters for that uses the same thread for both I/O and application-level
+ * callbacks. For synchronous calls this is the application thread making the request; for
+ * asynchronous calls this is a thread provided by OkHttp's dispatcher.
+ */
+final class DefaultCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
+      return null;
+    }
+
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Object, Call<?>>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<Object> adapt(Call<Object> call) {
+        return call;
+      }
+    };
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index ce5f2066b..a633d60e8 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,34 +19,35 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+import okhttp3.Request;
 
-final class ExecutorCallAdapterFactory implements CallAdapter.Factory {
-  private final Executor callbackExecutor;
+final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
+  final Executor callbackExecutor;
 
   ExecutorCallAdapterFactory(Executor callbackExecutor) {
     this.callbackExecutor = callbackExecutor;
   }
 
   @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (Utils.getRawType(returnType) != Call.class) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
+    return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
+      @Override public Call<Object> adapt(Call<Object> call) {
         return new ExecutorCallbackCall<>(callbackExecutor, call);
       }
     };
   }
 
   static final class ExecutorCallbackCall<T> implements Call<T> {
-    private final Executor callbackExecutor;
-    private final Call<T> delegate;
+    final Executor callbackExecutor;
+    final Call<T> delegate;
 
     ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
       this.callbackExecutor = callbackExecutor;
@@ -54,24 +55,26 @@
     }
 
     @Override public void enqueue(final Callback<T> callback) {
+      if (callback == null) throw new NullPointerException("callback == null");
+
       delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(final Response<T> response) {
+        @Override public void onResponse(Call<T> call, final Response<T> response) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancelation
-                callback.onFailure(new IOException("Canceled"));
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
               } else {
-                callback.onResponse(response);
+                callback.onResponse(ExecutorCallbackCall.this, response);
               }
             }
           });
         }
 
-        @Override public void onFailure(final Throwable t) {
+        @Override public void onFailure(Call<T> call, final Throwable t) {
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
-              callback.onFailure(t);
+              callback.onFailure(ExecutorCallbackCall.this, t);
             }
           });
         }
@@ -98,5 +101,9 @@
     @Override public Call<T> clone() {
       return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
     }
+
+    @Override public Request request() {
+      return delegate.request();
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/MethodHandler.java b/retrofit/src/main/java/retrofit2/MethodHandler.java
deleted file mode 100644
index 10eddb408..000000000
--- a/retrofit/src/main/java/retrofit2/MethodHandler.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-
-final class MethodHandler<T> {
-  @SuppressWarnings("unchecked")
-  static MethodHandler<?> create(Retrofit retrofit, Method method) {
-    CallAdapter<Object> callAdapter = (CallAdapter<Object>) createCallAdapter(method, retrofit);
-    Type responseType = callAdapter.responseType();
-    Converter<ResponseBody, Object> responseConverter =
-        (Converter<ResponseBody, Object>) createResponseConverter(method, retrofit, responseType);
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
-    return new MethodHandler<>(retrofit.client(), requestFactory, callAdapter, responseConverter);
-  }
-
-  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
-    Type returnType = method.getGenericReturnType();
-    if (Utils.hasUnresolvableType(returnType)) {
-      throw Utils.methodError(method,
-          "Method return type must not include a type variable or wildcard: %s", returnType);
-    }
-    if (returnType == void.class) {
-      throw Utils.methodError(method, "Service methods cannot return void.");
-    }
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.callAdapter(returnType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
-    }
-  }
-
-  private static Converter<ResponseBody, ?> createResponseConverter(Method method,
-      Retrofit retrofit, Type responseType) {
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.responseBodyConverter(responseType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw Utils.methodError(e, method, "Unable to create converter for %s", responseType);
-    }
-  }
-
-  private final OkHttpClient client;
-  private final RequestFactory requestFactory;
-  private final CallAdapter<T> callAdapter;
-  private final Converter<ResponseBody, T> responseConverter;
-
-  private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
-      CallAdapter<T> callAdapter, Converter<ResponseBody, T> responseConverter) {
-    this.client = client;
-    this.requestFactory = requestFactory;
-    this.callAdapter = callAdapter;
-    this.responseConverter = responseConverter;
-  }
-
-  Object invoke(Object... args) {
-    return callAdapter.adapt(new OkHttpCall<>(client, requestFactory, responseConverter, args));
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index fc2d70b6f..5b9a196ff 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -15,89 +15,124 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
 
-import static retrofit2.Utils.closeQuietly;
-
 final class OkHttpCall<T> implements Call<T> {
-  private final OkHttpClient client;
-  private final RequestFactory requestFactory;
-  private final Converter<ResponseBody, T> responseConverter;
+  private final ServiceMethod<T, ?> serviceMethod;
   private final Object[] args;
 
-  private volatile com.squareup.okhttp.Call rawCall;
-  private boolean executed; // Guarded by this.
   private volatile boolean canceled;
 
-  OkHttpCall(OkHttpClient client, RequestFactory requestFactory,
-      Converter<ResponseBody, T> responseConverter, Object[] args) {
-    this.client = client;
-    this.requestFactory = requestFactory;
-    this.responseConverter = responseConverter;
+  // All guarded by this.
+  private okhttp3.Call rawCall;
+  private Throwable creationFailure; // Either a RuntimeException or IOException.
+  private boolean executed;
+
+  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
+    this.serviceMethod = serviceMethod;
     this.args = args;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(client, requestFactory, responseConverter, args);
+    return new OkHttpCall<>(serviceMethod, args);
+  }
+
+  @Override public synchronized Request request() {
+    okhttp3.Call call = rawCall;
+    if (call != null) {
+      return call.request();
+    }
+    if (creationFailure != null) {
+      if (creationFailure instanceof IOException) {
+        throw new RuntimeException("Unable to create request.", creationFailure);
+      } else {
+        throw (RuntimeException) creationFailure;
+      }
+    }
+    try {
+      return (rawCall = createRawCall()).request();
+    } catch (RuntimeException e) {
+      creationFailure = e;
+      throw e;
+    } catch (IOException e) {
+      creationFailure = e;
+      throw new RuntimeException("Unable to create request.", e);
+    }
   }
 
   @Override public void enqueue(final Callback<T> callback) {
+    if (callback == null) throw new NullPointerException("callback == null");
+
+    okhttp3.Call call;
+    Throwable failure;
+
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed.");
       executed = true;
+
+      call = rawCall;
+      failure = creationFailure;
+      if (call == null && failure == null) {
+        try {
+          call = rawCall = createRawCall();
+        } catch (Throwable t) {
+          failure = creationFailure = t;
+        }
+      }
     }
 
-    com.squareup.okhttp.Call rawCall;
-    try {
-      rawCall = createRawCall();
-    } catch (Throwable t) {
-      callback.onFailure(t);
+    if (failure != null) {
+      callback.onFailure(this, failure);
       return;
     }
+
     if (canceled) {
-      rawCall.cancel();
+      call.cancel();
     }
-    this.rawCall = rawCall;
 
-    rawCall.enqueue(new com.squareup.okhttp.Callback() {
-      private void callFailure(Throwable e) {
+    call.enqueue(new okhttp3.Callback() {
+      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
+          throws IOException {
+        Response<T> response;
         try {
-          callback.onFailure(e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+          response = parseResponse(rawResponse);
+        } catch (Throwable e) {
+          callFailure(e);
+          return;
         }
+        callSuccess(response);
       }
 
-      private void callSuccess(Response<T> response) {
+      @Override public void onFailure(okhttp3.Call call, IOException e) {
         try {
-          callback.onResponse(response);
+          callback.onFailure(OkHttpCall.this, e);
         } catch (Throwable t) {
           t.printStackTrace();
         }
       }
 
-      @Override public void onFailure(Request request, IOException e) {
-        callFailure(e);
+      private void callFailure(Throwable e) {
+        try {
+          callback.onFailure(OkHttpCall.this, e);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
       }
 
-      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
-        Response<T> response;
+      private void callSuccess(Response<T> response) {
         try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+          callback.onResponse(OkHttpCall.this, response);
+        } catch (Throwable t) {
+          t.printStackTrace();
         }
-        callSuccess(response);
       }
     });
   }
@@ -107,25 +142,48 @@ private void callSuccess(Response<T> response) {
   }
 
   @Override public Response<T> execute() throws IOException {
+    okhttp3.Call call;
+
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed.");
       executed = true;
+
+      if (creationFailure != null) {
+        if (creationFailure instanceof IOException) {
+          throw (IOException) creationFailure;
+        } else {
+          throw (RuntimeException) creationFailure;
+        }
+      }
+
+      call = rawCall;
+      if (call == null) {
+        try {
+          call = rawCall = createRawCall();
+        } catch (IOException | RuntimeException e) {
+          creationFailure = e;
+          throw e;
+        }
+      }
     }
 
-    com.squareup.okhttp.Call rawCall = createRawCall();
     if (canceled) {
-      rawCall.cancel();
+      call.cancel();
     }
-    this.rawCall = rawCall;
 
-    return parseResponse(rawCall.execute());
+    return parseResponse(call.execute());
   }
 
-  private com.squareup.okhttp.Call createRawCall() throws IOException {
-    return client.newCall(requestFactory.create(args));
+  private okhttp3.Call createRawCall() throws IOException {
+    Request request = serviceMethod.toRequest(args);
+    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+    if (call == null) {
+      throw new NullPointerException("Call.Factory returned null.");
+    }
+    return call;
   }
 
-  private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
+  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
     ResponseBody rawBody = rawResponse.body();
 
     // Remove the body's source (the only stateful object) so we can pass the response along.
@@ -137,20 +195,21 @@ private void callSuccess(Response<T> response) {
     if (code < 200 || code >= 300) {
       try {
         // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+        ResponseBody bufferedBody = Utils.buffer(rawBody);
         return Response.error(bufferedBody, rawResponse);
       } finally {
-        closeQuietly(rawBody);
+        rawBody.close();
       }
     }
 
     if (code == 204 || code == 205) {
+      rawBody.close();
       return Response.success(null, rawResponse);
     }
 
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
-      T body = responseConverter.convert(catchingBody);
+      T body = serviceMethod.toResponse(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -162,9 +221,13 @@ private void callSuccess(Response<T> response) {
 
   public void cancel() {
     canceled = true;
-    com.squareup.okhttp.Call rawCall = this.rawCall;
-    if (rawCall != null) {
-      rawCall.cancel();
+
+    okhttp3.Call call;
+    synchronized (this) {
+      call = rawCall;
+    }
+    if (call != null) {
+      call.cancel();
     }
   }
 
@@ -185,18 +248,18 @@ public void cancel() {
       return contentType;
     }
 
-    @Override public long contentLength() throws IOException {
+    @Override public long contentLength() {
       return contentLength;
     }
 
-    @Override public BufferedSource source() throws IOException {
+    @Override public BufferedSource source() {
       throw new IllegalStateException("Cannot read raw response body of a converted body.");
     }
   }
 
   static final class ExceptionCatchingRequestBody extends ResponseBody {
     private final ResponseBody delegate;
-    private IOException thrownException;
+    IOException thrownException;
 
     ExceptionCatchingRequestBody(ResponseBody delegate) {
       this.delegate = delegate;
@@ -206,24 +269,12 @@ public void cancel() {
       return delegate.contentType();
     }
 
-    @Override public long contentLength() throws IOException {
-      try {
-        return delegate.contentLength();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
+    @Override public long contentLength() {
+      return delegate.contentLength();
     }
 
-    @Override public BufferedSource source() throws IOException {
-      BufferedSource delegateSource;
-      try {
-        delegateSource = delegate.source();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-      return Okio.buffer(new ForwardingSource(delegateSource) {
+    @Override public BufferedSource source() {
+      return Okio.buffer(new ForwardingSource(delegate.source()) {
         @Override public long read(Buffer sink, long byteCount) throws IOException {
           try {
             return super.read(sink, byteCount);
@@ -235,7 +286,7 @@ public void cancel() {
       });
     }
 
-    @Override public void close() throws IOException {
+    @Override public void close() {
       delegate.close();
     }
 
diff --git a/retrofit/src/main/java/retrofit2/RequestAction.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
similarity index 57%
rename from retrofit/src/main/java/retrofit2/RequestAction.java
rename to retrofit/src/main/java/retrofit2/ParameterHandler.java
index bc97cea3c..c332fad50 100644
--- a/retrofit/src/main/java/retrofit2/RequestAction.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -15,49 +15,50 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+import okhttp3.Headers;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
 
 import static retrofit2.Utils.checkNotNull;
 
-abstract class RequestAction<T> {
-  abstract void perform(RequestBuilder builder, T value) throws IOException;
+abstract class ParameterHandler<T> {
+  abstract void apply(RequestBuilder builder, T value) throws IOException;
 
-  final RequestAction<Iterable<T>> iterable() {
-    return new RequestAction<Iterable<T>>() {
-      @Override void perform(RequestBuilder builder, Iterable<T> values) throws IOException {
+  final ParameterHandler<Iterable<T>> iterable() {
+    return new ParameterHandler<Iterable<T>>() {
+      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
         if (values == null) return; // Skip null values.
 
         for (T value : values) {
-          RequestAction.this.perform(builder, value);
+          ParameterHandler.this.apply(builder, value);
         }
       }
     };
   }
 
-  final RequestAction<Object> array() {
-    return new RequestAction<Object>() {
-      @Override void perform(RequestBuilder builder, Object values) throws IOException {
+  final ParameterHandler<Object> array() {
+    return new ParameterHandler<Object>() {
+      @Override void apply(RequestBuilder builder, Object values) throws IOException {
         if (values == null) return; // Skip null values.
 
         for (int i = 0, size = Array.getLength(values); i < size; i++) {
           //noinspection unchecked
-          RequestAction.this.perform(builder, (T) Array.get(values, i));
+          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
         }
       }
     };
   }
 
-  static final class Url extends RequestAction<String> {
-    @Override void perform(RequestBuilder builder, String value) {
+  static final class RelativeUrl extends ParameterHandler<Object> {
+    @Override void apply(RequestBuilder builder, Object value) {
       builder.setRelativeUrl(value);
     }
   }
 
-  static final class Header<T> extends RequestAction<T> {
+  static final class Header<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
 
@@ -66,13 +67,13 @@
       this.valueConverter = valueConverter;
     }
 
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
       if (value == null) return; // Skip null values.
       builder.addHeader(name, valueConverter.convert(value));
     }
   }
 
-  static final class Path<T> extends RequestAction<T> {
+  static final class Path<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
@@ -83,7 +84,7 @@
       this.encoded = encoded;
     }
 
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
       if (value == null) {
         throw new IllegalArgumentException(
             "Path parameter \"" + name + "\" value must not be null.");
@@ -92,7 +93,7 @@
     }
   }
 
-  static final class Query<T> extends RequestAction<T> {
+  static final class Query<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
@@ -103,13 +104,13 @@
       this.encoded = encoded;
     }
 
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
       if (value == null) return; // Skip null values.
       builder.addQueryParam(name, valueConverter.convert(value), encoded);
     }
   }
 
-  static final class QueryMap<T> extends RequestAction<Map<String, T>> {
+  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
@@ -118,8 +119,10 @@
       this.encoded = encoded;
     }
 
-    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) return; // Skip null values.
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Query map was null.");
+      }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
@@ -127,14 +130,43 @@
           throw new IllegalArgumentException("Query map contained null key.");
         }
         T entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Query map contained null value for key '" + entryKey + "'.");
         }
+        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
       }
     }
   }
 
-  static final class Field<T> extends RequestAction<T> {
+  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+
+    HeaderMap(Converter<T, String> valueConverter) {
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Header map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String headerName = entry.getKey();
+        if (headerName == null) {
+          throw new IllegalArgumentException("Header map contained null key.");
+        }
+        T headerValue = entry.getValue();
+        if (headerValue == null) {
+          throw new IllegalArgumentException(
+              "Header map contained null value for key '" + headerName + "'.");
+        }
+        builder.addHeader(headerName, valueConverter.convert(headerValue));
+      }
+    }
+  }
+
+  static final class Field<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
@@ -145,13 +177,13 @@
       this.encoded = encoded;
     }
 
-    @Override void perform(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
       if (value == null) return; // Skip null values.
       builder.addFormField(name, valueConverter.convert(value), encoded);
     }
   }
 
-  static final class FieldMap<T> extends RequestAction<Map<String, T>> {
+  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
@@ -160,8 +192,10 @@
       this.encoded = encoded;
     }
 
-    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) return; // Skip null values.
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Field map was null.");
+      }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
@@ -169,14 +203,16 @@
           throw new IllegalArgumentException("Field map contained null key.");
         }
         T entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Field map contained null value for key '" + entryKey + "'.");
         }
+        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
       }
     }
   }
 
-  static final class Part<T> extends RequestAction<T> {
+  static final class Part<T> extends ParameterHandler<T> {
     private final Headers headers;
     private final Converter<T, RequestBody> converter;
 
@@ -185,7 +221,7 @@
       this.converter = converter;
     }
 
-    @Override void perform(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, T value) {
       if (value == null) return; // Skip null values.
 
       RequestBody body;
@@ -198,7 +234,20 @@
     }
   }
 
-  static final class PartMap<T> extends RequestAction<Map<String, T>> {
+  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+    static final RawPart INSTANCE = new RawPart();
+
+    private RawPart() {
+    }
+
+    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+      if (value != null) { // Skip null values.
+        builder.addPart(value);
+      }
+    }
+  }
+
+  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, RequestBody> valueConverter;
     private final String transferEncoding;
 
@@ -207,8 +256,10 @@
       this.transferEncoding = transferEncoding;
     }
 
-    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) return; // Skip null values.
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Part map was null.");
+      }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
@@ -217,7 +268,8 @@
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          continue; // Skip null values.
+          throw new IllegalArgumentException(
+              "Part map contained null value for key '" + entryKey + "'.");
         }
 
         Headers headers = Headers.of(
@@ -229,14 +281,14 @@
     }
   }
 
-  static final class Body<T> extends RequestAction<T> {
+  static final class Body<T> extends ParameterHandler<T> {
     private final Converter<T, RequestBody> converter;
 
     Body(Converter<T, RequestBody> converter) {
       this.converter = converter;
     }
 
-    @Override void perform(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, T value) {
       if (value == null) {
         throw new IllegalArgumentException("Body parameter value must not be null.");
       }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 327d79208..e67159bff 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,7 +18,9 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
@@ -43,14 +45,23 @@ private static Platform findPlatform() {
       return new Java8();
     } catch (ClassNotFoundException ignored) {
     }
+    try {
+      Class.forName("org.robovm.apple.foundation.NSObject");
+      return new IOS();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
+  Executor defaultCallbackExecutor() {
+    return null;
+  }
+
   CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
-    return DefaultCallAdapter.FACTORY;
+    return DefaultCallAdapterFactory.INSTANCE;
   }
 
   boolean isDefaultMethod(Method method) {
@@ -70,8 +81,11 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
 
     @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
         Object... args) throws Throwable {
-      return MethodHandles.lookup()
-          .in(declaringClass)
+      // Because the service interface might not be public, we need to use a MethodHandle lookup
+      // that ignores the visibility of the declaringClass.
+      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+      constructor.setAccessible(true);
+      return constructor.newInstance(declaringClass, -1 /* trusted */)
           .unreflectSpecial(method, declaringClass)
           .bindTo(object)
           .invokeWithArguments(args);
@@ -79,10 +93,11 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
   }
 
   static class Android extends Platform {
+    @Override public Executor defaultCallbackExecutor() {
+      return new MainThreadExecutor();
+    }
+
     @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      if (callbackExecutor == null) {
-        callbackExecutor = new MainThreadExecutor();
-      }
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
 
@@ -94,4 +109,47 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
       }
     }
   }
+
+  static class IOS extends Platform {
+    @Override public Executor defaultCallbackExecutor() {
+      return new MainThreadExecutor();
+    }
+
+    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+
+    static class MainThreadExecutor implements Executor {
+      private static Object queue;
+      private static Method addOperation;
+
+      static {
+        try {
+          // queue = NSOperationQueue.getMainQueue();
+          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
+          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
+          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
+        } catch (Exception e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      @Override public void execute(Runnable r) {
+        try {
+          // queue.addOperation(r);
+          addOperation.invoke(queue, r);
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+          throw new AssertionError(e);
+        } catch (InvocationTargetException e) {
+          Throwable cause = e.getCause();
+          if (cause instanceof RuntimeException) {
+            throw (RuntimeException) cause;
+          } else if (cause instanceof Error) {
+            throw (Error) cause;
+          }
+          throw new RuntimeException(cause);
+        }
+      }
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 256f0ca94..3a25b6f53 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -15,21 +15,21 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.FormEncodingBuilder;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.MultipartBuilder;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.FormBody;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
 import okio.Buffer;
 import okio.BufferedSink;
 
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
 
   private final String method;
 
@@ -41,8 +41,8 @@
   private MediaType contentType;
 
   private final boolean hasBody;
-  private MultipartBuilder multipartBuilder;
-  private FormEncodingBuilder formEncodingBuilder;
+  private MultipartBody.Builder multipartBuilder;
+  private FormBody.Builder formBuilder;
   private RequestBody body;
 
   RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
@@ -60,21 +60,26 @@
 
     if (isFormEncoded) {
       // Will be set to 'body' in 'build'.
-      formEncodingBuilder = new FormEncodingBuilder();
+      formBuilder = new FormBody.Builder();
     } else if (isMultipart) {
       // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBuilder();
-      multipartBuilder.type(MultipartBuilder.FORM);
+      multipartBuilder = new MultipartBody.Builder();
+      multipartBuilder.setType(MultipartBody.FORM);
     }
   }
 
-  void setRelativeUrl(String relativeUrl) {
-    this.relativeUrl = relativeUrl;
+  void setRelativeUrl(Object relativeUrl) {
+    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
+    this.relativeUrl = relativeUrl.toString();
   }
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      contentType = MediaType.parse(value);
+      MediaType type = MediaType.parse(value);
+      if (type == null) {
+        throw new IllegalArgumentException("Malformed content type: " + value);
+      }
+      contentType = type;
     } else {
       requestBuilder.addHeader(name, value);
     }
@@ -85,20 +90,20 @@ void addPathParam(String name, String value, boolean encoded) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
   }
 
-  static String canonicalize(String input, boolean alreadyEncoded) {
+  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
     int codePoint;
     for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
       if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
         // Slow path: the character at i requires encoding!
         Buffer out = new Buffer();
         out.writeUtf8(input, 0, i);
-        canonicalize(out, input, i, limit, alreadyEncoded);
+        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
         return out.readUtf8();
       }
     }
@@ -107,7 +112,8 @@ static String canonicalize(String input, boolean alreadyEncoded) {
     return input;
   }
 
-  static void canonicalize(Buffer out, String input, int pos, int limit, boolean alreadyEncoded) {
+  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+      boolean alreadyEncoded) {
     Buffer utf8Buffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
@@ -115,10 +121,9 @@ static void canonicalize(Buffer out, String input, int pos, int limit, boolean a
       if (alreadyEncoded
           && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
         // Skip this character.
-      } else if (codePoint < 0x20
-          || codePoint >= 0x7f
-          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+      } else if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
         // Percent encode this character.
         if (utf8Buffer == null) {
           utf8Buffer = new Buffer();
@@ -140,7 +145,11 @@ static void canonicalize(Buffer out, String input, int pos, int limit, boolean a
   void addQueryParam(String name, String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.resolve(relativeUrl).newBuilder();
+      urlBuilder = baseUrl.newBuilder(relativeUrl);
+      if (urlBuilder == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
       relativeUrl = null;
     }
 
@@ -153,9 +162,9 @@ void addQueryParam(String name, String value, boolean encoded) {
 
   void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
-      formEncodingBuilder.addEncoded(name, value);
+      formBuilder.addEncoded(name, value);
     } else {
-      formEncodingBuilder.add(name, value);
+      formBuilder.add(name, value);
     }
   }
 
@@ -163,6 +172,10 @@ void addPart(Headers headers, RequestBody body) {
     multipartBuilder.addPart(headers, body);
   }
 
+  void addPart(MultipartBody.Part part) {
+    multipartBuilder.addPart(part);
+  }
+
   void setBody(RequestBody body) {
     this.body = body;
   }
@@ -175,13 +188,17 @@ Request build() {
     } else {
       // No query parameters triggered builder creation, just combine the relative URL and base URL.
       url = baseUrl.resolve(relativeUrl);
+      if (url == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
     }
 
     RequestBody body = this.body;
     if (body == null) {
       // Try to pull from one of the builders.
-      if (formEncodingBuilder != null) {
-        body = formEncodingBuilder.build();
+      if (formBuilder != null) {
+        body = formBuilder.build();
       } else if (multipartBuilder != null) {
         body = multipartBuilder.build();
       } else if (hasBody) {
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
deleted file mode 100644
index 7a266483c..000000000
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-import java.io.IOException;
-
-final class RequestFactory {
-  private final String method;
-  private final BaseUrl baseUrl;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final RequestAction[] requestActions;
-
-  RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
-      RequestAction[] requestActions) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.headers = headers;
-    this.contentType = contentType;
-    this.hasBody = hasBody;
-    this.isFormEncoded = isFormEncoded;
-    this.isMultipart = isMultipart;
-    this.requestActions = requestActions;
-  }
-
-  Request create(Object... args) throws IOException {
-    RequestBuilder requestBuilder =
-        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
-            isFormEncoded, isMultipart);
-
-    if (args != null) {
-      RequestAction[] actions = requestActions;
-      if (actions.length != args.length) {
-        throw new IllegalArgumentException("Argument count ("
-            + args.length
-            + ") doesn't match action count ("
-            + actions.length
-            + ")");
-      }
-      for (int i = 0, count = args.length; i < count; i++) {
-        actions[i].perform(requestBuilder, args[i]);
-      }
-    }
-
-    return requestBuilder.build();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/RequestFactoryParser.java b/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
deleted file mode 100644
index d27c94ddf..000000000
--- a/retrofit/src/main/java/retrofit2/RequestFactoryParser.java
+++ /dev/null
@@ -1,545 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.Headers;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.Url;
-
-import static retrofit2.Utils.methodError;
-
-final class RequestFactoryParser {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
-    RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations(responseType);
-    parser.parseParameters(retrofit);
-    return parser.toRequestFactory(retrofit.baseUrl());
-  }
-
-  private final Method method;
-
-  private String httpMethod;
-  private boolean hasBody;
-  private boolean isFormEncoded;
-  private boolean isMultipart;
-  private String relativeUrl;
-  private com.squareup.okhttp.Headers headers;
-  private MediaType contentType;
-  private RequestAction[] requestActions;
-
-  private Set<String> relativeUrlParamNames;
-
-  private RequestFactoryParser(Method method) {
-    this.method = method;
-  }
-
-  private RequestFactory toRequestFactory(BaseUrl baseUrl) {
-    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
-        isFormEncoded, isMultipart, requestActions);
-  }
-
-  private RuntimeException parameterError(Throwable cause, int index, String message,
-      Object... args) {
-    return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  private void parseMethodAnnotations(Type responseType) {
-    for (Annotation annotation : method.getAnnotations()) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError(method, "HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof Headers) {
-        String[] headersToParse = ((Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError(method, "@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
-
-    if (httpMethod == null) {
-      throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-    }
-    if (!hasBody) {
-      if (isMultipart) {
-        throw methodError(method,
-            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-      }
-      if (isFormEncoded) {
-        throw methodError(method,
-            "FormUrlEncoded can only be specified on HTTP methods with request body "
-                + "(e.g., @POST).");
-      }
-    }
-  }
-
-  private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-    if (this.httpMethod != null) {
-      throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
-          this.httpMethod, httpMethod);
-    }
-    this.httpMethod = httpMethod;
-    this.hasBody = hasBody;
-
-    if (value.isEmpty()) {
-      return;
-    }
-
-    // Get the relative URL path and existing query string, if present.
-    int question = value.indexOf('?');
-    if (question != -1 && question < value.length() - 1) {
-      // Ensure the query string does not have any named parameters.
-      String queryParams = value.substring(question + 1);
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-      if (queryParamMatcher.find()) {
-        throw methodError(method, "URL query string \"%s\" must not have replace block. "
-            + "For dynamic query parameters use @Query.", queryParams);
-      }
-    }
-
-    this.relativeUrl = value;
-    this.relativeUrlParamNames = parsePathParameters(value);
-  }
-
-  private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
-    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
-    for (String header : headers) {
-      int colon = header.indexOf(':');
-      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError(method,
-            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-      }
-      String headerName = header.substring(0, colon);
-      String headerValue = header.substring(colon + 1).trim();
-      if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentType = MediaType.parse(headerValue);
-      } else {
-        builder.add(headerName, headerValue);
-      }
-    }
-    return builder.build();
-  }
-
-  private void parseParameters(Retrofit retrofit) {
-    Type[] methodParameterTypes = method.getGenericParameterTypes();
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
-
-    boolean gotField = false;
-    boolean gotPart = false;
-    boolean gotBody = false;
-    boolean gotPath = false;
-    boolean gotQuery = false;
-    boolean gotUrl = false;
-
-    int count = methodParameterAnnotationArrays.length;
-    RequestAction[] requestActions = new RequestAction[count];
-    for (int i = 0; i < count; i++) {
-      Type methodParameterType = methodParameterTypes[i];
-      if (Utils.hasUnresolvableType(methodParameterType)) {
-        throw parameterError(i, "Parameter type must not include a type variable or wildcard: %s",
-            methodParameterType);
-      }
-
-      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
-      if (methodParameterAnnotations != null) {
-        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          RequestAction action = null;
-          if (methodParameterAnnotation instanceof Url) {
-            if (gotUrl) {
-              throw parameterError(i, "Multiple @Url method annotations found.");
-            }
-            if (gotPath) {
-              throw parameterError(i, "@Path parameters may not be used with @Url.");
-            }
-            if (gotQuery) {
-              throw parameterError(i, "A @Url parameter must not come after a @Query");
-            }
-            if (methodParameterType != String.class) {
-              throw parameterError(i, "@Url must be String type.");
-            }
-            if (relativeUrl != null) {
-              throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
-            }
-            gotUrl = true;
-            action = new RequestAction.Url();
-
-          } else if (methodParameterAnnotation instanceof Path) {
-            if (gotQuery) {
-              throw parameterError(i, "A @Path parameter must not come after a @Query.");
-            }
-            if (gotUrl) {
-              throw parameterError(i, "@Path parameters may not be used with @Url.");
-            }
-            if (relativeUrl == null) {
-              throw parameterError(i, "@Path can only be used with relative url on @%s",
-                  httpMethod);
-            }
-            gotPath = true;
-
-            Path path = (Path) methodParameterAnnotation;
-            String name = path.value();
-            validatePathName(i, name);
-
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-            action = new RequestAction.Path<>(name, valueConverter, path.encoded());
-
-          } else if (methodParameterAnnotation instanceof Query) {
-            Query query = (Query) methodParameterAnnotation;
-            String name = query.value();
-            boolean encoded = query.encoded();
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded).array();
-            } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Query<>(name, valueConverter, encoded);
-            }
-
-            gotQuery = true;
-
-          } else if (methodParameterAnnotation instanceof QueryMap) {
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@QueryMap parameter type must be Map.");
-            }
-            if (!(methodParameterType instanceof ParameterizedType)) {
-              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (String.class != keyType) {
-              throw parameterError(i, "@QueryMap keys must be of type String: " + keyType);
-            }
-            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(valueType, methodParameterAnnotations);
-
-            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
-            action = new RequestAction.QueryMap<>(valueConverter, queryMap.encoded());
-
-          } else if (methodParameterAnnotation instanceof Header) {
-            Header header = (Header) methodParameterAnnotation;
-            String name = header.value();
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter).array();
-            } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Header<>(name, valueConverter);
-            }
-
-          } else if (methodParameterAnnotation instanceof Field) {
-            if (!isFormEncoded) {
-              throw parameterError(i, "@Field parameters can only be used with form encoding.");
-            }
-            Field field = (Field) methodParameterAnnotation;
-            String name = field.value();
-            boolean encoded = field.encoded();
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded).array();
-            } else {
-              Converter<?, String> valueConverter =
-                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Field<>(name, valueConverter, encoded);
-            }
-
-            gotField = true;
-
-          } else if (methodParameterAnnotation instanceof FieldMap) {
-            if (!isFormEncoded) {
-              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@FieldMap parameter type must be Map.");
-            }
-            if (!(methodParameterType instanceof ParameterizedType)) {
-              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (String.class != keyType) {
-              throw parameterError(i, "@FieldMap keys must be of type String: " + keyType);
-            }
-            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-            Converter<?, String> valueConverter =
-                retrofit.stringConverter(valueType, methodParameterAnnotations);
-
-            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
-            action = new RequestAction.FieldMap<>(valueConverter, fieldMap.encoded());
-            gotField = true;
-
-          } else if (methodParameterAnnotation instanceof Part) {
-            if (!isMultipart) {
-              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
-            }
-            Part part = (Part) methodParameterAnnotation;
-            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
-                "Content-Transfer-Encoding", part.encoding());
-
-            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
-            if (Iterable.class.isAssignableFrom(rawParameterType)) {
-              if (!(methodParameterType instanceof ParameterizedType)) {
-                throw parameterError(i, rawParameterType.getSimpleName()
-                    + " must include generic type (e.g., "
-                    + rawParameterType.getSimpleName()
-                    + "<String>)");
-              }
-              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(iterableType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter).iterable();
-            } else if (rawParameterType.isArray()) {
-              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(arrayComponentType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter).array();
-            } else {
-              Converter<?, RequestBody> valueConverter =
-                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
-              action = new RequestAction.Part<>(headers, valueConverter);
-            }
-
-            gotPart = true;
-
-          } else if (methodParameterAnnotation instanceof PartMap) {
-            if (!isMultipart) {
-              throw parameterError(i,
-                  "@PartMap parameters can only be used with multipart encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@PartMap parameter type must be Map.");
-            }
-            if (!(methodParameterType instanceof ParameterizedType)) {
-              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
-            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (String.class != keyType) {
-              throw parameterError(i, "@PartMap keys must be of type String: " + keyType);
-            }
-            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-            Converter<?, RequestBody> valueConverter =
-                retrofit.requestBodyConverter(valueType, methodParameterAnnotations);
-
-            PartMap partMap = (PartMap) methodParameterAnnotation;
-            action = new RequestAction.PartMap<>(valueConverter, partMap.encoding());
-            gotPart = true;
-
-          } else if (methodParameterAnnotation instanceof Body) {
-            if (isFormEncoded || isMultipart) {
-              throw parameterError(i,
-                  "@Body parameters cannot be used with form or multi-part encoding.");
-            }
-            if (gotBody) {
-              throw parameterError(i, "Multiple @Body method annotations found.");
-            }
-
-            Converter<?, RequestBody> converter;
-            try {
-              converter =
-                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
-            } catch (RuntimeException e) { // Wide exception range because factories are user code.
-              throw parameterError(e, i, "Unable to create @Body converter for %s",
-                  methodParameterType);
-            }
-            action = new RequestAction.Body<>(converter);
-            gotBody = true;
-          }
-
-          if (action != null) {
-            if (requestActions[i] != null) {
-              throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
-            }
-            requestActions[i] = action;
-          }
-        }
-      }
-
-      if (requestActions[i] == null) {
-        throw parameterError(i, "No Retrofit annotation found.");
-      }
-    }
-
-    if (relativeUrl == null && !gotUrl) {
-      throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
-    }
-    if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-      throw methodError(method, "Non-body HTTP method cannot contain @Body.");
-    }
-    if (isFormEncoded && !gotField) {
-      throw methodError(method, "Form-encoded method must contain at least one @Field.");
-    }
-    if (isMultipart && !gotPart) {
-      throw methodError(method, "Multipart method must contain at least one @Part.");
-    }
-
-    this.requestActions = requestActions;
-  }
-
-  private void validatePathName(int index, String name) {
-    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
-          PARAM_URL_REGEX.pattern(), name);
-    }
-    // Verify URL replacement name is actually present in the URL path.
-    if (!relativeUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 276a57b78..a0efab014 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -15,19 +15,35 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.ResponseBody;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
 
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
   public static <T> Response<T> success(T body) {
-    return success(body, new com.squareup.okhttp.Response.Builder() //
+    return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
         .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
+        .request(new Request.Builder().url("http://localhost/").build())
+        .build());
+  }
+
+  /**
+   * Create a synthetic successful response using {@code headers} with {@code body} as the
+   * deserialized body.
+   */
+  public static <T> Response<T> success(T body, Headers headers) {
+    if (headers == null) throw new NullPointerException("headers == null");
+    return success(body, new okhttp3.Response.Builder() //
+        .code(200)
+        .message("OK")
+        .protocol(Protocol.HTTP_1_1)
+        .headers(headers)
+        .request(new Request.Builder().url("http://localhost/").build())
         .build());
   }
 
@@ -35,7 +51,7 @@
    * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
    * body.
    */
-  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
+  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
     if (rawResponse == null) throw new NullPointerException("rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
@@ -49,15 +65,15 @@
    */
   public static <T> Response<T> error(int code, ResponseBody body) {
     if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
-    return error(body, new com.squareup.okhttp.Response.Builder() //
+    return error(body, new okhttp3.Response.Builder() //
         .code(code)
         .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
+        .request(new Request.Builder().url("http://localhost/").build())
         .build());
   }
 
   /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
-  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
+  public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
     if (body == null) throw new NullPointerException("body == null");
     if (rawResponse == null) throw new NullPointerException("rawResponse == null");
     if (rawResponse.isSuccessful()) {
@@ -66,18 +82,18 @@
     return new Response<>(rawResponse, null, body);
   }
 
-  private final com.squareup.okhttp.Response rawResponse;
+  private final okhttp3.Response rawResponse;
   private final T body;
   private final ResponseBody errorBody;
 
-  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
     this.rawResponse = rawResponse;
     this.body = body;
     this.errorBody = errorBody;
   }
 
   /** The raw response from the HTTP client. */
-  public com.squareup.okhttp.Response raw() {
+  public okhttp3.Response raw() {
     return rawResponse;
   }
 
@@ -96,18 +112,22 @@ public Headers headers() {
     return rawResponse.headers();
   }
 
-  /** {@code true} if {@link #code()} is in the range [200..300). */
-  public boolean isSuccess() {
+  /** Returns true if {@link #code()} is in the range [200..300). */
+  public boolean isSuccessful() {
     return rawResponse.isSuccessful();
   }
 
-  /** The deserialized response body of a {@linkplain #isSuccess() successful} response. */
+  /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
   public T body() {
     return body;
   }
 
-  /** The raw response body of an {@linkplain #isSuccess() unsuccessful} response. */
+  /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
   public ResponseBody errorBody() {
     return errorBody;
   }
+
+  @Override public String toString() {
+    return rawResponse.toString();
+  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index ed04166a2..e7659c5cd 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -15,102 +15,114 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import retrofit2.http.GET;
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
+import retrofit2.http.Url;
 
+import static java.util.Collections.unmodifiableList;
 import static retrofit2.Utils.checkNotNull;
 
 /**
- * Adapts a Java interface to a REST API.
+ * Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to
+ * define how requests are made. Create instances using {@linkplain Builder
+ * the builder} and pass your interface to {@link #create} to generate an implementation.
  * <p>
- * API endpoints are defined as methods on an interface with annotations providing metadata about
- * the form in which the HTTP call should be made.
- * <p>
- * The relative path for a given method is obtained from an annotation on the method describing
- * the request type. The built-in methods are {@link retrofit2.http.GET GET},
- * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
- * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
- * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with {@link HTTP @HTTP}.
- * <p>
- * Method parameters can be used to replace parts of the URL by annotating them with
- * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
- * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit2.http.Query @Query}.
- * <p>
- * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The object
- * will be converted to request representation by one of the {@link Converter.Factory} instances.
- * A {@link RequestBody} can also be used for a raw representation.
- * <p>
- * Alternative request body formats are supported by method annotations and corresponding parameter
- * annotations:
- * <ul>
- * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
- * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
- * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with parts
- * specified by the {@link retrofit2.http.Part @Part} parameter annotation.
- * </ul>
- * <p>
- * Additional static headers can be added for an endpoint using the
- * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a header
- * annotate a parameter with {@link Header @Header}.
- * <p>
- * By default, methods return a {@link Call} which represents the HTTP request. The generic
- * parameter of the call is the response body type and will be converted by one of the
- * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
- * representation. {@link Void} can be used if you do not care about the body contents.
- * <p>
- * For example:
- * <pre>
- * public interface CategoryService {
- *   &#64;POST("/category/{cat}")
- *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
- * }
- * </pre>
- * <p>
- * Calling {@link #create(Class) create()} with {@code CategoryService.class} will validate the
- * annotations and create a new implementation of the service definition.
+ * For example,
+ * <pre><code>
+ * Retrofit retrofit = new Retrofit.Builder()
+ *     .baseUrl("https://api.example.com/")
+ *     .addConverterFactory(GsonConverterFactory.create())
+ *     .build();
+ *
+ * MyApi api = retrofit.create(MyApi.class);
+ * Response&lt;User&gt; user = api.getUser().execute();
+ * </code></pre>
  *
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, MethodHandler<?>> methodHandlerCache = new LinkedHashMap<>();
+  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
 
-  private final OkHttpClient client;
-  private final BaseUrl baseUrl;
+  private final okhttp3.Call.Factory callFactory;
+  private final HttpUrl baseUrl;
   private final List<Converter.Factory> converterFactories;
   private final List<CallAdapter.Factory> adapterFactories;
   private final Executor callbackExecutor;
   private final boolean validateEagerly;
 
-  private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
-      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
-      boolean validateEagerly) {
-    this.client = client;
+  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+      Executor callbackExecutor, boolean validateEagerly) {
+    this.callFactory = callFactory;
     this.baseUrl = baseUrl;
-    this.converterFactories = converterFactories;
-    this.adapterFactories = adapterFactories;
+    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
+    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
     this.callbackExecutor = callbackExecutor;
     this.validateEagerly = validateEagerly;
   }
 
-  /** Create an implementation of the API defined by the {@code service} interface. */
+  /**
+   * Create an implementation of the API endpoints defined by the {@code service} interface.
+   * <p>
+   * The relative path for a given method is obtained from an annotation on the method describing
+   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+   * parameter with {@link Url @Url}.
+   * <p>
+   * Method parameters can be used to replace parts of the URL by annotating them with
+   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+   * {@link retrofit2.http.Query @Query}.
+   * <p>
+   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+   * object will be converted to request representation by one of the {@link Converter.Factory}
+   * instances. A {@link RequestBody} can also be used for a raw representation.
+   * <p>
+   * Alternative request body formats are supported by method annotations and corresponding
+   * parameter annotations:
+   * <ul>
+   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+   * </ul>
+   * <p>
+   * Additional static headers can be added for an endpoint using the
+   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+   * header annotate a parameter with {@link Header @Header}.
+   * <p>
+   * By default, methods return a {@link Call} which represents the HTTP request. The generic
+   * parameter of the call is the response body type and will be converted by one of the
+   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+   * representation. {@link Void} can be used if you do not care about the body contents.
+   * <p>
+   * For example:
+   * <pre>
+   * public interface CategoryService {
+   *   &#64;POST("category/{cat}/")
+   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+   * }
+   * </pre>
+   */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
     Utils.validateServiceInterface(service);
@@ -130,7 +142,10 @@ private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> c
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            return loadMethodHandler(method).invoke(args);
+            ServiceMethod<Object, Object> serviceMethod =
+                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            return serviceMethod.callAdapter.adapt(okHttpCall);
           }
         });
   }
@@ -139,33 +154,44 @@ private void eagerlyValidateMethods(Class<?> service) {
     Platform platform = Platform.get();
     for (Method method : service.getDeclaredMethods()) {
       if (!platform.isDefaultMethod(method)) {
-        loadMethodHandler(method);
+        loadServiceMethod(method);
       }
     }
   }
 
-  MethodHandler<?> loadMethodHandler(Method method) {
-    MethodHandler<?> handler;
-    synchronized (methodHandlerCache) {
-      handler = methodHandlerCache.get(method);
-      if (handler == null) {
-        handler = MethodHandler.create(this, method);
-        methodHandlerCache.put(method, handler);
+  ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+    if (result != null) return result;
+
+    synchronized (serviceMethodCache) {
+      result = serviceMethodCache.get(method);
+      if (result == null) {
+        result = new ServiceMethod.Builder<>(this, method).build();
+        serviceMethodCache.put(method, result);
       }
     }
-    return handler;
+    return result;
   }
 
-  public OkHttpClient client() {
-    return client;
+  /**
+   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+   * Typically an instance of {@link OkHttpClient}.
+   */
+  public okhttp3.Call.Factory callFactory() {
+    return callFactory;
   }
 
-  public BaseUrl baseUrl() {
+  /** The API base URL. */
+  public HttpUrl baseUrl() {
     return baseUrl;
   }
 
+  /**
+   * Returns a list of the factories tried when creating a
+   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+   */
   public List<CallAdapter.Factory> callAdapterFactories() {
-    return Collections.unmodifiableList(adapterFactories);
+    return adapterFactories;
   }
 
   /**
@@ -174,7 +200,7 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
     return nextCallAdapter(null, returnType, annotations);
   }
 
@@ -184,14 +210,14 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
     checkNotNull(returnType, "returnType == null");
     checkNotNull(annotations, "annotations == null");
 
     int start = adapterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
       if (adapter != null) {
         return adapter;
       }
@@ -199,24 +225,29 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
         .append(returnType)
-        .append(". Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
 
   /**
-   * TODO
+   * Returns a list of the factories tried when creating a
+   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
    */
   public List<Converter.Factory> converterFactories() {
-    return Collections.unmodifiableList(converterFactories);
+    return converterFactories;
   }
 
   /**
@@ -225,8 +256,9 @@ public BaseUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type, Annotation[] annotations) {
-    return nextRequestBodyConverter(null, type, annotations);
+  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
   }
 
   /**
@@ -236,14 +268,16 @@ public BaseUrl baseUrl() {
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
   public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
     checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
+    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+    checkNotNull(methodAnnotations, "methodAnnotations == null");
 
     int start = converterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter.Factory factory = converterFactories.get(i);
       Converter<?, RequestBody> converter =
-          converterFactories.get(i).requestBodyConverter(type, annotations, this);
+          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, RequestBody>) converter;
@@ -252,15 +286,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
         .append(type)
-        .append(". Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -298,15 +334,17 @@ public BaseUrl baseUrl() {
 
     StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
         .append(type)
-        .append(". Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
-    }
+        .append(".\n");
     if (skipPast != null) {
-      builder.append("\nSkipped:");
+      builder.append("  Skipped:");
       for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
       }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
     }
     throw new IllegalArgumentException(builder.toString());
   }
@@ -321,7 +359,7 @@ public BaseUrl baseUrl() {
 
     for (int i = 0, count = converterFactories.size(); i < count; i++) {
       Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations);
+          converterFactories.get(i).stringConverter(type, annotations, this);
       if (converter != null) {
         //noinspection unchecked
         return (Converter<T, String>) converter;
@@ -333,6 +371,10 @@ public BaseUrl baseUrl() {
     return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
   }
 
+  /**
+   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+   * in which case callbacks should be made synchronously on the background thread.
+   */
   public Executor callbackExecutor() {
     return callbackExecutor;
   }
@@ -344,27 +386,50 @@ public Executor callbackExecutor() {
    * are optional.
    */
   public static final class Builder {
-    private OkHttpClient client;
-    private BaseUrl baseUrl;
+    private Platform platform;
+    private okhttp3.Call.Factory callFactory;
+    private HttpUrl baseUrl;
     private List<Converter.Factory> converterFactories = new ArrayList<>();
     private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
     private Executor callbackExecutor;
     private boolean validateEagerly;
 
-    public Builder() {
+    Builder(Platform platform) {
+      this.platform = platform;
       // Add the built-in converter factory first. This prevents overriding its behavior but also
       // ensures correct behavior when using converters that consume all types.
       converterFactories.add(new BuiltInConverters());
     }
 
-    /** The HTTP client used for requests. */
+    public Builder() {
+      this(Platform.get());
+    }
+
+    /**
+     * The HTTP client used for requests.
+     * <p>
+     * This is a convenience method for calling {@link #callFactory}.
+     * <p>
+     * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
+     * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
+     * instance to prevent this if desired.
+     */
     public Builder client(OkHttpClient client) {
-      this.client = checkNotNull(client, "client == null");
+      return callFactory(checkNotNull(client, "client == null"));
+    }
+
+    /**
+     * Specify a custom call factory for creating {@link Call} instances.
+     * <p>
+     * Note: Calling {@link #client} automatically sets this value.
+     */
+    public Builder callFactory(okhttp3.Call.Factory factory) {
+      this.callFactory = checkNotNull(factory, "factory == null");
       return this;
     }
 
     /**
-     * Set a fixed API base URL.
+     * Set the API base URL.
      *
      * @see #baseUrl(HttpUrl)
      */
@@ -378,7 +443,7 @@ public Builder baseUrl(String baseUrl) {
     }
 
     /**
-     * Set a fixed API base URL.
+     * Set the API base URL.
      * <p>
      * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
      * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
@@ -427,37 +492,25 @@ public Builder baseUrl(String baseUrl) {
      * Endpoint: //github.com/square/retrofit/<br>
      * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
      */
-    public Builder baseUrl(final HttpUrl baseUrl) {
+    public Builder baseUrl(HttpUrl baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
       List<String> pathSegments = baseUrl.pathSegments();
       if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
         throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
       }
-      return baseUrl(new BaseUrl() {
-        @Override public HttpUrl url() {
-          return baseUrl;
-        }
-      });
-    }
-
-    /**
-     * Set an API base URL which can change over time.
-     *
-     * @see #baseUrl(HttpUrl)
-     */
-    public Builder baseUrl(BaseUrl baseUrl) {
-      this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
+      this.baseUrl = baseUrl;
       return this;
     }
 
     /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory converterFactory) {
-      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
+    public Builder addConverterFactory(Converter.Factory factory) {
+      converterFactories.add(checkNotNull(factory, "factory == null"));
       return this;
     }
 
     /**
-     * TODO
+     * Add a call adapter factory for supporting service method return types other than {@link
+     * Call}.
      */
     public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
       adapterFactories.add(checkNotNull(factory, "factory == null"));
@@ -467,9 +520,12 @@ public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
     /**
      * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
      * your service method.
+     * <p>
+     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+     * return types}.
      */
-    public Builder callbackExecutor(Executor callbackExecutor) {
-      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
+    public Builder callbackExecutor(Executor executor) {
+      this.callbackExecutor = checkNotNull(executor, "executor == null");
       return this;
     }
 
@@ -482,26 +538,36 @@ public Builder validateEagerly(boolean validateEagerly) {
       return this;
     }
 
-    /** Create the {@link Retrofit} instances. */
+    /**
+     * Create the {@link Retrofit} instance using the configured values.
+     * <p>
+     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+     * OkHttpClient} will be created and used.
+     */
     public Retrofit build() {
       if (baseUrl == null) {
         throw new IllegalStateException("Base URL required.");
       }
 
-      OkHttpClient client = this.client;
-      if (client == null) {
-        client = new OkHttpClient();
+      okhttp3.Call.Factory callFactory = this.callFactory;
+      if (callFactory == null) {
+        callFactory = new OkHttpClient();
+      }
+
+      Executor callbackExecutor = this.callbackExecutor;
+      if (callbackExecutor == null) {
+        callbackExecutor = platform.defaultCallbackExecutor();
       }
 
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
 
       // Make a defensive copy of the converters.
       List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
 
-      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
-          validateEagerly);
+      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
+          callbackExecutor, validateEagerly);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
new file mode 100644
index 000000000..3a4325a7e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -0,0 +1,758 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.Body;
+import retrofit2.http.DELETE;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.HEAD;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Multipart;
+import retrofit2.http.OPTIONS;
+import retrofit2.http.PATCH;
+import retrofit2.http.POST;
+import retrofit2.http.PUT;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+import retrofit2.http.Url;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+final class ServiceMethod<R, T> {
+  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+  final okhttp3.Call.Factory callFactory;
+  final CallAdapter<R, T> callAdapter;
+
+  private final HttpUrl baseUrl;
+  private final Converter<ResponseBody, R> responseConverter;
+  private final String httpMethod;
+  private final String relativeUrl;
+  private final Headers headers;
+  private final MediaType contentType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final ParameterHandler<?>[] parameterHandlers;
+
+  ServiceMethod(Builder<R, T> builder) {
+    this.callFactory = builder.retrofit.callFactory();
+    this.callAdapter = builder.callAdapter;
+    this.baseUrl = builder.retrofit.baseUrl();
+    this.responseConverter = builder.responseConverter;
+    this.httpMethod = builder.httpMethod;
+    this.relativeUrl = builder.relativeUrl;
+    this.headers = builder.headers;
+    this.contentType = builder.contentType;
+    this.hasBody = builder.hasBody;
+    this.isFormEncoded = builder.isFormEncoded;
+    this.isMultipart = builder.isMultipart;
+    this.parameterHandlers = builder.parameterHandlers;
+  }
+
+  /** Builds an HTTP request from method arguments. */
+  Request toRequest(Object... args) throws IOException {
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+        contentType, hasBody, isFormEncoded, isMultipart);
+
+    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
+
+    int argumentCount = args != null ? args.length : 0;
+    if (argumentCount != handlers.length) {
+      throw new IllegalArgumentException("Argument count (" + argumentCount
+          + ") doesn't match expected count (" + handlers.length + ")");
+    }
+
+    for (int p = 0; p < argumentCount; p++) {
+      handlers[p].apply(requestBuilder, args[p]);
+    }
+
+    return requestBuilder.build();
+  }
+
+  /** Builds a method return value from an HTTP response body. */
+  R toResponse(ResponseBody body) throws IOException {
+    return responseConverter.convert(body);
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder<T, R> {
+    final Retrofit retrofit;
+    final Method method;
+    final Annotation[] methodAnnotations;
+    final Annotation[][] parameterAnnotationsArray;
+    final Type[] parameterTypes;
+
+    Type responseType;
+    boolean gotField;
+    boolean gotPart;
+    boolean gotBody;
+    boolean gotPath;
+    boolean gotQuery;
+    boolean gotUrl;
+    String httpMethod;
+    boolean hasBody;
+    boolean isFormEncoded;
+    boolean isMultipart;
+    String relativeUrl;
+    Headers headers;
+    MediaType contentType;
+    Set<String> relativeUrlParamNames;
+    ParameterHandler<?>[] parameterHandlers;
+    Converter<ResponseBody, T> responseConverter;
+    CallAdapter<T, R> callAdapter;
+
+    public Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+      this.methodAnnotations = method.getAnnotations();
+      this.parameterTypes = method.getGenericParameterTypes();
+      this.parameterAnnotationsArray = method.getParameterAnnotations();
+    }
+
+    public ServiceMethod build() {
+      callAdapter = createCallAdapter();
+      responseType = callAdapter.responseType();
+      if (responseType == Response.class || responseType == okhttp3.Response.class) {
+        throw methodError("'"
+            + Utils.getRawType(responseType).getName()
+            + "' is not a valid response body type. Did you mean ResponseBody?");
+      }
+      responseConverter = createResponseConverter();
+
+      for (Annotation annotation : methodAnnotations) {
+        parseMethodAnnotation(annotation);
+      }
+
+      if (httpMethod == null) {
+        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+      }
+
+      if (!hasBody) {
+        if (isMultipart) {
+          throw methodError(
+              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+        }
+        if (isFormEncoded) {
+          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+              + "request body (e.g., @POST).");
+        }
+      }
+
+      int parameterCount = parameterAnnotationsArray.length;
+      parameterHandlers = new ParameterHandler<?>[parameterCount];
+      for (int p = 0; p < parameterCount; p++) {
+        Type parameterType = parameterTypes[p];
+        if (Utils.hasUnresolvableType(parameterType)) {
+          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+              parameterType);
+        }
+
+        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+        if (parameterAnnotations == null) {
+          throw parameterError(p, "No Retrofit annotation found.");
+        }
+
+        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+      }
+
+      if (relativeUrl == null && !gotUrl) {
+        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+      }
+      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+        throw methodError("Non-body HTTP method cannot contain @Body.");
+      }
+      if (isFormEncoded && !gotField) {
+        throw methodError("Form-encoded method must contain at least one @Field.");
+      }
+      if (isMultipart && !gotPart) {
+        throw methodError("Multipart method must contain at least one @Part.");
+      }
+
+      return new ServiceMethod<>(this);
+    }
+
+    private CallAdapter<T, R> createCallAdapter() {
+      Type returnType = method.getGenericReturnType();
+      if (Utils.hasUnresolvableType(returnType)) {
+        throw methodError(
+            "Method return type must not include a type variable or wildcard: %s", returnType);
+      }
+      if (returnType == void.class) {
+        throw methodError("Service methods cannot return void.");
+      }
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        //noinspection unchecked
+        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, "Unable to create call adapter for %s", returnType);
+      }
+    }
+
+    private void parseMethodAnnotation(Annotation annotation) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+        if (!Void.class.equals(responseType)) {
+          throw methodError("HEAD method must use Void as response type.");
+        }
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof OPTIONS) {
+        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof retrofit2.http.Headers) {
+        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError("@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError("Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError("Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+      if (this.httpMethod != null) {
+        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+            this.httpMethod, httpMethod);
+      }
+      this.httpMethod = httpMethod;
+      this.hasBody = hasBody;
+
+      if (value.isEmpty()) {
+        return;
+      }
+
+      // Get the relative URL path and existing query string, if present.
+      int question = value.indexOf('?');
+      if (question != -1 && question < value.length() - 1) {
+        // Ensure the query string does not have any named parameters.
+        String queryParams = value.substring(question + 1);
+        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+        if (queryParamMatcher.find()) {
+          throw methodError("URL query string \"%s\" must not have replace block. "
+              + "For dynamic query parameters use @Query.", queryParams);
+        }
+      }
+
+      this.relativeUrl = value;
+      this.relativeUrlParamNames = parsePathParameters(value);
+    }
+
+    private Headers parseHeaders(String[] headers) {
+      Headers.Builder builder = new Headers.Builder();
+      for (String header : headers) {
+        int colon = header.indexOf(':');
+        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+          throw methodError(
+              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        }
+        String headerName = header.substring(0, colon);
+        String headerValue = header.substring(colon + 1).trim();
+        if ("Content-Type".equalsIgnoreCase(headerName)) {
+          MediaType type = MediaType.parse(headerValue);
+          if (type == null) {
+            throw methodError("Malformed content type: %s", headerValue);
+          }
+          contentType = type;
+        } else {
+          builder.add(headerName, headerValue);
+        }
+      }
+      return builder.build();
+    }
+
+    private ParameterHandler<?> parseParameter(
+        int p, Type parameterType, Annotation[] annotations) {
+      ParameterHandler<?> result = null;
+      for (Annotation annotation : annotations) {
+        ParameterHandler<?> annotationAction = parseParameterAnnotation(
+            p, parameterType, annotations, annotation);
+
+        if (annotationAction == null) {
+          continue;
+        }
+
+        if (result != null) {
+          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+        }
+
+        result = annotationAction;
+      }
+
+      if (result == null) {
+        throw parameterError(p, "No Retrofit annotation found.");
+      }
+
+      return result;
+    }
+
+    private ParameterHandler<?> parseParameterAnnotation(
+        int p, Type type, Annotation[] annotations, Annotation annotation) {
+      if (annotation instanceof Url) {
+        if (gotUrl) {
+          throw parameterError(p, "Multiple @Url method annotations found.");
+        }
+        if (gotPath) {
+          throw parameterError(p, "@Path parameters may not be used with @Url.");
+        }
+        if (gotQuery) {
+          throw parameterError(p, "A @Url parameter must not come after a @Query");
+        }
+        if (relativeUrl != null) {
+          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+        }
+
+        gotUrl = true;
+
+        if (type == HttpUrl.class
+            || type == String.class
+            || type == URI.class
+            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+          return new ParameterHandler.RelativeUrl();
+        } else {
+          throw parameterError(p,
+              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        }
+
+      } else if (annotation instanceof Path) {
+        if (gotQuery) {
+          throw parameterError(p, "A @Path parameter must not come after a @Query.");
+        }
+        if (gotUrl) {
+          throw parameterError(p, "@Path parameters may not be used with @Url.");
+        }
+        if (relativeUrl == null) {
+          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+        }
+        gotPath = true;
+
+        Path path = (Path) annotation;
+        String name = path.value();
+        validatePathName(p, name);
+
+        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+        return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+      } else if (annotation instanceof Query) {
+        Query query = (Query) annotation;
+        String name = query.value();
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@QueryMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+      } else if (annotation instanceof Header) {
+        Header header = (Header) annotation;
+        String name = header.value();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Header<>(name, converter).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Header<>(name, converter).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Header<>(name, converter);
+        }
+
+      } else if (annotation instanceof HeaderMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@HeaderMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.HeaderMap<>(valueConverter);
+
+      } else if (annotation instanceof Field) {
+        if (!isFormEncoded) {
+          throw parameterError(p, "@Field parameters can only be used with form encoding.");
+        }
+        Field field = (Field) annotation;
+        String name = field.value();
+        boolean encoded = field.encoded();
+
+        gotField = true;
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof FieldMap) {
+        if (!isFormEncoded) {
+          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+        }
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@FieldMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        gotField = true;
+        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+      } else if (annotation instanceof Part) {
+        if (!isMultipart) {
+          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+        }
+        Part part = (Part) annotation;
+        gotPart = true;
+
+        String partName = part.value();
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (partName.isEmpty()) {
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = rawParameterType.getComponentType();
+            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            return ParameterHandler.RawPart.INSTANCE;
+          } else {
+            throw parameterError(p,
+                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+          }
+        } else {
+          Headers headers =
+              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                  "Content-Transfer-Encoding", part.encoding());
+
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                  + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                  + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                + "include a part name in the annotation.");
+          } else {
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter);
+          }
+        }
+
+      } else if (annotation instanceof PartMap) {
+        if (!isMultipart) {
+          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+        }
+        gotPart = true;
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@PartMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+        }
+
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+              + "Use @Part List<Part> or a different value type instead.");
+        }
+
+        Converter<?, RequestBody> valueConverter =
+            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+        PartMap partMap = (PartMap) annotation;
+        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+      } else if (annotation instanceof Body) {
+        if (isFormEncoded || isMultipart) {
+          throw parameterError(p,
+              "@Body parameters cannot be used with form or multi-part encoding.");
+        }
+        if (gotBody) {
+          throw parameterError(p, "Multiple @Body method annotations found.");
+        }
+
+        Converter<?, RequestBody> converter;
+        try {
+          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+        } catch (RuntimeException e) {
+          // Wide exception range because factories are user code.
+          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+        }
+        gotBody = true;
+        return new ParameterHandler.Body<>(converter);
+      }
+
+      return null; // Not a Retrofit annotation.
+    }
+
+    private void validatePathName(int p, String name) {
+      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+            PARAM_URL_REGEX.pattern(), name);
+      }
+      // Verify URL replacement name is actually present in the URL path.
+      if (!relativeUrlParamNames.contains(name)) {
+        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+      }
+    }
+
+    private Converter<ResponseBody, T> createResponseConverter() {
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        return retrofit.responseBodyConverter(responseType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, "Unable to create converter for %s", responseType);
+      }
+    }
+
+    private RuntimeException methodError(String message, Object... args) {
+      return methodError(null, message, args);
+    }
+
+    private RuntimeException methodError(Throwable cause, String message, Object... args) {
+      message = String.format(message, args);
+      return new IllegalArgumentException(message
+          + "\n    for method "
+          + method.getDeclaringClass().getSimpleName()
+          + "."
+          + method.getName(), cause);
+    }
+
+    private RuntimeException parameterError(
+        Throwable cause, int p, String message, Object... args) {
+      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
+    }
+
+    private RuntimeException parameterError(int p, String message, Object... args) {
+      return methodError(message + " (parameter #" + (p + 1) + ")", args);
+    }
+  }
+
+  /**
+   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+   * in the URI, it will only show up once in the set.
+   */
+  static Set<String> parsePathParameters(String path) {
+    Matcher m = PARAM_URL_REGEX.matcher(path);
+    Set<String> patterns = new LinkedHashSet<>();
+    while (m.find()) {
+      patterns.add(m.group(1));
+    }
+    return patterns;
+  }
+
+  static Class<?> boxIfPrimitive(Class<?> type) {
+    if (boolean.class == type) return Boolean.class;
+    if (byte.class == type) return Byte.class;
+    if (char.class == type) return Character.class;
+    if (double.class == type) return Double.class;
+    if (float.class == type) return Float.class;
+    if (int.class == type) return Integer.class;
+    if (long.class == type) return Long.class;
+    if (short.class == type) return Short.class;
+    return type;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index bb0ac907e..09ab09064 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -1,12 +1,11 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2007 The Guava Authors
+ * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -16,24 +15,271 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.Closeable;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Method;
+import java.lang.reflect.GenericDeclaration;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
+import java.util.NoSuchElementException;
+import okhttp3.ResponseBody;
 import okio.Buffer;
-import okio.BufferedSource;
-import okio.Source;
 
 final class Utils {
+  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+  private Utils() {
+    // No instances.
+  }
+
+  static Class<?> getRawType(Type type) {
+    if (type == null) throw new NullPointerException("type == null");
+
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+    }
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+    }
+    if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+    }
+    if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+    }
+    if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+    }
+
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+  }
+
+  /** Returns true if {@code a} and {@code b} are equal. */
+  static boolean equals(Type a, Type b) {
+    if (a == b) {
+      return true; // Also handles (a == null && b == null).
+
+    } else if (a instanceof Class) {
+      return a.equals(b); // Class already specifies equals().
+
+    } else if (a instanceof ParameterizedType) {
+      if (!(b instanceof ParameterizedType)) return false;
+      ParameterizedType pa = (ParameterizedType) a;
+      ParameterizedType pb = (ParameterizedType) b;
+      return equal(pa.getOwnerType(), pb.getOwnerType())
+          && pa.getRawType().equals(pb.getRawType())
+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+    } else if (a instanceof GenericArrayType) {
+      if (!(b instanceof GenericArrayType)) return false;
+      GenericArrayType ga = (GenericArrayType) a;
+      GenericArrayType gb = (GenericArrayType) b;
+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+    } else if (a instanceof WildcardType) {
+      if (!(b instanceof WildcardType)) return false;
+      WildcardType wa = (WildcardType) a;
+      WildcardType wb = (WildcardType) b;
+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+    } else if (a instanceof TypeVariable) {
+      if (!(b instanceof TypeVariable)) return false;
+      TypeVariable<?> va = (TypeVariable<?>) a;
+      TypeVariable<?> vb = (TypeVariable<?>) b;
+      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+          && va.getName().equals(vb.getName());
+
+    } else {
+      return false; // This isn't a type we support!
+    }
+  }
+
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) return context;
+
+    // We skip searching through interfaces if unknown is an interface.
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // Check our supertypes.
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // We can't resolve this further.
+    return toResolve;
+  }
+
+  private static int indexOf(Object[] array, Object toFind) {
+    for (int i = 0; i < array.length; i++) {
+      if (toFind.equals(array[i])) return i;
+    }
+    throw new NoSuchElementException();
+  }
+
+  private static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  static int hashCodeOrZero(Object o) {
+    return o != null ? o.hashCode() : 0;
+  }
+
+  static String typeToString(Type type) {
+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+  }
+
+  /**
+   * Returns the generic form of {@code supertype}. For example, if this is {@code
+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+   * Iterable.class}.
+   *
+   * @param supertype a superclass of, or interface implemented by, this.
+   */
+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+    return resolve(context, contextRawType,
+        getGenericSupertype(context, contextRawType, supertype));
+  }
+
+  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    // This implementation is made a little more complicated in an attempt to avoid object-creation.
+    while (true) {
+      if (toResolve instanceof TypeVariable) {
+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+        if (toResolve == typeVariable) {
+          return toResolve;
+        }
+
+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+        Class<?> original = (Class<?>) toResolve;
+        Type componentType = original.getComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof GenericArrayType) {
+        GenericArrayType original = (GenericArrayType) toResolve;
+        Type componentType = original.getGenericComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof ParameterizedType) {
+        ParameterizedType original = (ParameterizedType) toResolve;
+        Type ownerType = original.getOwnerType();
+        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        boolean changed = newOwnerType != ownerType;
+
+        Type[] args = original.getActualTypeArguments();
+        for (int t = 0, length = args.length; t < length; t++) {
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          if (resolvedTypeArgument != args[t]) {
+            if (!changed) {
+              args = args.clone();
+              changed = true;
+            }
+            args[t] = resolvedTypeArgument;
+          }
+        }
+
+        return changed
+            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+            : original;
+
+      } else if (toResolve instanceof WildcardType) {
+        WildcardType original = (WildcardType) toResolve;
+        Type[] originalLowerBound = original.getLowerBounds();
+        Type[] originalUpperBound = original.getUpperBounds();
+
+        if (originalLowerBound.length == 1) {
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          if (lowerBound != originalLowerBound[0]) {
+            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
+          }
+        } else if (originalUpperBound.length == 1) {
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          if (upperBound != originalUpperBound[0]) {
+            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
+          }
+        }
+        return original;
+
+      } else {
+        return toResolve;
+      }
+    }
+  }
+
+  private static Type resolveTypeVariable(
+      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+    Class<?> declaredByRaw = declaringClassOf(unknown);
+
+    // We can't reduce this further.
+    if (declaredByRaw == null) return unknown;
+
+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+    if (declaredBy instanceof ParameterizedType) {
+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    }
+
+    return unknown;
+  }
+
+  /**
+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+   * a class.
+   */
+  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
+  }
+
+  static void checkNotPrimitive(Type type) {
+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException();
+    }
+  }
+
   static <T> T checkNotNull(T object, String message) {
     if (object == null) {
       throw new NullPointerException(message);
@@ -41,14 +287,6 @@
     return object;
   }
 
-  static void closeQuietly(Closeable closeable) {
-    if (closeable == null) return;
-    try {
-      closeable.close();
-    } catch (IOException ignored) {
-    }
-  }
-
   /** Returns true if {@code annotations} contains an instance of {@code cls}. */
   static boolean isAnnotationPresent(Annotation[] annotations,
       Class<? extends Annotation> cls) {
@@ -60,20 +298,9 @@ static boolean isAnnotationPresent(Annotation[] annotations,
     return false;
   }
 
-  /**
-   * Replace a {@link Response} with an identical copy whose body is backed by a
-   * {@link Buffer} rather than a {@link Source}.
-   */
-  static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws IOException {
-    if (body == null) {
-      return null;
-    }
-
-    BufferedSource source = body.source();
+  static ResponseBody buffer(final ResponseBody body) throws IOException {
     Buffer buffer = new Buffer();
-    buffer.writeAll(source);
-    source.close();
-
+    body.source().readAll(buffer);
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
@@ -89,11 +316,11 @@ static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws I
     }
   }
 
-  public static Type getParameterUpperBound(int index, ParameterizedType type) {
+  static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
-    if (types.length <= index) {
+    if (index < 0 || index >= types.length) {
       throw new IllegalArgumentException(
-          "Expected at least " + index + " type argument(s) but got: " + Arrays.toString(types));
+          "Index " + index + " not in range [0," + types.length + ") for " + type);
     }
     Type paramType = types[index];
     if (paramType instanceof WildcardType) {
@@ -102,7 +329,7 @@ public static Type getParameterUpperBound(int index, ParameterizedType type) {
     return paramType;
   }
 
-  public static boolean hasUnresolvableType(Type type) {
+  static boolean hasUnresolvableType(Type type) {
     if (type instanceof Class<?>) {
       return false;
     }
@@ -129,74 +356,141 @@ public static boolean hasUnresolvableType(Type type) {
         + "GenericArrayType, but <" + type + "> is of type " + className);
   }
 
-  // This method is copyright 2008 Google Inc. and is taken from Gson under the Apache 2.0 license.
-  public static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
+  static Type getCallResponseType(Type returnType) {
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    return getParameterUpperBound(0, (ParameterizedType) returnType);
+  }
 
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
+  private static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final Type ownerType;
+    private final Type rawType;
+    private final Type[] typeArguments;
 
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>
+          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+        throw new IllegalArgumentException();
+      }
 
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
+      this.ownerType = ownerType;
+      this.rawType = rawType;
+      this.typeArguments = typeArguments.clone();
 
-    } else if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
+      for (Type typeArgument : this.typeArguments) {
+        if (typeArgument == null) throw new NullPointerException();
+        checkNotPrimitive(typeArgument);
+      }
+    }
 
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+    @Override public Type[] getActualTypeArguments() {
+      return typeArguments.clone();
+    }
 
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
+    @Override public Type getRawType() {
+      return rawType;
     }
-  }
 
-  static RuntimeException methodError(Method method, String message, Object... args) {
-    return methodError(null, method, message, args);
-  }
+    @Override public Type getOwnerType() {
+      return ownerType;
+    }
 
-  static RuntimeException methodError(Throwable cause, Method method, String message,
-      Object... args) {
-    message = String.format(message, args);
-    IllegalArgumentException e = new IllegalArgumentException(message
-        + "\n    for method "
-        + method.getDeclaringClass().getSimpleName()
-        + "."
-        + method.getName());
-    e.initCause(cause);
-    return e;
+    @Override public boolean equals(Object other) {
+      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    }
 
+    @Override public int hashCode() {
+      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+      result.append(typeToString(rawType));
+      if (typeArguments.length == 0) return result.toString();
+      result.append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < typeArguments.length; i++) {
+        result.append(", ").append(typeToString(typeArguments[i]));
+      }
+      return result.append(">").toString();
+    }
   }
 
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+  private static final class GenericArrayTypeImpl implements GenericArrayType {
+    private final Type componentType;
+
+    public GenericArrayTypeImpl(Type componentType) {
+      this.componentType = componentType;
     }
-    final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    // Ensure the Call response type is not Response, we automatically deliver the Response object.
-    if (getRawType(responseType) == retrofit2.Response.class) {
-      throw new IllegalArgumentException(
-          "Call<T> cannot use Response as its generic parameter. "
-              + "Specify the response body type only (e.g., Call<TweetResponse>).");
+    @Override public Type getGenericComponentType() {
+      return componentType;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof GenericArrayType
+          && Utils.equals(this, (GenericArrayType) o);
+    }
+
+    @Override public int hashCode() {
+      return componentType.hashCode();
+    }
+
+    @Override public String toString() {
+      return typeToString(componentType) + "[]";
     }
-    return responseType;
   }
 
-  private Utils() {
-    // No instances.
+  /**
+   * The WildcardType interface supports multiple upper bounds and multiple
+   * lower bounds. We only support what the Java 6 language needs - at most one
+   * bound. If a lower bound is set, the upper bound must be Object.class.
+   */
+  private static final class WildcardTypeImpl implements WildcardType {
+    private final Type upperBound;
+    private final Type lowerBound;
+
+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+      if (lowerBounds.length > 1) throw new IllegalArgumentException();
+      if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+      if (lowerBounds.length == 1) {
+        if (lowerBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(lowerBounds[0]);
+        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+        this.lowerBound = lowerBounds[0];
+        this.upperBound = Object.class;
+      } else {
+        if (upperBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(upperBounds[0]);
+        this.lowerBound = null;
+        this.upperBound = upperBounds[0];
+      }
+    }
+
+    @Override public Type[] getUpperBounds() {
+      return new Type[] { upperBound };
+    }
+
+    @Override public Type[] getLowerBounds() {
+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+    }
+
+    @Override public int hashCode() {
+      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    }
+
+    @Override public String toString() {
+      if (lowerBound != null) return "? super " + typeToString(lowerBound);
+      if (upperBound == Object.class) return "?";
+      return "? extends " + typeToString(upperBound);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 673a0a528..98d1d8684 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -32,8 +32,6 @@
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
- *
- * @author Eric Denman (edenman@squareup.com)
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/DELETE.java b/retrofit/src/main/java/retrofit2/http/DELETE.java
index c4a7143f0..4a2b3e519 100644
--- a/retrofit/src/main/java/retrofit2/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit2/http/DELETE.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 9c6d354c8..4dbd1bf11 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -30,22 +30,22 @@
  * field pair for each non-{@code null} item.
  * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/")
- * Call&lt;ResponseBody> example(
+ * Call&lt;ResponseBody&gt; example(
  *     &#64;Field("name") String name,
  *     &#64;Field("occupation") String occupation);
- * }</pre>
+ * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
  * <p>
  * Array/Varargs Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/list")
- * Call&lt;ResponseBody> example(@Field("name") String... names);
- * }</pre>
+ * Call&lt;ResponseBody&gt; example(@Field("name") String... names);
+ * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "Jane Doe")} yields a request body of
  * {@code name=Bob+Smith&name=Jane+Doe}.
  *
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index fa2b272c3..a7eb1ee86 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -25,16 +25,16 @@
 /**
  * Named key/value pairs for a form-encoded request.
  * <p>
- * Field values may be {@code null} which will omit them from the request body.
- * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;FormUrlEncoded
  * &#64;POST("/things")
- * Call&lt;ResponseBody> things(@FieldMap Map&lt;String, String&gt; fields);
- * }</pre>
+ * Call&lt;ResponseBody&gt; things(@FieldMap Map&lt;String, String&gt; fields);
+ * </code></pre>
  * Calling with {@code foo.things(ImmutableMap.of("foo", "bar", "kit", "kat")} yields a request
  * body of {@code foo=bar&kit=kat}.
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see FormUrlEncoded
  * @see Field
diff --git a/retrofit/src/main/java/retrofit2/http/GET.java b/retrofit/src/main/java/retrofit2/http/GET.java
index 7c487a51d..deca1820d 100644
--- a/retrofit/src/main/java/retrofit2/http/GET.java
+++ b/retrofit/src/main/java/retrofit2/http/GET.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/HEAD.java b/retrofit/src/main/java/retrofit2/http/HEAD.java
index 0d7477542..077787d4f 100644
--- a/retrofit/src/main/java/retrofit2/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit2/http/HEAD.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index 1704fd780..101eecf3b 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -15,29 +15,29 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Use a custom HTTP verb for a request.
- * <pre>{@code
+ * <pre><code>
  * interface Service {
  *   &#064;HTTP(method = "CUSTOM", path = "custom/endpoint/")
- *   Call<ResponseBody> customEndpoint();
+ *   Call&lt;ResponseBody&gt; customEndpoint();
  * }
- * }</pre>
+ * </code></pre>
  * This annotation can also used for sending {@code DELETE} with a request body:
- * <pre>{@code
+ * <pre><code>
  * interface Service {
  *   &#064;HTTP(method = "DELETE", path = "remove/", hasBody = true)
- *   Call<ResponseBody> deleteObject(@Body RequestBody object);
+ *   Call&lt;ResponseBody&gt; deleteObject(@Body RequestBody object);
  * }
- * }</pre>
+ * </code></pre>
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index 57714326c..b8f7a70ea 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -23,20 +23,19 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Replaces the header with the the value of its target.
- * <p>
- * <pre>{@code
+ * Replaces the header with the value of its target.
+ * <pre><code>
  * &#64;GET("/")
- * Call&lt;ResponseBody> foo(@Header("Accept-Language") String lang);
- * }</pre>
- * <p>
+ * Call&lt;ResponseBody&gt; foo(@Header("Accept-Language") String lang);
+ * </code></pre>
  * Header parameters may be {@code null} which will omit them from the request. Passing a
  * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
  * <p>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
- * @author Adrian Cole (adrianc@netflix.com)
+ * @see Headers
+ * @see HeaderMap
  */
 @Documented
 @Retention(RUNTIME)
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
new file mode 100644
index 000000000..aa1facd39
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.util.Map;
+
+/**
+ * Adds headers specified in the {@link Map}.
+ * <p>
+ * Values are converted to strings using {@link String#valueOf(Object)}.
+ * <p>
+ * Simple Example:
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@HeaderMap Map&lt;String, String&gt; headers);
+ *
+ * ...
+ *
+ * // The following call yields /search with headers
+ * // Accept: text/plain and Accept-Charset: utf-8
+ * foo.list(ImmutableMap.of("Accept", "text/plain", "Accept-Charset", "utf-8"));
+ * </pre>
+ *
+ * @see Header
+ * @see Headers
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface HeaderMap {
+
+}
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index abc16409f..b360f3ec3 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -24,8 +24,7 @@
 
 /**
  * Adds headers literally supplied in the {@code value}.
- * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Headers("Cache-Control: max-age=640000")
  * &#64;GET("/")
  * ...
@@ -36,12 +35,12 @@
  * })
  * &#64;GET("/")
  * ...
- * }</pre>
- * <p>
+ * </code></pre>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
- * @author Adrian Cole (adrianc@netflix.com)
+ * @see Header
+ * @see HeaderMap
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/OPTIONS.java b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
index 578cc68ec..17dc085e3 100644
--- a/retrofit/src/main/java/retrofit2/http/OPTIONS.java
+++ b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/PATCH.java b/retrofit/src/main/java/retrofit2/http/PATCH.java
index 4a79069b8..035276982 100644
--- a/retrofit/src/main/java/retrofit2/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit2/http/PATCH.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/POST.java b/retrofit/src/main/java/retrofit2/http/POST.java
index b2ca5374b..34352cd34 100644
--- a/retrofit/src/main/java/retrofit2/http/POST.java
+++ b/retrofit/src/main/java/retrofit2/http/POST.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/PUT.java b/retrofit/src/main/java/retrofit2/http/PUT.java
index 204fc4eb0..0d4437f86 100644
--- a/retrofit/src/main/java/retrofit2/http/PUT.java
+++ b/retrofit/src/main/java/retrofit2/http/PUT.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index 301daac16..f320c088f 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -26,23 +26,27 @@
 /**
  * Denotes a single part of a multi-part request.
  * <p>
- * The parameter type on which this annotation exists will be processed in one of two ways:
+ * The parameter type on which this annotation exists will be processed in one of three ways:
  * <ul>
- * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
- * directly with its content type.</li>
+ * <li>If the type is {@link okhttp3.MultipartBody.Part} the contents will be used directly. Omit
+ * the name from the annotation (i.e., {@code @Part MultipartBody.Part part}).</li>
+ * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
+ * directly with its content type. Supply the part name in the annotation (e.g.,
+ * {@code @Part("foo") RequestBody foo}).</li>
  * <li>Other object types will be converted to an appropriate representation by using
- * {@linkplain Converter a converter}.</li>
+ * {@linkplain Converter a converter}. Supply the part name in the annotation (e.g.,
+ * {@code @Part("foo") Image photo}).</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
  * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Multipart
  * &#64;POST("/")
- * Call&lt;ResponseBody> example(
+ * Call&lt;ResponseBody&gt; example(
  *     &#64;Part("description") String description,
  *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
- * }</pre>
+ * </code></pre>
  * <p>
  * Part parameters may not be {@code null}.
  */
@@ -50,7 +54,11 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Part {
-  String value();
+  /**
+   * The name of the part. Required for all parameter types except
+   * {@link okhttp3.MultipartBody.Part}.
+   */
+  String value() default "";
   /** The {@code Content-Transfer-Encoding} of this part. */
   String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 3be4ef98d..79eae2147 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -28,19 +28,21 @@
  * <p>
  * Values of the map on which this annotation exists will be processed in one of two ways:
  * <ul>
- * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
+ * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
  * directly with its content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
- * <pre>{@code
+ * <pre><code>
  * &#64;Multipart
  * &#64;POST("/upload")
- * Call&lt;ResponseBody> upload(
+ * Call&lt;ResponseBody&gt; upload(
  *     &#64;Part("file") RequestBody file,
  *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
- * }</pre>
+ * </code></pre>
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Multipart
  * @see Part
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index feaf34b27..4d8c6f054 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -27,20 +27,20 @@
  * {@link String#valueOf(Object)} and URL encoded.
  * <p>
  * Simple example:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/image/{id}")
- * Call&lt;ResponseBody> example(@Path("id") int id);
- * }</pre>
+ * Call&lt;ResponseBody&gt; example(@Path("id") int id);
+ * </code></pre>
  * Calling with {@code foo.example(1)} yields {@code /image/1}.
  * <p>
  * Values are URL encoded by default. Disable with {@code encoded=true}.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/user/{name}")
- * Call&lt;ResponseBody> encoded(@Path("name") String name);
+ * Call&lt;ResponseBody&gt; encoded(@Path("name") String name);
  *
  * &#64;GET("/user/{name}")
- * Call&lt;ResponseBody> notEncoded(@Path(value="name", encoded=true) String name);
- * }</pre>
+ * Call&lt;ResponseBody&gt; notEncoded(@Path(value="name", encoded=true) String name);
+ * </code></pre>
  * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
  * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 29205bebc..01d294f3a 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -30,33 +30,33 @@
  * query parameter for each non-{@code null} item.
  * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("page") int page);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Query("page") int page);
+ * </code></pre>
  * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
  * <p>
  * Example with {@code null}:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("category") String category);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Query("category") String category);
+ * </code></pre>
  * Calling with {@code foo.list(null)} yields {@code /list}.
  * <p>
  * Array/Varargs Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/list")
- * Call&lt;ResponseBody> list(@Query("category") String... categories);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Query("category") String... categories);
+ * </code></pre>
  * Calling with {@code foo.list("bar", "baz")} yields
  * {@code /list?category=bar&category=baz}.
  * <p>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@Query(value="foo", encoded=true) String foo);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Query(value="foo", encoded=true) String foo);
+ * </code></pre>
  * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
  *
  * @see QueryMap
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 60cff1cb3..27e6ae836 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -25,26 +25,26 @@
 /**
  * Query parameter keys and values appended to the URL.
  * <p>
- * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
- * URL encoded and {@code null} will not include the query parameter in the URL. {@code null} keys
- * are not allowed.
+ * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
  * <p>
  * Simple Example:
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@QueryMap Map&lt;String, String&gt; filters);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@QueryMap Map&lt;String, String&gt; filters);
+ * </code></pre>
  * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
  * {@code /search?foo=bar&kit=kat}.
  * <p>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET("/search")
- * Call&lt;ResponseBody> list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
- * }</pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+foo"))} yields
- * {@code /search?foo=foo%2Bbar}.
+ * Call&lt;ResponseBody&gt; list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+bar"))} yields
+ * {@code /search?foo=foo+bar}.
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
  */
diff --git a/retrofit/src/main/java/retrofit2/http/Streaming.java b/retrofit/src/main/java/retrofit2/http/Streaming.java
index 57bd0fa3e..4a87591df 100644
--- a/retrofit/src/main/java/retrofit2/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit2/http/Streaming.java
@@ -23,8 +23,8 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link com.squareup.okhttp.Response Response} as is,
- * i.e. without converting {@link com.squareup.okhttp.Response#body() body()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
+ * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index f614a46d4..31187ca3d 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -15,10 +15,10 @@
  */
 package retrofit2.http;
 
-import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -26,10 +26,10 @@
 
 /**
  * URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
- * <pre>{@code
+ * <pre><code>
  * &#64;GET
- * Call&lt;ResponseBody> list(@Url String url);
- * }</pre>
+ * Call&lt;ResponseBody&gt; list(@Url String url);
+ * </code></pre>
  * <p>
  * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
  * the value will be resolved against a base URL to create the full endpoint URL.
diff --git a/retrofit/src/test/java/retrofit2/CallAdapterTest.java b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
new file mode 100644
index 000000000..d1ed83480
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static retrofit2.CallAdapter.Factory.getParameterUpperBound;
+import static retrofit2.CallAdapter.Factory.getRawType;
+
+public final class CallAdapterTest {
+  @Test public void parameterizedTypeInvalidIndex() {
+    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
+    try {
+      getParameterUpperBound(-1, listOfString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+    }
+    try {
+      getParameterUpperBound(1, listOfString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+    }
+  }
+
+  @Test public void parameterizedTypes() {
+    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
+    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
+
+    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
+    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
+    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
+
+    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+    }.getType();
+    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
+  }
+
+  @Test public void rawTypeThrowsOnNull() {
+    try {
+      getRawType(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("type == null");
+    }
+  }
+
+  @Test public void rawTypes() throws NoSuchMethodException {
+    assertThat(getRawType(String.class)).isSameAs(String.class);
+
+    Type listOfString = new TypeToken<List<String>>() {}.getType();
+    assertThat(getRawType(listOfString)).isSameAs(List.class);
+
+    Type stringArray = new TypeToken<String[]>() {}.getType();
+    assertThat(getRawType(stringArray)).isSameAs(String[].class);
+
+    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+    }.getType()).getActualTypeArguments()[0];
+    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
+
+    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
+    }.getType()).getActualTypeArguments()[0];
+    assertThat(getRawType(wildParam)).isSameAs(List.class);
+
+    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
+    assertThat(getRawType(typeVar)).isSameAs(Object.class);
+  }
+
+  @SuppressWarnings("unused") // Used reflectively.
+  static class A<T> {
+    T method() {
+      return null;
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index c25b45375..18dd035af 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -15,31 +15,34 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
+import retrofit2.http.Path;
 import retrofit2.http.Streaming;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -54,6 +57,7 @@
     @GET("/") Call<ResponseBody> getBody();
     @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
     @POST("/") Call<String> postString(@Body String body);
+    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
   }
 
   @Test public void http200Sync() throws IOException {
@@ -66,7 +70,7 @@
     server.enqueue(new MockResponse().setBody("Hi"));
 
     Response<String> response = example.getString().execute();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
   }
 
@@ -82,19 +86,19 @@
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         t.printStackTrace();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     Response<String> response = responseRef.get();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
   }
 
@@ -108,7 +112,7 @@
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
     Response<String> response = example.getString().execute();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.code()).isEqualTo(404);
     assertThat(response.errorBody().string()).isEqualTo("Hi");
   }
@@ -125,19 +129,19 @@
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         t.printStackTrace();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     Response<String> response = responseRef.get();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.code()).isEqualTo(404);
     assertThat(response.errorBody().string()).isEqualTo("Hi");
   }
@@ -171,16 +175,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     Throwable failure = failureRef.get();
     assertThat(failure).isInstanceOf(IOException.class);
@@ -191,7 +195,8 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
           @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
               Retrofit retrofit) {
             return new Converter<String, RequestBody>() {
               @Override public RequestBody convert(String value) throws IOException {
@@ -217,7 +222,8 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(new ToStringConverterFactory() {
           @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
               Retrofit retrofit) {
             return new Converter<String, RequestBody>() {
               @Override public RequestBody convert(String value) throws IOException {
@@ -232,16 +238,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
         .hasMessage("I am broken!");
@@ -277,20 +283,20 @@
 
   @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
     // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient();
-    client.interceptors().add(new Interceptor() {
-      @Override public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
-        com.squareup.okhttp.Response response = chain.proceed(chain.request());
-        ResponseBody body = response.body();
-        BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-          @Override public long read(Buffer sink, long byteCount) throws IOException {
-            throw new IOException("cause");
+    OkHttpClient client = new OkHttpClient.Builder() //
+        .addInterceptor(new Interceptor() {
+          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
+            okhttp3.Response response = chain.proceed(chain.request());
+            ResponseBody body = response.body();
+            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+              @Override public long read(Buffer sink, long byteCount) throws IOException {
+                throw new IOException("cause");
+              }
+            });
+            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+            return response.newBuilder().body(body).build();
           }
-        });
-        body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-        return response.newBuilder().body(body).build();
-      }
-    });
+        }).build();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -347,16 +353,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
 
     assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
         .hasMessage("I am broken!");
@@ -568,8 +574,8 @@
     assertThat(call.isExecuted()).isFalse();
 
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {}
-      @Override public void onFailure(Throwable t) {}
+      @Override public void onResponse(Call<String> call, Response<String> response) {}
+      @Override public void onFailure(Call<String> call, Throwable t) {}
     });
     assertThat(call.isExecuted()).isTrue();
   }
@@ -607,16 +613,16 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
     });
-    latch.await();
+    assertTrue(latch.await(10, SECONDS));
     assertThat(failureRef.get()).hasMessage("Canceled");
   }
 
@@ -651,11 +657,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<String> call, Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -664,7 +670,278 @@
     call.cancel();
     assertThat(call.isCanceled()).isTrue();
 
-    assertTrue(latch.await(2, SECONDS));
+    assertTrue(latch.await(10, SECONDS));
     assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
   }
+
+  @Test public void requestBeforeExecuteCreates() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    call.execute();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.execute();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
+      throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index a838193ea..6f1480d23 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+import okhttp3.Request;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -55,17 +56,6 @@
     }
   }
 
-  @Test public void responseThrows() {
-    Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
-    try {
-      factory.get(returnType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
-          + "Specify the response body type only (e.g., Call<TweetResponse>).");
-    }
-  }
-
   @Test public void responseType() {
     Type classType = new TypeToken<Call<String>>() {}.getType();
     assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
@@ -80,10 +70,10 @@
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    Call<String> call = adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
         return response;
       }
@@ -93,42 +83,44 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    EmptyCall originalCall = new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(response);
+        callback.onResponse(this, response);
       }
-    });
+    };
+    Call<String> call = adapter.adapt(originalCall);
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(response);
+    verify(callback).onResponse(call, response);
   }
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    EmptyCall originalCall = new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(throwable);
+        callback.onFailure(this, throwable);
       }
-    });
+    };
+    Call<String> call = adapter.adapt(originalCall);
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
     verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(throwable);
+    verify(callback).onFailure(call, throwable);
     verifyNoMoreInteractions(callback);
   }
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> call = adapter.adapt(delegate);
     Call<String> cloned = call.clone();
     assertThat(cloned).isNotSameAs(call);
     verify(delegate).clone();
@@ -137,10 +129,10 @@
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> call = adapter.adapt(delegate);
     call.cancel();
     verify(delegate).cancel();
     verifyNoMoreInteractions(delegate);
@@ -170,5 +162,9 @@
     @Override public Call<String> clone() {
       throw new UnsupportedOperationException();
     }
+
+    @Override public Request request() {
+      throw new UnsupportedOperationException();
+    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
new file mode 100644
index 000000000..8333969c6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
+public final class Java8DefaultMethodsTest {
+  //@Rule public final MockWebServer server = new MockWebServer();
+  //
+  //interface Example {
+  //  @GET("/") Call<String> user(@Query("name") String name);
+  //
+  //  default Call<String> user() {
+  //    return user("hey");
+  //  }
+  //}
+  //
+  //@Test public void test() throws IOException {
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //
+  //  Retrofit retrofit = new Retrofit.Builder()
+  //      .baseUrl(server.url("/"))
+  //      .addConverterFactory(new ToStringConverterFactory())
+  //      .build();
+  //  Example example = retrofit.create(Example.class);
+  //
+  //  Response<String> response = example.user().execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //  Response<String> response = example.user("hi").execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //}
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
new file mode 100644
index 000000000..63fa57b6c
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import android.net.Uri;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static retrofit2.RequestBuilderTest.buildRequest;
+
+@RunWith(RobolectricTestRunner.class)
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderAndroidTest {
+  @Test public void getWithAndroidUriUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Uri url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithAndroidUriUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Uri url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 6a4aca488..0f3b5ebe6 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -1,25 +1,41 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
+import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
 import retrofit2.http.Field;
@@ -29,6 +45,7 @@
 import retrofit2.http.HEAD;
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
 import retrofit2.http.Headers;
 import retrofit2.http.Multipart;
 import retrofit2.http.OPTIONS;
@@ -60,7 +77,7 @@
 
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
     assertThat(request.body()).isNull();
   }
 
@@ -76,7 +93,7 @@
     RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
     assertBody(request.body(), "hi");
   }
 
@@ -177,7 +194,7 @@
       }
     }
     Request request = buildRequest(Example.class, "yep");
-    assertThat(request.urlString()).isEqualTo("http://example.com/?maybe=yep");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
   }
 
   @Test public void twoMethodsFail() {
@@ -193,8 +210,9 @@
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
+        assertThat(e.getMessage())
+            .isIn("Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method",
+                  "Only one HTTP method is allowed. Found: POST and PATCH.\n    for method Example.method");
     }
   }
 
@@ -441,6 +459,40 @@
     }
   }
 
+  @Test public void queryMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+  }
+
+  @Test public void queryMapRejectsNull() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map was null.");
+    }
+  }
+
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
@@ -461,6 +513,139 @@
     }
   }
 
+  @Test public void queryMapRejectsNullValues() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<>();
+    queryParams.put("ping", "pong");
+    queryParams.put("kit", null);
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+    }
+  }
+
+  @Test public void getWithHeaderMap() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+        return null;
+      }
+    }
+
+    Map<String, Object> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", "utf-8");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(2);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void headerMapMustBeAMap() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap List<String> headers) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void headerMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Foo headers) {
+        return null;
+      }
+    }
+
+    Foo headers = new Foo();
+    headers.put("Accept", "text/plain");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.headers().size()).isEqualTo(1);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+  }
+
+  @Test public void headerMapRejectsNull() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (Map<String, String>) null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map was null.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullKeys() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put(null, "utf-8");
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null key.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullValues() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", null);
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+    }
+  }
+
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
@@ -504,7 +689,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -518,7 +703,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("DELETE");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertNull(request.body());
   }
 
@@ -532,7 +717,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("HEAD");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -562,7 +747,7 @@
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "hi");
   }
 
@@ -577,7 +762,7 @@
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "hi");
   }
 
@@ -592,7 +777,7 @@
     Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "hi");
   }
 
@@ -606,7 +791,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("OPTIONS");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -620,7 +805,7 @@
     Request request = buildRequest(Example.class, "po ng");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
     assertThat(request.body()).isNull();
   }
 
@@ -634,7 +819,7 @@
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
     assertThat(request.body()).isNull();
   }
 
@@ -648,7 +833,49 @@
     Request request = buildRequest(Example.class, "po%20ng");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathSegments() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/pong/more");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\npong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
     assertThat(request.body()).isNull();
   }
 
@@ -677,7 +904,7 @@
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
     assertThat(request.body()).isNull();
   }
 
@@ -691,7 +918,7 @@
     Request request = buildRequest(Example.class, "p%20o%20n%20g");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
     assertThat(request.body()).isNull();
   }
 
@@ -703,7 +930,7 @@
       }
     }
     Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
   }
 
   @Test public void queryParamOptional() {
@@ -715,7 +942,7 @@
       }
     }
     Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
   }
 
   @Test public void getWithQueryUrlAndParam() {
@@ -728,7 +955,7 @@
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
     assertThat(request.body()).isNull();
   }
 
@@ -742,7 +969,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
     assertThat(request.body()).isNull();
   }
 
@@ -758,7 +985,7 @@
     Request request = buildRequest(Example.class, "pong", "kat", "raff");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
     assertThat(request.body()).isNull();
   }
 
@@ -790,7 +1017,7 @@
     Request request = buildRequest(Example.class, "pong?", "kat?");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
     assertThat(request.body()).isNull();
   }
 
@@ -805,7 +1032,7 @@
     Request request = buildRequest(Example.class, "pong&", "kat&");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
     assertThat(request.body()).isNull();
   }
 
@@ -820,7 +1047,7 @@
     Request request = buildRequest(Example.class, "pong#", "kat#");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
     assertThat(request.body()).isNull();
   }
 
@@ -836,7 +1063,7 @@
     Request request = buildRequest(Example.class, values);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
     assertThat(request.body()).isNull();
   }
 
@@ -852,7 +1079,7 @@
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
     assertThat(request.body()).isNull();
   }
 
@@ -868,7 +1095,7 @@
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
     assertThat(request.body()).isNull();
   }
 
@@ -882,13 +1109,12 @@
 
     Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "kat");
-    params.put("foo", null);
     params.put("ping", "pong");
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
     assertThat(request.body()).isNull();
   }
 
@@ -902,17 +1128,31 @@
 
     Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "k%20t");
-    params.put("foo", null);
     params.put("pi%20ng", "p%20g");
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getAbsoluteUrl() {
+    class Example {
+      @GET("http://example2.com/foo/bar/")
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithUrl() {
+  @Test public void getWithStringUrl() {
     class Example {
       @GET
       Call<ResponseBody> method(@Url String url) {
@@ -923,26 +1163,26 @@
     Request request = buildRequest(Example.class, "foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getAbsoluteUrl() {
+  @Test public void getWithJavaUriUrl() {
     class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
+      @GET
+      Call<ResponseBody> method(@Url URI url) {
         return null;
       }
     }
 
-    Request request = buildRequest(Example.class);
+    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example2.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithUrlAbsolute() {
+  @Test public void getWithStringUrlAbsolute() {
     class Example {
       @GET
       Call<ResponseBody> method(@Url String url) {
@@ -953,7 +1193,22 @@
     Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithJavaUriUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url URI url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -968,10 +1223,41 @@
     Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithHttpUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url HttpUrl url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
     assertThat(request.body()).isNull();
   }
 
+  @Test public void getWithNullUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url HttpUrl url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (HttpUrl) null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("@Url parameter is null.");
+    }
+  }
+
   @Test public void getWithNonStringUrlThrows() {
     class Example {
       @GET
@@ -984,8 +1270,10 @@
       buildRequest(Example.class, "foo/bar");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
-          + "    for method Example.method");
+      assertThat(e).hasMessage(
+          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+              + " (parameter #1)\n"
+              + "    for method Example.method");
     }
   }
 
@@ -1001,7 +1289,7 @@
       buildRequest(Example.class, "foo/bar");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
+      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
           + "    for method Example.method");
     }
   }
@@ -1085,7 +1373,7 @@
     Request request = buildRequest(Example.class, "foo/bar/", "hey!");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
   }
 
   @Test public void postWithUrl() {
@@ -1099,7 +1387,7 @@
     Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
     assertBody(request.body(), "hi");
   }
 
@@ -1114,7 +1402,7 @@
     Request request = buildRequest(Example.class, "pong", body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
     assertBody(request.body(), "Hi!");
   }
 
@@ -1128,7 +1416,7 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "");
   }
 
@@ -1143,25 +1431,10 @@
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("CUSTOM");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertBody(request.body(), "");
   }
 
-  @Test public void bodyResponseBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
@@ -1188,7 +1461,7 @@
     Request request = buildRequest(Example.class, "pong", body, "kat");
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
     assertBody(request.body(), "Hi!");
   }
 
@@ -1205,7 +1478,7 @@
         MediaType.parse("text/plain"), "kat"));
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1236,7 +1509,7 @@
         buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1254,55 +1527,287 @@
         .contains("\r\npong2\r\n--");
   }
 
-  @Test public void multipartIterable() throws IOException {
+  @Test public void multipartRequiresName() {
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<String> ping) {
+      Call<ResponseBody> method(@Part RequestBody part) {
         return null;
       }
     }
 
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
 
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
+  @Test public void multipartIterableRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<RequestBody> part) {
+        return null;
+      }
+    }
 
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
   }
 
-  @Test public void multipartWithEncoding() throws IOException {
+  @Test public void multipartArrayRequiresName() {
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+      Call<ResponseBody> method(@Part RequestBody[] part) {
         return null;
       }
     }
 
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartOkHttpPartForbidsName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartOkHttpPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, part);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpIterablePart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"foo\"\r\n")
+        .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpArrayPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request =
+        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"foo\"\r\n")
+        .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpPartWithFilename() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part =
+        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+    Request request = buildRequest(Example.class, part);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartIterable() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<String> ping) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong1\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"")
+        .contains("\r\npong2\r\n--");
+  }
+
+  @Test public void multipartIterableOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
+          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
@@ -1329,13 +1834,12 @@
 
     Map<String, RequestBody> params = new LinkedHashMap<>();
     params.put("ping", RequestBody.create(null, "pong"));
-    params.put("foo", null); // Should be skipped.
     params.put("kit", RequestBody.create(null, "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1351,8 +1855,6 @@
         .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
-
-    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
   }
 
   @Test public void multipartPartMapWithEncoding() throws IOException {
@@ -1366,13 +1868,12 @@
 
     Map<String, RequestBody> params = new LinkedHashMap<>();
     params.put("ping", RequestBody.create(null, "pong"));
-    params.put("foo", null); // Should be skipped.
     params.put("kit", RequestBody.create(null, "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1390,8 +1891,61 @@
         .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMapRejectsNonStringKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
+        return null;
+      }
+    }
 
-    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsOkHttpPartValues() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsNull() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map was null.");
+    }
   }
 
   @Test public void multipartPartMapRejectsNullKeys() {
@@ -1415,6 +1969,27 @@
     }
   }
 
+  @Test public void multipartPartMapRejectsNullValues() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put("kit", null);
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+    }
+  }
+
   @Test public void multipartPartMapMustBeMap() {
     class Example {
       @Multipart //
@@ -1433,6 +2008,29 @@
     }
   }
 
+  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Foo parts) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8())
+        .contains("name=\"hello\"")
+        .contains("\r\n\r\nworld\r\n--");
+  }
+
   @Test public void multipartNullRemovesPart() throws IOException {
     class Example {
       @Multipart //
@@ -1444,7 +2042,7 @@
     Request request = buildRequest(Example.class, "pong", null);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
 
     RequestBody body = request.body();
     Buffer buffer = new Buffer();
@@ -1580,13 +2178,29 @@
 
     Map<String, Object> fieldMap = new LinkedHashMap<>();
     fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
     fieldMap.put("ping", "pong");
 
     Request request = buildRequest(Example.class, fieldMap);
     assertBody(request.body(), "kit=kat&ping=pong");
   }
 
+  @Test public void fieldMapRejectsNull() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map was null.");
+    }
+  }
+
   @Test public void fieldMapRejectsNullKeys() {
     class Example {
       @FormUrlEncoded //
@@ -1598,7 +2212,6 @@
 
     Map<String, Object> fieldMap = new LinkedHashMap<>();
     fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
     fieldMap.put(null, "pong");
 
     try {
@@ -1609,6 +2222,27 @@
     }
   }
 
+  @Test public void fieldMapRejectsNullValues() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+    }
+  }
+
   @Test public void fieldMapMustBeAMap() {
     class Example {
       @FormUrlEncoded //
@@ -1626,6 +2260,27 @@
     }
   }
 
+  @Test public void fieldMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+  }
+
   @Test public void simpleHeaders() {
     class Example {
       @GET("/foo/bar/")
@@ -1639,11 +2294,11 @@
     }
     Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1656,10 +2311,10 @@
     }
     Request request = buildRequest(Example.class, new BigInteger("1234"));
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(1);
     assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1673,11 +2328,11 @@
     }
     Request request = buildRequest(Example.class, "kat");
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1690,10 +2345,10 @@
     }
     Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1706,10 +2361,10 @@
     }
     Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
+    okhttp3.Headers headers = request.headers();
     assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
@@ -1726,6 +2381,24 @@
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void malformedContentTypeHeaderThrows() {
+    class Example {
+      @POST("/") //
+      @Headers("Content-Type: hello, world!") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    try {
+      buildRequest(Example.class, body);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Malformed content type: hello, world!\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
     class Example {
       @DELETE("/") //
@@ -1750,6 +2423,73 @@
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
+  @Test public void malformedContentTypeParameterThrows() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    try {
+      buildRequest(Example.class, "hello, world!", body);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Malformed content type: hello, world!");
+    }
+  }
+
+  @Test public void malformedAnnotationRelativeUrlThrows() {
+    class Example {
+      @GET("ftp://example.org")
+      Call<ResponseBody> get() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void malformedParameterRelativeUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> get(@Url String relativeUrl) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, "ftp://example.org");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void multipartPartsShouldBeInOrder() throws IOException {
+    class Example {
+      @Multipart
+      @POST("/foo")
+      Call<ResponseBody> get(@Part("first") String data, @Part("second") String dataTwo, @Part("third") String dataThree) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "firstParam", "secondParam", "thirdParam");
+    MultipartBody body = (MultipartBody) request.body();
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String readBody = buffer.readUtf8();
+
+    assertThat(readBody.indexOf("firstParam")).isLessThan(readBody.indexOf("secondParam"));
+    assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
@@ -1761,28 +2501,29 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  private Request buildRequest(Class<?> cls, Object... args) {
-    OkHttpClient client = new OkHttpClient();
-
+  static <T> Request buildRequest(Class<T> cls, Object... args) {
     final AtomicReference<Request> requestRef = new AtomicReference<>();
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        requestRef.set(chain.request());
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        requestRef.set(request);
         throw new UnsupportedOperationException("Not implemented");
       }
-    });
+    };
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .addConverterFactory(new ToStringConverterFactory())
-        .client(client)
+        .callFactory(callFactory)
         .build();
 
     Method method = TestingUtils.onlyMethod(cls);
-    MethodHandler<?> handler = retrofit.loadMethodHandler(method);
-    Call<?> invoke = (Call<?>) handler.invoke(args);
+    //noinspection unchecked
+    ServiceMethod<T, Call<T>> serviceMethod =
+        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
+    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+    Call<T> call = serviceMethod.callAdapter.adapt(okHttpCall);
     try {
-      invoke.execute();
+      call.execute();
       throw new AssertionError();
     } catch (UnsupportedOperationException ignored) {
       return requestRef.get();
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 0c48cf9a8..3d059b8ad 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -15,28 +15,27 @@
  */
 package retrofit2;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.ResponseBody;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.ResponseBody;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
-  private final com.squareup.okhttp.Response successResponse =
-      new com.squareup.okhttp.Response.Builder() //
-          .code(200)
-          .message("OK")
-          .protocol(Protocol.HTTP_1_1)
-          .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
-          .build();
-  private final com.squareup.okhttp.Response errorResponse =
-      new com.squareup.okhttp.Response.Builder() //
-          .code(400)
-          .message("Broken!")
-          .protocol(Protocol.HTTP_1_1)
-          .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
-          .build();
+  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
+      .code(200)
+      .message("OK")
+      .protocol(Protocol.HTTP_1_1)
+      .request(new okhttp3.Request.Builder().url("http://localhost").build())
+      .build();
+  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
+      .code(400)
+      .message("Broken!")
+      .protocol(Protocol.HTTP_1_1)
+      .request(new okhttp3.Request.Builder().url("http://localhost").build())
+      .build();
 
   @Test public void success() {
     Object body = new Object();
@@ -45,17 +44,39 @@
     assertThat(response.code()).isEqualTo(200);
     assertThat(response.message()).isEqualTo("OK");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isSameAs(body);
     assertThat(response.errorBody()).isNull();
   }
 
   @Test public void successNullAllowed() {
     Response<Object> response = Response.success(null);
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isNull();
   }
 
+  @Test public void successWithHeaders() {
+    Object body = new Object();
+    Headers headers = Headers.of("foo", "bar");
+    Response<Object> response = Response.success(body, headers);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successWithNullHeadersThrows() {
+    try {
+      Response.success("", (okhttp3.Headers) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("headers == null");
+    }
+  }
+
   @Test public void successWithRawResponse() {
     Object body = new Object();
     Response<Object> response = Response.success(body, successResponse);
@@ -63,14 +84,14 @@
     assertThat(response.code()).isEqualTo(200);
     assertThat(response.message()).isEqualTo("OK");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.isSuccessful()).isTrue();
     assertThat(response.body()).isSameAs(body);
     assertThat(response.errorBody()).isNull();
   }
 
   @Test public void successWithNullRawResponseThrows() {
     try {
-      Response.success("", null);
+      Response.success("", (okhttp3.Response) null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("rawResponse == null");
@@ -93,7 +114,7 @@
     assertThat(response.code()).isEqualTo(400);
     assertThat(response.message()).isNull();
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.body()).isNull();
     assertThat(response.errorBody()).isSameAs(errorBody);
   }
@@ -124,7 +145,7 @@
     assertThat(response.code()).isEqualTo(400);
     assertThat(response.message()).isEqualTo("Broken!");
     assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.isSuccessful()).isFalse();
     assertThat(response.body()).isNull();
     assertThat(response.errorBody()).isSameAs(errorBody);
   }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 24c3ccd36..885394bfc 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -1,13 +1,20 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
@@ -18,20 +25,35 @@
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Rule;
 import org.junit.Test;
+import retrofit2.helpers.DelegatingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingConverterFactory;
+import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
 import retrofit2.http.Query;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
@@ -47,6 +69,10 @@
   interface CallMethod {
     @GET("/") Call<String> disallowed();
     @POST("/") Call<ResponseBody> disallowed(@Body String body);
+
+    @GET("/") Call<retrofit2.Response> badType1();
+    @GET("/") Call<okhttp3.Response> badType2();
+
     @GET("/") Call<ResponseBody> getResponseBody();
     @GET("/") Call<Void> getVoid();
     @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
@@ -86,6 +112,9 @@
     @Retention(RUNTIME)
     @interface Foo {}
   }
+  interface MutableParameters {
+    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
+  }
 
   @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
@@ -111,6 +140,36 @@
     }
   }
 
+  @Test public void responseTypeCannotBeRetrofitResponse() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    try {
+      service.badType1();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+              + "    for method CallMethod.badType1");
+    }
+  }
+
+  @Test public void responseTypeCannotBeOkHttpResponse() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    try {
+      service.badType2();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+              + "    for method CallMethod.badType2");
+    }
+  }
+
   @Test public void voidReturnTypeNotAllowed() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -171,19 +230,19 @@
   @Test public void callCallCustomAdapter() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+    class MyCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         factoryCalled.set(true);
-        if (Utils.getRawType(returnType) != Call.class) {
+        if (getRawType(returnType) != Call.class) {
           return null;
         }
-        return new CallAdapter<Call<?>>() {
+        return new CallAdapter<Object, Call<?>>() {
           @Override public Type responseType() {
-            return Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
+            return getParameterUpperBound(0, (ParameterizedType) returnType);
           }
 
-          @Override public <R> Call<R> adapt(Call<R> call) {
+          @Override public Call<Object> adapt(Call<Object> call) {
             adapterCalled.set(true);
             return call;
           }
@@ -202,18 +261,18 @@
   }
 
   @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+    class GreetingCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
-        if (Utils.getRawType(returnType) != String.class) {
+        if (getRawType(returnType) != String.class) {
           return null;
         }
-        return new CallAdapter<String>() {
+        return new CallAdapter<Object, String>() {
           @Override public Type responseType() {
             return String.class;
           }
 
-          @Override public <R> String adapt(Call<R> call) {
+          @Override public String adapt(Call<Object> call) {
             return "Hi!";
           }
         };
@@ -231,8 +290,8 @@
 
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+    class MyCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
@@ -259,12 +318,13 @@
       example.method();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-              + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>. Tried:\n"
-              + " * retrofit2.DefaultCallAdapter$1");
+      assertThat(e).hasMessage(""
+          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+          + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
 
@@ -289,14 +349,18 @@
     assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
   }
 
-  @Test public void parameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
     class MyConverterFactory extends Converter.Factory {
       @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, annotations, retrofit);
+      public Converter<?, RequestBody> requestBodyConverter(Type type,
+          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        parameterAnnotationsRef.set(parameterAnnotations);
+        methodAnnotationsRef.set(methodAnnotations);
+        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+            methodAnnotations, retrofit);
       }
     }
     Retrofit retrofit = new Retrofit.Builder()
@@ -306,14 +370,15 @@
     Annotated annotated = retrofit.create(Annotated.class);
     annotated.bodyParameter(null); // Trigger internal setup.
 
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
   }
 
   @Test public void parameterAnnotationsPassedToStringConverter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         annotationsRef.set(annotations);
 
         return new Converter<Object, String>() {
@@ -334,10 +399,13 @@
     assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
   }
 
-  @Test public void stringConverterNotCalledForString() {
+  @Test public void stringConverterCalledForString() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
-        throw new AssertionError();
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        factoryCalled.set(true);
+        return null;
       }
     }
     Retrofit retrofit = new Retrofit.Builder()
@@ -347,13 +415,14 @@
     CallMethod service = retrofit.create(CallMethod.class);
     Call<ResponseBody> call = service.queryString(null);
     assertThat(call).isNotNull();
-    // We also implicitly assert the above factory was not called as it would have thrown.
+    assertThat(factoryCalled.get()).isTrue();
   }
 
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -377,12 +446,13 @@
       example.disallowed("Hi!");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-              + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters");
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
     }
   }
 
@@ -398,31 +468,13 @@
       example.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
           + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void converterReturningNullThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new Converter.Factory() {})
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-
-    try {
-      service.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit2.BuiltInConverters\n"
-              + " * retrofit2.RetrofitTest$1");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
     }
   }
 
@@ -450,6 +502,22 @@
     assertThat(response.body()).isNull();
   }
 
+  @Test public void voidResponsesArePooled() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    example.getVoid().execute();
+    example.getVoid().execute();
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
   @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -506,7 +574,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends com.squareup.okhttp.ResponseBody>\n"
+          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
           + "    for method UnresolvableResponseType.wildcardUpperBound");
     }
   }
@@ -552,7 +620,7 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends com.squareup.okhttp.RequestBody> (parameter #1)\n"
+          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
           + "    for method UnresolvableParameterType.wildcardUpperBound");
     }
   }
@@ -579,12 +647,6 @@
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("baseUrl == null");
     }
-    try {
-      new Retrofit.Builder().baseUrl((BaseUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
   }
 
   @Test public void baseUrlInvalidThrows() {
@@ -616,9 +678,8 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
-    BaseUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isNotNull();
-    assertThat(baseUrl.url().toString()).isEqualTo("http://example.com/");
+    HttpUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
   }
 
   @Test public void baseHttpUrlPropagated() {
@@ -626,17 +687,7 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(url)
         .build();
-    BaseUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isNotNull();
-    assertThat(baseUrl.url()).isSameAs(url);
-  }
-
-  @Test public void baseUrlPropagated() {
-    BaseUrl baseUrl = mock(BaseUrl.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(baseUrl)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(baseUrl);
+    assertThat(retrofit.baseUrl()).isSameAs(url);
   }
 
   @Test public void clientNullThrows() {
@@ -648,20 +699,95 @@
     }
   }
 
-  @Test public void clientDefault() {
+  @Test public void callFactoryDefault() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com")
         .build();
-      assertThat(retrofit.client()).isNotNull();
+    assertThat(retrofit.callFactory()).isNotNull();
+  }
+
+  @Test public void callFactoryPropagated() {
+    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(callFactory)
+        .build();
+    assertThat(retrofit.callFactory()).isSameAs(callFactory);
   }
 
-  @Test public void clientPropagated() {
+  @Test public void callFactoryClientPropagated() {
     OkHttpClient client = new OkHttpClient();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .client(client)
         .build();
-    assertThat(retrofit.client()).isSameAs(client);
+    assertThat(retrofit.callFactory()).isSameAs(client);
+  }
+
+  @Test public void callFactoryUsed() throws IOException {
+    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        return new OkHttpClient().newCall(request);
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callFactory(callFactory)
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    CallMethod service = retrofit.create(CallMethod.class);
+    service.getResponseBody().execute();
+    verify(callFactory).newCall(any(Request.class));
+    verifyNoMoreInteractions(callFactory);
+  }
+
+  @Test public void callFactoryReturningNullThrows() throws IOException {
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        return null;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(callFactory)
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+    try {
+      call.execute();
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("Call.Factory returned null.");
+    }
+  }
+
+  @Test public void callFactoryThrowingPropagates() {
+    final RuntimeException cause = new RuntimeException("Broken!");
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        throw cause;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(callFactory)
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+    try {
+      call.execute();
+      fail();
+    } catch (Exception e) {
+      assertThat(e).isSameAs(cause);
+    }
   }
 
   @Test public void converterNullThrows() {
@@ -669,7 +795,7 @@
       new Retrofit.Builder().addConverterFactory(null);
       fail();
     } catch (NullPointerException e) {
-      assertThat(e).hasMessage("converterFactory == null");
+      assertThat(e).hasMessage("factory == null");
     }
   }
 
@@ -684,7 +810,8 @@
 
   @Test public void requestConverterFactoryQueried() {
     Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
+    Annotation[] parameterAnnotations = new Annotation[0];
+    Annotation[] methodAnnotations = new Annotation[1];
 
     Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
     Converter.Factory factory = mock(Converter.Factory.class);
@@ -694,12 +821,14 @@
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, annotations, retrofit);
+    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+        methodAnnotations, retrofit);
 
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type, annotations);
+    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+        parameterAnnotations, methodAnnotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).requestBodyConverter(type, annotations, retrofit);
+    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -707,28 +836,55 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    Converter.Factory factory1 = spy(new Converter.Factory() {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type returnType,
-          Annotation[] annotations, Retrofit retrofit) {
-        return null;
-      }
-    });
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addConverterFactory(factory1)
+        .addConverterFactory(nonMatchingFactory)
         .build();
 
     try {
-      retrofit.requestBodyConverter(type, annotations);
+      retrofit.requestBodyConverter(type, annotations, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate RequestBody converter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
     }
 
-    verify(factory1).requestBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void requestConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
   }
 
   @Test public void responseConverterFactoryQueried() {
@@ -756,28 +912,55 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    Converter.Factory factory1 = spy(new Converter.Factory() {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type returnType,
-          Annotation[] annotations, Retrofit retrofit) {
-        return null;
-      }
-    });
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addConverterFactory(factory1)
+        .addConverterFactory(nonMatchingFactory)
         .build();
 
     try {
       retrofit.responseBodyConverter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate ResponseBody converter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
     }
 
-    verify(factory1).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void responseConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
   }
 
   @Test public void stringConverterFactoryQueried() {
@@ -792,12 +975,12 @@
         .addConverterFactory(factory)
         .build();
 
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations);
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
 
     Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
-    verify(factory).stringConverter(type, annotations);
+    verify(factory).stringConverter(type, annotations, retrofit);
     verifyNoMoreInteractions(factory);
   }
 
@@ -839,7 +1022,7 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
 
     Retrofit retrofit = new Retrofit.Builder()
@@ -849,7 +1032,7 @@
 
     doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory).get(type, annotations, retrofit);
@@ -860,11 +1043,11 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
     CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
@@ -877,7 +1060,7 @@
 
     doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory1).get(type, annotations, retrofit);
@@ -890,17 +1073,17 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
     CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
     CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
@@ -914,7 +1097,7 @@
 
     doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory1).get(type, annotations, retrofit);
@@ -929,52 +1112,59 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
+        .addCallAdapterFactory(nonMatchingFactory)
         .build();
 
-    doReturn(null).when(factory).get(type, annotations, retrofit);
-
     try {
       retrofit.callAdapter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Could not locate call adapter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
+    assertThat(nonMatchingFactory.called).isTrue();
   }
 
   @Test public void callAdapterFactoryDelegateNoMatchThrows() {
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
+    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(delegatingFactory1)
+        .addCallAdapterFactory(delegatingFactory2)
+        .addCallAdapterFactory(nonMatchingFactory)
         .build();
 
     try {
       retrofit.callAdapter(type, annotations);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageContaining("Skipped:")
-          .hasMessageStartingWith(
-              "Could not locate call adapter for class java.lang.String. Tried:");
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
+    assertThat(delegatingFactory1.called).isTrue();
+    assertThat(delegatingFactory2.called).isTrue();
+    assertThat(nonMatchingFactory.called).isTrue();
   }
 
   @Test public void callbackExecutorNullThrows() {
@@ -982,17 +1172,30 @@
       new Retrofit.Builder().callbackExecutor(null);
       fail();
     } catch (NullPointerException e) {
-      assertThat(e).hasMessage("callbackExecutor == null");
+      assertThat(e).hasMessage("executor == null");
     }
   }
 
-  @Test public void callbackExecutorNoDefault() {
+  @Test public void callbackExecutorPropagatesDefaultJvm() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
     assertThat(retrofit.callbackExecutor()).isNull();
   }
 
+  @Test public void callbackExecutorPropagatesDefaultAndroid() {
+    final Executor executor = Executors.newSingleThreadExecutor();
+    Platform platform = new Platform() {
+      @Override Executor defaultCallbackExecutor() {
+        return executor;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder(platform)
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
   @Test public void callbackExecutorPropagated() {
     Executor executor = mock(Executor.class);
     Retrofit retrofit = new Retrofit.Builder()
@@ -1019,11 +1222,11 @@
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Response<ResponseBody> response) {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
         t.printStackTrace();
       }
     });
@@ -1050,11 +1253,11 @@
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Response<ResponseBody> response) {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
         throw new AssertionError();
       }
 
-      @Override public void onFailure(Throwable t) {
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
         latch.countDown();
       }
     });
@@ -1063,4 +1266,39 @@
     verify(executor).execute(any(Runnable.class));
     verifyNoMoreInteractions(executor);
   }
+
+  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
+  @Test public void argumentCapture() throws Exception {
+    AtomicInteger i = new AtomicInteger();
+
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
+
+    i.set(100);
+    Call<String> call1 = mutableParameters.method(i);
+
+    i.set(101);
+    Response<String> response1 = call1.execute();
+
+    i.set(102);
+    assertEquals("a", response1.body());
+    assertEquals("/?i=101", server.takeRequest().getPath());
+
+    i.set(200);
+    Call<String> call2 = call1.clone();
+
+    i.set(201);
+    Response<String> response2 = call2.execute();
+
+    i.set(202);
+    assertEquals("b", response2.body());
+
+    assertEquals("/?i=201", server.takeRequest().getPath());
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryParserTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
similarity index 61%
rename from retrofit/src/test/java/retrofit2/RequestFactoryParserTest.java
rename to retrofit/src/test/java/retrofit2/ServiceMethodTest.java
index 502368545..c9c48f31e 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryParserTest.java
+++ b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
 import java.util.Set;
@@ -6,7 +20,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class RequestFactoryParserTest {
+public final class ServiceMethodTest {
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
@@ -27,7 +41,7 @@
   }
 
   private static void expectParams(String path, String... expected) {
-    Set<String> calculated = RequestFactoryParser.parsePathParameters(path);
+    Set<String> calculated = ServiceMethod.parsePathParameters(path);
     assertThat(calculated).containsExactly(expected);
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 7bbf68e0a..3847509ea 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -1,4 +1,18 @@
-// Copyright 2013 Square, Inc.
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package retrofit2;
 
 import java.lang.reflect.Method;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
similarity index 53%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java
rename to retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
index b4c2808d3..6ce48efe2 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/SingleHelper.java
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,23 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.helpers;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-import rx.Observable;
-import rx.Single;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
 
-final class SingleHelper {
-  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
-    return new CallAdapter<Single<?>>() {
-      @Override public Type responseType() {
-        return callAdapter.responseType();
-      }
+public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
 
-      @Override public <R> Single<?> adapt(Call<R> call) {
-        Observable<?> observable = callAdapter.adapt(call);
-        return observable.toSingle();
-      }
-    };
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return retrofit.nextCallAdapter(this, returnType, annotations);
   }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
new file mode 100644
index 000000000..3f44ddff8
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
new file mode 100644
index 000000000..343839944
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingConverterFactory extends Converter.Factory {
+  public boolean called;
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
similarity index 78%
rename from retrofit/src/test/java/retrofit2/ToStringConverterFactory.java
rename to retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index f7a9743ff..0a70e3ddb 100644
--- a/retrofit/src/test/java/retrofit2/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -13,17 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2;
+package retrofit2.helpers;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
 
-class ToStringConverterFactory extends Converter.Factory {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+public class ToStringConverterFactory extends Converter.Factory {
+  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
@@ -39,7 +41,7 @@
   }
 
   @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] annotations, Retrofit retrofit) {
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<String, RequestBody>() {
         @Override public RequestBody convert(String value) throws IOException {
diff --git a/samples/pom.xml b/samples/pom.xml
index ed051d0c6..07483d1cf 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,13 +30,23 @@
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-simplexml</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
     </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.jsoup</groupId>
+      <artifactId>jsoup</artifactId>
+      <version>${jsoup.version}</version>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index b8cc32893..790675975 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -15,21 +15,21 @@
  */
 package com.example.retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.BufferedSink;
 import retrofit2.Call;
 import retrofit2.Converter;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.Body;
 import retrofit2.http.POST;
@@ -49,11 +49,11 @@
    */
   static class ChunkingConverterFactory extends Converter.Factory {
     @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       boolean isBody = false;
       boolean isChunked = false;
-      for (Annotation annotation : annotations) {
+      for (Annotation annotation : parameterAnnotations) {
         isBody |= annotation instanceof Body;
         isChunked |= annotation instanceof Chunked;
       }
@@ -63,7 +63,7 @@
 
       // Look up the real converter to delegate to.
       final Converter<Object, RequestBody> delegate =
-          retrofit.nextRequestBodyConverter(this, type, annotations);
+          retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
       // Wrap it in a Converter which removes the content length from the delegate's body.
       return new Converter<Object, RequestBody>() {
         @Override public RequestBody convert(Object value) throws IOException {
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
new file mode 100644
index 000000000..97c739e39
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.ConnectionPool;
+import okhttp3.Dispatcher;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.ResponseBody;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+/** A simple web crawler that uses a Retrofit service to turn URLs into webpages. */
+public final class Crawler {
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+      new LinkedHashSet<HttpUrl>());
+  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
+  private final PageService pageService;
+
+  public Crawler(PageService pageService) {
+    this.pageService = pageService;
+  }
+
+  public void crawlPage(HttpUrl url) {
+    // Skip hosts that we've visited many times.
+    AtomicInteger hostnameCount = new AtomicInteger();
+    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+    if (previous != null) hostnameCount = previous;
+    if (hostnameCount.incrementAndGet() > 100) return;
+
+    // Asynchronously visit URL.
+    pageService.get(url).enqueue(new Callback<Page>() {
+      @Override public void onResponse(Call<Page> call, Response<Page> response) {
+        if (!response.isSuccessful()) {
+          System.out.println(call.request().url() + ": failed: " + response.code());
+          return;
+        }
+
+        // Print this page's URL and title.
+        Page page = response.body();
+        HttpUrl base = response.raw().request().url();
+        System.out.println(base + ": " + page.title);
+
+        // Enqueue its links for visiting.
+        for (String link : page.links) {
+          HttpUrl linkUrl = base.resolve(link);
+          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+            crawlPage(linkUrl);
+          }
+        }
+      }
+
+      @Override public void onFailure(Call<Page> call, Throwable t) {
+        System.out.println(call.request().url() + ": failed: " + t);
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
+    dispatcher.setMaxRequests(20);
+    dispatcher.setMaxRequestsPerHost(1);
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .dispatcher(dispatcher)
+        .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(HttpUrl.parse("https://example.com/"))
+        .addConverterFactory(PageAdapter.FACTORY)
+        .client(okHttpClient)
+        .build();
+
+    PageService pageService = retrofit.create(PageService.class);
+
+    Crawler crawler = new Crawler(pageService);
+    crawler.crawlPage(HttpUrl.parse(args[0]));
+  }
+
+  interface PageService {
+    @GET Call<Page> get(@Url HttpUrl url);
+  }
+
+  static class Page {
+    public final String title;
+    public final List<String> links;
+
+    public Page(String title, List<String> links) {
+      this.title = title;
+      this.links = links;
+    }
+  }
+
+  static final class PageAdapter implements Converter<ResponseBody, Page> {
+    static final Converter.Factory FACTORY = new Converter.Factory() {
+      @Override public Converter<ResponseBody, ?> responseBodyConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
+        if (type == Page.class) return new PageAdapter();
+        return null;
+      }
+    };
+
+    @Override public Page convert(ResponseBody responseBody) throws IOException {
+      Document document = Jsoup.parse(responseBody.string());
+      List<String> links = new ArrayList<>();
+      for (Element element : document.select("a[href]")) {
+        links.add(element.attr("href"));
+      }
+      return new Page(document.title(), Collections.unmodifiableList(links));
+    }
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
deleted file mode 100644
index cce467ee1..000000000
--- a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.retrofit;
-
-import com.google.common.reflect.TypeToken;
-import com.google.common.util.concurrent.AbstractFuture;
-import com.google.common.util.concurrent.ListenableFuture;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executors;
-import retrofit2.Call;
-import retrofit2.CallAdapter;
-import retrofit2.Callback;
-import retrofit2.GsonConverterFactory;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-import retrofit2.http.GET;
-
-/**
- * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
- * a service method return type.
- */
-public final class CustomCallAdapter {
-  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      TypeToken<?> token = TypeToken.of(returnType);
-      if (token.getRawType() != ListenableFuture.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "ListenableFuture must have generic type (e.g., ListenableFuture<ResponseBody>)");
-      }
-      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
-      return new CallAdapter<ListenableFuture<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
-
-        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
-          CallFuture<R> future = new CallFuture<>(call);
-          call.enqueue(future);
-          return future;
-        }
-      };
-    }
-
-    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
-      private final Call<T> call;
-
-      private CallFuture(Call<T> call) {
-        this.call = call;
-      }
-
-      @Override protected void interruptTask() {
-        call.cancel();
-      }
-
-      @Override public void onResponse(Response<T> response) {
-        if (response.isSuccess()) {
-          set(response.body());
-        } else {
-          setException(new IOException()); // TODO something more useful.
-        }
-      }
-
-      @Override public void onFailure(Throwable t) {
-        setException(t);
-      }
-    }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    ListenableFuture<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    final ListenableFuture<Ip> ip = service.getIp();
-    ip.addListener(new Runnable() {
-      @Override public void run() {
-        try {
-          System.out.println("IP: " + ip.get().origin);
-        } catch (InterruptedException | ExecutionException e) {
-          e.printStackTrace();
-        }
-      }
-    }, Executors.newSingleThreadExecutor());
-  }
-}
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
index 163120e94..4fc6c8669 100644
--- a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -15,14 +15,14 @@
  */
 package com.example.retrofit;
 
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import retrofit2.Call;
 import retrofit2.Converter;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
diff --git a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
new file mode 100644
index 000000000..7507b840a
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+/**
+ * This example uses an OkHttp interceptor to change the target hostname dynamically at runtime.
+ * Typically this would be used to implement client-side load balancing or to use the webserver
+ * that's nearest geographically.
+ */
+public final class DynamicBaseUrl {
+  public interface Pop {
+    @GET("robots.txt")
+    Call<ResponseBody> robots();
+  }
+
+  static final class HostSelectionInterceptor implements Interceptor {
+    private volatile String host;
+
+    public void setHost(String host) {
+      this.host = host;
+    }
+
+    @Override public okhttp3.Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      String host = this.host;
+      if (host != null) {
+        HttpUrl newUrl = request.url().newBuilder()
+            .host(host)
+            .build();
+        request = request.newBuilder()
+            .url(newUrl)
+            .build();
+      }
+      return chain.proceed(request);
+    }
+  }
+
+  public static void main(String... args) throws IOException {
+    HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .addInterceptor(hostSelectionInterceptor)
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://www.coca-cola.com/")
+        .callFactory(okHttpClient)
+        .build();
+
+    Pop pop = retrofit.create(Pop.class);
+
+    Response<ResponseBody> response1 = pop.robots().execute();
+    System.out.println("Response from: " + response1.raw().request().url());
+    System.out.println(response1.body().string());
+
+    hostSelectionInterceptor.setHost("www.pepsi.com");
+
+    Response<ResponseBody> response2 = pop.robots().execute();
+    System.out.println("Response from: " + response2.raw().request().url());
+    System.out.println(response2.body().string());
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
similarity index 71%
rename from samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
rename to samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 2326319b7..28e8521ac 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -15,15 +15,15 @@
  */
 package com.example.retrofit;
 
-import com.google.common.reflect.TypeToken;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,7 +32,7 @@
  * A sample showing a custom {@link CallAdapter} which adapts the built-in {@link Call} to a custom
  * version whose callback has more granular methods.
  */
-public final class ErrorHandlingCallAdapter {
+public final class ErrorHandlingAdapter {
   /** A callback which offers granular callbacks for various conditions. */
   interface MyCallback<T> {
     /** Called for [200, 300) responses. */
@@ -58,36 +58,48 @@
     // TODO MyResponse<T> execute() throws MyHttpException;
   }
 
-  public static class ErrorHandlingCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
+    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit) {
-      TypeToken<?> token = TypeToken.of(returnType);
-      if (token.getRawType() != MyCall.class) {
+      if (getRawType(returnType) != MyCall.class) {
         return null;
       }
       if (!(returnType instanceof ParameterizedType)) {
         throw new IllegalStateException(
             "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
       }
-      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
+      Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+      Executor callbackExecutor = retrofit.callbackExecutor();
+      return new ErrorHandlingCallAdapter<>(responseType, callbackExecutor);
+    }
 
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call);
-        }
-      };
+    private static final class ErrorHandlingCallAdapter<R> implements CallAdapter<R, MyCall<R>> {
+      private final Type responseType;
+      private final Executor callbackExecutor;
+
+      ErrorHandlingCallAdapter(Type responseType, Executor callbackExecutor) {
+        this.responseType = responseType;
+        this.callbackExecutor = callbackExecutor;
+      }
+
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public MyCall<R> adapt(Call<R> call) {
+        return new MyCallAdapter<>(call, callbackExecutor);
+      }
     }
   }
 
   /** Adapts a {@link Call} to {@link MyCall}. */
   static class MyCallAdapter<T> implements MyCall<T> {
     private final Call<T> call;
+    private final Executor callbackExecutor;
 
-    MyCallAdapter(Call<T> call) {
+    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
       this.call = call;
+      this.callbackExecutor = callbackExecutor;
     }
 
     @Override public void cancel() {
@@ -96,7 +108,10 @@
 
     @Override public void enqueue(final MyCallback<T> callback) {
       call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Response<T> response) {
+        @Override public void onResponse(Call<T> call, Response<T> response) {
+          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
           int code = response.code();
           if (code >= 200 && code < 300) {
             callback.success(response);
@@ -111,7 +126,10 @@
           }
         }
 
-        @Override public void onFailure(Throwable t) {
+        @Override public void onFailure(Call<T> call, Throwable t) {
+          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
           if (t instanceof IOException) {
             callback.networkError((IOException) t);
           } else {
@@ -122,7 +140,7 @@
     }
 
     @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone());
+      return new MyCallAdapter<>(call.clone(), callbackExecutor);
     }
   }
 
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
new file mode 100644
index 000000000..2163f3dec
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Both the Gson converter and the Simple Framework converter accept all types. Because of this,
+ * you cannot use both in a single service by default. In order to work around this, we can create
+ * an @Json and @Xml annotation to declare which serialization format each endpoint should use and
+ * then write our own Converter.Factory which delegates to either the Gson or Simple Framework
+ * converter.
+ */
+public final class JsonAndXmlConverters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  @Retention(RUNTIME)
+  @interface Xml {
+  }
+
+  static class QualifiedTypeConverterFactory extends Converter.Factory {
+    private final Converter.Factory jsonFactory;
+    private final Converter.Factory xmlFactory;
+
+    QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
+      this.jsonFactory = jsonFactory;
+      this.xmlFactory = xmlFactory;
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+        }
+        if (annotation instanceof Xml) {
+          return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        if (annotation instanceof Json) {
+          return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+        if (annotation instanceof Xml) {
+          return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Default(value = DefaultType.FIELD)
+  static class User {
+    @Attribute
+    public String name;
+  }
+
+  interface Service {
+    @GET("/") @Json
+    Call<User> exampleJson();
+    @GET("/") @Xml
+    Call<User> exampleXml();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new QualifiedTypeConverterFactory(
+            GsonConverterFactory.create(),
+            SimpleXmlConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    User user1 = service.exampleJson().execute().body();
+    System.out.println("User 1: " + user1.name);
+
+    User user2 = service.exampleXml().execute().body();
+    System.out.println("User 2: " + user2.name);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
new file mode 100644
index 000000000..bc29f8355
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Query;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+public final class JsonQueryParameters {
+  @Retention(RUNTIME)
+  @interface Json {
+  }
+
+  static class JsonStringConverterFactory extends Converter.Factory {
+    private final Converter.Factory delegateFactory;
+
+    JsonStringConverterFactory(Converter.Factory delegateFactory) {
+      this.delegateFactory = delegateFactory;
+    }
+
+    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        if (annotation instanceof Json) {
+          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+          // reference to it explicitly as a field.
+          Converter<?, RequestBody> delegate =
+              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+          return new DelegateToStringConverter<>(delegate);
+        }
+      }
+      return null;
+    }
+
+    static class DelegateToStringConverter<T> implements Converter<T, String> {
+      private final Converter<T, RequestBody> delegate;
+
+      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override public String convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        delegate.convert(value).writeTo(buffer);
+        return buffer.readUtf8();
+      }
+    }
+  }
+
+  static class Filter {
+    public final String userId;
+
+    public Filter(String userId) {
+      this.userId = userId;
+    }
+  }
+
+  interface Service {
+    @GET("/filter")
+    Call<ResponseBody> example(@Json @Query("value") Filter value);
+  }
+
+  public static void main(String... args) throws IOException, InterruptedException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse());
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Call<ResponseBody> call = service.example(new Filter("123"));
+    Response<ResponseBody> response = call.execute();
+    // TODO handle user response...
+
+    // Print the request path that the server saw to show the JSON query param:
+    RecordedRequest recordedRequest = server.takeRequest();
+    System.out.println(recordedRequest.getPath());
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 6b98ff88b..347c911af 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -73,7 +73,9 @@ public static void main(String... args) throws IOException {
 
     // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
     NetworkBehavior behavior = NetworkBehavior.create();
-    MockRetrofit mockRetrofit = MockRetrofit.create(retrofit, behavior);
+    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+        .networkBehavior(behavior)
+        .build();
 
     BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
     MockGitHub gitHub = new MockGitHub(delegate);
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index 135eb818c..ef5a3060e 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit2.Call;
-import retrofit2.GsonConverterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import retrofit2.http.Path;
diff --git a/website/index.html b/website/index.html
index a7933983c..21483f474 100644
--- a/website/index.html
+++ b/website/index.html
@@ -47,12 +47,12 @@ <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsun
               <h3>Introduction</h3>
               <p>Retrofit turns your HTTP API into a Java interface.</p>
               <pre class="prettyprint">public interface GitHubService {
-  @GET("/users/{user}/repos")
+  @GET("users/{user}/repos")
   Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
               <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .baseUrl("https://api.github.com")
+    .baseUrl("https://api.github.com/")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
@@ -64,7 +64,6 @@ <h3>Introduction</h3>
                 <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
                 <li>Multipart request body and file upload</li>
               </ul>
-              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
             </section>
 
             <section id="api-declaration">
@@ -73,24 +72,24 @@ <h3>API Declaration</h3>
 
               <h4>Request Method</h4>
               <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-              <pre class="prettyprint">@GET("/users/list")</pre>
+              <pre class="prettyprint">@GET("users/list")</pre>
               <p>You can also specify query parameters in the URL.</p>
-              <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
+              <pre class="prettyprint">@GET("users/list?sort=desc")</pre>
 
               <h4>URL Manipulation</h4>
               <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
-              <pre class="prettyprint">@GET("/group/{id}/users")
+              <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId);</pre>
               <p>Query parameters can also be added.</p>
-              <pre class="prettyprint">@GET("/group/{id}/users")
+              <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
               <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
-              <pre class="prettyprint">@GET("/group/{id}/users")
+              <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
               <h4>Request Body</h4>
               <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
-              <pre class="prettyprint">@POST("/users/new")
+              <pre class="prettyprint">@POST("users/new")
 Call&lt;User> createUser(@Body User user);</pre>
               <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
@@ -98,28 +97,28 @@ <h4>Form Encoded and Multipart</h4>
               <p>Methods can also be declared to send form-encoded and multipart data.</p>
               <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
               <pre class="prettyprint">@FormUrlEncoded
-@POST("/user/edit")
+@POST("user/edit")
 Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
               <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
               <pre class="prettyprint">@Multipart
-@PUT("/user/photo")
+@PUT("user/photo")
 Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
               <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
 
               <h4>Header Manipulation</h4>
               <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
               <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
-@GET("/widget/list")
+@GET("widget/list")
 Call&lt;List&lt;Widget>> widgetList();</pre>
               <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
-@GET("/users/{username}")
+@GET("users/{username}")
 Call&lt;User> getUser(@Path("username") String username);</pre>
               <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
               <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
-              <pre class="prettyprint">@GET("/user")
+              <pre class="prettyprint">@GET("user")
 Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
               <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
 
@@ -136,12 +135,13 @@ <h4>Converters</h4>
               <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
               <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
               <ul>
-                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
-                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
-                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
-                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
-                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
-                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
+                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code></li>
+                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li>
+                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li>
+                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li>
+                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li>
+                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li>
+                <li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li>
               </ul>
               <p>Here's an example of using the <code>GsonConverterFactory</code> class to generate an implementation of the <code>GitHubService</code> interface which uses Gson for its deserialization.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
@@ -151,7 +151,7 @@ <h4>Converters</h4>
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
               <h4>Custom Converters</h4>
-              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
+              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
             </section>
 
             <section id="download">
@@ -173,9 +173,15 @@ <h4>Gradle</h4>
               <h4>ProGuard</h4>
               <p>If you are using Proguard in your project add the following lines to your configuration:</p>
               <pre class="prettyprint">
--dontwarn retrofit2.**
--keep class retrofit2.** { *; }
+# Platform calls Class.forName on types which do not exist on Android to determine platform.
+-dontnote retrofit2.Platform
+# Platform used when running on RoboVM on iOS. Will not be used at runtime.
+-dontnote retrofit2.Platform$IOS$MainThreadExecutor
+# Platform used when running on Java 8 VMs. Will not be used at runtime.
+-dontwarn retrofit2.Platform$Java8
+# Retain generic type information for use by reflection by converters and adapters.
 -keepattributes Signature
+# Retain declared checked exceptions for use by a Proxy instance.
 -keepattributes Exceptions
 </pre>
             </section>
