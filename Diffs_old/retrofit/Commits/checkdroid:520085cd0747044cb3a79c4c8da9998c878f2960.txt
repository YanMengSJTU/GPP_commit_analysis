diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 2b0b0e146..b1a7320f8 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -16,5 +16,6 @@
 
   <modules>
     <module>rxjava</module>
+    <module>rxjava-mock</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava-mock/pom.xml b/retrofit-adapters/rxjava-mock/pom.xml
new file mode 100644
index 000000000..d69458e9a
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava-mock</artifactId>
+  <name>Adapter: RxJava Mock</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit-mock</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
new file mode 100644
index 000000000..3fd67a6c8
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class ObservableBehaviorAdapter implements BehaviorAdapter<Observable<?>> {
+  public static ObservableBehaviorAdapter create() {
+    return new ObservableBehaviorAdapter();
+  }
+
+  private ObservableBehaviorAdapter() {
+  }
+
+  @Override public Observable<?> applyBehavior(final Behavior behavior, final Observable<?> value) {
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return value;
+          }
+        });
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
new file mode 100644
index 000000000..6b2528f66
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import rx.Observable;
+import rx.Subscriber;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+
+public final class ObservableBehaviorAdapterTest {
+  interface DoWorkService {
+    Observable<String> response();
+  }
+
+  private final Behavior behavior = Behavior.create(new Random(2847));
+  private DoWorkService service;
+
+  @Before public void setUp() {
+    DoWorkService mockService = new DoWorkService() {
+      @Override public Observable<String> response() {
+        return Observable.just("Hi!");
+      }
+    };
+
+    BehaviorAdapter<?> adapter = ObservableBehaviorAdapter.create();
+    MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
+    service = mockRetrofit.create(DoWorkService.class, mockService);
+  }
+
+  @Test public void failureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Observable<String> observable = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void successAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Observable<String> observable = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
index b5ef199bf..87eedb119 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
@@ -20,7 +20,7 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.List;
@@ -36,7 +36,7 @@
 import static org.junit.Assert.fail;
 
 public final class ObservableCallAdapterFactoryTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
     @GET("/") Observable<String> body();
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
index 7bf80ca88..097bf063e 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
@@ -23,7 +23,7 @@
 
 public final class ResultTest {
   @Test public void response() {
-    Response<String> response = Response.fakeSuccess("Hi");
+    Response<String> response = Response.success("Hi");
     Result<String> result = Result.fromResponse(response);
     assertThat(result.isError()).isFalse();
     assertThat(result.error()).isNull();
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
index abf65483d..8d58997dc 100644
--- a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
@@ -22,8 +22,8 @@
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -79,7 +79,7 @@
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
index 1c4d3f6d2..9df401a7b 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
@@ -27,8 +27,8 @@
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -102,7 +102,7 @@
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
diff --git a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
index 5b05a5335..f919b96f6 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
@@ -21,8 +21,8 @@
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.ToJson;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -78,7 +78,7 @@
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
index d227110da..ed5caa207 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
@@ -17,8 +17,8 @@
 
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.util.List;
 import okio.Buffer;
@@ -42,7 +42,7 @@
     @GET("/") Call<List<String>> wrongType();
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
index 35d2b120a..20df7596f 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
@@ -16,8 +16,8 @@
 package retrofit;
 
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -41,7 +41,7 @@
     @GET("/") Call<String> wrongClass();
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
index 959cf4956..9b395f93d 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
@@ -16,8 +16,8 @@
 package retrofit;
 
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
@@ -41,7 +41,7 @@
     @GET("/") Call<List<String>> wrongType();
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
diff --git a/retrofit-mock/src/main/java/retrofit/MockCall.java b/retrofit-mock/src/main/java/retrofit/MockCall.java
deleted file mode 100644
index 9eed1df72..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockCall.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-
-final class MockCall<T> implements Call<T> {
-  private final MockRetrofit mockRetrofit;
-  private final ExecutorService backgroundExecutor;
-  private final Executor callbackExecutor;
-  private final Response<T> response;
-  private final IOException failure;
-  private final boolean isFailure;
-
-  private volatile Future<?> task;
-  private volatile boolean canceled;
-  private volatile boolean executed;
-
-  MockCall(MockRetrofit mockRetrofit, ExecutorService backgroundExecutor, Executor callbackExecutor,
-      Response<T> response, IOException failure) {
-    if (callbackExecutor == null) {
-      callbackExecutor = new Executor() {
-        @Override public void execute(Runnable command) {
-          command.run();
-        }
-      };
-    }
-    this.mockRetrofit = mockRetrofit;
-    this.backgroundExecutor = backgroundExecutor;
-    this.callbackExecutor = callbackExecutor;
-    this.response = response;
-    this.failure = failure;
-    this.isFailure = failure != null;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public Call<T> clone() {
-    return new MockCall<>(mockRetrofit, backgroundExecutor, callbackExecutor, response, failure);
-  }
-
-  private Response<T> getResponse() throws IOException, InterruptedException {
-    if (mockRetrofit.calculateIsFailure() || isFailure) {
-      Thread.sleep(mockRetrofit.calculateDelayForError());
-      throw isFailure ? failure : new IOException("Mock exception");
-    }
-    Thread.sleep(mockRetrofit.calculateDelayForCall());
-    return response;
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
-    }
-    task = backgroundExecutor.submit(new Runnable() {
-      private void callFailure(final Throwable throwable) {
-        callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            try {
-              callback.onFailure(throwable);
-            } catch (Throwable t) {
-              Thread thread = Thread.currentThread();
-              thread.getUncaughtExceptionHandler().uncaughtException(thread, t);
-            }
-          }
-        });
-      }
-
-      private void callSuccess(final Response<T> response) {
-        callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            try {
-              callback.onResponse(response);
-            } catch (Throwable t) {
-              Thread thread = Thread.currentThread();
-              thread.getUncaughtExceptionHandler().uncaughtException(thread, t);
-            }
-          }
-        });
-      }
-
-      @Override public void run() {
-        Response<T> response;
-        try {
-          response = getResponse();
-        } catch (IOException e) {
-          callFailure(e);
-          return;
-        } catch (InterruptedException e) {
-          callFailure(new InterruptedIOException("canceled"));
-          return;
-        }
-        callSuccess(response);
-      }
-    });
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
-    }
-    if (canceled) {
-      throw new InterruptedIOException("canceled");
-    }
-
-    Future<Response<T>> task = backgroundExecutor.submit(new Callable<Response<T>>() {
-      @Override public Response<T> call() throws Exception {
-        return getResponse();
-      }
-    });
-    this.task = task;
-
-    try {
-      return task.get();
-    } catch (CancellationException | InterruptedException e) {
-      throw new InterruptedIOException("canceled");
-    } catch (ExecutionException e) {
-      Throwable cause = e.getCause();
-      if (cause instanceof RuntimeException) {
-        throw (RuntimeException) cause;
-      }
-      if (cause instanceof IOException) {
-        throw (IOException) cause;
-      }
-      throw new IllegalStateException(cause);
-    }
-  }
-
-  @Override public void cancel() {
-    canceled = true;
-    Future<?> task = this.task;
-    if (task != null) {
-      task.cancel(true);
-    }
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit/MockRetrofit.java
deleted file mode 100644
index 75453d1e9..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockRetrofit.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.io.IOException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-
-/**
- * Creates {@link Call} instances which simulate the delay and error characteristics of a real
- * network.
- * <p>
- * Because APIs are defined as interfaces, versions of the API that use mock data can be created by
- * simply implementing the API interface on a class. These mock implementations execute
- * synchronously which is a large deviation from the behavior of those backed by an API call over
- * the network. By using the {@code Call} instances created using this class, the interface will
- * still use mock data but exhibit the delays and errors of a real network.
- * <p>
- * Example:
- * <pre>
- * public interface UserService {
- *   &#64;GET("/user/{id}")
- *   Call&lt;User> getUser(@Path("id") String userId);
- * }
- *
- * public class MockUserService implements UserService {
- *   private final MockRetrofit mock = // ...
- *
- *   &#64;Override public Call&lt;User> getUser(String userId) {
- *     return mock.newSuccessCall(new User("Jake"));
- *   }
- * }
- * </pre>
- */
-public final class MockRetrofit {
-  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
-  private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by ±40%.
-  private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
-  private static final int DEFAULT_ERROR_DELAY_FACTOR = 3; // Errors will be scaled by this value.
-
-  /**
-   * Create an instance with a normal {@link Retrofit} instance and an executor service on which
-   * the simulated delays will be created. Instances of this class should be re-used so that the
-   * behavior of every mock service is consistent.
-   */
-  public static MockRetrofit from(Retrofit restAdapter, ExecutorService backgroundExecutor) {
-    return new MockRetrofit(restAdapter, backgroundExecutor);
-  }
-
-  private final ExecutorService backgroundExecutor;
-  private final Executor callbackExecutor;
-
-  final Random random = new Random();
-
-  private volatile int delayMs = DEFAULT_DELAY_MS;
-  private volatile int variancePercent = DEFAULT_VARIANCE_PCT;
-  private volatile int errorPercent = DEFAULT_ERROR_PCT;
-
-  private MockRetrofit(Retrofit retrofit, ExecutorService backgroundExecutor) {
-    this.backgroundExecutor = backgroundExecutor;
-    this.callbackExecutor = retrofit.callbackExecutor();
-  }
-
-  /** Create a call which succeeds with {@code body} in its response. */
-  public <T> Call<T> newSuccessCall(T body) {
-    return newSuccessCall(Response.fakeSuccess(body));
-  }
-
-  /** Create a call which succeeds with {@code response}. */
-  public <T> Call<T> newSuccessCall(Response<T> response) {
-    return new MockCall<>(this, backgroundExecutor, callbackExecutor, response, null);
-  }
-
-  /** Create a call which fails with {@code e}.  */
-  public <T> Call<T> newFailureCall(IOException e) {
-    return new MockCall<>(this, backgroundExecutor, callbackExecutor, null, e);
-  }
-
-  /** Set the network round trip delay. */
-  public void setDelay(long amount, TimeUnit unit) {
-    if (amount < 0) {
-      throw new IllegalArgumentException("Amount must be positive value.");
-    }
-    long delayMs = unit.toMillis(amount);
-    if (delayMs > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Delay value too large. Max: " + Integer.MAX_VALUE);
-    }
-    this.delayMs = (int) delayMs;
-  }
-
-  /** The network round trip delay. */
-  public long delay(TimeUnit unit) {
-    return MILLISECONDS.convert(delayMs, unit);
-  }
-
-  /** Set the plus-or-minus variance percentage of the network round trip delay. */
-  public void setVariancePercent(int variancePct) {
-    if (variancePct < 0 || variancePct > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
-    }
-    this.variancePercent = variancePct;
-  }
-
-  /** The plus-or-minus variance percentage of the network round trip delay. */
-  public int variancePercent() {
-    return variancePercent;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public void setErrorPercent(int errorPct) {
-    if (errorPct < 0 || errorPct > 100) {
-      throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
-    }
-    this.errorPercent = errorPct;
-  }
-
-  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public int errorPercent() {
-    return errorPercent;
-  }
-
-  /**
-   * Randomly determine whether this call should result in a network failure.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #newSuccessCall} or {@link #newFailureCall}.
-   */
-  public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < errorPercent;
-  }
-
-  /**
-   * Get the delay (in milliseconds) that should be used for triggering a network error.
-   * <p>
-   * Because we are triggering an error, use a random delay between 0 and three times the normal
-   * network delay to simulate a flaky connection failing anywhere from quickly to slowly.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #newSuccessCall} or {@link #newFailureCall}.
-   */
-  public int calculateDelayForError() {
-    if (delayMs == 0) return 0;
-
-    return random.nextInt(delayMs * DEFAULT_ERROR_DELAY_FACTOR);
-  }
-
-  /**
-   * Get the delay (in milliseconds) that should be used for delaying a network call response.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #newSuccessCall} or {@link #newFailureCall}.
-   */
-  public int calculateDelayForCall() {
-    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
-    float lowerBound = 1f - delta; // 0.2f --> 0.8f
-    float upperBound = 1f + delta; // 0.2f --> 1.2f
-    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
-    float delayPercent = (random.nextFloat() * bound) + lowerBound; // 0.8 + (rnd * 0.4)
-    return (int) (delayMs * delayPercent);
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Behavior.java b/retrofit-mock/src/main/java/retrofit/mock/Behavior.java
new file mode 100644
index 000000000..713561c5c
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/Behavior.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class Behavior {
+  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+  private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
+  private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+
+  public static Behavior create() {
+    return new Behavior(new Random());
+  }
+
+  public static Behavior create(Random random) {
+    return new Behavior(random);
+  }
+
+  private final Random random;
+
+  private volatile long delayMs = DEFAULT_DELAY_MS;
+  private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
+  private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
+  private volatile IOException failureException = new IOException("Mock failure!");
+
+  private Behavior(Random random) {
+    this.random = random;
+  }
+
+  /** Set the network round trip delay. */
+  public void setDelay(long amount, TimeUnit unit) {
+    if (amount < 0) {
+      throw new IllegalArgumentException("Amount must be positive value.");
+    }
+    this.delayMs = unit.toMillis(amount);
+  }
+
+  /** The network round trip delay. */
+  public long delay(TimeUnit unit) {
+    return MILLISECONDS.convert(delayMs, unit);
+  }
+
+  /** Set the plus-or-minus variance percentage of the network round trip delay. */
+  public void setVariancePercent(int variancePercent) {
+    if (variancePercent < 0 || variancePercent > 100) {
+      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+    }
+    this.variancePercent = variancePercent;
+  }
+
+  /** The plus-or-minus variance percentage of the network round trip delay. */
+  public int variancePercent() {
+    return variancePercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public void setFailurePercent(int failurePercent) {
+    if (failurePercent < 0 || failurePercent > 100) {
+      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+    }
+    this.failurePercent = failurePercent;
+  }
+
+  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public int failurePercent() {
+    return failurePercent;
+  }
+
+  /** Set the exception to be used when a failure is triggered. */
+  public void setFailureException(IOException exception) {
+    if (exception == null) {
+      throw new NullPointerException("exception == null");
+    }
+    this.failureException = exception;
+  }
+
+  /** The exception to be used when a failure is triggered. */
+  public IOException failureException() {
+    return failureException;
+  }
+
+  /**
+   * Randomly determine whether this call should result in a network failure in accordance with
+   * configured behavior. When true, {@link #failureException()} should be thrown.
+   */
+  public boolean calculateIsFailure() {
+    int randomValue = random.nextInt(100);
+    return randomValue < failurePercent;
+  }
+
+  /**
+   * Get the delay that should be used for delaying a response in accordance with configured
+   * behavior.
+   */
+  public long calculateDelay(TimeUnit unit) {
+    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
+    float lowerBound = 1f - delta; // 0.2f --> 0.8f
+    float upperBound = 1f + delta; // 0.2f --> 1.2f
+    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
+    long callDelayMs = (long) (delayMs * delayPercent);
+    return MILLISECONDS.convert(callDelayMs, unit);
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java
new file mode 100644
index 000000000..5dde8b58f
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+public interface BehaviorAdapter<T> {
+  T applyBehavior(Behavior behavior, T value);
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
new file mode 100644
index 000000000..2e3bce2a1
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicReference;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+final class BehaviorCall<T> implements Call<T> {
+  private final Behavior behavior;
+  private final ExecutorService backgroundExecutor;
+  private final Executor callbackExecutor;
+  private final Call<T> delegate;
+
+  private volatile Future<?> task;
+  private volatile boolean canceled;
+  private volatile boolean executed;
+
+  BehaviorCall(Behavior behavior, ExecutorService backgroundExecutor, Executor callbackExecutor,
+      Call<T> delegate) {
+    if (callbackExecutor == null) {
+      callbackExecutor = new Executor() {
+        @Override public void execute(Runnable command) {
+          command.run();
+        }
+      };
+    }
+    this.behavior = behavior;
+    this.backgroundExecutor = backgroundExecutor;
+    this.callbackExecutor = callbackExecutor;
+    this.delegate = delegate;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public Call<T> clone() {
+    return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, delegate.clone());
+  }
+
+  @Override public void enqueue(final Callback<T> callback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+    task = backgroundExecutor.submit(new Runnable() {
+      private boolean delaySleep() {
+        long sleepMs = behavior.calculateDelay(MILLISECONDS);
+        if (sleepMs > 0) {
+          try {
+            Thread.sleep(sleepMs);
+          } catch (InterruptedException e) {
+            callFailure(new InterruptedIOException("canceled"));
+            return false;
+          }
+        }
+        return true;
+      }
+
+      private void callResponse(final Response<T> response) {
+        callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            callback.onResponse(response);
+          }
+        });
+      }
+
+      private void callFailure(final Throwable throwable) {
+        callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            callback.onFailure(throwable);
+          }
+        });
+      }
+
+      @Override public void run() {
+        if (canceled) {
+          callFailure(new InterruptedIOException("canceled"));
+        } else if (behavior.calculateIsFailure()) {
+          if (delaySleep()) {
+            callFailure(behavior.failureException());
+          }
+        } else {
+          delegate.enqueue(new Callback<T>() {
+            @Override public void onResponse(final Response<T> response) {
+              if (delaySleep()) {
+                callResponse(response);
+              }
+            }
+
+            @Override public void onFailure(final Throwable t) {
+              if (delaySleep()) {
+                callFailure(t);
+              }
+            }
+          });
+        }
+      }
+    });
+  }
+
+  @Override public Response<T> execute() throws IOException {
+    final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    enqueue(new Callback<T>() {
+      @Override public void onResponse(Response<T> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    try {
+      latch.await();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException("canceled");
+    }
+    Response<T> response = responseRef.get();
+    if (response != null) return response;
+    Throwable failure = failureRef.get();
+    if (failure instanceof RuntimeException) throw (RuntimeException) failure;
+    if (failure instanceof IOException) throw (IOException) failure;
+    throw new RuntimeException(failure);
+  }
+
+  @Override public void cancel() {
+    canceled = true;
+    Future<?> task = this.task;
+    if (task != null) {
+      task.cancel(true);
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
new file mode 100644
index 000000000..e580d1076
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import retrofit.Call;
+import retrofit.Retrofit;
+
+public final class CallBehaviorAdapter implements BehaviorAdapter<Call<?>> {
+  private final Executor callbackExecutor;
+  private final ExecutorService backgroundExecutor;
+
+  /**
+   * Create an instance with a normal {@link Retrofit} instance and an executor service on which
+   * the simulated delays will be created. Instances of this class should be re-used so that the
+   * behavior of every mock service is consistent.
+   */
+  public CallBehaviorAdapter(Retrofit retrofit, ExecutorService backgroundExecutor) {
+    this.callbackExecutor = retrofit.callbackExecutor();
+    this.backgroundExecutor = backgroundExecutor;
+  }
+
+  @Override public Call<?> applyBehavior(Behavior behavior, Call<?> value) {
+    return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, value);
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Calls.java b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
new file mode 100644
index 000000000..e1d0e7e4f
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+
+/** Factory methods for creating {@link Call} instances which immediately respond or fail. */
+public final class Calls {
+  public static <T> Call<T> response(T successValue) {
+    return response(Response.success(successValue));
+  }
+
+  public static <T> Call<T> response(final Response<T> response) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        return response;
+      }
+
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onResponse(response);
+      }
+
+      @Override public void cancel() {
+      }
+
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
+    };
+  }
+
+  public static <T> Call<T> failure(final IOException failure) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        throw failure;
+      }
+
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onFailure(failure);
+      }
+
+      @Override public void cancel() {
+      }
+
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
+    };
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
new file mode 100644
index 000000000..dcd966c13
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+public final class MockRetrofit {
+  private final BehaviorAdapter<Object> adapter;
+  private final Behavior behavior;
+
+  @SuppressWarnings("unchecked") //
+  public MockRetrofit(BehaviorAdapter<?> adapter, Behavior behavior) {
+    this.adapter = (BehaviorAdapter<Object>) adapter;
+    this.behavior = behavior;
+  }
+
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  public <T> T create(Class<T> service, final T instance) {
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
+        new InvocationHandler() {
+          @Override public Object invoke(Object proxy, Method method, Object[] args)
+              throws Throwable {
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            method.setAccessible(true); // Just In Case™
+            return adapter.applyBehavior(behavior, method.invoke(instance, args));
+          }
+        });
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/BehaviorTest.java b/retrofit-mock/src/test/java/retrofit/BehaviorTest.java
new file mode 100644
index 000000000..46b75be17
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit/BehaviorTest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.util.Random;
+import org.junit.Test;
+import retrofit.mock.Behavior;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BehaviorTest {
+  private final Behavior behavior = Behavior.create(new Random(2847));
+
+  @Test public void delayMustBePositive() {
+    try {
+      behavior.setDelay(-1, SECONDS);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Amount must be positive value.");
+    }
+  }
+
+  @Test public void varianceRestrictsRange() {
+    try {
+      behavior.setVariancePercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setVariancePercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void failureRestrictsRange() {
+    try {
+      behavior.setFailurePercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setFailurePercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void failurePercentageIsAccurate() {
+    behavior.setFailurePercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsFailure()).isFalse();
+    }
+
+    behavior.setFailurePercent(3);
+    int failures = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsFailure()) {
+        failures += 1;
+      }
+    }
+    assertThat(failures).isEqualTo(2964); // ~3% of 100k
+  }
+
+  @Test public void delayVarianceIsAccurate() {
+    behavior.setDelay(2, SECONDS);
+
+    behavior.setVariancePercent(0);
+    for (int i = 0; i < 100000; i++) {
+      assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
+    }
+
+    behavior.setVariancePercent(40);
+    long lowerBound = Integer.MAX_VALUE;
+    long upperBound = Integer.MIN_VALUE;
+    for (int i = 0; i < 100000; i++) {
+      long delay = behavior.calculateDelay(MILLISECONDS);
+      if (delay > upperBound) {
+        upperBound = delay;
+      }
+      if (delay < lowerBound) {
+        lowerBound = delay;
+      }
+    }
+    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
+    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
index 9c9764005..f1f2d8cdc 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
@@ -13,161 +13,88 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package retrofit;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.util.Random;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
+import retrofit.mock.Behavior;
+import retrofit.mock.BehaviorAdapter;
+import retrofit.mock.CallBehaviorAdapter;
+import retrofit.mock.Calls;
+import retrofit.mock.MockRetrofit;
 
+import static java.util.concurrent.Executors.newSingleThreadExecutor;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class MockRetrofitTest {
-  private MockRetrofit mockRetrofit;
-
-  @Before public void setUp() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    mockRetrofit = MockRetrofit.from(retrofit, Executors.newCachedThreadPool());
-
-    // Seed the random with a value so the tests are deterministic.
-    mockRetrofit.random.setSeed(2847);
+public final class MockRetrofitTest {
+  interface DoWorkService {
+    Call<String> response();
+    Call<String> failure();
   }
 
-  @Test public void delayRestrictsRange() {
-    try {
-      mockRetrofit.setDelay(-1, SECONDS);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Amount must be positive value.");
-    }
-    try {
-      mockRetrofit.setDelay(Long.MAX_VALUE, SECONDS);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith("Delay value too large.");
-    }
-  }
-
-  @Test public void varianceRestrictsRange() {
-    try {
-      mockRetrofit.setVariancePercent(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-    try {
-      mockRetrofit.setVariancePercent(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-  }
+  private final IOException mockFailure = new IOException("Timeout!");
+  private final Behavior behavior = Behavior.create(new Random(2847));
+  private DoWorkService service;
 
-  @Test public void errorRestrictsRange() {
-    try {
-      mockRetrofit.setErrorPercent(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
-    }
-    try {
-      mockRetrofit.setErrorPercent(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
-    }
-  }
-
-  @Test public void errorPercentageIsAccurate() {
-    mockRetrofit.setErrorPercent(0);
-    for (int i = 0; i < 10000; i++) {
-      assertThat(mockRetrofit.calculateIsFailure()).isFalse();
-    }
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
 
-    mockRetrofit.setErrorPercent(3);
-    int failures = 0;
-    for (int i = 0; i < 100000; i++) {
-      if (mockRetrofit.calculateIsFailure()) {
-        failures += 1;
+    DoWorkService mockService = new DoWorkService() {
+      @Override public Call<String> response() {
+        return Calls.response("Response!");
       }
-    }
-    assertThat(failures).isEqualTo(2964); // ~3% of 100k
-  }
-
-  @Test public void delayVarianceIsAccurate() {
-    mockRetrofit.setDelay(2, SECONDS);
-
-    mockRetrofit.setVariancePercent(0);
-    for (int i = 0; i < 100000; i++) {
-      assertThat(mockRetrofit.calculateDelayForCall()).isEqualTo(2000);
-    }
 
-    mockRetrofit.setVariancePercent(40);
-    int lowerBound = Integer.MAX_VALUE;
-    int upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      int delay = mockRetrofit.calculateDelayForCall();
-      if (delay > upperBound) {
-        upperBound = delay;
+      @Override public Call<String> failure() {
+        return Calls.failure(mockFailure);
       }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
-    }
-    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
-    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
-  }
+    };
 
-  @Test public void errorVarianceIsAccurate() {
-    mockRetrofit.setDelay(2, SECONDS);
-
-    int lowerBound = Integer.MAX_VALUE;
-    int upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      int delay = mockRetrofit.calculateDelayForError();
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
-    }
-    assertThat(upperBound).isEqualTo(5999); // 3 * 2000
-    assertThat(lowerBound).isEqualTo(0);
+    BehaviorAdapter<?> adapter = new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
+    service = mockRetrofit.create(DoWorkService.class, mockService);
   }
 
-  @Test public void syncErrorThrows() {
-    mockRetrofit.setErrorPercent(100);
-    mockRetrofit.setDelay(1, MILLISECONDS);
+  @Test public void syncFailureThrowsAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
 
-    Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    Call<String> call = service.response();
 
+    long startNanos = System.nanoTime();
     try {
       call.execute();
       fail();
     } catch (IOException e) {
-      assertThat(e).hasMessage("Mock exception");
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(e).isSameAs(behavior.failureException());
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
     }
   }
 
-  @Test public void asyncErrorTriggersFailure() throws InterruptedException {
-    mockRetrofit.setErrorPercent(100);
-    mockRetrofit.setDelay(1, MILLISECONDS);
+  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
 
-    Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    Call<String> call = service.response();
 
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
@@ -176,40 +103,42 @@
       }
 
       @Override public void onFailure(Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         failureRef.set(t);
         latch.countDown();
       }
     });
     assertTrue(latch.await(1, SECONDS));
 
-    assertThat(failureRef.get()).hasMessage("Mock exception");
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
   }
 
   @Test public void syncSuccessReturnsAfterDelay() throws IOException {
-    mockRetrofit.setDelay(100, MILLISECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    Call<String> call = service.response();
 
     long startNanos = System.nanoTime();
     Response<String> response = call.execute();
     long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
 
-    assertThat(response.body()).isEqualTo("Hi");
+    assertThat(response.body()).isEqualTo("Response!");
     assertThat(tookMs).isGreaterThanOrEqualTo(100);
   }
 
-  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException {
-    mockRetrofit.setDelay(100, MILLISECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    Call<String> call = service.response();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<>();
+    final AtomicReference<String> actual = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
       @Override public void onResponse(Response<String> response) {
@@ -224,17 +153,16 @@
     });
     assertTrue(latch.await(1, SECONDS));
 
-    assertThat(actual.get()).isEqualTo("Hi");
+    assertThat(actual.get()).isEqualTo("Response!");
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
   }
 
   @Test public void syncFailureThrownAfterDelay() {
-    mockRetrofit.setDelay(100, MILLISECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    IOException failure = new FileNotFoundException("Oh noes");
-    Call<Object> call = mockRetrofit.newFailureCall(failure);
+    Call<String> call = service.failure();
 
     long startNanos = System.nanoTime();
     try {
@@ -243,24 +171,23 @@
     } catch (IOException e) {
       long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
       assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e).isSameAs(failure);
+      assertThat(e).isSameAs(mockFailure);
     }
   }
 
   @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
-    mockRetrofit.setDelay(100, MILLISECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    IOException failure = new FileNotFoundException("Oh noes");
-    Call<Object> call = mockRetrofit.newFailureCall(failure);
+    Call<String> call = service.failure();
 
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     final long startNanos = System.nanoTime();
-    call.enqueue(new Callback<Object>() {
-      @Override public void onResponse(Response<Object> response) {
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
         throw new AssertionError();
       }
 
@@ -273,15 +200,15 @@
     assertTrue(latch.await(1, SECONDS));
 
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(failureRef.get()).isSameAs(failure);
+    assertThat(failureRef.get()).isSameAs(mockFailure);
   }
 
   @Test public void syncCanBeCanceled() throws IOException {
-    mockRetrofit.setDelay(10, SECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    final Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    final Call<String> call = service.response();
 
     new Thread(new Runnable() {
       @Override public void run() {
@@ -301,12 +228,40 @@
     }
   }
 
+  @Test public void asyncCanBeCanceled() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // TODO we shouldn't need to sleep
+    Thread.sleep(100); // Ensure the task has started.
+    call.cancel();
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  }
+
   @Test public void syncCanceledBeforeStart() throws IOException {
-    mockRetrofit.setDelay(100, MILLISECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    final Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    final Call<String> call = service.response();
 
     call.cancel();
     try {
@@ -317,12 +272,13 @@
     }
   }
 
-  @Test public void asyncCanBeCanceled() throws InterruptedException {
-    mockRetrofit.setDelay(10, SECONDS);
-    mockRetrofit.setVariancePercent(0);
-    mockRetrofit.setErrorPercent(0);
+  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
 
-    final Call<String> call = mockRetrofit.newSuccessCall("Hi");
+    final Call<String> call = service.response();
+    call.cancel();
 
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
@@ -337,10 +293,6 @@
       }
     });
 
-    // TODO we shouldn't need to sleep
-    Thread.sleep(100); // Ensure the task has started.
-    call.cancel();
-
     assertTrue(latch.await(1, SECONDS));
     assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
   }
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
index b3a63e616..dab90ff09 100644
--- a/retrofit/src/main/java/retrofit/Response.java
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -29,7 +29,7 @@
   /**
    * TODO
    */
-  public static <T> Response<T> fakeSuccess(T body) {
+  public static <T> Response<T> success(T body) {
     return success(body, new com.squareup.okhttp.Response.Builder() //
         .code(200)
         .protocol(Protocol.HTTP_1_1)
@@ -48,7 +48,7 @@
   /**
    * TODO
    */
-  public static <T> Response<T> fakeError(int code, ResponseBody body) {
+  public static <T> Response<T> error(int code, ResponseBody body) {
     return error(body, new com.squareup.okhttp.Response.Builder() //
         .code(code)
         .protocol(Protocol.HTTP_1_1)
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index b50751631..418b23c00 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -104,7 +104,7 @@ private Retrofit(OkHttpClient client, BaseUrl baseUrl, Converter.Factory convert
   }
 
   /** Create an implementation of the API defined by the {@code service} interface. */
-  @SuppressWarnings("unchecked") // Single interface proxy creation guarded by parameter safety.
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(Class<T> service) {
     Utils.validateServiceClass(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
index c58ba94a3..a0796cf07 100644
--- a/retrofit/src/test/java/retrofit/CallTest.java
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -20,8 +20,8 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.concurrent.CountDownLatch;
@@ -46,7 +46,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class CallTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
     @GET("/") Call<String> getString();
diff --git a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
index 4af377f1b..ca089e3a9 100644
--- a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
@@ -73,7 +73,7 @@
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    final Response<String> response = Response.fakeSuccess("Hi");
+    final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
         return response;
@@ -85,7 +85,7 @@
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    final Response<String> response = Response.fakeSuccess("Hi");
+    final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
         callback.onResponse(response);
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
index 7579ac3c8..27a1548d7 100644
--- a/retrofit/src/test/java/retrofit/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -7,7 +7,7 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -36,7 +36,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class RetrofitTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   interface CallMethod {
     @GET("/") Call<String> disallowed();
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index fda2e614d..b05f00844 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -13,8 +13,11 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import retrofit.Call;
-import retrofit.MockRetrofit;
 import retrofit.Retrofit;
+import retrofit.mock.Behavior;
+import retrofit.mock.CallBehaviorAdapter;
+import retrofit.mock.Calls;
+import retrofit.mock.MockRetrofit;
 
 /**
  * An example of using {@link MockRetrofit} to create a mock service implementation with
@@ -23,12 +26,9 @@
 public final class SimpleMockService {
   /** A mock implementation of the {@link GitHub} API interface. */
   static final class MockGitHub implements GitHub {
-    private final MockRetrofit mockRetrofit;
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
-    public MockGitHub(MockRetrofit mockRetrofit) {
-      this.mockRetrofit = mockRetrofit;
-
+    public MockGitHub() {
       ownerRepoContributors = new LinkedHashMap<>();
 
       // Seed some mock data.
@@ -48,7 +48,7 @@ public MockGitHub(MockRetrofit mockRetrofit) {
           response = contributors;
         }
       }
-      return mockRetrofit.newSuccessCall(response);
+      return Calls.response(response);
     }
 
     public void addContributor(String owner, String repo, String name, int contributions) {
@@ -72,15 +72,17 @@ public static void main(String... args) throws IOException {
         .baseUrl(SimpleService.API_URL)
         .build();
 
-    // Wrap the Retrofit instance to allow creating mock calls which fake network delay.
+    // Create the Behavior object which manages the fake behavior and the background executor.
+    Behavior behavior = Behavior.create();
     ExecutorService bg = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
         .setNameFormat("mock-retrofit-%d")
         .setDaemon(true)
         .build());
-    MockRetrofit mockRetrofit = MockRetrofit.from(retrofit, bg);
 
-    // Create the mock implementation passing in the MockRetrofit to use.
-    MockGitHub gitHub = new MockGitHub(mockRetrofit);
+    // Create the mock implementation and use MockRetrofit to apply the behavior to it.
+    MockRetrofit mockRetrofit = new MockRetrofit(new CallBehaviorAdapter(retrofit, bg), behavior);
+    MockGitHub mockGitHub = new MockGitHub();
+    GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
     printContributors(gitHub, "square", "retrofit");
@@ -88,8 +90,8 @@ public static void main(String... args) throws IOException {
 
     // Using the mock object, add some additional mock data.
     System.out.println("Adding more mock data...\n");
-    gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
-    gitHub.addContributor("square", "picasso", "Kit Kat", 53);
+    mockGitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+    mockGitHub.addContributor("square", "picasso", "Kit Kat", 53);
 
     // Query for the contributors again so we can see the mock data that was added.
     printContributors(gitHub, "square", "retrofit");
