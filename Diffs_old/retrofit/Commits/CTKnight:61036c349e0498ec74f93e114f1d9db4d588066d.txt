diff --git a/retrofit-processors/pom.xml b/retrofit-processors/pom.xml
index f0d4902ca..11b7ddffb 100644
--- a/retrofit-processors/pom.xml
+++ b/retrofit-processors/pom.xml
@@ -38,6 +38,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>javapoet</artifactId>
+      <version>1.11.1</version>
+    </dependency>
     <dependency>
       <groupId>org.jetbrains.kotlin</groupId>
       <artifactId>kotlin-test-junit</artifactId>
diff --git a/retrofit-processors/src/main/kotlin/retrofit2/RetrofitCheckProcessor.kt b/retrofit-processors/src/main/kotlin/retrofit2/RetrofitCheckProcessor.kt
index ad224d364..7ca0bbfeb 100644
--- a/retrofit-processors/src/main/kotlin/retrofit2/RetrofitCheckProcessor.kt
+++ b/retrofit-processors/src/main/kotlin/retrofit2/RetrofitCheckProcessor.kt
@@ -1,46 +1,43 @@
 package retrofit2
 
 import com.google.auto.service.AutoService
+import com.squareup.javapoet.ArrayTypeName
+import com.squareup.javapoet.ParameterizedTypeName
+import com.squareup.javapoet.TypeName
+import com.squareup.javapoet.TypeVariableName
+import com.squareup.javapoet.WildcardTypeName
 import retrofit2.processors.ErrorMessage
 import retrofit2.processors.RetrofitService
+import retrofit2.processors.error
+import retrofit2.processors.warning
 import javax.annotation.processing.AbstractProcessor
-import javax.annotation.processing.Filer
-import javax.annotation.processing.Messager
 import javax.annotation.processing.ProcessingEnvironment
 import javax.annotation.processing.Processor
 import javax.annotation.processing.RoundEnvironment
 import javax.lang.model.SourceVersion
-import javax.lang.model.element.Element
 import javax.lang.model.element.ElementKind
 import javax.lang.model.element.ExecutableElement
 import javax.lang.model.element.TypeElement
-import javax.lang.model.util.Elements
-import javax.lang.model.util.Types
-import javax.tools.Diagnostic
 
 @AutoService(Processor::class)
 class RetrofitCheckProcessor : AbstractProcessor() {
-  private lateinit var typeUtils: Types
-  private lateinit var elementUtils: Elements
-  private lateinit var filer: Filer
-  private lateinit var messager: Messager
+
+  lateinit var processingEnvironment: ProcessingEnvironment
+    private set
 
   @Synchronized
   override fun init(env: ProcessingEnvironment) {
     super.init(env)
-    typeUtils = env.typeUtils
-    elementUtils = env.elementUtils
-    filer = env.filer
-    messager = env.messager
+
+    this.processingEnvironment = env
   }
 
   override fun process(annoations: Set<TypeElement>, env: RoundEnvironment): Boolean {
     env.getElementsAnnotatedWith(RetrofitService::class.java).forEach { annotated ->
       if (annotated !is TypeElement) {
-        warning(annotated, ErrorMessage.NOT_TYPE_ELEMENT)
+        processingEnvironment.warning(annotated, ErrorMessage.NOT_TYPE_ELEMENT)
         return@forEach
       }
-
       validateInterface(annotated)
     }
     return true
@@ -51,32 +48,50 @@ class RetrofitCheckProcessor : AbstractProcessor() {
 
   override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latestSupported()
 
-  private fun error(e: Element, msg: String) {
-    messager.printMessage(Diagnostic.Kind.ERROR, msg, e)
-  }
-
-  private fun warning(e: Element, msg: String) {
-    messager.printMessage(Diagnostic.Kind.WARNING, msg, e)
-  }
-
   private fun validateInterface(annotated: TypeElement) {
     if (annotated.kind != ElementKind.INTERFACE) {
-      error(annotated, ErrorMessage.INVALID_TYPE)
+      processingEnvironment.error(annotated, ErrorMessage.INVALID_TYPE)
     }
 
     if (!annotated.interfaces.isEmpty()) {
-      error(annotated, ErrorMessage.TOO_MUCH_INTERFACE)
+      processingEnvironment.error(annotated, ErrorMessage.TOO_MUCH_INTERFACE)
     }
 
     val methods = annotated
         .enclosedElements
+        .asSequence()
         .mapNotNull { element -> element as? ExecutableElement }
         .filter { element -> !element.isDefault }
+        .toList()
 
     methods.forEach { validateMethod(it) }
   }
 
   private fun validateMethod(element: ExecutableElement) {
     val returnType = element.returnType
+    val returnTypeName = TypeName.get(returnType)
+    validReturnType(returnTypeName, element)
+  }
+
+  private fun validReturnType(returnTypeName: TypeName, element: ExecutableElement) {
+    when (returnTypeName) {
+      TypeName.VOID -> {
+        processingEnvironment.error(element, ErrorMessage.METHOD_RETURN_VOID)
+      }
+      is TypeVariableName -> {
+        processingEnvironment.error(element,
+            "${ErrorMessage.METHOD_RETURN_UNRESOLVED}: ${returnTypeName.name}")
+      }
+      is WildcardTypeName -> {
+        processingEnvironment.error(element,
+            "${ErrorMessage.METHOD_RETURN_UNRESOLVED}: $returnTypeName")
+      }
+      is ArrayTypeName -> {
+        validReturnType(returnTypeName.componentType, element)
+      }
+      is ParameterizedTypeName -> {
+        returnTypeName.typeArguments.forEach { validReturnType(it, element) }
+      }
+    }
   }
-}
\ No newline at end of file
+}
diff --git a/retrofit-processors/src/main/kotlin/retrofit2/processors/Constants.kt b/retrofit-processors/src/main/kotlin/retrofit2/processors/Constants.kt
index b0d04350f..e76ad7f4b 100644
--- a/retrofit-processors/src/main/kotlin/retrofit2/processors/Constants.kt
+++ b/retrofit-processors/src/main/kotlin/retrofit2/processors/Constants.kt
@@ -4,6 +4,8 @@ class ErrorMessage {
   companion object {
     const val INVALID_TYPE = "API declarations must be interfaces."
     const val TOO_MUCH_INTERFACE = "API interfaces must not extend other interfaces."
-    const val NOT_TYPE_ELEMENT = "The annotated element is not an instance of TypeElement, skipped"
+    const val NOT_TYPE_ELEMENT = "The annotated element is not an instance of TypeElement, skipped."
+    const val METHOD_RETURN_VOID = "Service methods cannot return void."
+    const val METHOD_RETURN_UNRESOLVED = "Method return type must not include a type variable or wildcard"
   }
 }
\ No newline at end of file
diff --git a/retrofit-processors/src/main/kotlin/retrofit2/processors/LogUtils.kt b/retrofit-processors/src/main/kotlin/retrofit2/processors/LogUtils.kt
new file mode 100644
index 000000000..21eb0beb9
--- /dev/null
+++ b/retrofit-processors/src/main/kotlin/retrofit2/processors/LogUtils.kt
@@ -0,0 +1,13 @@
+package retrofit2.processors
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.Element
+import javax.tools.Diagnostic
+
+fun ProcessingEnvironment.error(e: Element, msg: String) {
+  messager.printMessage(Diagnostic.Kind.ERROR, msg, e)
+}
+
+fun ProcessingEnvironment.warning(e: Element, msg: String) {
+  messager.printMessage(Diagnostic.Kind.WARNING, msg, e)
+}
\ No newline at end of file
