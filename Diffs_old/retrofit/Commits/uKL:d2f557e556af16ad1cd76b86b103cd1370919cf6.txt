diff --git a/retrofit/src/main/java/retrofit/CallbackRunnable.java b/retrofit/src/main/java/retrofit/CallbackRunnable.java
index c11734003..6c503f65e 100644
--- a/retrofit/src/main/java/retrofit/CallbackRunnable.java
+++ b/retrofit/src/main/java/retrofit/CallbackRunnable.java
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package retrofit;
 
 import java.util.concurrent.Executor;
 
 /**
- * A {@link Runnable} executed on a background thread to invoke {@link #obtainResponse()} which
- * performs an HTTP request. The response of the request, whether it be an object or exception, is
- * then marshaled to the supplied {@link Executor} in the form of a method call on a
- * {@link Callback}.
+ * A {@link Runnable} executed on a background thread to invoke
+ * {@link #obtainResponse()} which performs an HTTP request. The response of the
+ * request, whether it be an object or exception, is then marshaled to the
+ * supplied {@link Executor} in the form of a method call on a {@link Callback}.
  */
 abstract class CallbackRunnable<T> implements Runnable {
   private final Callback<T> callback;
@@ -32,8 +33,7 @@
     this.callbackExecutor = callbackExecutor;
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public final void run() {
+  @SuppressWarnings("unchecked") @Override public final void run() {
     try {
       final ResponseWrapper wrapper = obtainResponse();
       callbackExecutor.execute(new Runnable() {
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 2c198c87c..77212ef25 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -68,6 +68,11 @@
  * {@link retrofit.converter.Converter Converter}.
  * </ul>
  * <p>
+ * If your do not want the response to be converted you can use {@link VoidResponse} as a
+ * {@link Callback} type. Response body won't be copied from the {@link InputStream} and you
+ * will save the memory. You can use {@link VoidResponse}
+ * in both synchronous and asynchronous calls.
+ * <p>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
  * will be converted to request representation by a call to
  * {@link retrofit.converter.Converter#toBody(Object) toBody} on the supplied
@@ -282,8 +287,12 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
         Type type = methodDetails.responseObjectType;
 
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-          if (type.equals(Void.class)) {
-            return null;
+          if (type.equals(VoidResponse.class)) {
+            if (methodDetails.isSynchronous) {
+              return null;
+            }
+
+            return new ResponseWrapper(response, null);
           }
           // Caller requested the raw Response object directly.
           if (type.equals(Response.class)) {
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 5c113a886..980bdf675 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -30,6 +30,7 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
 import static org.mockito.Matchers.same;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
@@ -72,7 +73,8 @@
     @GET("/") void something(Callback<Object> callback);
     @GET("/") Response direct();
     @GET("/") void direct(Callback<Response> callback);
-    @GET("/") Void directWithVoidResponse();
+    @GET("/") VoidResponse directWithVoidResponse();
+    @GET("/") void directWithVoidResponse(Callback<VoidResponse> callback);
   }
 
   private Client mockClient;
@@ -446,18 +448,36 @@ public void log(String message) {
   }
 
   @Test public void getNoResponseShouldNotTouchResponse() throws Exception {
-      // given
-      TypedInput mockInput = mock(TypedInput.class);
-      Response response = new Response(200, "OK", NO_HEADERS, mockInput);
-      when(mockClient.execute(any(Request.class))) //
-          .thenReturn(response);
+    // given
+    TypedInput mockInput = mock(TypedInput.class);
+    Response response = new Response(200, "OK", NO_HEADERS, mockInput);
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(response);
 
-      // when
-      example.directWithVoidResponse();
+    // when
+    example.directWithVoidResponse();
 
-      // then
-      verify(mockInput, never()).in();
-    }
+    // then
+    verify(mockInput, never()).in();
+  }
+
+  @Test public void getNoResponseShouldNotTouchResponseAsync() throws Exception {
+    // given
+    Callback<VoidResponse> callback = mock(Callback.class);
+    TypedInput mockInput = mock(TypedInput.class);
+    Response response = new Response(200, "OK", NO_HEADERS, mockInput);
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(response);
+
+    // when
+    example.directWithVoidResponse(callback);
+
+    // then
+    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+    verify(mockCallbackExecutor).execute(any(Runnable.class));
+    verify(callback).success(isNull(VoidResponse.class), same(response));
+    verify(mockInput, never()).in();
+  }
 
   @Test public void getResponseDirectlyAsync() throws Exception {
     Response response = new Response(200, "OK", NO_HEADERS, null);
