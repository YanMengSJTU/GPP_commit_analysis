diff --git a/README.md b/README.md
index 3a6acb0c5..68301a9ed 100644
--- a/README.md
+++ b/README.md
@@ -1,10 +1,23 @@
-Retrofit
+Retrofit Lax
 ========
 
-Type-safe HTTP client for Android and Java by Square, Inc.
-
+This is a modified version of the type-safe HTTP client for Android and Java by Square, Inc. 
 For more information please see [the website][1].
 
+Notable modifications:
+
+1. Service methods may now return `void`, as long as a compatible `CallAdapterFactory` 
+is provided.
+2. The `adapter-pojo` module includes a `PojoCallAdapterFactory` that executes
+requests immediately and throws an `HttpException` if the response is anything 
+outside the `2xx` range. This also handles `void` return types by returning `null`.
+    - You will need to include the `adapter-pojo` module as a separate dependency
+and provide a `ConverterFactory` that can convert any types your interface will 
+be returning.
+3. The `@QueryObject` annotation may be added to a method parameter. This unwraps
+each readable property of a POJO into a query parameter. Properties must have a public 
+getter method to be parsed.
+
 
 Download
 --------
@@ -21,7 +34,7 @@ Grab via Maven:
     <dependency>
         <groupId>com.github.kjens93.retrofit-lax</groupId>
         <artifactId>retrofit</artifactId>
-        <version>2.1.0</version>
+        <version>2.1.1</version>
     </dependency>
 </dependencies>
 ```
@@ -33,7 +46,7 @@ allprojects {
         maven { url 'https://jitpack.io' }
     }
     dependencies {
-        compile 'com.squareup.retrofit2:retrofit:2.1.0'
+        compile 'com.squareup.retrofit2:retrofit:2.1.1'
     }
 }
 ```
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 583ae038f..f1cd6381e 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -18,6 +18,11 @@
       <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
     </dependency>
+    <dependency>
+      <groupId>commons-beanutils</groupId>
+      <artifactId>commons-beanutils</artifactId>
+      <version>1.9.3</version>
+    </dependency>
 
     <dependency>
       <groupId>com.google.android</groupId>
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..f2edf9dbb 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -15,12 +15,17 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.reflect.Array;
-import java.util.Map;
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
+import org.apache.commons.beanutils.PropertyUtils;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Type;
+import java.util.Map;
 
 import static retrofit2.Utils.checkNotNull;
 
@@ -139,6 +144,45 @@
     }
   }
 
+  static final class QueryObject extends ParameterHandler<Object> {
+    private final boolean encoded;
+    private final Retrofit retrofit;
+    private final Annotation[] annotations;
+
+    QueryObject(boolean encoded, Retrofit retrofit, Annotation[] annotations) {
+      this.encoded = encoded;
+      this.retrofit = retrofit;
+      this.annotations = annotations;
+    }
+
+    @Override void apply(RequestBuilder builder, Object value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Query object was null.");
+      }
+      try {
+        Map<String, Object> properties = PropertyUtils.describe(value);
+        if (properties.get("class") instanceof Type) {
+          properties.remove("class");
+        }
+        if (properties.isEmpty()) {
+          throw new IllegalArgumentException("Query object does not have any readable properties. " +
+                  "Do the intended properties have a public getter method?");
+        }
+        for (Map.Entry<String, Object> property : properties.entrySet()) {
+          String entryKey = property.getKey();
+          Object entryValue = property.getValue();
+          if (entryValue != null) {
+            Converter<Object, String> valueConverter =
+                    retrofit.stringConverter(entryValue.getClass().getGenericSuperclass(), annotations);
+            builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+          }
+        }
+      } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+        throw new IllegalArgumentException("Query object could not be read", e);
+      }
+    }
+  }
+
   static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
 
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 51f0a757e..e60ec8642 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -425,6 +425,9 @@ private Headers parseHeaders(String[] headers) {
 
         return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
+      } else if (annotation instanceof QueryObject) {
+        return new ParameterHandler.QueryObject(((QueryObject) annotation).encoded(), retrofit, annotations);
+
       } else if (annotation instanceof Header) {
         Header header = (Header) annotation;
         String name = header.value();
diff --git a/retrofit/src/main/java/retrofit2/http/QueryObject.java b/retrofit/src/main/java/retrofit2/http/QueryObject.java
new file mode 100644
index 000000000..29ae6aa17
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/QueryObject.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter keys and values appended to the URL.
+ * <p>
+ * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
+ * <p>
+ * Simple Example, given the class:
+ * <pre><code>
+ *     class Foo {
+ *       String foo;
+ *       String kit;
+ *       //Constructors, getters, setters
+ *     }
+ * </code></pre>
+ * and the interface:
+ * <pre><code>
+ *     &#64;GET("/search")
+ *     Call&lt;ResponseBody&gt; list(@QueryMap Foo filters);
+ * </code></pre>
+ *
+ * </code></pre>
+ * Calling with {@code new Foo("bar", "kat")} yields
+ * {@code /search?foo=bar&kit=kat}.
+ * <p>
+ * Keys and values representing parameter values are URL encoded by default. Specify
+ * {@link #encoded() encoded=true} to change this behavior.
+ *
+ * A {@code null} value, as a key, is not allowed. A {@code null} value, as a value,
+ * omits the entry from the query.
+ *
+ * @see Query
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryObject {
+  /** Specifies whether parameter names and values are already URL encoded. */
+  boolean encoded() default false;
+}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 0f3b5ebe6..cbe70b88b 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -15,49 +15,20 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.math.BigInteger;
-import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
+import okhttp3.*;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
 import retrofit2.helpers.ToStringConverterFactory;
-import retrofit2.http.Body;
-import retrofit2.http.DELETE;
-import retrofit2.http.Field;
-import retrofit2.http.FieldMap;
-import retrofit2.http.FormUrlEncoded;
-import retrofit2.http.GET;
-import retrofit2.http.HEAD;
-import retrofit2.http.HTTP;
-import retrofit2.http.Header;
-import retrofit2.http.HeaderMap;
+import retrofit2.http.*;
 import retrofit2.http.Headers;
-import retrofit2.http.Multipart;
-import retrofit2.http.OPTIONS;
-import retrofit2.http.PATCH;
-import retrofit2.http.POST;
-import retrofit2.http.PUT;
-import retrofit2.http.Part;
-import retrofit2.http.PartMap;
-import retrofit2.http.Path;
-import retrofit2.http.Query;
-import retrofit2.http.QueryMap;
-import retrofit2.http.Url;
+
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.math.BigInteger;
+import java.net.URI;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertNull;
@@ -533,6 +504,56 @@
     }
   }
 
+  @Test public void getWithQueryObject() {
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryObject Foo foo) { return null; }
+    }
+
+    Foo foo = new Foo();
+
+    foo.bar = "hi";
+
+    Request request = buildRequest(Example.class, foo);
+
+    assertThat(request.url().toString()).contains("bar=hi");
+
+  }
+
+  @Test public void queryObjectMustHaveReadableProperties() {
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryObject Bar bar) { return null; }
+    }
+
+    Bar bar = new Bar();
+
+    bar.bar = "hi";
+
+    try {
+      buildRequest(Example.class, bar);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining("public getter method");
+    }
+
+  }
+
+  @Test public void queryObjectSupportsNullValues() {
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryObject Foo foo) { return null; }
+    }
+
+    Request request = buildRequest(Example.class, new Foo());
+
+    assertThat(request.url().toString()).doesNotContain("bar");
+
+  }
+
   @Test public void getWithHeaderMap() {
     class Example {
       @GET("/search")
@@ -2490,6 +2511,17 @@
     assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
   }
 
+  public static class Foo {
+    public String getBar() {
+      return bar;
+    }
+    public String bar;
+  }
+
+  public static class Bar {
+    public String bar;
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
