diff --git a/pom.xml b/pom.xml
index 4e9818dfd..96b732dbf 100644
--- a/pom.xml
+++ b/pom.xml
@@ -53,7 +53,7 @@
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.9</rxjava.version>
+    <rxjava.version>1.2.0</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.7</gson.version>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index df40799c5..b3624fc3a 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -57,7 +57,7 @@ private GuavaCallAdapterFactory() {
   }
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != ListenableFuture.class) {
       return null;
     }
@@ -69,7 +69,7 @@ private GuavaCallAdapterFactory() {
 
     if (getRawType(innerType) != Response.class) {
       // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+      return new BodyCallAdapter<>(innerType);
     }
 
     // Generic type is Response<T>. Extract T and create the Response version of the adapter.
@@ -78,10 +78,10 @@ private GuavaCallAdapterFactory() {
           + " as Response<Foo> or Response<? extends Foo>");
     }
     Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
+    return new ResponseCallAdapter<>(responseType);
   }
 
-  private static class BodyCallAdapter implements CallAdapter<ListenableFuture<?>> {
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, ListenableFuture<R>> {
     private final Type responseType;
 
     BodyCallAdapter(Type responseType) {
@@ -92,7 +92,7 @@ private GuavaCallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> ListenableFuture<R> adapt(final Call<R> call) {
+    @Override public ListenableFuture<R> adapt(final Call<R> call) {
       return new AbstractFuture<R>() {
         {
           call.enqueue(new Callback<R>() {
@@ -117,7 +117,8 @@ private GuavaCallAdapterFactory() {
     }
   }
 
-  private static class ResponseCallAdapter implements CallAdapter<ListenableFuture<?>> {
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, ListenableFuture<Response<R>>> {
     private final Type responseType;
 
     ResponseCallAdapter(Type responseType) {
@@ -128,7 +129,7 @@ private GuavaCallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> ListenableFuture<Response<R>> adapt(final Call<R> call) {
+    @Override public ListenableFuture<Response<R>> adapt(final Call<R> call) {
       return new AbstractFuture<Response<R>>() {
         {
           call.enqueue(new Callback<R>() {
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
index 62d449eb9..c8abdf1c2 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -72,7 +72,7 @@
   }
 
   @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index b0bd0efb0..fd905475d 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -56,7 +56,7 @@ private Java8CallAdapterFactory() {
   }
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != CompletableFuture.class) {
       return null;
     }
@@ -68,7 +68,7 @@ private Java8CallAdapterFactory() {
 
     if (getRawType(innerType) != Response.class) {
       // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+      return new BodyCallAdapter<>(innerType);
     }
 
     // Generic type is Response<T>. Extract T and create the Response version of the adapter.
@@ -77,10 +77,10 @@ private Java8CallAdapterFactory() {
           + " as Response<Foo> or Response<? extends Foo>");
     }
     Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
+    return new ResponseCallAdapter<>(responseType);
   }
 
-  private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
     private final Type responseType;
 
     BodyCallAdapter(Type responseType) {
@@ -91,7 +91,7 @@ private Java8CallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> CompletableFuture<R> adapt(final Call<R> call) {
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
       final CompletableFuture<R> future = new CompletableFuture<R>() {
         @Override public boolean cancel(boolean mayInterruptIfRunning) {
           if (mayInterruptIfRunning) {
@@ -119,7 +119,8 @@ private Java8CallAdapterFactory() {
     }
   }
 
-  private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
     private final Type responseType;
 
     ResponseCallAdapter(Type responseType) {
@@ -130,7 +131,7 @@ private Java8CallAdapterFactory() {
       return responseType;
     }
 
-    @Override public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
       final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
         @Override public boolean cancel(boolean mayInterruptIfRunning) {
           if (mayInterruptIfRunning) {
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
index 89d2b9537..283268881 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -72,7 +72,7 @@
   }
 
   @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
new file mode 100644
index 000000000..88e5c5e4e
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.Callable;
+import retrofit2.Response;
+
+final class BodyCallable<R> implements Callable<R> {
+  private final Callable<Response<R>> responseCallable;
+
+  BodyCallable(Callable<Response<R>> responseCallable) {
+    this.responseCallable = responseCallable;
+  }
+
+  @Override public R call() throws Exception {
+    Response<R> response = responseCallable.call();
+    if (response.isSuccessful()) {
+      return response.body();
+    }
+    throw new HttpException(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
deleted file mode 100644
index 1ae1499eb..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import retrofit2.Response;
-import rx.Observable.OnSubscribe;
-import rx.Subscriber;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaPlugins;
-
-final class BodyOnSubscribe<T> implements OnSubscribe<T> {
-  private final OnSubscribe<Response<T>> upstream;
-
-  BodyOnSubscribe(OnSubscribe<Response<T>> upstream) {
-    this.upstream = upstream;
-  }
-
-  @Override public void call(Subscriber<? super T> subscriber) {
-    upstream.call(new BodySubscriber<>(subscriber));
-  }
-
-  private static class BodySubscriber<R> extends Subscriber<Response<R>> {
-    private final Subscriber<? super R> subscriber;
-    /** Indicates whether a terminal event has been sent to {@link #subscriber}. */
-    private boolean subscriberTerminated;
-
-    BodySubscriber(Subscriber<? super R> subscriber) {
-      super(subscriber);
-      this.subscriber = subscriber;
-    }
-
-    @Override public void onNext(Response<R> response) {
-      if (response.isSuccessful()) {
-        subscriber.onNext(response.body());
-      } else {
-        subscriberTerminated = true;
-        Throwable t = new HttpException(response);
-        try {
-          subscriber.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          CompositeException composite = new CompositeException(t, inner);
-          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
-        }
-      }
-    }
-
-    @Override public void onError(Throwable throwable) {
-      if (!subscriberTerminated) {
-        subscriber.onError(throwable);
-      } else {
-        // This should never happen! onNext handles and forwards errors automatically.
-        Throwable broken = new AssertionError(
-            "This should never happen! Report as a Retrofit bug with the full stacktrace.");
-        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
-        broken.initCause(throwable);
-        RxJavaPlugins.getInstance().getErrorHandler().handleError(broken);
-      }
-    }
-
-    @Override public void onCompleted() {
-      if (!subscriberTerminated) {
-        subscriber.onCompleted();
-      }
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
deleted file mode 100644
index a76a86a4f..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-import retrofit2.Call;
-import retrofit2.Response;
-import rx.Observable.OnSubscribe;
-import rx.Producer;
-import rx.Subscriber;
-import rx.Subscription;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaPlugins;
-
-final class CallOnSubscribe<T> implements OnSubscribe<Response<T>> {
-  private final Call<T> originalCall;
-
-  CallOnSubscribe(Call<T> originalCall) {
-    this.originalCall = originalCall;
-  }
-
-  @Override public void call(Subscriber<? super Response<T>> subscriber) {
-    // Since Call is a one-shot type, clone it for each new subscriber.
-    Call<T> call = originalCall.clone();
-    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
-    subscriber.add(arbiter);
-    subscriber.setProducer(arbiter);
-  }
-
-  private static final class CallArbiter<T> extends AtomicBoolean
-      implements Subscription, Producer {
-    private final Call<T> call;
-    private final Subscriber<? super Response<T>> subscriber;
-
-    CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
-      this.call = call;
-      this.subscriber = subscriber;
-    }
-
-    @Override public void unsubscribe() {
-      call.cancel();
-    }
-
-    @Override public boolean isUnsubscribed() {
-      return call.isCanceled();
-    }
-
-    @Override public void request(long amount) {
-      if (amount == 0 || !compareAndSet(false, true)) {
-        return;
-      }
-
-      boolean terminated = false;
-      try {
-        Response<T> response = call.execute();
-        if (!call.isCanceled()) {
-          subscriber.onNext(response);
-        }
-        if (!call.isCanceled()) {
-          terminated = true;
-          subscriber.onCompleted();
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (terminated) {
-          RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
-        } else if (!call.isCanceled()) {
-          try {
-            subscriber.onError(t);
-          } catch (Throwable inner) {
-            Exceptions.throwIfFatal(inner);
-            CompositeException composite = new CompositeException(t, inner);
-            RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
-          }
-        }
-      }
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
new file mode 100644
index 000000000..7d075e71b
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import retrofit2.Call;
+import retrofit2.Response;
+
+final class ResponseCallable<T> implements Callable<Response<T>> {
+  private final Call<T> call;
+
+  ResponseCallable(Call<T> call) {
+    this.call = call;
+  }
+
+  @Override public Response<T> call() throws IOException {
+    // Since Call is a one-shot type, clone it for each new caller.
+    return call.clone().execute();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
new file mode 100644
index 000000000..ea9e37c25
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.Callable;
+import retrofit2.Response;
+
+final class ResultCallable<R> implements Callable<Result<R>> {
+  private final Callable<Response<R>> responseCallable;
+
+  ResultCallable(Callable<Response<R>> responseCallable) {
+    this.responseCallable = responseCallable;
+  }
+
+  @Override public Result<R> call() {
+    try {
+      return Result.response(responseCallable.call());
+    } catch (Throwable t) {
+      return Result.error(t);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
deleted file mode 100644
index 798df5af8..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import retrofit2.Response;
-import rx.Observable.OnSubscribe;
-import rx.Subscriber;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaPlugins;
-
-final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
-  private final OnSubscribe<Response<T>> upstream;
-
-  ResultOnSubscribe(OnSubscribe<Response<T>> upstream) {
-    this.upstream = upstream;
-  }
-
-  @Override public void call(Subscriber<? super Result<T>> subscriber) {
-    upstream.call(new ResultSubscriber<T>(subscriber));
-  }
-
-  private static class ResultSubscriber<R> extends Subscriber<Response<R>> {
-    private final Subscriber<? super Result<R>> subscriber;
-
-    ResultSubscriber(Subscriber<? super Result<R>> subscriber) {
-      super(subscriber);
-      this.subscriber = subscriber;
-    }
-
-    @Override public void onNext(Response<R> response) {
-      subscriber.onNext(Result.response(response));
-    }
-
-    @Override public void onError(Throwable throwable) {
-      try {
-        subscriber.onNext(Result.<R>error(throwable));
-      } catch (Throwable t) {
-        try {
-          subscriber.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          CompositeException composite = new CompositeException(t, inner);
-          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
-        }
-        return;
-      }
-      subscriber.onCompleted();
-    }
-
-    @Override public void onCompleted() {
-      subscriber.onCompleted();
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index 5a728aff8..19cf184ad 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -18,12 +18,10 @@
 import java.lang.reflect.Type;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
-import retrofit2.Response;
 import rx.Observable;
-import rx.Observable.OnSubscribe;
 import rx.Scheduler;
 
-final class RxJavaCallAdapter implements CallAdapter<Object> {
+final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
   private final Scheduler scheduler;
   private final boolean isResult;
@@ -45,25 +43,24 @@
     return responseType;
   }
 
-  @Override public <R> Object adapt(Call<R> call) {
-    OnSubscribe<Response<R>> callFunc = new CallOnSubscribe<>(call);
+  @Override public Object adapt(Call<R> call) {
+    ResponseCallable<R> resultCallable = new ResponseCallable<>(call);
 
-    OnSubscribe<?> func;
+    Observable<?> observable;
     if (isResult) {
-      func = new ResultOnSubscribe<>(callFunc);
+      observable = Observable.fromCallable(new ResultCallable<>(resultCallable));
     } else if (isBody) {
-      func = new BodyOnSubscribe<>(callFunc);
+      observable = Observable.fromCallable(new BodyCallable<>(resultCallable));
     } else {
-      func = callFunc;
+      observable = Observable.fromCallable(resultCallable);
     }
-    Observable<?> observable = Observable.create(func);
 
     if (scheduler != null) {
       observable = observable.subscribeOn(scheduler);
     }
 
     if (isSingle) {
-      return SingleHelper.toSingle(observable);
+      return observable.toSingle();
     }
     if (isCompletable) {
       return CompletableHelper.toCompletable(observable);
@@ -80,14 +77,4 @@ static Object toCompletable(Observable<?> observable) {
       return observable.toCompletable();
     }
   }
-
-  /**
-   * Separate static class defers classloading and bytecode verification since Single is not an
-   * RxJava stable API yet.
-   */
-  private static final class SingleHelper {
-    static Object toSingle(Observable<?> observable) {
-      return observable.toSingle();
-    }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 101daebdc..283451679 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -80,11 +80,10 @@ private RxJavaCallAdapterFactory(Scheduler scheduler) {
   }
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
-    String canonicalName = rawType.getCanonicalName();
-    boolean isSingle = "rx.Single".equals(canonicalName);
-    boolean isCompletable = "rx.Completable".equals(canonicalName);
+    boolean isSingle = rawType == Single.class;
+    boolean isCompletable = "rx.Completable".equals(rawType.getCanonicalName());
     if (rawType != Observable.class && !isSingle && !isCompletable) {
       return null;
     }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index d22877347..b10ab34af 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -16,7 +16,6 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
-import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
@@ -26,13 +25,8 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaErrorHandler;
-import rx.plugins.RxJavaPlugins;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
 
 public final class CompletableTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -76,56 +70,4 @@
     service.completable().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
-
-  @Test public void bodyThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.completable().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.completable().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 39265f5e9..53dcc0770 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -16,7 +16,6 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
-import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
@@ -27,10 +26,6 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaErrorHandler;
-import rx.plugins.RxJavaPlugins;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -86,83 +81,16 @@
 
     RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
     service.body().unsafeSubscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
 
     subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
     subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
-  @Test public void bodyThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onNext(String value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void bodyThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    subscriber.assertValue("Hi");
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
@@ -194,83 +122,16 @@
 
     RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
     service.response().unsafeSubscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
 
     subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
     subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
-  @Test public void responseThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onNext(Response<String> value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void responseThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
@@ -303,82 +164,13 @@
 
     RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
     service.result().unsafeSubscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
 
     subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
     subscriber.assertAnyValue().assertCompleted();
 
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
-
-  @Test public void resultThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onNext(Result<String> value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException first = new RuntimeException();
-    final RuntimeException second = new RuntimeException();
-    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onNext(Result<String> value) {
-        // The only way to trigger onError for a result is if onNext throws.
-        throw first;
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw second;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(first, second);
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
index 3c2e435ad..674575f74 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -54,7 +54,7 @@
   }
 
   @Test public void nonRxJavaTypeReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index 668807987..c4c35ab45 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -16,11 +16,9 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
-import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -28,10 +26,6 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Single;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaErrorHandler;
-import rx.plugins.RxJavaPlugins;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -96,59 +90,6 @@
     subscriber.assertError(e);
   }
 
-  @Test public void bodyThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    subscriber.assertValue("Hi");
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
@@ -189,59 +130,6 @@
     subscriber.assertError(e);
   }
 
-  @Test public void responseThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
@@ -282,60 +170,4 @@
 
     subscriber.assertError(e);
   }
-
-  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onCompleted() {
-        throw e;
-      }
-    });
-
-    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
-  @Test public void resultThrowingInOnErrorDeliveredToPlugin() throws Throwable {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-      @Override public void handleError(Throwable throwable) {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException first = new RuntimeException("First");
-    final RuntimeException second = new RuntimeException("Second");
-    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onNext(Result<String> value) {
-        // The only way to trigger onError for a result is if onNext throws.
-        throw first;
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw second;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(first, second);
-  }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index f6db311be..4b224bd97 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -56,7 +56,7 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectReader reader = mapper.reader(javaType);
+    ObjectReader reader = mapper.readerFor(javaType);
     return new JacksonResponseBodyConverter<>(reader);
   }
 
@@ -64,7 +64,7 @@ private JacksonConverterFactory(ObjectMapper mapper) {
   public Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectWriter writer = mapper.writerFor(javaType);
     return new JacksonRequestBodyConverter<>(writer);
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index d566c3044..60e5f1bfd 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -50,21 +50,28 @@ public static MoshiConverterFactory create() {
 
   /** Create an instance using {@code moshi} for conversion. */
   public static MoshiConverterFactory create(Moshi moshi) {
-    return new MoshiConverterFactory(moshi, false);
+    if (moshi == null) throw new NullPointerException("moshi == null");
+    return new MoshiConverterFactory(moshi, false, false);
   }
 
   private final Moshi moshi;
   private final boolean lenient;
+  private final boolean serializeNulls;
 
-  private MoshiConverterFactory(Moshi moshi, boolean lenient) {
-    if (moshi == null) throw new NullPointerException("moshi == null");
+  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean serializeNulls) {
     this.moshi = moshi;
     this.lenient = lenient;
+    this.serializeNulls = serializeNulls;
   }
 
   /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
   public MoshiConverterFactory asLenient() {
-    return new MoshiConverterFactory(moshi, true);
+    return new MoshiConverterFactory(moshi, true, serializeNulls);
+  }
+
+  /** Return a new factory which includes null values into the serialized JSON. */
+  public MoshiConverterFactory withNullSerialization() {
+    return new MoshiConverterFactory(moshi, lenient, true);
   }
 
   @Override
@@ -84,7 +91,7 @@ public MoshiConverterFactory asLenient() {
     if (lenient) {
       adapter = adapter.lenient();
     }
-    return new MoshiRequestBodyConverter<>(adapter);
+    return new MoshiRequestBodyConverter<>(adapter, serializeNulls);
   }
 
   private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index ac3d095d3..5e59b17fe 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -16,6 +16,7 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonWriter;
 import java.io.IOException;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
@@ -26,14 +27,18 @@
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
+  private final boolean serializeNulls;
 
-  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
+  MoshiRequestBodyConverter(JsonAdapter<T> adapter, boolean serializeNulls) {
     this.adapter = adapter;
+    this.serializeNulls = serializeNulls;
   }
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
-    adapter.toJson(buffer, value);
+    JsonWriter writer = JsonWriter.of(buffer);
+    writer.setSerializeNulls(serializeNulls);
+    adapter.toJson(writer, value);
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index 3b902d1d8..d22c37267 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -119,6 +119,7 @@
 
   private Service service;
   private Service serviceLenient;
+  private Service serviceNulls;
 
   @Before public void setUp() {
     Moshi moshi = new Moshi.Builder()
@@ -137,6 +138,7 @@
         .build();
     MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
     MoshiConverterFactory factoryLenient = factory.asLenient();
+    MoshiConverterFactory factoryNulls = factory.withNullSerialization();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(factory)
@@ -145,8 +147,13 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(factoryLenient)
         .build();
+    Retrofit retrofitNulls = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryNulls)
+        .build();
     service = retrofit.create(Service.class);
     serviceLenient = retrofitLenient.create(Service.class);
+    serviceNulls = retrofitNulls.create(Service.class);
   }
 
   @Test public void anInterface() throws IOException, InterruptedException {
@@ -207,6 +214,14 @@
     assertThat(body.theName).isEqualTo("value");
   }
 
+  @Test public void withNulls() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    Call<AnImplementation> call = serviceNulls.anImplementation(new AnImplementation(null));
+    call.execute();
+    assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
+  }
+
   @Test public void utf8BomSkipped() throws IOException {
     Buffer responseBody = new Buffer()
         .write(ByteString.decodeHex("EFBBBF"))
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
index 3bbd190bb..8145bde2d 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -50,8 +50,8 @@
 
   static class DirectCallAdapterFactory extends CallAdapter.Factory {
     @Override
-    public CallAdapter<?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      return new CallAdapter<Object>() {
+    public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      return new CallAdapter<Object, Object>() {
         @Override public Type responseType() {
           return returnType;
         }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 7c9361f65..21af3a6d3 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -51,15 +51,16 @@ public T returningResponse(Object response) {
   }
 
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public T returning(Call<?> call) {
-    final Call<?> behaviorCall = new BehaviorCall<>(behavior, executor, call);
+  public <R> T returning(Call<R> call) {
+    final Call<R> behaviorCall = new BehaviorCall<>(behavior, executor, call);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
         new InvocationHandler() {
           @Override
-          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+          public T invoke(Object proxy, Method method, Object[] args) throws Throwable {
             Type returnType = method.getGenericReturnType();
             Annotation[] methodAnnotations = method.getAnnotations();
-            CallAdapter<?> callAdapter = retrofit.callAdapter(returnType, methodAnnotations);
+            CallAdapter<R, T> callAdapter =
+                (CallAdapter<R, T>) retrofit.callAdapter(returnType, methodAnnotations);
             return callAdapter.adapt(behaviorCall);
           }
         });
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 2f56683b8..927540bf4 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -20,11 +20,12 @@
 import java.lang.reflect.Type;
 
 /**
- * Adapts a {@link Call} into the type of {@code T}. Instances are created by {@linkplain Factory a
- * factory} which is {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into
- * the {@link Retrofit} instance.
+ * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
+ * created by {@linkplain Factory a factory} which is
+ * {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into the {@link Retrofit}
+ * instance.
  */
-public interface CallAdapter<T> {
+public interface CallAdapter<R, T> {
   /**
    * Returns the value type that this adapter uses when converting the HTTP response body to a Java
    * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
@@ -52,7 +53,7 @@
    * }
    * </code></pre>
    */
-  <R> T adapt(Call<R> call);
+  T adapt(Call<R> call);
 
   /**
    * Creates {@link CallAdapter} instances based on the return type of {@linkplain
@@ -63,7 +64,7 @@
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
+    public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit);
 
     /**
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index dd6e79244..c0f114cf3 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -27,18 +27,18 @@
   static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
 
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
+    return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
+      @Override public Call<Object> adapt(Call<Object> call) {
         return call;
       }
     };
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 0c44243c6..a633d60e8 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -29,17 +29,17 @@
   }
 
   @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
+    return new CallAdapter<Object, Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
+      @Override public Call<Object> adapt(Call<Object> call) {
         return new ExecutorCallbackCall<>(callbackExecutor, call);
       }
     };
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5aa102db2..5b9a196ff 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -25,7 +25,7 @@
 import okio.Okio;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T> serviceMethod;
+  private final ServiceMethod<T, ?> serviceMethod;
   private final Object[] args;
 
   private volatile boolean canceled;
@@ -35,7 +35,7 @@
   private Throwable creationFailure; // Either a RuntimeException or IOException.
   private boolean executed;
 
-  OkHttpCall(ServiceMethod<T> serviceMethod, Object[] args) {
+  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
     this.serviceMethod = serviceMethod;
     this.args = args;
   }
@@ -203,6 +203,7 @@ private void callSuccess(Response<T> response) {
     }
 
     if (code == 204 || code == 205) {
+      rawBody.close();
       return Response.success(null, rawResponse);
     }
 
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index b194d4ed5..e7659c5cd 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -21,9 +21,9 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
@@ -57,7 +57,7 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
+  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   private final okhttp3.Call.Factory callFactory;
   private final HttpUrl baseUrl;
@@ -142,8 +142,9 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            ServiceMethod serviceMethod = loadServiceMethod(method);
-            OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            ServiceMethod<Object, Object> serviceMethod =
+                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
             return serviceMethod.callAdapter.adapt(okHttpCall);
           }
         });
@@ -158,12 +159,14 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
-  ServiceMethod loadServiceMethod(Method method) {
-    ServiceMethod result;
+  ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+    if (result != null) return result;
+
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
-        result = new ServiceMethod.Builder(this, method).build();
+        result = new ServiceMethod.Builder<>(this, method).build();
         serviceMethodCache.put(method, result);
       }
     }
@@ -197,7 +200,7 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
     return nextCallAdapter(null, returnType, annotations);
   }
 
@@ -207,14 +210,14 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
     checkNotNull(returnType, "returnType == null");
     checkNotNull(annotations, "annotations == null");
 
     int start = adapterFactories.indexOf(skipPast) + 1;
     for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
       if (adapter != null) {
         return adapter;
       }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 26706453a..3a4325a7e 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -56,17 +56,17 @@
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<T> {
+final class ServiceMethod<R, T> {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
   static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
 
   final okhttp3.Call.Factory callFactory;
-  final CallAdapter<?> callAdapter;
+  final CallAdapter<R, T> callAdapter;
 
   private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, T> responseConverter;
+  private final Converter<ResponseBody, R> responseConverter;
   private final String httpMethod;
   private final String relativeUrl;
   private final Headers headers;
@@ -76,7 +76,7 @@
   private final boolean isMultipart;
   private final ParameterHandler<?>[] parameterHandlers;
 
-  ServiceMethod(Builder<T> builder) {
+  ServiceMethod(Builder<R, T> builder) {
     this.callFactory = builder.retrofit.callFactory();
     this.callAdapter = builder.callAdapter;
     this.baseUrl = builder.retrofit.baseUrl();
@@ -113,7 +113,7 @@ Request toRequest(Object... args) throws IOException {
   }
 
   /** Builds a method return value from an HTTP response body. */
-  T toResponse(ResponseBody body) throws IOException {
+  R toResponse(ResponseBody body) throws IOException {
     return responseConverter.convert(body);
   }
 
@@ -122,7 +122,7 @@ T toResponse(ResponseBody body) throws IOException {
    * requires potentially-expensive reflection so it is best to build each service method only once
    * and reuse it. Builders cannot be reused.
    */
-  static final class Builder<T> {
+  static final class Builder<T, R> {
     final Retrofit retrofit;
     final Method method;
     final Annotation[] methodAnnotations;
@@ -146,7 +146,7 @@ T toResponse(ResponseBody body) throws IOException {
     Set<String> relativeUrlParamNames;
     ParameterHandler<?>[] parameterHandlers;
     Converter<ResponseBody, T> responseConverter;
-    CallAdapter<?> callAdapter;
+    CallAdapter<T, R> callAdapter;
 
     public Builder(Retrofit retrofit, Method method) {
       this.retrofit = retrofit;
@@ -218,7 +218,7 @@ public ServiceMethod build() {
       return new ServiceMethod<>(this);
     }
 
-    private CallAdapter<?> createCallAdapter() {
+    private CallAdapter<T, R> createCallAdapter() {
       Type returnType = method.getGenericReturnType();
       if (Utils.hasUnresolvableType(returnType)) {
         throw methodError(
@@ -229,7 +229,8 @@ public ServiceMethod build() {
       }
       Annotation[] annotations = method.getAnnotations();
       try {
-        return retrofit.callAdapter(returnType, annotations);
+        //noinspection unchecked
+        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
       } catch (RuntimeException e) { // Wide exception range because factories are user code.
         throw methodError(e, "Unable to create call adapter for %s", returnType);
       }
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index 24b871052..6f1480d23 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -70,10 +70,10 @@
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+    Call<String> call = adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
         return response;
       }
@@ -83,15 +83,15 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     EmptyCall originalCall = new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
         callback.onResponse(this, response);
       }
     };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
+    Call<String> call = adapter.adapt(originalCall);
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
     verify(callback).onResponse(call, response);
@@ -99,15 +99,15 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
     EmptyCall originalCall = new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
         callback.onFailure(this, throwable);
       }
     };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
+    Call<String> call = adapter.adapt(originalCall);
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
     verifyNoMoreInteractions(callbackExecutor);
@@ -117,10 +117,10 @@
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> call = adapter.adapt(delegate);
     Call<String> cloned = call.clone();
     assertThat(cloned).isNotSameAs(call);
     verify(delegate).clone();
@@ -129,10 +129,10 @@
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> call = adapter.adapt(delegate);
     call.cancel();
     verify(delegate).cancel();
     verifyNoMoreInteractions(delegate);
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 905eebe4c..0f3b5ebe6 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -2501,7 +2501,7 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  static Request buildRequest(Class<?> cls, Object... args) {
+  static <T> Request buildRequest(Class<T> cls, Object... args) {
     final AtomicReference<Request> requestRef = new AtomicReference<>();
     okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
       @Override public okhttp3.Call newCall(Request request) {
@@ -2517,9 +2517,11 @@ static Request buildRequest(Class<?> cls, Object... args) {
         .build();
 
     Method method = TestingUtils.onlyMethod(cls);
-    ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
-    OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
+    //noinspection unchecked
+    ServiceMethod<T, Call<T>> serviceMethod =
+        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
+    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+    Call<T> call = serviceMethod.callAdapter.adapt(okHttpCall);
     try {
       call.execute();
       throw new AssertionError();
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 41036c987..885394bfc 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -231,18 +231,18 @@
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         factoryCalled.set(true);
         if (getRawType(returnType) != Call.class) {
           return null;
         }
-        return new CallAdapter<Call<?>>() {
+        return new CallAdapter<Object, Call<?>>() {
           @Override public Type responseType() {
             return getParameterUpperBound(0, (ParameterizedType) returnType);
           }
 
-          @Override public <R> Call<R> adapt(Call<R> call) {
+          @Override public Call<Object> adapt(Call<Object> call) {
             adapterCalled.set(true);
             return call;
           }
@@ -262,17 +262,17 @@
 
   @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         if (getRawType(returnType) != String.class) {
           return null;
         }
-        return new CallAdapter<String>() {
+        return new CallAdapter<Object, String>() {
           @Override public Type responseType() {
             return String.class;
           }
 
-          @Override public <R> String adapt(Call<R> call) {
+          @Override public String adapt(Call<Object> call) {
             return "Hi!";
           }
         };
@@ -291,7 +291,7 @@
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
           Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
@@ -1022,7 +1022,7 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
 
     Retrofit retrofit = new Retrofit.Builder()
@@ -1032,7 +1032,7 @@
 
     doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory).get(type, annotations, retrofit);
@@ -1043,11 +1043,11 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
     CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
@@ -1060,7 +1060,7 @@
 
     doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory1).get(type, annotations, retrofit);
@@ -1073,17 +1073,17 @@
     Type type = String.class;
     Annotation[] annotations = new Annotation[0];
 
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
     CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
     CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
     CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
       @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
         return retrofit.nextCallAdapter(this, returnType, annotations);
       }
     });
@@ -1097,7 +1097,7 @@
 
     doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
 
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
     assertThat(actualAdapter).isSameAs(expectedAdapter);
 
     verify(factory1).get(type, annotations, retrofit);
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
index 918b0ea0f..6ce48efe2 100644
--- a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -24,7 +24,7 @@
   public boolean called;
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return retrofit.nextCallAdapter(this, returnType, annotations);
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 2b4954813..3f44ddff8 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -24,7 +24,7 @@
   public boolean called;
 
   @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
similarity index 86%
rename from samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
rename to samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 0189da92b..28e8521ac 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -32,7 +32,7 @@
  * A sample showing a custom {@link CallAdapter} which adapts the built-in {@link Call} to a custom
  * version whose callback has more granular methods.
  */
-public final class ErrorHandlingCallAdapter {
+public final class ErrorHandlingAdapter {
   /** A callback which offers granular callbacks for various conditions. */
   interface MyCallback<T> {
     /** Called for [200, 300) responses. */
@@ -59,7 +59,7 @@
   }
 
   public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit) {
       if (getRawType(returnType) != MyCall.class) {
         return null;
@@ -68,17 +68,27 @@
         throw new IllegalStateException(
             "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
       }
-      final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
-      final Executor callbackExecutor = retrofit.callbackExecutor();
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
+      Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+      Executor callbackExecutor = retrofit.callbackExecutor();
+      return new ErrorHandlingCallAdapter<>(responseType, callbackExecutor);
+    }
 
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call, callbackExecutor);
-        }
-      };
+    private static final class ErrorHandlingCallAdapter<R> implements CallAdapter<R, MyCall<R>> {
+      private final Type responseType;
+      private final Executor callbackExecutor;
+
+      ErrorHandlingCallAdapter(Type responseType, Executor callbackExecutor) {
+        this.responseType = responseType;
+        this.callbackExecutor = callbackExecutor;
+      }
+
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public MyCall<R> adapt(Call<R> call) {
+        return new MyCallAdapter<>(call, callbackExecutor);
+      }
     }
   }
 
