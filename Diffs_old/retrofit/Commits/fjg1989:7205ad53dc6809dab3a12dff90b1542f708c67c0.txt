diff --git a/CHANGELOG.md b/CHANGELOG.md
index a2b736bd6..e2eb7feba 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,38 @@
 Change Log
 ==========
 
+Version 2.0.0-beta2 *(2015-09-28)*
+----------------------------------
+
+ * New: Using a response type of `Void` (e.g., `Call<Void>`) will ignore and discard the response body. This
+   can be used when there will be no response body (such as in a 201 response) or whenever the body is not
+   needed. `@Head` requests are now forced to use this as their response type.
+ * New: `validateEagerly()` method on `Retrofit.Builder` will verify the correctness of all service methods
+   on calls to `create()` instead of lazily validating on first use.
+ * New: `Converter` is now parameterized over both 'from' and 'to' types with a single `convert` method.
+   `Converter.Factory` is now an abstract class and has factory methods for both request body and response
+   body.
+ * New: `Converter.Factory` and `CallAdapter.Factory` now receive the method annotations when being created
+   for a return/response type and the parameter annotations when being created for a parameter type.
+ * New: `callAdapter()` method on `Retrofit` allows querying a `CallAdapter` for a given type. The
+   `nextCallAdapter()` method allows delegating to another `CallAdapter` from within a `CallAdapter.Factory`.
+   This is useful for composing call adapters to incrementally build up behavior.
+ * New: `requestConverter()` and `responseConverter()` methods on `Retrofit` allow querying a `Converter` for
+   a given type.
+ * New: `onResponse` method in `Callback` now receives the `Retrofit` instance. Combined with the
+   `responseConverter()` method on `Retrofit`, this provides a way of deserializing an error body on `Response`.
+   See the `DeserializeErrorBody` sample for an example.
+ * New: The `MoshiConverterFactory` has been updated for its v1.0.0.
+ * Fix: Using `ResponseBody` for the response type or `RequestBody` for a parameter type is now correctly
+   identified. Previously these types would erroneously be passed to the supplied converter.
+ * Fix: The encoding of `@Path` values has been corrected to conform to OkHttp's `HttpUrl`.
+ * Fix: Use form-data content disposition subtype for `@Multipart`.
+ * Fix: `Observable` and `Single`-based execution of requests now behave synchronously (and thus requires
+   `subscribeOn()` for running in the background).
+ * Fix: Correct `GsonConverterFactory` to honor the configuration of the `Gson` instances (such as not
+   serializing null values, the default).
+
+
 Version 2.0.0-beta1 *(2015-08-27)*
 ----------------------------------
 
diff --git a/README.md b/README.md
index a8276e398..5bbcdc582 100644
--- a/README.md
+++ b/README.md
@@ -14,12 +14,12 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>retrofit</artifactId>
-  <version>2.0.0-beta1</version>
+  <version>2.0.0-beta2</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:2.0.0-beta1'
+compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/deploy_website.sh b/deploy_website.sh
index 134675d3a..f7c8b370d 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -3,9 +3,6 @@
 set -ex
 
 REPO="git@github.com:square/retrofit.git"
-GROUP_ID="com.squareup.retrofit"
-ARTIFACT_ID="retrofit"
-
 DIR=temp-clone
 
 # Delete any existing temporary website clone
@@ -20,18 +17,12 @@ cd $DIR
 # Checkout and track the gh-pages branch
 git checkout -t origin/gh-pages
 
-# Delete everything
-rm -rf *
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
 
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
-rm javadoc.zip
-
 # Stage all files in git and create a commit
 git add .
 git add -u
diff --git a/pom.xml b/pom.xml
index 3c3ecd9fb..b26fb4a24 100644
--- a/pom.xml
+++ b/pom.xml
@@ -57,12 +57,12 @@
     <rxjava.version>1.0.14</rxjava.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.3.1</gson.version>
+    <gson.version>2.4</gson.version>
     <protobuf.version>2.5.0</protobuf.version>
     <jackson.version>2.4.3</jackson.version>
-    <wire.version>1.7.0</wire.version>
+    <wire.version>2.0.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>0.9.0</moshi.version>
+    <moshi.version>1.0.0</moshi.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
index 0449dd70b..a1aa64881 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.Type;
 import rx.Observable;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.subscriptions.Subscriptions;
@@ -38,7 +39,8 @@ public static RxJavaCallAdapterFactory create() {
   private RxJavaCallAdapterFactory() {
   }
 
-  @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations) {
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = Utils.getRawType(returnType);
     boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
     if (rawType != Observable.class && !isSingle) {
@@ -101,27 +103,22 @@ private CallOnSubscribe(Call<T> originalCall) {
         }
       }));
 
-      call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Response<T> response) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
-          try {
-            subscriber.onNext(response);
-          } catch (Throwable t) {
-            subscriber.onError(t);
-            return;
-          }
-          subscriber.onCompleted();
+      try {
+        Response<T> response = call.execute();
+        if (!subscriber.isUnsubscribed()) {
+          subscriber.onNext(response);
         }
-
-        @Override public void onFailure(Throwable t) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        if (!subscriber.isUnsubscribed()) {
           subscriber.onError(t);
         }
-      });
+        return;
+      }
+
+      if (!subscriber.isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
     }
   }
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
index 142c4c9d6..b37b3c467 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
@@ -52,10 +52,11 @@
     @GET("/") Single<Result<String>> singleResult();
   }
 
+  private Retrofit retrofit;
   private Service service;
 
   @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
+    retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new StringConverterFactory())
         .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
@@ -159,21 +160,25 @@
   @Test public void responseType() {
     CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS).responseType()) //
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(responseType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(resultType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
   }
 
   @Test public void nonObservableTypeReturnsNull() {
     CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS);
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
@@ -181,14 +186,14 @@
     CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type observableType = new TypeToken<Observable>() {}.getType();
     try {
-      factory.get(observableType, NO_ANNOTATIONS);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
     }
     Type singleType = new TypeToken<Single>() {}.getType();
     try {
-      factory.get(singleType, NO_ANNOTATIONS);
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
@@ -199,14 +204,14 @@
     CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type observableType = new TypeToken<Observable<Response>>() {}.getType();
     try {
-      factory.get(observableType, NO_ANNOTATIONS);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
     }
     Type singleType = new TypeToken<Single<Response>>() {}.getType();
     try {
-      factory.get(singleType, NO_ANNOTATIONS);
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
@@ -217,14 +222,14 @@
     CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type observableType = new TypeToken<Observable<Result>>() {}.getType();
     try {
-      factory.get(observableType, NO_ANNOTATIONS);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
     }
     Type singleType = new TypeToken<Single<Result>>() {}.getType();
     try {
-      factory.get(singleType, NO_ANNOTATIONS);
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
index f1f4001b0..36279874c 100644
--- a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
@@ -63,6 +63,6 @@ private GsonConverterFactory(Gson gson) {
 
   @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonRequestBodyConverter<>(adapter);
+    return new GsonRequestBodyConverter<>(gson, adapter);
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
index 278e3444f..651b02973 100644
--- a/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
@@ -15,7 +15,9 @@
  */
 package retrofit;
 
+import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonWriter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
@@ -28,18 +30,21 @@
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
+  private final Gson gson;
   private final TypeAdapter<T> adapter;
 
-  GsonRequestBodyConverter(TypeAdapter<T> adapter) {
+  GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
     this.adapter = adapter;
   }
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
     Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    JsonWriter jsonWriter = gson.newJsonWriter(writer);
     try {
-      adapter.toJson(writer, value);
-      writer.flush();
+      adapter.write(jsonWriter, value);
+      jsonWriter.flush();
     } catch (IOException e) {
       throw new AssertionError(e); // Writing to Buffer does no I/O.
     }
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
index 8dadf9cb5..3d4b6e4f0 100644
--- a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
@@ -118,6 +118,15 @@
     RecordedRequest request = server.takeRequest();
     assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void serializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    service.anImplementation(new AnImplementation(null)).execute();
 
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
 }
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index 492e42601..9968ccd38 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -3,8 +3,8 @@ Moshi Converter
 
 A `Converter` which uses [Moshi][1] for serialization to and from JSON.
 
-A default `Moshi` instance will be created or one can be configured and passed to the
-`MoshiConverter` construction to further control the serialization.
+A default `Moshi` instance will be created or one can be configured and passed to
+`MoshiConverterFactory.create()` to further control the serialization.
 
 
  [1]: https://github.com/square/moshi
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
index 4bcbce40b..238ec6931 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
@@ -89,7 +89,7 @@
           + "    for method Service.wrongClass");
       assertThat(e.getCause()).hasMessage(
           "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.BuiltInConverters\n"
               + " * retrofit.ProtoConverterFactory");
     }
   }
@@ -106,7 +106,7 @@
           + "    for method Service.wrongType");
       assertThat(e.getCause()).hasMessage(
           "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.BuiltInConverters\n"
               + " * retrofit.ProtoConverterFactory");
     }
   }
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 88069b48f..9c82b143e 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -3,8 +3,5 @@ Wire Converter
 
 A `Converter` which uses [Wire][1] for protocol buffer-compatible serialization.
 
-A default `Wire` instance will be created or one can be configured and passed to the
-`WireConverter` construction to further control the serialization.
-
 
  [1]: https://github.com/square/wire
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
index 569527460..cb108be02 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
@@ -18,33 +18,21 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
+import com.squareup.wire.ProtoAdapter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
 /**
  * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
  * <p>
- * This converter only applies for types which extend from {@link Message} (or one of its
- * subclasses).
+ * This converter only applies for types which extend from {@link Message}.
  */
 public final class WireConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Wire} instance for conversion. */
   public static WireConverterFactory create() {
-    return create(new Wire());
+    return new WireConverterFactory();
   }
 
-  /** Create an instance using {@code wire} for conversion. */
-  public static WireConverterFactory create(Wire wire) {
-    return new WireConverterFactory(wire);
-  }
-
-  private final Wire wire;
-
-  /** Create a converter using the supplied {@link Wire} instance. */
-  private WireConverterFactory(Wire wire) {
-    if (wire == null) throw new NullPointerException("wire == null");
-    this.wire = wire;
+  private WireConverterFactory() {
   }
 
   @Override
@@ -57,16 +45,20 @@ private WireConverterFactory(Wire wire) {
       return null;
     }
     //noinspection unchecked
-    return new WireResponseBodyConverter<>(wire, (Class<? extends Message>) c);
+    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+    return new WireResponseBodyConverter<>(adapter);
   }
 
   @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
-    if (!Message.class.isAssignableFrom((Class<?>) type)) {
+    Class<?> c = (Class<?>) type;
+    if (!Message.class.isAssignableFrom(c)) {
       return null;
     }
-    return new WireRequestBodyConverter<>();
+    //noinspection unchecked
+    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+    return new WireRequestBodyConverter<>(adapter);
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
index fd2defd6e..9f90062ea 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
@@ -18,13 +18,22 @@
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
+import okio.Buffer;
 
-final class WireRequestBodyConverter<T extends Message> implements Converter<T, RequestBody> {
+final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
+  private final ProtoAdapter<T> adapter;
+
+  WireRequestBodyConverter(ProtoAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
   @Override public RequestBody convert(T value) throws IOException {
-    byte[] bytes = value.toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
+    Buffer buffer = new Buffer();
+    adapter.encode(buffer, value);
+    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
index 13530a9ad..8dce25081 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
@@ -17,25 +17,24 @@
 
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
+import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
 import okio.BufferedSource;
 
-final class WireResponseBodyConverter<T extends Message> implements Converter<ResponseBody, T> {
-  private final Wire wire;
-  private final Class<T> cls;
+final class WireResponseBodyConverter<T extends Message<T, ?>>
+    implements Converter<ResponseBody, T> {
+  private final ProtoAdapter<T> adapter;
 
-  WireResponseBodyConverter(Wire wire, Class<T> cls) {
-    this.wire = wire;
-    this.cls = cls;
+  WireResponseBodyConverter(ProtoAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
   @Override public T convert(ResponseBody value) throws IOException {
-    BufferedSource source = value.source();
     try {
-      return wire.parseFrom(source, cls);
+      BufferedSource source = value.source();
+      return adapter.decode(source);
     } finally {
-      Utils.closeQuietly(source);
+      Utils.closeQuietly(value);
     }
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/Phone.java b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
index e8a47989d..ab0a73683 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
@@ -1,27 +1,80 @@
 // Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: ../wire-runtime/src/test/proto/person.proto
+// Source file: test.proto at 2:1
 package retrofit;
 
+import com.squareup.wire.FieldEncoding;
 import com.squareup.wire.Message;
-import com.squareup.wire.ProtoField;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import java.io.IOException;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.StringBuilder;
+import okio.ByteString;
 
-import static com.squareup.wire.Message.Datatype.STRING;
-import static com.squareup.wire.Message.Label.OPTIONAL;
+public final class Phone extends Message<Phone, Phone.Builder> {
+  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter<Phone>(FieldEncoding.LENGTH_DELIMITED, Phone.class) {
+    @Override
+    public int encodedSize(Phone value) {
+      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+          + value.unknownFields().size();
+    }
+
+    @Override
+    public void encode(ProtoWriter writer, Phone value) throws IOException {
+      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+      writer.writeBytes(value.unknownFields());
+    }
+
+    @Override
+    public Phone decode(ProtoReader reader) throws IOException {
+      Builder builder = new Builder();
+      long token = reader.beginMessage();
+      for (int tag; (tag = reader.nextTag()) != -1;) {
+        switch (tag) {
+          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
+          default: {
+            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+            builder.addUnknownField(tag, fieldEncoding, value);
+          }
+        }
+      }
+      reader.endMessage(token);
+      return builder.build();
+    }
+
+    @Override
+    public Phone redact(Phone value) {
+      Builder builder = value.newBuilder();
+      builder.clearUnknownFields();
+      return builder.build();
+    }
+  };
 
-public final class Phone extends Message {
+  private static final long serialVersionUID = 0L;
 
-  public static final String DEFAULT_PHONE = "";
+  public static final String DEFAULT_NUMBER = "";
 
-  @ProtoField(tag = 1, type = STRING, label = OPTIONAL)
   public final String number;
 
   public Phone(String number) {
+    this(number, ByteString.EMPTY);
+  }
+
+  public Phone(String number, ByteString unknownFields) {
+    super(unknownFields);
     this.number = number;
   }
 
-  private Phone(Builder builder) {
-    this(builder.number);
-    setBuilder(builder);
+  @Override
+  public Builder newBuilder() {
+    Builder builder = new Builder();
+    builder.number = number;
+    builder.addUnknownFields(unknownFields());
+    return builder;
   }
 
   @Override
@@ -29,41 +82,42 @@ public boolean equals(Object other) {
     if (other == this) return true;
     if (!(other instanceof Phone)) return false;
     Phone o = (Phone) other;
-    return equals(number, o.number);
+    return equals(unknownFields(), o.unknownFields())
+        && equals(number, o.number);
   }
 
   @Override
   public int hashCode() {
-    int result = hashCode;
+    int result = super.hashCode;
     if (result == 0) {
-      result = number != null ? number.hashCode() : 0;
-      hashCode = result;
+      result = unknownFields().hashCode();
+      result = result * 37 + (number != null ? number.hashCode() : 0);
+      super.hashCode = result;
     }
     return result;
   }
 
-  public static final class Builder extends Message.Builder<Phone> {
+  @Override
+  public String toString() {
+    StringBuilder builder = new StringBuilder();
+    if (number != null) builder.append(", number=").append(number);
+    return builder.replace(0, 2, "Phone{").append('}').toString();
+  }
 
+  public static final class Builder extends com.squareup.wire.Message.Builder<Phone, Builder> {
     public String number;
 
     public Builder() {
     }
 
-    public Builder(Phone message) {
-      super(message);
-      if (message == null) return;
-      this.number = message.number;
-    }
-
-    public Builder number(String name) {
-      this.number = name;
+    public Builder number(String number) {
+      this.number = number;
       return this;
     }
 
     @Override
     public Phone build() {
-      checkRequiredFields();
-      return new Phone(this);
+      return new Phone(number, buildUnknownFields());
     }
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
index 9019654ec..e3c27b535 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
@@ -88,7 +88,7 @@
           + "    for method Service.wrongClass");
       assertThat(e.getCause()).hasMessage(
           "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.BuiltInConverters\n"
               + " * retrofit.WireConverterFactory");
     }
   }
@@ -105,7 +105,7 @@
           + "    for method Service.wrongType");
       assertThat(e.getCause()).hasMessage(
           "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.BuiltInConverters\n"
               + " * retrofit.WireConverterFactory");
     }
   }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
index 6857cdc8b..d3f7e7d4f 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -25,10 +25,12 @@
 import retrofit.Call;
 import retrofit.Callback;
 import retrofit.Response;
+import retrofit.Retrofit;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 final class BehaviorCall<T> implements Call<T> {
+  private final Retrofit retrofit;
   private final NetworkBehavior behavior;
   private final ExecutorService backgroundExecutor;
   private final Executor callbackExecutor;
@@ -38,8 +40,14 @@
   private volatile boolean canceled;
   private volatile boolean executed;
 
-  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor,
-      Executor callbackExecutor, Call<T> delegate) {
+  BehaviorCall(Retrofit retrofit, NetworkBehavior behavior, ExecutorService backgroundExecutor,
+      Call<T> delegate) {
+    this.retrofit = retrofit;
+    this.behavior = behavior;
+    this.backgroundExecutor = backgroundExecutor;
+    this.delegate = delegate;
+
+    Executor callbackExecutor = retrofit.callbackExecutor();
     if (callbackExecutor == null) {
       callbackExecutor = new Executor() {
         @Override public void execute(Runnable command) {
@@ -47,15 +55,12 @@
         }
       };
     }
-    this.behavior = behavior;
-    this.backgroundExecutor = backgroundExecutor;
     this.callbackExecutor = callbackExecutor;
-    this.delegate = delegate;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public Call<T> clone() {
-    return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, delegate.clone());
+    return new BehaviorCall<>(retrofit, behavior, backgroundExecutor, delegate.clone());
   }
 
   @Override public void enqueue(final Callback<T> callback) {
@@ -80,7 +85,7 @@ private boolean delaySleep() {
       private void callResponse(final Response<T> response) {
         callbackExecutor.execute(new Runnable() {
           @Override public void run() {
-            callback.onResponse(response);
+            callback.onResponse(response, retrofit);
           }
         });
       }
@@ -102,7 +107,7 @@ private void callFailure(final Throwable throwable) {
           }
         } else {
           delegate.enqueue(new Callback<T>() {
-            @Override public void onResponse(final Response<T> response) {
+            @Override public void onResponse(final Response<T> response, Retrofit retrofit) {
               if (delaySleep()) {
                 callResponse(response);
               }
@@ -124,7 +129,7 @@ private void callFailure(final Throwable throwable) {
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     enqueue(new Callback<T>() {
-      @Override public void onResponse(Response<T> response) {
+      @Override public void onResponse(Response<T> response, Retrofit retrofit) {
         responseRef.set(response);
         latch.countDown();
       }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
index 551f706f0..ee216a597 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
@@ -15,13 +15,12 @@
  */
 package retrofit.mock;
 
-import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import retrofit.Call;
 import retrofit.Retrofit;
 
 public final class CallBehaviorAdapter implements NetworkBehavior.Adapter<Call<?>> {
-  private final Executor callbackExecutor;
+  private final Retrofit retrofit;
   private final ExecutorService backgroundExecutor;
 
   /**
@@ -30,11 +29,11 @@
    * behavior of every mock service is consistent.
    */
   public CallBehaviorAdapter(Retrofit retrofit, ExecutorService backgroundExecutor) {
-    this.callbackExecutor = retrofit.callbackExecutor();
+    this.retrofit = retrofit;
     this.backgroundExecutor = backgroundExecutor;
   }
 
   @Override public Call<?> applyBehavior(NetworkBehavior behavior, Call<?> value) {
-    return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, value);
+    return new BehaviorCall<>(retrofit, behavior, backgroundExecutor, value);
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Calls.java b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
index e1d0e7e4f..4dbab1179 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
@@ -19,21 +19,22 @@
 import retrofit.Call;
 import retrofit.Callback;
 import retrofit.Response;
+import retrofit.Retrofit;
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
-  public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
+  public static <T> Call<T> response(T successValue, Retrofit retrofit) {
+    return response(Response.success(successValue), retrofit);
   }
 
-  public static <T> Call<T> response(final Response<T> response) {
+  public static <T> Call<T> response(final Response<T> response, final Retrofit retrofit) {
     return new Call<T>() {
       @Override public Response<T> execute() throws IOException {
         return response;
       }
 
       @Override public void enqueue(Callback<T> callback) {
-        callback.onResponse(response);
+        callback.onResponse(response, retrofit);
       }
 
       @Override public void cancel() {
diff --git a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
index 55e4549bb..bfdcb0286 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
@@ -48,13 +48,13 @@
   private DoWorkService service;
 
   @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
+    final Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com")
         .build();
 
     DoWorkService mockService = new DoWorkService() {
       @Override public Call<String> response() {
-        return Calls.response("Response!");
+        return Calls.response("Response!", retrofit);
       }
 
       @Override public Call<String> failure() {
@@ -98,7 +98,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
@@ -141,7 +141,7 @@
     final AtomicReference<String> actual = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         actual.set(response.body());
         latch.countDown();
@@ -187,7 +187,7 @@
     final CountDownLatch latch = new CountDownLatch(1);
     final long startNanos = System.nanoTime();
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
@@ -238,7 +238,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         latch.countDown();
       }
 
@@ -283,7 +283,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         latch.countDown();
       }
 
diff --git a/retrofit/src/main/java/retrofit/BuiltInConverterFactory.java b/retrofit/src/main/java/retrofit/BuiltInConverters.java
similarity index 56%
rename from retrofit/src/main/java/retrofit/BuiltInConverterFactory.java
rename to retrofit/src/main/java/retrofit/BuiltInConverters.java
index 66ba26488..be2f81d5e 100644
--- a/retrofit/src/main/java/retrofit/BuiltInConverterFactory.java
+++ b/retrofit/src/main/java/retrofit/BuiltInConverters.java
@@ -17,11 +17,14 @@
 
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import retrofit.http.Streaming;
 
-final class BuiltInConverterFactory extends Converter.Factory {
+import static retrofit.Utils.closeQuietly;
+
+final class BuiltInConverters extends Converter.Factory {
   @Override
   public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
     if (ResponseBody.class.equals(type)) {
@@ -40,4 +43,38 @@
     }
     return null;
   }
+
+  static final class VoidConverter implements Converter<ResponseBody, Void> {
+    @Override public Void convert(ResponseBody value) throws IOException {
+      value.close();
+      return null;
+    }
+  }
+
+  static final class OkHttpRequestBodyConverter implements Converter<RequestBody, RequestBody> {
+    @Override public RequestBody convert(RequestBody value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class OkHttpResponseBodyConverter implements Converter<ResponseBody, ResponseBody> {
+    private final boolean isStreaming;
+
+    OkHttpResponseBodyConverter(boolean isStreaming) {
+      this.isStreaming = isStreaming;
+    }
+
+    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+      if (isStreaming) {
+        return value;
+      }
+
+      // Buffer the entire body to avoid future I/O.
+      try {
+        return Utils.readBodyToBytesIfNecessary(value);
+      } finally {
+        closeQuietly(value);
+      }
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/CallAdapter.java b/retrofit/src/main/java/retrofit/CallAdapter.java
index 4fd172a6b..d8dba7b00 100644
--- a/retrofit/src/main/java/retrofit/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -38,6 +38,6 @@
      * Returns a call adapter for interface methods that return {@code returnType}, or null if this
      * factory doesn't adapt that type.
      */
-    CallAdapter<?> get(Type returnType, Annotation[] annotations);
+    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 6841a2dd3..71ccd0e95 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -30,7 +30,7 @@
  */
 public interface Callback<T> {
   /** Successful HTTP response. */
-  void onResponse(Response<T> response);
+  void onResponse(Response<T> response, Retrofit retrofit);
 
   /** Invoked when a network or unexpected exception occurred during the HTTP request. */
   void onFailure(Throwable t);
diff --git a/retrofit/src/main/java/retrofit/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
index 1525d8878..d4c2f228e 100644
--- a/retrofit/src/main/java/retrofit/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -23,8 +23,7 @@
 
 /**
  * Convert objects to and from their representation as HTTP bodies. Register a converter with
- * Retrofit using {@link Retrofit.Builder#addConverter(Type, Converter)} or {@link
- * Retrofit.Builder#addConverterFactory(Factory)}.
+ * Retrofit using {@link Retrofit.Builder#addConverterFactory(Factory)}.
  */
 public interface Converter<F, T> {
   T convert(F value) throws IOException;
diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
index 220169a48..64f9bf913 100644
--- a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
@@ -24,8 +24,9 @@
  * is a thread provided by OkHttp's dispatcher.
  */
 final class DefaultCallAdapter implements CallAdapter<Call<?>> {
-  public static final Factory FACTORY = new Factory() {
-    @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations) {
+  static final Factory FACTORY = new Factory() {
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (Utils.getRawType(returnType) != Call.class) {
         return null;
       }
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
deleted file mode 100644
index 52d0e819c..000000000
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-
-final class ExceptionCatchingRequestBody extends ResponseBody {
-  private final ResponseBody delegate;
-  private IOException thrownException;
-
-  ExceptionCatchingRequestBody(ResponseBody delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() throws IOException {
-    try {
-      return delegate.contentLength();
-    } catch (IOException e) {
-      thrownException = e;
-      throw e;
-    }
-  }
-
-  @Override public BufferedSource source() throws IOException {
-    BufferedSource delegateSource;
-    try {
-      delegateSource = delegate.source();
-    } catch (IOException e) {
-      thrownException = e;
-      throw e;
-    }
-    return Okio.buffer(new ForwardingSource(delegateSource) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        try {
-          return super.read(sink, byteCount);
-        } catch (IOException e) {
-          thrownException = e;
-          throw e;
-        }
-      }
-    });
-  }
-
-  @Override public void close() throws IOException {
-    delegate.close();
-  }
-
-  void throwIfCaught() throws IOException {
-    if (thrownException != null) {
-      throw thrownException;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
index 655f60e25..06a29ddae 100644
--- a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -27,7 +27,8 @@
     this.callbackExecutor = callbackExecutor;
   }
 
-  @Override public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations) {
+  @Override
+  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (Utils.getRawType(returnType) != Call.class) {
       return null;
     }
@@ -79,10 +80,10 @@
       this.delegate = delegate;
     }
 
-    @Override public void onResponse(final Response<T> response) {
+    @Override public void onResponse(final Response<T> response, final Retrofit retrofit) {
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          delegate.onResponse(response);
+          delegate.onResponse(response, retrofit);
         }
       });
     }
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
index 2312996f6..4ec92c145 100644
--- a/retrofit/src/main/java/retrofit/MethodHandler.java
+++ b/retrofit/src/main/java/retrofit/MethodHandler.java
@@ -15,28 +15,23 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import java.util.List;
 
 final class MethodHandler<T> {
   @SuppressWarnings("unchecked")
-  static MethodHandler<?> create(Method method, OkHttpClient client, BaseUrl baseUrl,
-      List<CallAdapter.Factory> callAdapterFactories, List<Converter.Factory> converterFactories) {
-    CallAdapter<Object> callAdapter =
-        (CallAdapter<Object>) createCallAdapter(method, callAdapterFactories);
+  static MethodHandler<?> create(Retrofit retrofit, Method method) {
+    CallAdapter<Object> callAdapter = (CallAdapter<Object>) createCallAdapter(method, retrofit);
+    Type responseType = callAdapter.responseType();
     Converter<ResponseBody, Object> responseConverter =
-        (Converter<ResponseBody, Object>) createResponseConverter(method,
-            callAdapter.responseType(), converterFactories);
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactories);
-    return new MethodHandler<>(client, requestFactory, callAdapter, responseConverter);
+        (Converter<ResponseBody, Object>) createResponseConverter(method, retrofit, responseType);
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
+    return new MethodHandler<>(retrofit, requestFactory, callAdapter, responseConverter);
   }
 
-  private static CallAdapter<?> createCallAdapter(Method method,
-      List<CallAdapter.Factory> adapterFactories) {
+  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
       throw Utils.methodError(method,
@@ -47,36 +42,36 @@
     }
     Annotation[] annotations = method.getAnnotations();
     try {
-      return Utils.resolveCallAdapter(adapterFactories, returnType, annotations);
+      return retrofit.callAdapter(returnType, annotations);
     } catch (RuntimeException e) { // Wide exception range because factories are user code.
       throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
     }
   }
 
   private static Converter<ResponseBody, ?> createResponseConverter(Method method,
-      Type responseType, List<Converter.Factory> converterFactories) {
+      Retrofit retrofit, Type responseType) {
     Annotation[] annotations = method.getAnnotations();
     try {
-      return Utils.resolveResponseBodyConverter(converterFactories, responseType, annotations);
+      return retrofit.responseConverter(responseType, annotations);
     } catch (RuntimeException e) { // Wide exception range because factories are user code.
       throw Utils.methodError(e, method, "Unable to create converter for %s", responseType);
     }
   }
 
-  private final OkHttpClient client;
+  private final Retrofit retrofit;
   private final RequestFactory requestFactory;
   private final CallAdapter<T> callAdapter;
   private final Converter<ResponseBody, T> responseConverter;
 
-  private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
+  private MethodHandler(Retrofit retrofit, RequestFactory requestFactory,
       CallAdapter<T> callAdapter, Converter<ResponseBody, T> responseConverter) {
-    this.client = client;
+    this.retrofit = retrofit;
     this.requestFactory = requestFactory;
     this.callAdapter = callAdapter;
     this.responseConverter = responseConverter;
   }
 
   Object invoke(Object... args) {
-    return callAdapter.adapt(new OkHttpCall<>(client, requestFactory, responseConverter, args));
+    return callAdapter.adapt(new OkHttpCall<>(retrofit, requestFactory, responseConverter, args));
   }
 }
diff --git a/retrofit/src/main/java/retrofit/NoContentResponseBody.java b/retrofit/src/main/java/retrofit/NoContentResponseBody.java
deleted file mode 100644
index 098087653..000000000
--- a/retrofit/src/main/java/retrofit/NoContentResponseBody.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.BufferedSource;
-
-final class NoContentResponseBody extends ResponseBody {
-  private final MediaType contentType;
-  private final long contentLength;
-
-  NoContentResponseBody(MediaType contentType, long contentLength) {
-    this.contentType = contentType;
-    this.contentLength = contentLength;
-  }
-
-  @Override public MediaType contentType() {
-    return contentType;
-  }
-
-  @Override public long contentLength() throws IOException {
-    return contentLength;
-  }
-
-  @Override public BufferedSource source() throws IOException {
-    throw new IllegalStateException("Cannot read raw response body of a converted body.");
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index db009e9d5..e649fee74 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -15,15 +15,19 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
 
 import static retrofit.Utils.closeQuietly;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final OkHttpClient client;
+  private final Retrofit retrofit;
   private final RequestFactory requestFactory;
   private final Converter<ResponseBody, T> responseConverter;
   private final Object[] args;
@@ -32,9 +36,9 @@
   private boolean executed; // Guarded by this.
   private volatile boolean canceled;
 
-  OkHttpCall(OkHttpClient client, RequestFactory requestFactory,
+  OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,
       Converter<ResponseBody, T> responseConverter, Object[] args) {
-    this.client = client;
+    this.retrofit = retrofit;
     this.requestFactory = requestFactory;
     this.responseConverter = responseConverter;
     this.args = args;
@@ -42,7 +46,7 @@
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(client, requestFactory, responseConverter, args);
+    return new OkHttpCall<>(retrofit, requestFactory, responseConverter, args);
   }
 
   @Override public void enqueue(final Callback<T> callback) {
@@ -74,7 +78,7 @@ private void callFailure(Throwable e) {
 
       private void callSuccess(Response<T> response) {
         try {
-          callback.onResponse(response);
+          callback.onResponse(response, retrofit);
         } catch (Throwable t) {
           t.printStackTrace();
         }
@@ -113,7 +117,7 @@ private void callSuccess(Response<T> response) {
   }
 
   private com.squareup.okhttp.Call createRawCall() {
-    return client.newCall(requestFactory.create(args));
+    return retrofit.client().newCall(requestFactory.create(args));
   }
 
   private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
@@ -158,4 +162,78 @@ public void cancel() {
       rawCall.cancel();
     }
   }
+
+  static final class NoContentResponseBody extends ResponseBody {
+    private final MediaType contentType;
+    private final long contentLength;
+
+    NoContentResponseBody(MediaType contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public long contentLength() throws IOException {
+      return contentLength;
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      throw new IllegalStateException("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  static final class ExceptionCatchingRequestBody extends ResponseBody {
+    private final ResponseBody delegate;
+    private IOException thrownException;
+
+    ExceptionCatchingRequestBody(ResponseBody delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public MediaType contentType() {
+      return delegate.contentType();
+    }
+
+    @Override public long contentLength() throws IOException {
+      try {
+        return delegate.contentLength();
+      } catch (IOException e) {
+        thrownException = e;
+        throw e;
+      }
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      BufferedSource delegateSource;
+      try {
+        delegateSource = delegate.source();
+      } catch (IOException e) {
+        thrownException = e;
+        throw e;
+      }
+      return Okio.buffer(new ForwardingSource(delegateSource) {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          try {
+            return super.read(sink, byteCount);
+          } catch (IOException e) {
+            thrownException = e;
+            throw e;
+          }
+        }
+      });
+    }
+
+    @Override public void close() throws IOException {
+      delegate.close();
+    }
+
+    void throwIfCaught() throws IOException {
+      if (thrownException != null) {
+        throw thrownException;
+      }
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
deleted file mode 100644
index b22ab20e2..000000000
--- a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.RequestBody;
-import java.io.IOException;
-
-final class OkHttpRequestBodyConverter implements Converter<RequestBody, RequestBody> {
-  @Override public RequestBody convert(RequestBody value) throws IOException {
-    return value;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
deleted file mode 100644
index c324c4c8e..000000000
--- a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-
-import static retrofit.Utils.closeQuietly;
-
-final class OkHttpResponseBodyConverter implements Converter<ResponseBody, ResponseBody> {
-  private final boolean isStreaming;
-
-  OkHttpResponseBodyConverter(boolean isStreaming) {
-    this.isStreaming = isStreaming;
-  }
-
-  @Override public ResponseBody convert(ResponseBody value) throws IOException {
-    if (isStreaming) {
-      return value;
-    }
-
-    // Buffer the entire body to avoid future I/O.
-    try {
-      return Utils.readBodyToBytesIfNecessary(value);
-    } finally {
-      closeQuietly(value);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 7828dab06..65eed2c1a 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -23,11 +23,14 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
+import okio.Buffer;
 import okio.BufferedSink;
 
 final class RequestBuilder {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+
   private final String method;
 
   private final HttpUrl baseUrl;
@@ -61,6 +64,7 @@
     } else if (isMultipart) {
       // Will be set to 'body' in 'build'.
       multipartBuilder = new MultipartBuilder();
+      multipartBuilder.type(MultipartBuilder.FORM);
     }
   }
 
@@ -81,20 +85,55 @@ void addPathParam(String name, String value, boolean encoded) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    try {
-      if (!encoded) {
-        String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
-        // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
-        // encode spaces rather than +. Query encoding difference specified in HTML spec.
-        // Any remaining plus signs represent spaces as already URLEncoded.
-        encodedValue = encodedValue.replace("+", "%20");
-        relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));
+  }
+
+  static String canonicalize(String input, boolean alreadyEncoded) {
+    int codePoint;
+    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, 0, i);
+        canonicalize(out, input, i, limit, alreadyEncoded);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters required encoding.
+    return input;
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit, boolean alreadyEncoded) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
       } else {
-        relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
       }
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
index ba302c483..eea1b0520 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilderAction.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
@@ -20,7 +20,6 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
-import java.util.List;
 import java.util.Map;
 
 import static retrofit.Utils.checkNotNull;
@@ -215,13 +214,12 @@
   }
 
   static final class PartMap extends RequestBuilderAction {
-    private final List<Converter.Factory> converterFactories;
+    private final Retrofit retrofit;
     private final String transferEncoding;
     private final Annotation[] annotations;
 
-    PartMap(List<Converter.Factory> converterFactories, String transferEncoding,
-        Annotation[] annotations) {
-      this.converterFactories = converterFactories;
+    PartMap(Retrofit retrofit, String transferEncoding, Annotation[] annotations) {
+      this.retrofit = retrofit;
       this.transferEncoding = transferEncoding;
       this.annotations = annotations;
     }
@@ -241,14 +239,13 @@
         }
 
         Headers headers = Headers.of(
-            "Content-Disposition", "name=\"" + entryKey + "\"",
+            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
             "Content-Transfer-Encoding", transferEncoding);
 
         Class<?> entryClass = entryValue.getClass();
         //noinspection unchecked
         Converter<Object, RequestBody> converter =
-            (Converter<Object, RequestBody>) Utils.resolveRequestBodyConverter(converterFactories,
-                entryClass, annotations);
+            (Converter<Object, RequestBody>) retrofit.requestConverter(entryClass, annotations);
         RequestBody body;
         try {
           body = converter.convert(entryValue);
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
index 7d3017115..4d807ded0 100644
--- a/retrofit/src/main/java/retrofit/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -21,7 +21,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -55,12 +54,11 @@
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-  static RequestFactory parse(Method method, BaseUrl baseUrl,
-      List<Converter.Factory> converterFactories) {
+  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
     RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations();
-    parser.parseParameters(converterFactories);
-    return parser.toRequestFactory(baseUrl);
+    parser.parseMethodAnnotations(responseType);
+    parser.parseParameters(retrofit);
+    return parser.toRequestFactory(retrofit.baseUrl());
   }
 
   private final Method method;
@@ -94,7 +92,7 @@ private RuntimeException parameterError(int index, String message, Object... arg
     return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
   }
 
-  private void parseMethodAnnotations() {
+  private void parseMethodAnnotations(Type responseType) {
     for (Annotation annotation : method.getAnnotations()) {
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
@@ -102,6 +100,9 @@ private void parseMethodAnnotations() {
         parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
       } else if (annotation instanceof HEAD) {
         parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+        if (!Void.class.equals(responseType)) {
+          throw methodError(method, "HEAD method must use Void as response type.");
+        }
       } else if (annotation instanceof PATCH) {
         parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
       } else if (annotation instanceof POST) {
@@ -193,7 +194,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
     return builder.build();
   }
 
-  private void parseParameters(List<Converter.Factory> converterFactories) {
+  private void parseParameters(Retrofit retrofit) {
     Type[] methodParameterTypes = method.getGenericParameterTypes();
     Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
 
@@ -290,12 +291,12 @@ private void parseParameters(List<Converter.Factory> converterFactories) {
             }
             Part part = (Part) methodParameterAnnotation;
             com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "name=\"" + part.value() + "\"",
+                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
                 "Content-Transfer-Encoding", part.encoding());
             Converter<?, RequestBody> converter;
             try {
-              converter = Utils.resolveRequestBodyConverter(converterFactories, methodParameterType,
-                  methodParameterAnnotations);
+              converter =
+                  retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
             } catch (RuntimeException e) { // Wide exception range because factories are user code.
               throw parameterError(e, i, "Unable to create @Part converter for %s",
                   methodParameterType);
@@ -312,7 +313,7 @@ private void parseParameters(List<Converter.Factory> converterFactories) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
             PartMap partMap = (PartMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.PartMap(converterFactories, partMap.encoding(),
+            action = new RequestBuilderAction.PartMap(retrofit, partMap.encoding(),
                 methodParameterAnnotations);
             gotPart = true;
 
@@ -327,8 +328,8 @@ private void parseParameters(List<Converter.Factory> converterFactories) {
 
             Converter<?, RequestBody> converter;
             try {
-              converter = Utils.resolveRequestBodyConverter(converterFactories, methodParameterType,
-                  methodParameterAnnotations);
+              converter =
+                  retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
             } catch (RuntimeException e) { // Wide exception range because factories are user code.
               throw parameterError(e, i, "Unable to create @Body converter for %s",
                   methodParameterType);
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index 765a9c5d5..4d2b04071 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -19,9 +19,11 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
@@ -59,7 +61,7 @@
  * <ul>
  * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
  * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
- * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
+ * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with parts
  * specified by the {@link retrofit.http.Part @Part} parameter annotation.
  * </ul>
  * <p>
@@ -94,20 +96,26 @@
   private final List<Converter.Factory> converterFactories;
   private final List<CallAdapter.Factory> adapterFactories;
   private final Executor callbackExecutor;
+  private final boolean validateEagerly;
 
   private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
-      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor) {
+      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
+      boolean validateEagerly) {
     this.client = client;
     this.baseUrl = baseUrl;
     this.converterFactories = converterFactories;
     this.adapterFactories = adapterFactories;
     this.callbackExecutor = callbackExecutor;
+    this.validateEagerly = validateEagerly;
   }
 
   /** Create an implementation of the API defined by the {@code service} interface. */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
     Utils.validateServiceInterface(service);
+    if (validateEagerly) {
+      eagerlyValidateMethods(service);
+    }
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
@@ -126,13 +134,21 @@ private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> c
         });
   }
 
+  private void eagerlyValidateMethods(Class<?> service) {
+    Platform platform = Platform.get();
+    for (Method method : service.getDeclaredMethods()) {
+      if (!platform.isDefaultMethod(method)) {
+        loadMethodHandler(method);
+      }
+    }
+  }
+
   MethodHandler<?> loadMethodHandler(Method method) {
     MethodHandler<?> handler;
     synchronized (methodHandlerCache) {
       handler = methodHandlerCache.get(method);
       if (handler == null) {
-        handler =
-            MethodHandler.create(method, client, baseUrl, adapterFactories, converterFactories);
+        handler = MethodHandler.create(this, method);
         methodHandlerCache.put(method, handler);
       }
     }
@@ -147,6 +163,50 @@ public BaseUrl baseUrl() {
     return baseUrl;
   }
 
+  public List<CallAdapter.Factory> callAdapterFactories() {
+    return Collections.unmodifiableList(adapterFactories);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories}.
+   */
+  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+    return nextCallAdapter(null, returnType, annotations);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories} except {@code skipPast}.
+   */
+  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+      Annotation[] annotations) {
+    checkNotNull(returnType, "returnType == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = adapterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      if (adapter != null) {
+        return adapter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+        .append(returnType)
+        .append(". Tried:");
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+    }
+    if (skipPast != null) {
+      builder.append("\nSkipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+      }
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
   /**
    * TODO
    */
@@ -154,8 +214,56 @@ public BaseUrl baseUrl() {
     return Collections.unmodifiableList(converterFactories);
   }
 
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return Collections.unmodifiableList(adapterFactories);
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+   * {@linkplain #converterFactories() factories}.
+   */
+  public <T> Converter<T, RequestBody> requestConverter(Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<?, RequestBody> converter =
+          converterFactories.get(i).toRequestBody(type, annotations);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<T, RequestBody>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+        .append(type)
+        .append(". Tried:");
+    for (Converter.Factory converterFactory : converterFactories) {
+      builder.append("\n * ").append(converterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+   * {@linkplain #converterFactories() factories}.
+   */
+  public <T> Converter<ResponseBody, T> responseConverter(Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<ResponseBody, ?> converter =
+          converterFactories.get(i).fromResponseBody(type, annotations);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<ResponseBody, T>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+        .append(type)
+        .append(". Tried:");
+    for (Converter.Factory converterFactory : converterFactories) {
+      builder.append("\n * ").append(converterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
   }
 
   public Executor callbackExecutor() {
@@ -174,11 +282,12 @@ public Executor callbackExecutor() {
     private List<Converter.Factory> converterFactories = new ArrayList<>();
     private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
     private Executor callbackExecutor;
+    private boolean validateEagerly;
 
     public Builder() {
       // Add the built-in converter factory first. This prevents overriding its behavior but also
       // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverterFactory());
+      converterFactories.add(new BuiltInConverters());
     }
 
     /** The HTTP client used for requests. */
@@ -236,6 +345,15 @@ public Builder callbackExecutor(Executor callbackExecutor) {
       return this;
     }
 
+    /**
+     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+     * the configuration of all methods in the supplied interface.
+     */
+    public Builder validateEagerly() {
+      validateEagerly = true;
+      return this;
+    }
+
     /** Create the {@link Retrofit} instances. */
     public Retrofit build() {
       if (baseUrl == null) {
@@ -254,7 +372,8 @@ public Retrofit build() {
       // Make a defensive copy of the converters.
       List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
 
-      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor);
+      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
+          validateEagerly);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index 053b12d0d..ee8912bbe 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,7 +16,6 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import java.io.Closeable;
@@ -30,7 +29,6 @@
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
-import java.util.List;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Source;
@@ -62,62 +60,6 @@ static boolean isAnnotationPresent(Annotation[] annotations,
     return false;
   }
 
-  static CallAdapter<?> resolveCallAdapter(List<CallAdapter.Factory> adapterFactories, Type type,
-      Annotation[] annotations) {
-    for (int i = 0, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(type, annotations);
-      if (adapter != null) {
-        return adapter;
-      }
-    }
-
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(type)
-        .append(". Tried:");
-    for (CallAdapter.Factory adapterFactory : adapterFactories) {
-      builder.append("\n * ").append(adapterFactory.getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  static Converter<?, RequestBody> resolveRequestBodyConverter(
-      List<Converter.Factory> converterFactories, Type type, Annotation[] annotations) {
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, RequestBody> converter =
-          converterFactories.get(i).toRequestBody(type, annotations);
-      if (converter != null) {
-        return converter;
-      }
-    }
-
-    StringBuilder builder =
-        new StringBuilder("Could not locate RequestBody converter for ").append(type)
-            .append(". Tried:");
-    for (Converter.Factory converterFactory : converterFactories) {
-      builder.append("\n * ").append(converterFactory.getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  static Converter<ResponseBody, ?> resolveResponseBodyConverter(
-      List<Converter.Factory> converterFactories, Type type, Annotation[] annotations) {
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).fromResponseBody(type, annotations);
-      if (converter != null) {
-        return converter;
-      }
-    }
-
-    StringBuilder builder =
-        new StringBuilder("Could not locate ResponseBody converter for ").append(type)
-            .append(". Tried:");
-    for (Converter.Factory converterFactory : converterFactories) {
-      builder.append("\n * ").append(converterFactory.getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
   /**
    * Replace a {@link Response} with an identical copy whose body is backed by a
    * {@link Buffer} rather than a {@link Source}.
diff --git a/retrofit/src/main/java/retrofit/VoidConverter.java b/retrofit/src/main/java/retrofit/VoidConverter.java
deleted file mode 100644
index 09fa3f229..000000000
--- a/retrofit/src/main/java/retrofit/VoidConverter.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-
-final class VoidConverter implements Converter<ResponseBody, Void> {
-  @Override public Void convert(ResponseBody value) throws IOException {
-    value.close();
-    return null;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index 9ae6f7adc..ab7176d99 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -22,7 +22,11 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a HEAD request to a REST path relative to base URL. */
+/**
+ * Make a HEAD request to a REST path relative to base URL.
+ * <p>
+ * Note: HEAD requests must use {@link Void} as the response type since there is no body content.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/retrofit/src/main/java/retrofit/http/HTTP.java b/retrofit/src/main/java/retrofit/http/HTTP.java
index f699bbe7d..5d54952ec 100644
--- a/retrofit/src/main/java/retrofit/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -22,6 +22,22 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+/**
+ * Use a custom HTTP verb for a request.
+ * <pre>{@code
+ * interface Service {
+ *   &#064;HTTP(method = "CUSTOM", path = "custom/endpoint/")
+ *   Call<ResponseBody> customEndpoint();
+ * }
+ * }</pre>
+ * This annotation can also used for sending {@code DELETE} with a request body:
+ * <pre>{@code
+ * interface Service {
+ *   &#064;HTTP(method = "DELETE", path = "remove/", hasBody = true)
+ *   Call<ResponseBody> deleteObject(@Body RequestBody object);
+ * }
+ * }</pre>
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 0f5913777..b06cad953 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -26,10 +26,10 @@
 /**
  * Denotes a single part of a multi-part request.
  * <p>
- * The parameter type on which this annotation exists will be processed in one of three ways:
+ * The parameter type on which this annotation exists will be processed in one of two ways:
  * <ul>
- * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
- * content type.</li>
+ * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
+ * directly with its content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
@@ -39,10 +39,9 @@
  * <pre>
  * &#64;Multipart
  * &#64;POST("/")
- * void example(&#64;Part("description") String description,
- *              &#64;Part("image") TypedFile image,
- *              ...
- * );
+ * Call&lt;<ResponseBody> example(
+ *     &#64;Part("description") String description,
+ *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
  * </pre>
  * <p>
  * Part parameters may not be {@code null}.
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index a8d788447..a3026ce30 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -24,12 +24,12 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Denotes name and value parts of a multi-part request
+ * Denotes name and value parts of a multi-part request.
  * <p>
- * Values of the map on which this annotation exists will be processed in one of three ways:
+ * Values of the map on which this annotation exists will be processed in one of two ways:
  * <ul>
- * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
- * content type.</li>
+ * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
+ * directly with its content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
@@ -37,7 +37,9 @@
  * <pre>
  * &#64;Multipart
  * &#64;POST("/upload")
- * void upload(&#64;Part("file") TypedFile file, &#64;PartMap Map&lt;String, String&gt; params);
+ * Call&lt;ResponseBody> upload(
+ *     &#64;Part("file") RequestBody file,
+ *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
  * </pre>
  *
  * @see Multipart
@@ -47,6 +49,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of this part. */
+  /** The {@code Content-Transfer-Encoding} of the parts. */
   String encoding() default "binary";
 }
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
index 2b4c26156..586c799f6 100644
--- a/retrofit/src/test/java/retrofit/CallTest.java
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -80,10 +80,12 @@
     server.enqueue(new MockResponse().setBody("Hi"));
 
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final AtomicReference<Retrofit> retrofitRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         responseRef.set(response);
+        retrofitRef.set(retrofit);
         latch.countDown();
       }
 
@@ -96,6 +98,8 @@
     Response<String> response = responseRef.get();
     assertThat(response.isSuccess()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
+
+    assertThat(retrofitRef.get()).isSameAs(retrofit);
   }
 
   @Test public void http404Sync() throws IOException {
@@ -125,7 +129,7 @@
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         responseRef.set(response);
         latch.countDown();
       }
@@ -171,7 +175,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
@@ -230,7 +234,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
@@ -342,7 +346,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
@@ -546,7 +550,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
@@ -590,7 +594,7 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
diff --git a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
index 1032cf461..98a165596 100644
--- a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
@@ -35,6 +35,9 @@
 public final class ExecutorCallAdapterFactoryTest {
   private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
+  private final Retrofit retrofit = new Retrofit.Builder()
+      .baseUrl("http://localhost:1")
+      .build();
   private final Callback<String> callback = mock(Callback.class);
   private final Executor callbackExecutor = spy(new Executor() {
     @Override public void execute(Runnable runnable) {
@@ -45,7 +48,7 @@
 
   @Test public void rawTypeThrows() {
     try {
-      factory.get(Call.class, NO_ANNOTATIONS);
+      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
@@ -55,7 +58,7 @@
   @Test public void responseThrows() {
     Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
     try {
-      factory.get(returnType, NO_ANNOTATIONS);
+      factory.get(returnType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
@@ -65,17 +68,20 @@
 
   @Test public void responseType() {
     Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS).responseType()) //
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
   }
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
@@ -87,21 +93,23 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(response);
+        callback.onResponse(response, retrofit);
       }
     });
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(response);
+    verify(callback).onResponse(response, retrofit);
   }
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
@@ -117,7 +125,8 @@
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
     Call<String> call = (Call<String>) adapter.adapt(delegate);
     Call<String> cloned = call.clone();
@@ -128,7 +137,8 @@
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
     Call<String> call = (Call<String>) adapter.adapt(delegate);
     call.cancel();
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 826b27472..0d56c016e 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -1,10 +1,13 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
@@ -13,6 +16,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -48,7 +52,7 @@
   @Test public void customMethodNoBody() {
     class Example {
       @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -63,7 +67,7 @@
   @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -80,7 +84,7 @@
       @Multipart //
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -98,7 +102,7 @@
       @FormUrlEncoded //
       @Multipart //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -114,7 +118,7 @@
   @Test public void invalidPathParam() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Path("hey!") String thing) {
+      Call<ResponseBody> method(@Path("hey!") String thing) {
         return null;
       }
     }
@@ -132,7 +136,7 @@
   @Test public void pathParamNotAllowedInQuery() throws Exception {
     class Example {
       @GET("/foo?bar={bar}") //
-      Call<Object> method(@Path("bar") String thing) {
+      Call<ResponseBody> method(@Path("bar") String thing) {
         return null;
       }
     }
@@ -149,7 +153,7 @@
   @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Body @Query("nope") String o) {
+      Call<ResponseBody> method(@Body @Query("nope") String o) {
         return null;
       }
     }
@@ -167,7 +171,7 @@
   @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Query("maybe") @NonNull Object o) {
+      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
         return null;
       }
     }
@@ -179,7 +183,7 @@
     class Example {
       @PATCH("/foo") //
       @POST("/foo") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -195,7 +199,7 @@
 
   @Test public void lackingMethod() {
     class Example {
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -211,7 +215,7 @@
   @Test public void implicitMultipartForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Part("a") int a) {
+      Call<ResponseBody> method(@Part("a") int a) {
         return null;
       }
     }
@@ -227,7 +231,7 @@
   @Test public void implicitMultipartWithPartMapForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@PartMap Map<String, String> params) {
+      Call<ResponseBody> method(@PartMap Map<String, String> params) {
         return null;
       }
     }
@@ -244,7 +248,7 @@
     class Example {
       @Multipart //
       @GET("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -261,7 +265,7 @@
     class Example {
       @Multipart //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -277,7 +281,7 @@
   @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Field("a") int a) {
+      Call<ResponseBody> method(@Field("a") int a) {
         return null;
       }
     }
@@ -293,7 +297,7 @@
   @Test public void implicitFormEncodingByFieldMapForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@FieldMap Map<String, String> a) {
+      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
         return null;
       }
     }
@@ -310,7 +314,7 @@
     class Example {
       @FormUrlEncoded //
       @GET("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -327,7 +331,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -343,7 +347,7 @@
     class Example {
       @GET("/") //
       @Headers({}) //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -359,7 +363,7 @@
     class Example {
       @GET("/") //
       @Headers("Malformed") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -375,7 +379,7 @@
   @Test public void pathParamNonPathParamAndTypedBytes() {
     class Example {
       @PUT("/{a}") //
-      Call<Object> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
         return null;
       }
     }
@@ -391,7 +395,7 @@
   @Test public void parameterWithoutAnnotation() {
     class Example {
       @GET("/") //
-      Call<Object> method(String a) {
+      Call<ResponseBody> method(String a) {
         return null;
       }
     }
@@ -407,7 +411,7 @@
   @Test public void nonBodyHttpMethodWithSingleEntity() {
     class Example {
       @GET("/") //
-      Call<Object> method(@Body String o) {
+      Call<ResponseBody> method(@Body String o) {
         return null;
       }
     }
@@ -423,7 +427,7 @@
   @Test public void queryMapMustBeAMap() {
     class Example {
       @GET("/") //
-      Call<Object> method(@QueryMap List<String> a) {
+      Call<ResponseBody> method(@QueryMap List<String> a) {
         return null;
       }
     }
@@ -439,7 +443,7 @@
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
-      Call<Object> method(@QueryMap Map<String, String> a) {
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
         return null;
       }
     }
@@ -459,7 +463,7 @@
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
-      Call<Object> method(@Body String o1, @Body String o2) {
+      Call<ResponseBody> method(@Body String o1, @Body String o2) {
         return null;
       }
     }
@@ -476,7 +480,7 @@
     class Example {
       @Multipart //
       @PUT("/") //
-      Call<Object> method(@Part("one") String o1, @Body String o2) {
+      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
         return null;
       }
     }
@@ -492,7 +496,7 @@
   @Test public void get() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -506,7 +510,7 @@
   @Test public void delete() {
     class Example {
       @DELETE("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -520,7 +524,7 @@
   @Test public void head() {
     class Example {
       @HEAD("/foo/bar/") //
-      Call<Object> method() {
+      Call<Void> method() {
         return null;
       }
     }
@@ -531,10 +535,25 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void headWithoutVoidThrows() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "HEAD method must use Void as response type.\n    for method Example.method");
+    }
+  }
+
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -549,7 +568,7 @@
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -564,7 +583,7 @@
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -579,7 +598,7 @@
   @Test public void getWithPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -593,7 +612,7 @@
   @Test public void getWithUnusedAndInvalidNamedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -607,7 +626,7 @@
   @Test public void getWithEncodedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path(value = "ping", encoded = true) String ping) {
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
         return null;
       }
     }
@@ -621,7 +640,7 @@
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -636,7 +655,7 @@
   @Test public void getWithQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -650,7 +669,7 @@
   @Test public void getWithEncodedQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
         return null;
       }
     }
@@ -664,7 +683,7 @@
   @Test public void queryParamOptionalOmitsQuery() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -675,7 +694,7 @@
   @Test public void queryParamOptional() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("foo") String foo, @Query("ping") String ping,
+      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
           @Query("kit") String kit) {
         return null;
       }
@@ -687,7 +706,7 @@
   @Test public void getWithQueryUrlAndParam() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -701,7 +720,7 @@
   @Test public void getWithQuery() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -715,7 +734,7 @@
   @Test public void getWithPathAndQueryParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit,
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
           @Query("riff") String riff) {
         return null;
       }
@@ -731,7 +750,7 @@
   @Test public void getWithQueryThenPathThrows() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Query("kit") String kit, @Path("ping") String ping) {
+      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
         return null;
       }
     }
@@ -748,7 +767,7 @@
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -763,7 +782,7 @@
   @Test public void getWithPathAndQueryAmpersandParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -771,14 +790,14 @@
     Request request = buildRequest(Example.class, "pong&", "kat&");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
     assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryHashParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -793,7 +812,7 @@
   @Test public void getWithQueryParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") List<Object> keys) {
+      Call<ResponseBody> method(@Query("key") List<Object> keys) {
         return null;
       }
     }
@@ -809,7 +828,7 @@
   @Test public void getWithQueryParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") Object[] keys) {
+      Call<ResponseBody> method(@Query("key") Object[] keys) {
         return null;
       }
     }
@@ -825,7 +844,7 @@
   @Test public void getWithQueryParamPrimitiveArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") int[] keys) {
+      Call<ResponseBody> method(@Query("key") int[] keys) {
         return null;
       }
     }
@@ -841,7 +860,7 @@
   @Test public void getWithQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@QueryMap Map<String, Object> query) {
+      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
         return null;
       }
     }
@@ -861,7 +880,7 @@
   @Test public void getWithEncodedQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@QueryMap(encoded = true) Map<String, Object> query) {
+      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
         return null;
       }
     }
@@ -881,7 +900,7 @@
   @Test public void getWithUrl() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -896,7 +915,7 @@
   @Test public void getAbsoluteUrl() {
     class Example {
       @GET("http://example2.com/foo/bar/")
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -911,7 +930,7 @@
   @Test public void getWithUrlAbsolute() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -926,7 +945,7 @@
   @Test public void getWithUrlAbsoluteSameHost() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -941,7 +960,7 @@
   @Test public void getWithNonStringUrlThrows() {
     class Example {
       @GET
-      Call<Object> method(@Url Object url) {
+      Call<ResponseBody> method(@Url Object url) {
         return null;
       }
     }
@@ -958,7 +977,7 @@
   @Test public void getUrlAndUrlParamThrows() {
     class Example {
       @GET("foo/bar")
-      Call<Object> method(@Url Object url) {
+      Call<ResponseBody> method(@Url Object url) {
         return null;
       }
     }
@@ -975,7 +994,7 @@
   @Test public void getWithoutUrlThrows() {
     class Example {
       @GET
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -992,7 +1011,7 @@
   @Test public void getWithUrlThenPathThrows() {
     class Example {
       @GET
-      Call<Object> method(@Url String url, @Path("hey") String hey) {
+      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
         return null;
       }
     }
@@ -1009,7 +1028,7 @@
   @Test public void getWithPathThenUrlThrows() {
     class Example {
       @GET
-      Call<Object> method(@Path("hey") String hey, @Url Object url) {
+      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
         return null;
       }
     }
@@ -1026,7 +1045,7 @@
   @Test public void getWithQueryThenUrlThrows() {
     class Example {
       @GET("foo/bar")
-      Call<Object> method(@Query("hey") String hey, @Url Object url) {
+      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
         return null;
       }
     }
@@ -1043,7 +1062,7 @@
   @Test public void getWithUrlThenQuery() {
     class Example {
       @GET
-      Call<Object> method(@Url String url, @Query("hey") String hey) {
+      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
         return null;
       }
     }
@@ -1057,7 +1076,7 @@
   @Test public void postWithUrl() {
     class Example {
       @POST
-      Call<Object> method(@Url String url, @Body RequestBody body) {
+      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
         return null;
       }
     }
@@ -1072,7 +1091,7 @@
   @Test public void normalPostWithPathParam() {
     class Example {
       @POST("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
         return null;
       }
     }
@@ -1087,7 +1106,7 @@
   @Test public void emptyBody() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1102,7 +1121,7 @@
   @Test public void customMethodEmptyBody() {
     class Example {
       @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1116,7 +1135,7 @@
   @Test public void bodyResponseBody() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1131,7 +1150,7 @@
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1146,7 +1165,7 @@
   @Test public void bodyWithPathParams() {
     class Example {
       @POST("/foo/bar/{ping}/{kit}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
         return null;
       }
     }
@@ -1162,7 +1181,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
         return null;
       }
     }
@@ -1179,10 +1198,12 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"\r\n")
         .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
   }
@@ -1191,7 +1212,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
+      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
           @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
         return null;
       }
@@ -1208,11 +1229,15 @@
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
-    assertThat(bodyString).contains("name=\"ping\"\r\n")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\npong\r\n--");
 
-    assertThat(bodyString).contains("name=\"kit\"")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 7-bit")
         .contains("\r\nkat\r\n--");
   }
@@ -1221,7 +1246,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap Map<String, Object> parts) {
         return null;
       }
     }
@@ -1242,10 +1267,12 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"\r\n")
         .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
 
@@ -1256,7 +1283,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
         return null;
       }
     }
@@ -1276,11 +1303,15 @@
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
-    assertThat(bodyString).contains("name=\"ping\"\r\n")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\npong\r\n--");
 
-    assertThat(bodyString).contains("name=\"kit\"")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\nkat\r\n--");
 
@@ -1291,7 +1322,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap Map<String, Object> parts) {
         return null;
       }
     }
@@ -1312,7 +1343,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap List<Object> parts) {
+      Call<ResponseBody> method(@PartMap List<Object> parts) {
         return null;
       }
     }
@@ -1330,7 +1361,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
         return null;
       }
     }
@@ -1345,6 +1376,7 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"")
         .contains("\r\npong\r\n--");
   }
@@ -1353,7 +1385,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") RequestBody ping) {
+      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
         return null;
       }
     }
@@ -1369,7 +1401,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping) {
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
         return null;
       }
     }
@@ -1381,7 +1413,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field(value = "na%20me", encoded = true) String foo) {
+      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
         return null;
       }
     }
@@ -1393,7 +1425,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping,
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
           @Field("kit") String kit) {
         return null;
       }
@@ -1406,7 +1438,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1420,7 +1452,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1434,7 +1466,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1448,7 +1480,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
         return null;
       }
     }
@@ -1465,7 +1497,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@FieldMap Map<String, Object> fieldMap) {
+      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
         return null;
       }
     }
@@ -1483,7 +1515,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method(@FieldMap Map<String, Object> a) {
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
         return null;
       }
     }
@@ -1505,7 +1537,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method(@FieldMap List<String> a) {
+      Call<ResponseBody> method(@FieldMap List<String> a) {
         return null;
       }
     }
@@ -1525,7 +1557,7 @@
           "ping: pong",
           "kit: kat"
       })
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1542,7 +1574,7 @@
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("kit") BigInteger kit) {
+      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
@@ -1559,7 +1591,7 @@
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Call<Object> method(@Header("kit") String kit) {
+      Call<ResponseBody> method(@Header("kit") String kit) {
         return null;
       }
     }
@@ -1576,7 +1608,7 @@
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("foo") List<String> kit) {
+      Call<ResponseBody> method(@Header("foo") List<String> kit) {
         return null;
       }
     }
@@ -1592,7 +1624,7 @@
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("foo") String[] kit) {
+      Call<ResponseBody> method(@Header("foo") String[] kit) {
         return null;
       }
     }
@@ -1609,7 +1641,7 @@
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1622,7 +1654,7 @@
     class Example {
       @DELETE("/") //
       @Headers("Content-Type: text/not-plain") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1633,7 +1665,7 @@
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
@@ -1654,17 +1686,34 @@ private static void assertBody(RequestBody body, String expected) {
   }
 
   private Request buildRequest(Class<?> cls, Object... args) {
-    Method method = TestingUtils.onlyMethod(cls);
+    OkHttpClient client = new OkHttpClient();
 
-    BaseUrl baseUrl = new BaseUrl() {
-      @Override public HttpUrl url() {
-        return HttpUrl.parse("http://example.com/");
+    final AtomicReference<Request> requestRef = new AtomicReference<>();
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        requestRef.set(chain.request());
+        throw new UnsupportedOperationException("Not implemented");
       }
-    };
-    List<Converter.Factory> converterFactories =
-        Arrays.asList(new BuiltInConverterFactory(), new ToStringConverterFactory());
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory())
+        .client(client)
+        .build();
 
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactories);
-    return requestFactory.create(args);
+    Method method = TestingUtils.onlyMethod(cls);
+    MethodHandler<?> handler = retrofit.loadMethodHandler(method);
+    Call<?> invoke = (Call<?>) handler.invoke(args);
+    try {
+      invoke.execute();
+      throw new AssertionError();
+    } catch (UnsupportedOperationException ignored) {
+      return requestRef.get();
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
index b80efc941..b129d735f 100644
--- a/retrofit/src/test/java/retrofit/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -34,6 +34,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
@@ -114,6 +115,21 @@
     }
   }
 
+  @Test public void validateEagerlyFailsAtCreation() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .validateEagerly()
+        .build();
+
+    try {
+      retrofit.create(VoidService.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
   @Test public void callCallAdapterAddedByDefault() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -126,7 +142,8 @@
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations) {
+      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         if (Utils.getRawType(returnType) != Call.class) {
           return null;
@@ -156,7 +173,8 @@
 
   @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations) {
+      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         if (Utils.getRawType(returnType) != String.class) {
           return null;
         }
@@ -184,7 +202,8 @@
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations) {
+      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
       }
@@ -273,7 +292,7 @@
               + "    for method CallMethod.disallowed");
       assertThat(e.getCause()).hasMessage(
           "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory");
+              + " * retrofit.BuiltInConverters");
     }
   }
 
@@ -293,7 +312,7 @@
           + "    for method CallMethod.disallowed");
       assertThat(e.getCause()).hasMessage(
           "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory");
+              + " * retrofit.BuiltInConverters");
     }
   }
 
@@ -312,7 +331,7 @@
           + "    for method CallMethod.disallowed");
       assertThat(e.getCause()).hasMessage(
           "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
-              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.BuiltInConverters\n"
               + " * retrofit.RetrofitTest$1");
     }
   }
@@ -508,7 +527,103 @@
         .build();
     List<Converter.Factory> converterFactories = retrofit.converterFactories();
     assertThat(converterFactories).hasSize(1);
-    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverterFactory.class);
+    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+  }
+
+  @Test public void requestConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).toRequestBody(type, annotations);
+
+    Converter<?, RequestBody> actualAdapter = retrofit.requestConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).toRequestBody(type, annotations);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void requestConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter.Factory factory1 = spy(new Converter.Factory() {
+      @Override
+      public Converter<?, RequestBody> toRequestBody(Type returnType, Annotation[] annotations) {
+        return null;
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.requestConverter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate RequestBody converter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).toRequestBody(type, annotations);
+    verifyNoMoreInteractions(factory1);
+  }
+
+  @Test public void responseConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).fromResponseBody(type, annotations);
+
+    Converter<ResponseBody, ?> actualAdapter = retrofit.responseConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).fromResponseBody(type, annotations);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void responseConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter.Factory factory1 = spy(new Converter.Factory() {
+      @Override
+      public Converter<ResponseBody, ?> fromResponseBody(Type returnType, Annotation[] annotations) {
+        return null;
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.responseConverter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).fromResponseBody(type, annotations);
+    verifyNoMoreInteractions(factory1);
   }
 
   @Test public void converterFactoryPropagated() {
@@ -545,6 +660,148 @@
     assertThat(retrofit.callAdapterFactories()).contains(factory);
   }
 
+  @Test public void callAdapterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegate() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .build();
+
+    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .addCallAdapterFactory(factory3)
+        .build();
+
+    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+    verify(factory3).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory3);
+  }
+
+  @Test public void callAdapterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+
+    doReturn(null).when(factory).get(type, annotations, retrofit);
+
+    try {
+      retrofit.callAdapter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate call adapter for class java.lang.String. Tried:");
+    }
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.callAdapter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining("Skipped:")
+          .hasMessageStartingWith(
+              "Could not locate call adapter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+  }
+
   @Test public void callbackExecutorNullThrows() {
     try {
       new Retrofit.Builder().callbackExecutor(null);
@@ -587,7 +844,7 @@
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Response<ResponseBody> response) {
+      @Override public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
         latch.countDown();
       }
 
@@ -618,7 +875,7 @@
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Response<ResponseBody> response) {
+      @Override public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
diff --git a/samples/pom.xml b/samples/pom.xml
index b1a3e9f85..cedb3a385 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -29,6 +29,10 @@
       <artifactId>converter-gson</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
index eba5385fa..ca6d972cc 100644
--- a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -36,8 +36,8 @@
  */
 public final class CustomCallAdapter {
   public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
-    @Override
-    public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations) {
+    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit) {
       TypeToken<?> token = TypeToken.of(returnType);
       if (token.getRawType() != ListenableFuture.class) {
         return null;
@@ -73,7 +73,7 @@ private CallFuture(Call<T> call) {
         call.cancel();
       }
 
-      @Override public void onResponse(Response<T> response) {
+      @Override public void onResponse(Response<T> response, Retrofit retrofit) {
         if (response.isSuccess()) {
           set(response.body());
         } else {
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
new file mode 100644
index 000000000..21765b13f
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import retrofit.Call;
+import retrofit.Converter;
+import retrofit.GsonConverterFactory;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+public final class DeserializeErrorBody {
+  interface Service {
+    @GET("/user") Call<User> getUser();
+  }
+
+  static class User {
+    // normal fields...
+  }
+
+  static class Error {
+    String message;
+  }
+
+  public static void main(String... args) throws IOException {
+    // Create a local web server which response with a 404 and JSON body.
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse()
+        .setResponseCode(404)
+        .setBody("{\"message\":\"Unable to locate resource\"}"));
+
+    // Create our Service instance with a Retrofit pointing at the local web server and Gson.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GsonConverterFactory.create())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Response<User> response = service.getUser().execute();
+
+    // Normally you would check response.isSuccess() here before doing the following, but we know
+    // this call will always fail. You could also use response.code() to determine whether to
+    // convert the error body and/or which type to use for conversion.
+
+    // Look up a converter for the Error type on the Retrofit instance.
+    Converter<ResponseBody, Error> errorConverter =
+        retrofit.responseConverter(Error.class, new Annotation[0]);
+    // Convert the error body into our Error type.
+    Error error = errorConverter.convert(response.errorBody());
+    System.out.println("ERROR: " + error.message);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index a591e2be7..2e2a47f3b 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -26,10 +26,12 @@
 public final class SimpleMockService {
   /** A mock implementation of the {@link GitHub} API interface. */
   static final class MockGitHub implements GitHub {
+    private final Retrofit retrofit;
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
-    public MockGitHub() {
-      ownerRepoContributors = new LinkedHashMap<>();
+    public MockGitHub(Retrofit retrofit) {
+      this.retrofit = retrofit;
+      this.ownerRepoContributors = new LinkedHashMap<>();
 
       // Seed some mock data.
       addContributor("square", "retrofit", "John Doe", 12);
@@ -48,7 +50,7 @@ public MockGitHub() {
           response = contributors;
         }
       }
-      return Calls.response(response);
+      return Calls.response(response, retrofit);
     }
 
     public void addContributor(String owner, String repo, String name, int contributions) {
@@ -81,7 +83,7 @@ public static void main(String... args) throws IOException {
 
     // Create the mock implementation and use MockRetrofit to apply the behavior to it.
     MockRetrofit mockRetrofit = new MockRetrofit(behavior, new CallBehaviorAdapter(retrofit, bg));
-    MockGitHub mockGitHub = new MockGitHub();
+    MockGitHub mockGitHub = new MockGitHub(retrofit);
     GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
diff --git a/website/index.html b/website/index.html
index ac8dc39db..9dc7e6e3a 100644
--- a/website/index.html
+++ b/website/index.html
@@ -27,6 +27,7 @@ <h1>Retrofit</h1>
               </ul>
             </menu>
           </div>
+        </div>
       </div>
     </header>
     <section id="subtitle">
@@ -42,134 +43,146 @@ <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsun
       <div class="container">
         <div class="row">
           <div class="span9">
-            <h3 id="introduction">Introduction</h3>
-            <p>Retrofit turns your HTTP API into a Java interface.</p>
-            <pre class="prettyprint">public interface GitHubService {
+            <section id="introduction">
+              <h3>Introduction</h3>
+              <p>Retrofit turns your HTTP API into a Java interface.</p>
+              <pre class="prettyprint">public interface GitHubService {
   @GET("/users/{user}/repos")
   Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
-            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+              <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+              <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.github.com")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-            <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
-            <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
-            <p>Use annotations to describe the HTTP request:</p>
-            <ul>
-              <li>URL parameter replacement and query parameter support</li>
-              <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
-              <li>Multipart request body and file upload</li>
-            </ul>
-            <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
-
-            <h3 id="api-declaration">API Declaration</h3>
-            <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
-
-            <h4>Request Method</h4>
-            <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-            <pre class="prettyprint">@GET("/users/list")</pre>
-            <p>You can also specify query parameters in the URL.</p>
-            <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
-
-            <h4>URL Manipulation</h4>
-            <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
+              <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
+              <p>Use annotations to describe the HTTP request:</p>
+              <ul>
+                <li>URL parameter replacement and query parameter support</li>
+                <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
+                <li>Multipart request body and file upload</li>
+              </ul>
+              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
+            </section>
+
+            <section id="api-declaration">
+              <h3>API Declaration</h3>
+              <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
+
+              <h4>Request Method</h4>
+              <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
+              <pre class="prettyprint">@GET("/users/list")</pre>
+              <p>You can also specify query parameters in the URL.</p>
+              <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
+
+              <h4>URL Manipulation</h4>
+              <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId);</pre>
-            <p>Query parameters can also be added.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>Query parameters can also be added.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
-            <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
-            <h4>Request Body</h4>
-            <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
-            <pre class="prettyprint">@POST("/users/new")
+              <h4>Request Body</h4>
+              <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
+              <pre class="prettyprint">@POST("/users/new")
 Call&lt;User> createUser(@Body User user);</pre>
-            <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
+              <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
-            <h4>Form Encoded and Multipart</h4>
-            <p>Methods can also be declared to send form-encoded and multipart data.</p>
-            <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
-            <pre class="prettyprint">@FormUrlEncoded
+              <h4>Form Encoded and Multipart</h4>
+              <p>Methods can also be declared to send form-encoded and multipart data.</p>
+              <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
+              <pre class="prettyprint">@FormUrlEncoded
 @POST("/user/edit")
 Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
-            <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
-            <pre class="prettyprint">@Multipart
+              <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
+              <pre class="prettyprint">@Multipart
 @PUT("/user/photo")
 Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
-            <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
+              <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
 
-            <h4>Header Manipulation</h4>
-            <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
-            <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
+              <h4>Header Manipulation</h4>
+              <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
+              <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
 @GET("/widget/list")
 Call&lt;List&lt;Widget>> widgetList();</pre>
-            <pre class="prettyprint">@Headers({
+              <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
 @GET("/users/{username}")
 Call&lt;User> getUser(@Path("username") String username);</pre>
-            <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
-            <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
-            <pre class="prettyprint">@GET("/user")
+              <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
+              <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
+              <pre class="prettyprint">@GET("/user")
 Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
-            <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
-
-            <h4>Synchronous vs. Asynchronous</h4>
-            <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
-            <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
-
-            <h3 id="restadapter-configuration">Retrofit Configuration</h3>
-            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
-
-            <h4>Converters</h4>
-            <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
-            <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
-            <ul>
-              <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
-              <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
-              <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
-              <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
-              <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
-              <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
-            </ul>
-            <h4>Custom Converters</h4>
-            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> interface</a> and pass in an instance when building your adapter.</p>
-
-            <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
+              <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
+
+              <h4>Synchronous vs. Asynchronous</h4>
+              <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
+              <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
+            </section>
+
+            <section id="restadapter-configuration">
+              <h3>Retrofit Configuration</h3>
+              <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+
+              <h4>Converters</h4>
+              <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
+              <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
+              <ul>
+                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
+                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
+                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
+                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
+                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
+                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
+              </ul>
+              <h4>Custom Converters</h4>
+              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
+            </section>
+
+            <section id="download">
+              <h3>Download</h3>
+              <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+              <h4>Maven</h4>
+              <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit&lt;/groupId>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
-            <h4>Gradle</h4>
-            <pre class="prettyprint">
+              <h4>Gradle</h4>
+              <pre class="prettyprint">
 compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-            <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
+              <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-            <h4>ProGuard</h4>
-            <p>If you are using Proguard in your project add the following lines to your configuration:</p>
-            <pre class="prettyprint">
+              <h4>ProGuard</h4>
+              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+              <pre class="prettyprint">
 -dontwarn retrofit.**
 -keep class retrofit.** { *; }
 -keepattributes Signature
 -keepattributes Exceptions
 </pre>
-            <h3 id="contributing">Contributing</h3>
-            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            </section>
+
+            <section id="contributing">
+              <h3>Contributing</h3>
+              <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
+              <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            </section>
 
-            <h3 id="license">License</h3>
-            <pre>Copyright 2013 Square, Inc.
+            <section id="license">
+              <h3>License</h3>
+              <pre>Copyright 2013 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -182,6 +195,7 @@ <h3 id="license">License</h3>
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</pre>
+            </section>
           </div>
           <div class="span3">
             <div class="content-nav" data-spy="affix" data-offset-top="80">
@@ -194,7 +208,7 @@ <h3 id="license">License</h3>
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="javadoc/index.html">Javadoc</a></li>
+                <li><a href="2.x/retrofit/">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
               </ul>
             </div>
