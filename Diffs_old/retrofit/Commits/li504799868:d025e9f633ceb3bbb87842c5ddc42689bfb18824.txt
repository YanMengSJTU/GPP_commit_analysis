diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..de8bb5e43 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -23,9 +23,13 @@
  * callbacks. For synchronous calls this is the application thread making the request; for
  * asynchronous calls this is a thread provided by OkHttp's dispatcher.
  */
+/**
+ * 默认的CallAdapterFactory
+ * */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
   static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
+  // 返回对应CallAdapter
   @Override
   public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index f819c7863..59f310cbd 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -23,6 +23,9 @@
 
 import static retrofit2.Utils.checkNotNull;
 
+/**
+ * 如果指定了线程池，会被封装成ExecutorCallAdapterFactory
+ * */
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
@@ -30,6 +33,7 @@
     this.callbackExecutor = callbackExecutor;
   }
 
+  // 找到对应的CallAdapter
   @Override
   public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
@@ -56,11 +60,15 @@
       this.delegate = delegate;
     }
 
+    /**
+     * 执行网络请求
+     * */
     @Override public void enqueue(final Callback<T> callback) {
       checkNotNull(callback, "callback == null");
 
       delegate.enqueue(new Callback<T>() {
         @Override public void onResponse(Call<T> call, final Response<T> response) {
+          // 返回成功或失败
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               if (delegate.isCanceled()) {
@@ -74,6 +82,7 @@
         }
 
         @Override public void onFailure(Call<T> call, final Throwable t) {
+          // 返回失败
           callbackExecutor.execute(new Runnable() {
             @Override public void run() {
               callback.onFailure(ExecutorCallbackCall.this, t);
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 45a77afe7..5442b77d9 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -29,17 +29,33 @@
 import static retrofit2.Utils.checkNotNull;
 import static retrofit2.Utils.throwIfFatal;
 
+/**
+ * 封装的Call信息
+ * */
 final class OkHttpCall<T> implements Call<T> {
+  /**
+   * 生成的ServiceMethod
+   * */
   private final ServiceMethod<T, ?> serviceMethod;
+
+  /**
+   * 参数集合
+   * */
   private final @Nullable Object[] args;
 
   private volatile boolean canceled;
 
   @GuardedBy("this")
+  /**
+   * okhttp的Call对象
+   * */
   private @Nullable okhttp3.Call rawCall;
   @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
   private @Nullable Throwable creationFailure;
   @GuardedBy("this")
+  /**
+   * 是否正在执行
+   * */
   private boolean executed;
 
   OkHttpCall(ServiceMethod<T, ?> serviceMethod, @Nullable Object[] args) {
@@ -53,10 +69,12 @@
   }
 
   @Override public synchronized Request request() {
+    // 如果已经有okhttp的call请求，返回call的request
     okhttp3.Call call = rawCall;
     if (call != null) {
       return call.request();
     }
+    // 判断是否创建请求失败过
     if (creationFailure != null) {
       if (creationFailure instanceof IOException) {
         throw new RuntimeException("Unable to create request.", creationFailure);
@@ -67,6 +85,7 @@
       }
     }
     try {
+      // 创建okhttp请求
       return (rawCall = createRawCall()).request();
     } catch (RuntimeException | Error e) {
       throwIfFatal(e); // Do not assign a fatal error to creationFailure.
@@ -78,6 +97,9 @@
     }
   }
 
+  /**
+   * 执行网络请求
+   * */
   @Override public void enqueue(final Callback<T> callback) {
     checkNotNull(callback, "callback == null");
 
@@ -181,6 +203,9 @@ private void callFailure(Throwable e) {
     return parseResponse(call.execute());
   }
 
+  /**
+   * 根据解析的信息，创建okhttp请求
+   * */
   private okhttp3.Call createRawCall() throws IOException {
     okhttp3.Call call = serviceMethod.toCall(args);
     if (call == null) {
@@ -189,10 +214,15 @@ private void callFailure(Throwable e) {
     return call;
   }
 
+  /**
+   * 解析网络请求的返回结果
+   * */
   Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+    // okhttp的请求结果
     ResponseBody rawBody = rawResponse.body();
 
     // Remove the body's source (the only stateful object) so we can pass the response along.
+    // 创建新的Response
     rawResponse = rawResponse.newBuilder()
         .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
         .build();
@@ -201,7 +231,9 @@ private void callFailure(Throwable e) {
     if (code < 200 || code >= 300) {
       try {
         // Buffer the entire body to avoid future I/O.
+        // body读取出来
         ResponseBody bufferedBody = Utils.buffer(rawBody);
+        // 返回Response
         return Response.error(bufferedBody, rawResponse);
       } finally {
         rawBody.close();
@@ -213,8 +245,10 @@ private void callFailure(Throwable e) {
       return Response.success(null, rawResponse);
     }
 
+    // 对rawBody封装一层代理
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
+      // 对返回的结果进行转换
       T body = serviceMethod.toResponse(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 3c3307b70..209b2913a 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -25,7 +25,13 @@
 import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+/**
+ * 平台封装类
+ * */
 class Platform {
+  /**
+   * 找到使用的平台
+   * */
   private static final Platform PLATFORM = findPlatform();
 
   static Platform get() {
@@ -33,6 +39,7 @@ static Platform get() {
   }
 
   private static Platform findPlatform() {
+    // 安卓
     try {
       Class.forName("android.os.Build");
       if (Build.VERSION.SDK_INT != 0) {
@@ -40,11 +47,13 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
+    // java
     try {
       Class.forName("java.util.Optional");
       return new Java8();
     } catch (ClassNotFoundException ignored) {
     }
+    // 默认
     return new Platform();
   }
 
@@ -87,6 +96,9 @@ boolean isDefaultMethod(Method method) {
     }
   }
 
+  /**
+   * 安卓平台
+   * */
   static class Android extends Platform {
     @Override public Executor defaultCallbackExecutor() {
       return new MainThreadExecutor();
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index f27db26ee..956818222 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -27,6 +27,9 @@
 import okio.Buffer;
 import okio.BufferedSink;
 
+/**
+ * 封装了所有的请求信息
+ * */
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 2f1ee2524..7c35dad7b 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -61,9 +61,12 @@
   private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   final okhttp3.Call.Factory callFactory;
+  // 网络请求的前缀域名
   final HttpUrl baseUrl;
+  // 转换工厂，可以对请求的数据和返回的数据进行加工
   final List<Converter.Factory> converterFactories;
   final List<CallAdapter.Factory> callAdapterFactories;
+  // 线程池
   final @Nullable Executor callbackExecutor;
   final boolean validateEagerly;
 
@@ -126,10 +129,12 @@
    */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
+    // 检查创建的网络请求的服务接口是否可用
     Utils.validateServiceInterface(service);
     if (validateEagerly) {
       eagerlyValidateMethods(service);
     }
+    // 当调用定义的接口方法的时候，通过动态代理调用自己的逻辑，发起网络请求
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
@@ -137,36 +142,51 @@
           @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
+            // 如果参数的类型是Object，直接反射调用
             if (method.getDeclaringClass() == Object.class) {
               return method.invoke(this, args);
             }
+            // 如果是default方法，根据平台类型直接调用
+            // android平台固定返回false
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
+            // 通过Method，封装成okhttp请求
             ServiceMethod<Object, Object> serviceMethod =
                 (ServiceMethod<Object, Object>) loadServiceMethod(method);
             OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            // 发起网络请求
             return serviceMethod.adapt(okHttpCall);
           }
         });
   }
 
+  /**
+   * 通过反射加载所有定义的方法
+   * */
   private void eagerlyValidateMethods(Class<?> service) {
+    // 得到当前的平台，android或者Java
     Platform platform = Platform.get();
+    // 遍历接口类中声明的方法
     for (Method method : service.getDeclaredMethods()) {
+      // 一个default方法的特征：public，非抽象方法的实例中的方法，非static，在接口中声明
+      // android平台默认返回的全是false，所以都需要添加
       if (!platform.isDefaultMethod(method)) {
+        // 加载方法
         loadServiceMethod(method);
       }
     }
   }
 
   ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    // 如果缓存中已经有了这个方法，直接返回
     ServiceMethod<?, ?> result = serviceMethodCache.get(method);
     if (result != null) return result;
-
+    // 同步锁
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
+        // 把这个方法封装成ServiceMethod对象，保存起来
         result = new ServiceMethod.Builder<>(this, method).build();
         serviceMethodCache.put(method, result);
       }
@@ -587,6 +607,7 @@ public Retrofit build() {
 
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
+      // 默认添加了平台的callAdapter
       callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
 
       // Make a defensive copy of the converters.
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 9e718b604..8e71f9e68 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -57,6 +57,9 @@
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
+/**
+ * 封装了接口类方法的信息，用于和okhttpCall进行转换
+ * */
 final class ServiceMethod<R, T> {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
@@ -64,11 +67,16 @@
   static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
 
   private final okhttp3.Call.Factory callFactory;
+  /**
+   * 负责运行okhttp请求
+   * */
   private final CallAdapter<R, T> callAdapter;
 
+  // Retrofit中设置的URL前缀
   private final HttpUrl baseUrl;
   private final Converter<ResponseBody, R> responseConverter;
   private final String httpMethod;
+  // 请求的相对地址，会拼接baseUrl
   private final String relativeUrl;
   private final Headers headers;
   private final MediaType contentType;
@@ -94,22 +102,25 @@
 
   /** Builds an HTTP request from method arguments. */
   okhttp3.Call toCall(@Nullable Object... args) throws IOException {
+    // 封装网络请求的信息
     RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
         contentType, hasBody, isFormEncoded, isMultipart);
 
+    //
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
+    // 判断参数的数量是否和方法的数量相等
     int argumentCount = args != null ? args.length : 0;
     if (argumentCount != handlers.length) {
       throw new IllegalArgumentException("Argument count (" + argumentCount
           + ") doesn't match expected count (" + handlers.length + ")");
     }
 
+    // 把参数添加到requestBuilder中
     for (int p = 0; p < argumentCount; p++) {
       handlers[p].apply(requestBuilder, args[p]);
     }
-
+    // 调用okhttpClient创建Call对象
     return callFactory.newCall(requestBuilder.build());
   }
 
@@ -118,6 +129,9 @@ T adapt(Call<R> call) {
   }
 
   /** Builds a method return value from an HTTP response body. */
+  /**
+   * 对得到的网络请求结果进行转换
+   * */
   R toResponse(ResponseBody body) throws IOException {
     return responseConverter.convert(body);
   }
@@ -158,27 +172,33 @@ R toResponse(ResponseBody body) throws IOException {
       this.method = method;
       this.methodAnnotations = method.getAnnotations();
       this.parameterTypes = method.getGenericParameterTypes();
+      // 参数的注解
       this.parameterAnnotationsArray = method.getParameterAnnotations();
     }
 
     public ServiceMethod build() {
+      // 创建callAdapter
       callAdapter = createCallAdapter();
+      // 得到返回值的类型
       responseType = callAdapter.responseType();
       if (responseType == Response.class || responseType == okhttp3.Response.class) {
         throw methodError("'"
             + Utils.getRawType(responseType).getName()
             + "' is not a valid response body type. Did you mean ResponseBody?");
       }
+      // 创建responseConverter
       responseConverter = createResponseConverter();
 
+      // 解析注解
       for (Annotation annotation : methodAnnotations) {
         parseMethodAnnotation(annotation);
       }
-
+      // 检查是否设置了请求方式
       if (httpMethod == null) {
         throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
       }
 
+      // 如果没有添加body，要检查请求的方式是否支持无body请求
       if (!hasBody) {
         if (isMultipart) {
           throw methodError(
@@ -190,20 +210,23 @@ public ServiceMethod build() {
         }
       }
 
+      // 遍历参数的注解
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
         Type parameterType = parameterTypes[p];
+        // 对注解的参数类型进行检查
         if (Utils.hasUnresolvableType(parameterType)) {
           throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
               parameterType);
         }
 
+        // 每一个参数都要有注解
         Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
         if (parameterAnnotations == null) {
           throw parameterError(p, "No Retrofit annotation found.");
         }
-
+        // 解析参数的注解
         parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
       }
 
@@ -223,24 +246,35 @@ public ServiceMethod build() {
       return new ServiceMethod<>(this);
     }
 
+    /**
+     * 创建CallAdapter
+     * */
     private CallAdapter<T, R> createCallAdapter() {
+      // 得到方法的返回值类型
       Type returnType = method.getGenericReturnType();
+      // 判断是否支持返回值的类型，只支持Class
       if (Utils.hasUnresolvableType(returnType)) {
         throw methodError(
             "Method return type must not include a type variable or wildcard: %s", returnType);
       }
+      // 返回值不能是空
       if (returnType == void.class) {
         throw methodError("Service methods cannot return void.");
       }
+      // 得到方法的注解
       Annotation[] annotations = method.getAnnotations();
       try {
         //noinspection unchecked
+        // 得到符合返回值类型和注解集合匹配的CallAdapter
         return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
       } catch (RuntimeException e) { // Wide exception range because factories are user code.
         throw methodError(e, "Unable to create call adapter for %s", returnType);
       }
     }
 
+    /**
+     * 解析方法的注解
+     * */
     private void parseMethodAnnotation(Annotation annotation) {
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
@@ -281,6 +315,9 @@ private void parseMethodAnnotation(Annotation annotation) {
       }
     }
 
+    /**
+     * 解析方法中注解，保存对应的value
+     * */
     private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
       if (this.httpMethod != null) {
         throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
@@ -294,6 +331,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       }
 
       // Get the relative URL path and existing query string, if present.
+      // 判断url链接之后的参数是否合法
       int question = value.indexOf('?');
       if (question != -1 && question < value.length() - 1) {
         // Ensure the query string does not have any named parameters.
@@ -305,7 +343,9 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
         }
       }
 
+      // 保存相对地址
       this.relativeUrl = value;
+      // 从地址中分离出设置的参数
       this.relativeUrlParamNames = parsePathParameters(value);
     }
 
@@ -332,6 +372,9 @@ private Headers parseHeaders(String[] headers) {
       return builder.build();
     }
 
+    /**
+     * 解析参数的注解
+     * */
     private ParameterHandler<?> parseParameter(
         int p, Type parameterType, Annotation[] annotations) {
       ParameterHandler<?> result = null;
@@ -357,24 +400,31 @@ private Headers parseHeaders(String[] headers) {
       return result;
     }
 
+    /**
+     * 解析某一个参数的注解
+     * */
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        // 如果已经有url注解
         if (gotUrl) {
           throw parameterError(p, "Multiple @Url method annotations found.");
         }
+        // @Path注解不能和@Url一起用
         if (gotPath) {
           throw parameterError(p, "@Path parameters may not be used with @Url.");
         }
+        // @Url必须在@Query前面
         if (gotQuery) {
           throw parameterError(p, "A @Url parameter must not come after a @Query");
         }
+        // 相对地址，不能和@Url一起使用
         if (relativeUrl != null) {
           throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
         }
 
         gotUrl = true;
-
+        // 返回地址参数
         if (type == HttpUrl.class
             || type == String.class
             || type == URI.class
@@ -402,6 +452,7 @@ private Headers parseHeaders(String[] headers) {
         validatePathName(p, name);
 
         Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+        // 返回路径参数
         return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
@@ -422,6 +473,7 @@ private Headers parseHeaders(String[] headers) {
           Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
           Converter<?, String> converter =
               retrofit.stringConverter(iterableType, annotations);
+          // 返回query信息
           return new ParameterHandler.Query<>(name, converter, encoded).iterable();
         } else if (rawParameterType.isArray()) {
           Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 12544e357..a3c338679 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -299,24 +299,31 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
+  /**
+   * 判断定义网络请求的接口类，是否符合要求
+   * */
   static <T> void validateServiceInterface(Class<T> service) {
+    // 必须是接口
     if (!service.isInterface()) {
       throw new IllegalArgumentException("API declarations must be interfaces.");
     }
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
     // the recommended pattern.
+    // 不能实现接口，也就是说一个纯接口类
     if (service.getInterfaces().length > 0) {
       throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
     }
   }
 
   static Type getParameterUpperBound(int index, ParameterizedType type) {
+    // 是否有泛型集合
     Type[] types = type.getActualTypeArguments();
     if (index < 0 || index >= types.length) {
       throw new IllegalArgumentException(
           "Index " + index + " not in range [0," + types.length + ") for " + type);
     }
+    // 得到返回值的类型
     Type paramType = types[index];
     if (paramType instanceof WildcardType) {
       return ((WildcardType) paramType).getUpperBounds()[0];
@@ -324,10 +331,15 @@ static Type getParameterUpperBound(int index, ParameterizedType type) {
     return paramType;
   }
 
+  /**
+   *
+   * */
   static boolean hasUnresolvableType(@Nullable Type type) {
+    // 如果返回值是Class类，返回false
     if (type instanceof Class<?>) {
       return false;
     }
+    // 得到type的泛型集合，递归判断泛型的类型
     if (type instanceof ParameterizedType) {
       ParameterizedType parameterizedType = (ParameterizedType) type;
       for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
@@ -337,12 +349,14 @@ static boolean hasUnresolvableType(@Nullable Type type) {
       }
       return false;
     }
+    // 是否是一个数组类型，判断数组中的元素的类型
     if (type instanceof GenericArrayType) {
       return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
     }
     if (type instanceof TypeVariable) {
       return true;
     }
+    // 参数是否有继承关系
     if (type instanceof WildcardType) {
       return true;
     }
@@ -351,6 +365,9 @@ static boolean hasUnresolvableType(@Nullable Type type) {
         + "GenericArrayType, but <" + type + "> is of type " + className);
   }
 
+  /**
+   *
+   * */
   static Type getCallResponseType(Type returnType) {
     if (!(returnType instanceof ParameterizedType)) {
       throw new IllegalArgumentException(
