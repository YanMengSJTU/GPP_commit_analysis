diff --git a/.travis.yml b/.travis.yml
index e6a844e22..79fe36a95 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,6 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
 after_success:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 80c420272..e2eb7feba 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,57 @@
 Change Log
 ==========
 
+Version 2.0.0-beta2 *(2015-09-28)*
+----------------------------------
+
+ * New: Using a response type of `Void` (e.g., `Call<Void>`) will ignore and discard the response body. This
+   can be used when there will be no response body (such as in a 201 response) or whenever the body is not
+   needed. `@Head` requests are now forced to use this as their response type.
+ * New: `validateEagerly()` method on `Retrofit.Builder` will verify the correctness of all service methods
+   on calls to `create()` instead of lazily validating on first use.
+ * New: `Converter` is now parameterized over both 'from' and 'to' types with a single `convert` method.
+   `Converter.Factory` is now an abstract class and has factory methods for both request body and response
+   body.
+ * New: `Converter.Factory` and `CallAdapter.Factory` now receive the method annotations when being created
+   for a return/response type and the parameter annotations when being created for a parameter type.
+ * New: `callAdapter()` method on `Retrofit` allows querying a `CallAdapter` for a given type. The
+   `nextCallAdapter()` method allows delegating to another `CallAdapter` from within a `CallAdapter.Factory`.
+   This is useful for composing call adapters to incrementally build up behavior.
+ * New: `requestConverter()` and `responseConverter()` methods on `Retrofit` allow querying a `Converter` for
+   a given type.
+ * New: `onResponse` method in `Callback` now receives the `Retrofit` instance. Combined with the
+   `responseConverter()` method on `Retrofit`, this provides a way of deserializing an error body on `Response`.
+   See the `DeserializeErrorBody` sample for an example.
+ * New: The `MoshiConverterFactory` has been updated for its v1.0.0.
+ * Fix: Using `ResponseBody` for the response type or `RequestBody` for a parameter type is now correctly
+   identified. Previously these types would erroneously be passed to the supplied converter.
+ * Fix: The encoding of `@Path` values has been corrected to conform to OkHttp's `HttpUrl`.
+ * Fix: Use form-data content disposition subtype for `@Multipart`.
+ * Fix: `Observable` and `Single`-based execution of requests now behave synchronously (and thus requires
+   `subscribeOn()` for running in the background).
+ * Fix: Correct `GsonConverterFactory` to honor the configuration of the `Gson` instances (such as not
+   serializing null values, the default).
+
+
+Version 2.0.0-beta1 *(2015-08-27)*
+----------------------------------
+
+ * New: `Call` encapsulates a single request/response HTTP call. A call can by run synchronously
+   via `execute()` or asynchronously via `enqueue()` and can be canceled with `cancel()`.
+ * New: `Response` is now parameterized and includes the deserialized body object.
+ * New: `@Url` parameter annotation allows passing a complete URL for an endpoint.
+ * New: OkHttp is now required as a dependency. Types like `TypedInput` and `TypedOutput` (and its
+   implementations), `Request`, and `Header` have been replaced with OkHttp types like `RequestBody`,
+   `ResponseBody`, and `Headers`.
+ * New: `CallAdapter` (and `Factory`) provides extension point for supporting multiple execution
+   mechanisms. An RxJava implementation is provided by a sibling module.
+ * New: `Converter` (and `Factory`) provides extension point for supporting multiple serialization
+   mechanisms. Gson, Jackson, Moshi, Protobuf, Wire, and SimpleXml implementations are provided by sibling
+   modules.
+ * Fix: A lot of things.
+ * Hello Droidcon NYC 2015!
+
+
 Version 1.9.0 *(2015-01-07)*
 ----------------------------
 
diff --git a/README.md b/README.md
index c101a0078..5bbcdc582 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 Retrofit
 ========
 
-Type-safe REST client for Android and Java by Square, Inc.
+Type-safe HTTP client for Android and Java by Square, Inc.
 
 For more information please see [the website][1].
 
@@ -14,17 +14,17 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>retrofit</artifactId>
-  <version>1.9.0</version>
+  <version>2.0.0-beta2</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:1.9.0'
+compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
-Retrofit requires at minimum Java 6 or Android 2.3.
+Retrofit requires at minimum Java 7 or Android 2.3.
 
 
 
diff --git a/pom.xml b/pom.xml
index f9adffe1d..5638a73c2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -29,14 +29,14 @@
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
-  <description>Type-safe REST client for Android and Java by Square, Inc.</description>
+  <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
   <url>http://github.com/square/retrofit/</url>
 
   <modules>
     <module>retrofit</module>
     <module>retrofit-adapters</module>
     <module>retrofit-converters</module>
-    <!--<module>retrofit-mock</module>-->
+    <module>retrofit-mock</module>
     <module>samples</module>
   </modules>
 
@@ -50,10 +50,11 @@
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <okhttp.version>2.4.0</okhttp.version>
+    <okhttp.version>2.5.0</okhttp.version>
+    <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.10</rxjava.version>
+    <rxjava.version>1.0.14</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.3.1</gson.version>
@@ -61,7 +62,7 @@
     <jackson.version>2.4.3</jackson.version>
     <wire.version>1.7.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>0.9.0</moshi.version>
+    <moshi.version>1.0.0</moshi.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -101,6 +102,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-annotations</artifactId>
+        <version>${animal.sniffer.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.squareup.okhttp</groupId>
         <artifactId>okhttp</artifactId>
@@ -214,6 +220,27 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <executions>
+          <execution>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
+          </signature>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 2b0b0e146..b1a7320f8 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -16,5 +16,6 @@
 
   <modules>
     <module>rxjava</module>
+    <module>rxjava-mock</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava-mock/pom.xml b/retrofit-adapters/rxjava-mock/pom.xml
new file mode 100644
index 000000000..d69458e9a
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava-mock</artifactId>
+  <name>Adapter: RxJava Mock</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit-mock</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
new file mode 100644
index 000000000..054c5556a
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class RxJavaBehaviorAdapter implements NetworkBehavior.Adapter<Object> {
+  public static RxJavaBehaviorAdapter create() {
+    return new RxJavaBehaviorAdapter();
+  }
+
+  private RxJavaBehaviorAdapter() {
+  }
+
+  @Override public Object applyBehavior(NetworkBehavior behavior, Object value) {
+    if (value instanceof Observable) {
+      return applyObservableBehavior(behavior, (Observable<?>) value);
+    }
+    String name = value.getClass().getCanonicalName();
+    if ("rx.Single".equals(name)) {
+      // Apply behavior to the Single from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.applySingleBehavior(behavior, value);
+    }
+    throw new IllegalStateException("Unsupported type " + name);
+  }
+
+  public Observable<?> applyObservableBehavior(final NetworkBehavior behavior,
+      final Observable<?> value) {
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return value;
+          }
+        });
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
new file mode 100644
index 000000000..d1c54214f
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.Single;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+final class SingleHelper {
+  @SuppressWarnings("unchecked") // Caller must instanceof / getClass() verify 'value' is Single.
+  public static Object applySingleBehavior(final NetworkBehavior behavior, Object value) {
+    final Single<Object> single = (Single<Object>) value;
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return single.toObservable();
+          }
+        })
+        .toSingle();
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
new file mode 100644
index 000000000..d256b84f0
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import rx.Observable;
+import rx.Single;
+import rx.Subscriber;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+
+public final class RxJavaBehaviorAdapterTest {
+  interface DoWorkService {
+    Observable<String> observableResponse();
+    Single<String> singleResponse();
+  }
+
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+  private DoWorkService service;
+
+  @Before public void setUp() {
+    DoWorkService mockService = new DoWorkService() {
+      @Override public Observable<String> observableResponse() {
+        return Observable.just("Hi!");
+      }
+
+      @Override public Single<String> singleResponse() {
+        return Single.just("Hi!");
+      }
+    };
+
+    NetworkBehavior.Adapter<?> adapter = RxJavaBehaviorAdapter.create();
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
+    service = mockRetrofit.create(DoWorkService.class, mockService);
+  }
+
+  @Test public void observableFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void observableSuccessAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void singleFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Single<String> observable = service.singleResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void singleSuccessAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Single<String> observable = service.singleResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java
new file mode 100644
index 000000000..77076a642
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java
@@ -0,0 +1,32 @@
+package retrofit;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
index 1302136ce..d6b1a9ede 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
@@ -21,11 +21,11 @@
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
-  static <T> Result<T> fromError(Throwable error) {
+  public static <T> Result<T> error(Throwable error) {
     return new Result<>(null, checkNotNull(error, "error == null"));
   }
 
-  static <T> Result<T> fromResponse(Response<T> response) {
+  public static <T> Result<T> response(Response<T> response) {
     return new Result<>(checkNotNull(response, "response == null"), null);
   }
 
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
similarity index 58%
rename from retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
index b40be0e69..a1aa64881 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
@@ -15,11 +15,12 @@
  */
 package retrofit;
 
-import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import rx.Observable;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.subscriptions.Subscriptions;
@@ -27,40 +28,49 @@
 /**
  * TODO docs
  */
-public final class ObservableCallAdapterFactory implements CallAdapter.Factory {
+public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
   /**
    * TODO
    */
-  public static ObservableCallAdapterFactory create() {
-    return new ObservableCallAdapterFactory();
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory();
   }
 
-  private ObservableCallAdapterFactory() {
+  private RxJavaCallAdapterFactory() {
   }
 
-  @Override public String toString() {
-    return getClass().getSimpleName();
-  }
-
-  @Override public CallAdapter<?> get(Type returnType) {
-    if (Utils.getRawType(returnType) != Observable.class) {
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = Utils.getRawType(returnType);
+    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
+    if (rawType != Observable.class && !isSingle) {
       return null;
     }
     if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Observable return type must be parameterized"
-          + " as Observable<Foo> or Observable<? extends Foo>");
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
 
+    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType);
+    if (isSingle) {
+      // Add Single-converter wrapper from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.makeSingle(callAdapter);
+    }
+    return callAdapter;
+  }
+
+  private CallAdapter<Observable<?>> getCallAdapter(Type returnType) {
     Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
     Class<?> rawObservableType = Utils.getRawType(observableType);
-
     if (rawObservableType == Response.class) {
       if (!(observableType instanceof ParameterizedType)) {
         throw new IllegalStateException("Response must be parameterized"
             + " as Response<Foo> or Response<? extends Foo>");
       }
       Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
-      return new ResponseCallAdapter<>(responseType);
+      return new ResponseCallAdapter(responseType);
     }
 
     if (rawObservableType == Result.class) {
@@ -69,7 +79,7 @@ private ObservableCallAdapterFactory() {
             + " as Result<Foo> or Result<? extends Foo>");
       }
       Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
-      return new ResultCallAdapter<>(responseType);
+      return new ResultCallAdapter(responseType);
     }
 
     return new SimpleCallAdapter(observableType);
@@ -93,31 +103,26 @@ private CallOnSubscribe(Call<T> originalCall) {
         }
       }));
 
-      call.enqueue(new Callback<T>() {
-        @Override public void success(Response<T> response) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
-          try {
-            subscriber.onNext(response);
-          } catch (Throwable t) {
-            subscriber.onError(t);
-            return;
-          }
-          subscriber.onCompleted();
+      try {
+        Response<T> response = call.execute();
+        if (!subscriber.isUnsubscribed()) {
+          subscriber.onNext(response);
         }
-
-        @Override public void failure(Throwable t) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        if (!subscriber.isUnsubscribed()) {
           subscriber.onError(t);
         }
-      });
+        return;
+      }
+
+      if (!subscriber.isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
     }
   }
 
-  static final class ResponseCallAdapter<T> implements CallAdapter<T> {
+  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
 
     ResponseCallAdapter(Type responseType) {
@@ -128,12 +133,12 @@ private CallOnSubscribe(Call<T> originalCall) {
       return responseType;
     }
 
-    @Override public Observable<Response<T>> adapt(Call<T> call) {
+    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
       return Observable.create(new CallOnSubscribe<>(call));
     }
   }
 
-  static final class SimpleCallAdapter<T> implements CallAdapter<T> {
+  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
 
     SimpleCallAdapter(Type responseType) {
@@ -144,20 +149,20 @@ private CallOnSubscribe(Call<T> originalCall) {
       return responseType;
     }
 
-    @Override public Observable<T> adapt(Call<T> call) {
+    @Override public <R> Observable<R> adapt(Call<R> call) {
       return Observable.create(new CallOnSubscribe<>(call)) //
-          .flatMap(new Func1<Response<T>, Observable<T>>() {
-            @Override public Observable<T> call(Response<T> response) {
+          .flatMap(new Func1<Response<R>, Observable<R>>() {
+            @Override public Observable<R> call(Response<R> response) {
               if (response.isSuccess()) {
                 return Observable.just(response.body());
               }
-              return Observable.error(new IOException()); // TODO non-suck message.
+              return Observable.error(new HttpException(response));
             }
           });
     }
   }
 
-  static final class ResultCallAdapter<T> implements CallAdapter<T> {
+  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
 
     ResultCallAdapter(Type responseType) {
@@ -168,16 +173,16 @@ private CallOnSubscribe(Call<T> originalCall) {
       return responseType;
     }
 
-    @Override public Observable<Result<T>> adapt(Call<T> call) {
+    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
       return Observable.create(new CallOnSubscribe<>(call)) //
-          .map(new Func1<Response<T>, Result<T>>() {
-            @Override public Result<T> call(Response<T> response) {
-              return Result.fromResponse(response);
+          .map(new Func1<Response<R>, Result<R>>() {
+            @Override public Result<R> call(Response<R> response) {
+              return Result.response(response);
             }
           })
-          .onErrorReturn(new Func1<Throwable, Result<T>>() {
-            @Override public Result<T> call(Throwable throwable) {
-              return Result.fromError(throwable);
+          .onErrorReturn(new Func1<Throwable, Result<R>>() {
+            @Override public Result<R> call(Throwable throwable) {
+              return Result.error(throwable);
             }
           });
     }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
new file mode 100644
index 000000000..9d3c28ef1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Single;
+
+final class SingleHelper {
+  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
+    return new CallAdapter<Single<?>>() {
+      @Override public Type responseType() {
+        return callAdapter.responseType();
+      }
+
+      @Override public <R> Single<?> adapt(Call<R> call) {
+        Observable<?> observable = callAdapter.adapt(call);
+        return observable.toSingle();
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
index 7bf80ca88..3eb406949 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
@@ -23,8 +23,8 @@
 
 public final class ResultTest {
   @Test public void response() {
-    Response<String> response = Response.fakeSuccess("Hi");
-    Result<String> result = Result.fromResponse(response);
+    Response<String> response = Response.success("Hi");
+    Result<String> result = Result.response(response);
     assertThat(result.isError()).isFalse();
     assertThat(result.error()).isNull();
     assertThat(result.response()).isSameAs(response);
@@ -32,7 +32,7 @@
 
   @Test public void nullResponseThrows() {
     try {
-      Result.fromResponse(null);
+      Result.response(null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("response == null");
@@ -41,7 +41,7 @@
 
   @Test public void error() {
     Throwable error = new IOException();
-    Result<Object> result = Result.fromError(error);
+    Result<Object> result = Result.error(error);
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isSameAs(error);
     assertThat(result.response()).isNull();
@@ -49,7 +49,7 @@
 
   @Test public void nullErrorThrows() {
     try {
-      Result.fromError(null);
+      Result.error(null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("error == null");
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
similarity index 51%
rename from retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
index a34bc02af..b37b3c467 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
@@ -20,8 +20,9 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import org.junit.Before;
@@ -29,28 +30,36 @@
 import org.junit.Test;
 import retrofit.http.GET;
 import rx.Observable;
+import rx.Single;
 import rx.observables.BlockingObservable;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public final class ObservableCallAdapterFactoryTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+public final class RxJavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
+    @GET("/") Observable<String> observableBody();
+    @GET("/") Observable<Response<String>> observableResponse();
+    @GET("/") Observable<Result<String>> observableResult();
+    @GET("/") Single<String> singleBody();
+    @GET("/") Single<Response<String>> singleResponse();
+    @GET("/") Single<Result<String>> singleResult();
   }
 
+  private Retrofit retrofit;
   private Service service;
 
   @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new StringConverterFactory())
-        .callAdapterFactory(ObservableCallAdapterFactory.create())
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -58,26 +67,27 @@
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     assertThat(o.first()).isEqualTo("Hi");
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     try {
       o.first();
       fail();
     } catch (RuntimeException e) {
-      // TODO assert on some indicator of 404.
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 OK");
     }
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     try {
       o.first();
       fail();
@@ -89,7 +99,7 @@
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
@@ -98,7 +108,7 @@
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo("Hi");
@@ -107,7 +117,7 @@
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     try {
       o.first();
       fail();
@@ -119,7 +129,7 @@
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -130,7 +140,7 @@
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -141,49 +151,67 @@
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   @Test public void responseType() {
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType).responseType()) //
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(responseType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(resultType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
   }
 
   @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
-    CallAdapter<?> adapter = factory.get(String.class);
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
   @Test public void rawTypeThrows() {
-    Type type = new TypeToken<Observable>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
     }
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
   }
 
-  @Test public void rawResponseTypeThrows() {
-    Type type = new TypeToken<Observable<Response>>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+  @Test public void rawObservableResponseTypeThrows() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
@@ -191,24 +219,43 @@
   }
 
   @Test public void rawResultTypeThrows() {
-    Type type = new TypeToken<Observable<Result>>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
     }
   }
 
-  static class StringConverterFactory implements Converter.Factory {
-    @Override public Converter<?> get(Type type) {
-      return new Converter<String>() {
-        @Override public String fromBody(ResponseBody body) throws IOException {
-          return body.string();
+  @Test public void single() {
+    // TODO Better tests here. Why is there no toBlocking() on Single?
+    assertNotNull(service.singleBody());
+    assertNotNull(service.singleResponse());
+    assertNotNull(service.singleResult());
+  }
+
+  static class StringConverterFactory extends Converter.Factory {
+    @Override
+    public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
         }
+      };
+    }
 
-        @Override public RequestBody toBody(String value) {
+    @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
           return RequestBody.create(MediaType.parse("text/plain"), value);
         }
       };
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
index adc79d39e..59b921be0 100644
--- a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
@@ -16,12 +16,20 @@
 package retrofit;
 
 import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.reflect.TypeToken;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Gson for JSON. */
-public final class GsonConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
+ * <p>
+ * Because Gson is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class GsonConverterFactory extends Converter.Factory {
   /**
    * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
@@ -45,8 +53,12 @@ private GsonConverterFactory(Gson gson) {
     this.gson = gson;
   }
 
-  @Override public Converter<?> get(Type type) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonConverter<>(adapter);
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    return new GsonResponseBodyConverter<>(gson, type);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    return new GsonRequestBodyConverter<>(gson, type);
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
similarity index 66%
rename from retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
index 95189be9e..a2b527ead 100644
--- a/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,44 +15,33 @@
  */
 package retrofit;
 
-import com.google.gson.TypeAdapter;
+import com.google.gson.Gson;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
-import java.io.Reader;
 import java.io.Writer;
+import java.lang.reflect.Type;
 import java.nio.charset.Charset;
 import okio.Buffer;
 
-final class GsonConverter<T> implements Converter<T> {
+final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
-  private final TypeAdapter<T> typeAdapter;
+  private final Gson gson;
+  private final Type type;
 
-  GsonConverter(TypeAdapter<T> typeAdapter) {
-    this.typeAdapter = typeAdapter;
+  GsonRequestBodyConverter(Gson gson, Type type) {
+    this.gson = gson;
+    this.type = type;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    Reader in = body.charStream();
-    try {
-      return typeAdapter.fromJson(in);
-    } finally {
-      try {
-        in.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
+  @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
     Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
     try {
-      typeAdapter.toJson(writer, value);
+      gson.toJson(value, type, writer);
       writer.flush();
     } catch (IOException e) {
       throw new AssertionError(e); // Writing to Buffer does no I/O.
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
similarity index 52%
rename from retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
index 3538c789b..0214cfd5c 100644
--- a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
@@ -15,33 +15,27 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.RequestBody;
+import com.google.gson.Gson;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.io.Reader;
+import java.lang.reflect.Type;
 
-import static retrofit.Utils.closeQuietly;
+final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final Gson gson;
+  private final Type type;
 
-final class OkHttpResponseBodyConverter implements Converter<ResponseBody> {
-  private final boolean isStreaming;
-
-  OkHttpResponseBodyConverter(boolean isStreaming) {
-    this.isStreaming = isStreaming;
+  GsonResponseBodyConverter(Gson gson, Type type) {
+    this.gson = gson;
+    this.type = type;
   }
 
-  @Override public ResponseBody fromBody(ResponseBody body) throws IOException {
-    if (isStreaming) {
-      return body;
-    }
-
-    // Buffer the entire body to avoid future I/O.
+  @Override public T convert(ResponseBody value) throws IOException {
+    Reader reader = value.charStream();
     try {
-      return Utils.readBodyToBytesIfNecessary(body);
+      return gson.fromJson(reader, type);
     } finally {
-      closeQuietly(body);
+      Utils.closeQuietly(reader);
     }
   }
-
-  @Override public RequestBody toBody(ResponseBody value) {
-    throw new UnsupportedOperationException();
-  }
 }
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
index 006e5ab36..3351fc5d0 100644
--- a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
@@ -22,8 +22,8 @@
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -79,7 +79,7 @@
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
@@ -88,8 +88,8 @@
         .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
         .create();
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(GsonConverterFactory.create(gson))
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GsonConverterFactory.create(gson))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -118,6 +118,15 @@
     RecordedRequest request = server.takeRequest();
     assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void serializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+
+    service.anImplementation(new AnImplementation(null)).execute();
 
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
deleted file mode 100644
index d63eeea6f..000000000
--- a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.ObjectReader;
-import com.fasterxml.jackson.databind.ObjectWriter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-
-final class JacksonConverter<T> implements Converter<T> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-
-  private final ObjectWriter writer;
-  private final ObjectReader reader;
-
-  JacksonConverter(ObjectWriter writer, ObjectReader reader) {
-    this.writer = writer;
-    this.reader = reader;
-  }
-
-
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream is = body.byteStream();
-    try {
-      return reader.readValue(is);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
-    try {
-      byte[] bytes = writer.writeValueAsBytes(value);
-      return RequestBody.create(MEDIA_TYPE, bytes);
-    } catch (JsonProcessingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
index 8f4efc0e8..194992018 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
@@ -19,10 +19,20 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Jackson. */
-public final class JacksonConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Jackson.
+ * <p>
+ * Because Jackson is so flexible in the types it supports, this converter assumes that it can
+ * handle all types. If you are mixing JSON serialization with something else (such as protocol
+ * buffers), you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this
+ * instance} last to allow the other converters a chance to see their types.
+ */
+public final class JacksonConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
   public static JacksonConverterFactory create() {
     return create(new ObjectMapper());
@@ -40,10 +50,16 @@ private JacksonConverterFactory(ObjectMapper mapper) {
     this.mapper = mapper;
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
     ObjectReader reader = mapper.reader(javaType);
-    return new JacksonConverter<>(writer, reader);
+    return new JacksonResponseBodyConverter<>(reader);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectWriter writer = mapper.writerWithType(javaType);
+    return new JacksonRequestBodyConverter<>(writer);
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java
new file mode 100644
index 000000000..78edddee4
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+
+final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private final ObjectWriter adapter;
+
+  JacksonRequestBodyConverter(ObjectWriter adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = adapter.writeValueAsBytes(value);
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java
new file mode 100644
index 000000000..fe3763435
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.Reader;
+
+final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final ObjectReader adapter;
+
+  JacksonResponseBodyConverter(ObjectReader adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    Reader reader = value.charStream();
+    try {
+      return adapter.readValue(reader);
+    } finally {
+      Utils.closeQuietly(reader);
+    }
+  }
+}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
similarity index 94%
rename from retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
rename to retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
index fc6111fa6..83ba86fe6 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
@@ -27,8 +27,8 @@
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -38,7 +38,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class JacksonConverterTest {
+public class JacksonConverterFactoryTest {
   interface AnInterface {
     String getName();
   }
@@ -102,7 +102,7 @@
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
@@ -120,8 +120,8 @@
         .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(JacksonConverterFactory.create(mapper))
+        .baseUrl(server.url("/"))
+        .addConverterFactory(JacksonConverterFactory.create(mapper))
         .build();
     service = retrofit.create(Service.class);
   }
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index 492e42601..9968ccd38 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -3,8 +3,8 @@ Moshi Converter
 
 A `Converter` which uses [Moshi][1] for serialization to and from JSON.
 
-A default `Moshi` instance will be created or one can be configured and passed to the
-`MoshiConverter` construction to further control the serialization.
+A default `Moshi` instance will be created or one can be configured and passed to
+`MoshiConverterFactory.create()` to further control the serialization.
 
 
  [1]: https://github.com/square/moshi
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
index 75506f511..70a605af6 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
@@ -17,10 +17,20 @@
 
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.Moshi;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Moshi for JSON. */
-public final class MoshiConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
+ * <p>
+ * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class MoshiConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Moshi} instance for conversion. */
   public static MoshiConverterFactory create() {
     return create(new Moshi.Builder().build());
@@ -38,8 +48,14 @@ private MoshiConverterFactory(Moshi moshi) {
     this.moshi = moshi;
   }
 
-  @Override public Converter<?> get(Type type) {
-    JsonAdapter<Object> adapter = moshi.adapter(type);
-    return new MoshiConverter<>(adapter);
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    JsonAdapter<?> adapter = moshi.adapter(type);
+    return new MoshiResponseBodyConverter<>(adapter);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    JsonAdapter<?> adapter = moshi.adapter(type);
+    return new MoshiRequestBodyConverter<>(adapter);
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
similarity index 62%
rename from retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
index de7c57add..f64109687 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
@@ -18,39 +18,25 @@
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.Buffer;
-import okio.BufferedSource;
 
-final class MoshiConverter<T> implements Converter<T> {
+final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
-  private JsonAdapter<T> adapter;
+  private final JsonAdapter<T> adapter;
 
-  MoshiConverter(JsonAdapter<T> adapter) {
+  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
     this.adapter = adapter;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    BufferedSource source = body.source();
-    try {
-      return adapter.fromJson(source);
-    } finally {
-      try {
-        source.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
+  @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
     try {
       adapter.toJson(buffer, value);
     } catch (IOException e) {
-      throw new AssertionError(e);
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
     }
-    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit/src/main/java/retrofit/NoContentResponseBody.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
similarity index 53%
rename from retrofit/src/main/java/retrofit/NoContentResponseBody.java
rename to retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
index 098087653..6ddb17e63 100644
--- a/retrofit/src/main/java/retrofit/NoContentResponseBody.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
@@ -15,29 +15,24 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
+import com.squareup.moshi.JsonAdapter;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.BufferedSource;
 
-final class NoContentResponseBody extends ResponseBody {
-  private final MediaType contentType;
-  private final long contentLength;
+final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final JsonAdapter<T> adapter;
 
-  NoContentResponseBody(MediaType contentType, long contentLength) {
-    this.contentType = contentType;
-    this.contentLength = contentLength;
+  MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
-  @Override public MediaType contentType() {
-    return contentType;
-  }
-
-  @Override public long contentLength() throws IOException {
-    return contentLength;
-  }
-
-  @Override public BufferedSource source() throws IOException {
-    throw new IllegalStateException("Cannot read raw response body of a converted body.");
+  @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = value.source();
+    try {
+      return adapter.fromJson(source);
+    } finally {
+      Utils.closeQuietly(source);
+    }
   }
 }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
similarity index 92%
rename from retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
rename to retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
index 93dcd1c4a..b14da4b7e 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
@@ -21,8 +21,8 @@
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.ToJson;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -32,7 +32,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class MoshiConverterTest {
+public final class MoshiConverterFactoryTest {
   interface AnInterface {
     String getName();
   }
@@ -78,7 +78,7 @@
     @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
@@ -87,8 +87,8 @@
         .add(new AnInterfaceAdapter())
         .build();
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(MoshiConverterFactory.create(moshi))
+        .baseUrl(server.url("/"))
+        .addConverterFactory(MoshiConverterFactory.create(moshi))
         .build();
     service = retrofit.create(Service.class);
   }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
index bcb9d2640..9dfdbe253 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
@@ -17,22 +17,31 @@
 
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Protocol Buffers. */
-public final class ProtoConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
+ * <p>
+ * This converter only applies for types which extend from {@link MessageLite} (or one of its
+ * subclasses).
+ */
+public final class ProtoConverterFactory extends Converter.Factory {
   public static ProtoConverterFactory create() {
     return new ProtoConverterFactory();
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
     if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
+      return null;
     }
     Class<?> c = (Class<?>) type;
     if (!MessageLite.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
+      return null;
     }
 
     Parser<MessageLite> parser;
@@ -42,9 +51,18 @@ public static ProtoConverterFactory create() {
       parser = (Parser<MessageLite>) field.get(null);
     } catch (NoSuchFieldException | IllegalAccessException e) {
       throw new IllegalArgumentException(
-          "Expected a protobuf message but " + c.getName() + " had no PARSER field.");
+          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
     }
+    return new ProtoResponseBodyConverter<>(parser);
+  }
 
-    return new ProtoConverter<>(parser);
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
+      return null;
+    }
+    return new ProtoRequestBodyConverter<>();
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
similarity index 55%
rename from retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
index c2a997f64..e88a6ad73 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,38 +15,15 @@
  */
 package retrofit;
 
+import com.google.protobuf.MessageLite;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
 import java.io.IOException;
-import java.io.InputStream;
 
-final class WireConverter<T extends Message> implements Converter<T> {
+final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  private final Wire wire;
-  private final Class<T> cls;
-
-  public WireConverter(Wire wire, Class<T> cls) {
-    this.wire = wire;
-    this.cls = cls;
-  }
-
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream in = body.byteStream();
-    try {
-      return wire.parseFrom(in, cls);
-    } finally {
-      try {
-        in.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
+  @Override public RequestBody convert(T value) throws IOException {
     byte[] bytes = value.toByteArray();
     return RequestBody.create(MEDIA_TYPE, bytes);
   }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
similarity index 60%
rename from retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
index 2dcd35ac9..63d611818 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
@@ -18,37 +18,26 @@
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
 
-final class ProtoConverter<T extends MessageLite> implements Converter<T> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+final class ProtoResponseBodyConverter<T extends MessageLite>
+    implements Converter<ResponseBody, T> {
+  private final Parser<T> parser;
 
-  private Parser<T> parser;
-
-  ProtoConverter(Parser<T> parser) {
+  ProtoResponseBodyConverter(Parser<T> parser) {
     this.parser = parser;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream is = body.byteStream();
+  @Override public T convert(ResponseBody value) throws IOException {
+    InputStream is = value.byteStream();
     try {
       return parser.parseFrom(is);
     } catch (InvalidProtocolBufferException e) {
-      throw new RuntimeException(e);
+      throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
+      Utils.closeQuietly(is);
     }
   }
-
-  @Override public RequestBody toBody(T value) {
-    byte[] bytes = value.toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
similarity index 77%
rename from retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
rename to retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
index bdcad8b99..238ec6931 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
@@ -17,8 +17,8 @@
 
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.util.List;
 import okio.Buffer;
@@ -34,7 +34,7 @@
 import static org.junit.Assert.fail;
 import static retrofit.PhoneProtos.Phone;
 
-public final class ProtoConverterTest {
+public final class ProtoConverterFactoryTest {
   interface Service {
     @GET("/") Call<Phone> get();
     @POST("/") Call<Phone> post(@Body Phone impl);
@@ -42,14 +42,14 @@
     @GET("/") Call<List<String>> wrongType();
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(ProtoConverterFactory.create())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -85,7 +85,12 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method Service.wrongClass");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.ProtoConverterFactory");
     }
   }
 
@@ -97,7 +102,12 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+          + "    for method Service.wrongType");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.ProtoConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
index 8f394c2c4..9e2909b80 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
@@ -15,12 +15,20 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
 
-/** A {@linkplain Converter.Factory converter} which uses Simple Framework for XML. */
-public final class SimpleXmlConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
+ * <p>
+ * This converter only applies for class types. Parameterized types (e.g., {@code List<Foo>}) are
+ * not handled.
+ */
+public final class SimpleXmlConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Persister} instance for conversion. */
   public static SimpleXmlConverterFactory create() {
     return create(new Persister());
@@ -54,11 +62,19 @@ public boolean isStrict() {
     return strict;
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
     if (!(type instanceof Class)) {
-      throw new IllegalArgumentException("Expected a raw class but was " + type);
+      return null;
     }
     Class<?> cls = (Class<?>) type;
-    return new SimpleXmlConverter<>(cls, serializer, strict);
+    return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class)) {
+      return null;
+    }
+    return new SimpleXmlRequestBodyConverter<>(serializer);
   }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java
new file mode 100644
index 000000000..f81c6b177
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import okio.Buffer;
+import org.simpleframework.xml.Serializer;
+
+final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final String CHARSET = "UTF-8";
+
+  private final Serializer serializer;
+
+  SimpleXmlRequestBodyConverter(Serializer serializer) {
+    this.serializer = serializer;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    try {
+      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+      serializer.write(value, osw);
+      osw.flush();
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
similarity index 60%
rename from retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
index 1170cba00..6d4e37247 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
@@ -15,32 +15,24 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStreamWriter;
-import okio.Buffer;
 import org.simpleframework.xml.Serializer;
 
-final class SimpleXmlConverter<T> implements Converter<T> {
-  private static final String CHARSET = "UTF-8";
-  private static final MediaType MEDIA_TYPE =
-      MediaType.parse("application/xml; charset=" + CHARSET);
-
+final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final Class<T> cls;
   private final Serializer serializer;
   private final boolean strict;
 
-  SimpleXmlConverter(Class<T> cls, Serializer serializer, boolean strict) {
+  SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
     this.cls = cls;
     this.serializer = serializer;
     this.strict = strict;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream is = body.byteStream();
+  @Override public T convert(ResponseBody value) throws IOException {
+    InputStream is = value.byteStream();
     try {
       T read = serializer.read(cls, is, strict);
       if (read == null) {
@@ -58,16 +50,4 @@
       }
     }
   }
-
-  @Override public RequestBody toBody(T value) {
-    Buffer buffer = new Buffer();
-    try {
-      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(value, osw);
-      osw.flush();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
similarity index 91%
rename from retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
rename to retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
index 292807b42..d0c6421ef 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
@@ -16,8 +16,8 @@
 package retrofit;
 
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -34,14 +34,14 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public class SimpleXmlConverterTest {
+public class SimpleXmlConverterFactoryTest {
   interface Service {
     @GET("/") Call<MyObject> get();
     @POST("/") Call<MyObject> post(@Body MyObject impl);
     @GET("/") Call<String> wrongClass();
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
@@ -49,8 +49,8 @@
     Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
     Persister persister = new Persister(format);
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(SimpleXmlConverterFactory.create(persister))
+        .baseUrl(server.url("/"))
+        .addConverterFactory(SimpleXmlConverterFactory.create(persister))
         .build();
     service = retrofit.create(Service.class);
   }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
index 135e50d61..569527460 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
@@ -15,12 +15,20 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.Wire;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers. */
-public final class WireConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
+ * <p>
+ * This converter only applies for types which extend from {@link Message} (or one of its
+ * subclasses).
+ */
+public final class WireConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Wire} instance for conversion. */
   public static WireConverterFactory create() {
     return create(new Wire());
@@ -39,15 +47,26 @@ private WireConverterFactory(Wire wire) {
     this.wire = wire;
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
     if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
+      return null;
     }
     Class<?> c = (Class<?>) type;
     if (!Message.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
+      return null;
     }
     //noinspection unchecked
-    return new WireConverter<>(wire, (Class<Message>) c);
+    return new WireResponseBodyConverter<>(wire, (Class<? extends Message>) c);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    if (!Message.class.isAssignableFrom((Class<?>) type)) {
+      return null;
+    }
+    return new WireRequestBodyConverter<>();
   }
 }
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
similarity index 62%
rename from retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
index ad2434e47..fd2defd6e 100644
--- a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
@@ -15,16 +15,16 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
+import com.squareup.wire.Message;
 import java.io.IOException;
 
-final class OkHttpRequestBodyConverter implements Converter<RequestBody> {
-  @Override public RequestBody fromBody(ResponseBody body) throws IOException {
-    throw new UnsupportedOperationException();
-  }
+final class WireRequestBodyConverter<T extends Message> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public RequestBody toBody(RequestBody value) {
-    return value;
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = value.toByteArray();
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
new file mode 100644
index 000000000..13530a9ad
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.io.IOException;
+import okio.BufferedSource;
+
+final class WireResponseBodyConverter<T extends Message> implements Converter<ResponseBody, T> {
+  private final Wire wire;
+  private final Class<T> cls;
+
+  WireResponseBodyConverter(Wire wire, Class<T> cls) {
+    this.wire = wire;
+    this.cls = cls;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = value.source();
+    try {
+      return wire.parseFrom(source, cls);
+    } finally {
+      Utils.closeQuietly(source);
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
similarity index 76%
rename from retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
rename to retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
index 0790a28f3..e3c27b535 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
@@ -16,8 +16,8 @@
 package retrofit;
 
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
@@ -33,7 +33,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public final class WireConverterTest {
+public final class WireConverterFactoryTest {
   interface Service {
     @GET("/") Call<Phone> get();
     @POST("/") Call<Phone> post(@Body Phone impl);
@@ -41,14 +41,14 @@
     @GET("/") Call<List<String>> wrongType();
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   private Service service;
 
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(WireConverterFactory.create())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(WireConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -84,7 +84,12 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method Service.wrongClass");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.WireConverterFactory");
     }
   }
 
@@ -96,7 +101,12 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+          + "    for method Service.wrongType");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.WireConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 83c3a836e..ca7e9fe07 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -35,10 +35,5 @@
       <artifactId>mockito-core</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 </project>
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
deleted file mode 100644
index 34eaea450..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockHttpException.java
+++ /dev/null
@@ -1,114 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import retrofit.converter.Converter;
-
-import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
-import static java.net.HttpURLConnection.HTTP_FORBIDDEN;
-import static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-
-/**
- * An exception used to trigger the simulation of an HTTP error for mock services.
- *
- * @see MockRetrofit
- */
-public class MockHttpException extends RuntimeException {
-  /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
-  public static MockHttpException newMovedPermanentely(String location, Object responseBody) {
-    if (location == null || "".equals(location.trim())) {
-      throw new IllegalArgumentException("Location must not be blank.");
-    }
-    return new MockHttpException(HTTP_MOVED_PERM, "Moved Permanently", responseBody)
-        .withHeader("Location", location);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 302 Moved Temporarily. */
-  public static MockHttpException newMovedTemporarily(String location, Object responseBody) {
-    if (location == null || "".equals(location.trim())) {
-      throw new IllegalArgumentException("Location must not be blank.");
-    }
-    return new MockHttpException(HTTP_MOVED_TEMP, "Moved Temporarily", responseBody)
-        .withHeader("Location", location);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 400 Bad Request. */
-  public static MockHttpException newBadRequest(Object responseBody) {
-    return new MockHttpException(HTTP_BAD_REQUEST, "Bad Request", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 401 Unauthorized. */
-  public static MockHttpException newUnauthorized(Object responseBody) {
-    return new MockHttpException(HTTP_UNAUTHORIZED, "Unauthorized", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 403 Forbidden. */
-  public static MockHttpException newForbidden(Object responseBody) {
-    return new MockHttpException(HTTP_FORBIDDEN, "Forbidded", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 404 Not Found. */
-  public static MockHttpException newNotFound(Object responseBody) {
-    return new MockHttpException(HTTP_NOT_FOUND, "Not Found", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 500 Internal Server Error. */
-  public static MockHttpException newInternalError(Object responseBody) {
-    return new MockHttpException(HTTP_INTERNAL_ERROR, "Internal Server Error", responseBody);
-  }
-
-  final int code;
-  final String reason;
-  final Object responseBody;
-  final Headers.Builder headers = new Headers.Builder();
-
-  /**
-   * Create a new HTTP exception.
-   *
-   * @param code HTTP status code to trigger. Must be 300 or higher.
-   * @param reason HTTP status reason message.
-   * @param responseBody Object to use as the contents of the response body.
-   */
-  public MockHttpException(int code, String reason, Object responseBody) {
-    super("HTTP " + code + " " + reason);
-    if (code < 300 || code > 599) {
-      throw new IllegalArgumentException("Unsupported HTTP error code: " + code);
-    }
-    if (reason == null || "".equals(reason.trim())) {
-      throw new IllegalArgumentException("Reason must not be blank.");
-    }
-    this.code = code;
-    this.reason = reason;
-    this.responseBody = responseBody;
-  }
-
-  /** Add a header to the response. */
-  public MockHttpException withHeader(String name, String value) {
-    if (name == null || "".equals(name.trim())) {
-      throw new IllegalArgumentException("Header name must not be blank.");
-    }
-    if (value == null || "".equals(value.trim())) {
-      throw new IllegalArgumentException("Header value must not be blank.");
-    }
-    headers.add(name, value);
-    return this;
-  }
-
-  Response toResponse(Request request, Converter converter) {
-    return new Response.Builder()
-        .code(code)
-        .message(reason)
-        .headers(headers.build())
-        .body(new MockResponseBody(converter, responseBody))
-        .protocol(Protocol.HTTP_1_1)
-        .request(request)
-        .build();
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
deleted file mode 100644
index 03f1194e9..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import retrofit.converter.Converter;
-
-class MockResponseBody extends ResponseBody {
-  private final Converter converter;
-  private final Object body;
-
-  private byte[] bytes;
-
-  MockResponseBody(Converter converter, Object body) {
-    this.converter = converter;
-    this.body = body;
-  }
-
-  @Override public MediaType contentType() {
-    return MediaType.parse("application/unknown");
-  }
-
-  @Override public long contentLength() {
-    try {
-      initBytes();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-    return bytes.length;
-  }
-
-  @Override public BufferedSource source() {
-    return new Buffer().write(bytes);
-  }
-
-  private synchronized void initBytes() throws IOException {
-    if (bytes == null) {
-      Buffer buffer = new Buffer();
-      converter.toBody(body, body.getClass()).writeTo(buffer);
-      bytes = buffer.readByteArray();
-    }
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
deleted file mode 100644
index c06a7653a..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ /dev/null
@@ -1,353 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-
-import static retrofit.RetrofitError.unexpectedError;
-
-/**
- * Wraps mock implementations of API interfaces so that they exhibit the delay and error
- * characteristics of a real network.
- * <p>
- * Because APIs are defined as interfaces, versions of the API that use mock data can be created by
- * simply implementing the API interface on a class. These mock implementations execute
- * synchronously which is a large deviation from the behavior of those backed by an API call over
- * the network. By wrapping the mock instances using this class, the interface will still use mock
- * data but exhibit the delays and errors that a real network would face.
- * <p>
- * Create an API interface and a mock implementation of it.
- * <pre>
- *   public interface UserService {
- *     &#64;GET("/user/{id}")
- *     User getUser(@Path("id") String userId);
- *   }
- *   public class MockUserService implements UserService {
- *     &#64;Override public User getUser(String userId) {
- *       return new User("Jake");
- *     }
- *   }
- * </pre>
- * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
- * <pre>
- *   MockRetrofit mockRetrofit = MockRetrofit.from(restAdapter);
- * </pre>
- * Instances of this class should be used as a singleton so that the behavior of every mock service
- * is consistent.
- * <p>
- * Rather than using the {@code MockUserService} directly, pass it through
- * {@link #create(Class, Object) the create method}.
- * <pre>
- *   UserService service = mockRetrofit.create(UserService.class, new MockUserService());
- * </pre>
- * The returned {@code UserService} instance will now behave like it is happening over the network
- * while allowing the mock implementation to be written synchronously.
- * <p>
- * HTTP errors can be simulated in your mock services by throwing an instance of
- * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
- * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
- */
-public final class MockRetrofit {
-  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
-  private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by ±40%.
-  private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
-  private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
-
-  /**
-   * Create a new {@link MockRetrofit} which will act as a factory for mock services. Some of
-   * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
-   */
-  public static MockRetrofit from(RestAdapter restAdapter, Executor executor) {
-    return new MockRetrofit(restAdapter, executor);
-  }
-
-  private final RestAdapter restAdapter;
-  private final Executor executor;
-  final Random random = new Random();
-
-  private int delayMs = DEFAULT_DELAY_MS;
-  private int variancePct = DEFAULT_VARIANCE_PCT;
-  private int errorPct = DEFAULT_ERROR_PCT;
-
-  private MockRetrofit(RestAdapter restAdapter, Executor executor) {
-    this.restAdapter = restAdapter;
-    this.executor = executor;
-  }
-
-  /** Set the network round trip delay, in milliseconds. */
-  public void setDelay(long delayMs) {
-    if (delayMs < 0) {
-      throw new IllegalArgumentException("Delay must be positive value.");
-    }
-    if (delayMs > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Delay value too large. Max: " + Integer.MAX_VALUE);
-    }
-    this.delayMs = (int) delayMs;
-  }
-
-  /** The network round trip delay, in milliseconds */
-  public long getDelay() {
-    return delayMs;
-  }
-
-  /** Set the plus-or-minus variance percentage of the network round trip delay. */
-  public void setVariancePercentage(int variancePct) {
-    if (variancePct < 0 || variancePct > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
-    }
-    this.variancePct = variancePct;
-  }
-
-  /** The plus-or-minus variance percentage of the network round trip delay. */
-  public int getVariancePercentage() {
-    return variancePct;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public void setErrorPercentage(int errorPct) {
-    if (errorPct < 0 || errorPct > 100) {
-      throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
-    }
-    this.errorPct = errorPct;
-  }
-
-  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public int getErrorPercentage() {
-    return errorPct;
-  }
-
-  /**
-   * Randomly determine whether this call should result in a network failure.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #create(Class, Object)}.
-   */
-  public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100) + 1;
-    return randomValue <= errorPct;
-  }
-
-  /**
-   * Get the delay (in milliseconds) that should be used for triggering a network error.
-   * <p>
-   * Because we are triggering an error, use a random delay between 0 and three times the normal
-   * network delay to simulate a flaky connection failing anywhere from quickly to slowly.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #create(Class, Object)}.
-   */
-  public int calculateDelayForError() {
-    if (delayMs == 0) return 0;
-
-    return random.nextInt(delayMs * ERROR_DELAY_FACTOR);
-  }
-
-  /**
-   * Get the delay (in milliseconds) that should be used for delaying a network call response.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #create(Class, Object)}.
-   */
-  public int calculateDelayForCall() {
-    float errorPercent = variancePct / 100f; // e.g., 20 / 100f == 0.2f
-    float lowerBound = 1f - errorPercent; // 0.2f --> 0.8f
-    float upperBound = 1f + errorPercent; // 0.2f --> 1.2f
-    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
-    float delayPercent = (random.nextFloat() * bound) + lowerBound; // 0.8 + (rnd * 0.4)
-    return (int) (delayMs * delayPercent);
-  }
-
-  /**
-   * Wrap the supplied mock implementation of a service so that it exhibits the delay and error
-   * characteristics of a real network.
-   *
-   * @see #setDelay(long)
-   * @see #setVariancePercentage(int)
-   * @see #setErrorPercentage(int)
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service, T mockService) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new MockHandler(service, mockService));
-  }
-
-  private class MockHandler implements InvocationHandler {
-    private final Object mockService;
-
-    public MockHandler(Object mockService, T service) {
-      this.mockService = mockService;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      // Load or create the details cache for the current method.
-      final MethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
-      final Request request = buildRequest(methodInfo, args);
-
-      if (methodInfo.executionType == MethodInfo.ExecutionType.SYNC) {
-        try {
-          return invokeSync(methodInfo, args, request);
-        } catch (RetrofitError error) {
-          Throwable newError = restAdapter.errorHandler.handleError(error);
-          if (newError == null) {
-            throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
-          }
-          throw newError;
-        }
-      }
-
-      executor.execute(new Runnable() {
-        @Override public void run() {
-          invokeAsync(methodInfo, args, request);
-        }
-      });
-      return null; // Asynchronous methods should have return type of void.
-    }
-
-    private Request buildRequest(MethodInfo methodInfo, Object[] args) throws Throwable {
-      // Begin building a normal request.
-      String apiUrl = restAdapter.baseUrl.url();
-      RequestBuilder requestBuilder = new RequestBuilder(apiUrl, methodInfo, restAdapter.converter);
-      requestBuilder.setArguments(args);
-      return requestBuilder.build();
-    }
-
-    private Object invokeSync(MethodInfo methodInfo, Object[] args, Request request)
-        throws Throwable {
-      String url = request.urlString();
-
-      if (calculateIsFailure()) {
-        sleep(calculateDelayForError());
-        IOException exception = new IOException("Mock network error!");
-        throw RetrofitError.networkFailure(url, exception);
-      }
-
-      int callDelay = calculateDelayForCall();
-      long beforeNanos = System.nanoTime();
-      try {
-        Object returnValue = methodInfo.method.invoke(mockService, args);
-
-        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
-        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
-        sleep(callDelay - tookMs);
-
-        return returnValue;
-      } catch (InvocationTargetException e) {
-        Throwable innerEx = e.getCause();
-        if (!(innerEx instanceof MockHttpException)) {
-          throw innerEx;
-        }
-        MockHttpException httpEx = (MockHttpException) innerEx;
-        Response response = httpEx.toResponse(request, restAdapter.converter);
-
-        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
-        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
-        sleep(callDelay - tookMs);
-
-        throw new MockHttpRetrofitError(httpEx.reason, url, response, httpEx.responseBody,
-            methodInfo.responseType);
-      }
-    }
-
-    private void invokeAsync(final MethodInfo methodInfo, final Object[] args,
-        final Request request) {
-      final String url = request.urlString();
-      final Callback callback = (Callback) args[args.length - 1];
-
-      if (calculateIsFailure()) {
-        sleep(calculateDelayForError());
-        IOException exception = new IOException("Mock network error!");
-        RetrofitError error = RetrofitError.networkFailure(url, exception);
-        Throwable cause = restAdapter.errorHandler.handleError(error);
-        final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            callback.failure(e);
-          }
-        });
-        return;
-      }
-
-      final int callDelay = calculateDelayForCall();
-      sleep(callDelay);
-
-      restAdapter.callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          try {
-            methodInfo.method.invoke(mockService, args);
-          } catch (Throwable throwable) {
-            final Throwable innerEx = throwable.getCause();
-            if (!(innerEx instanceof MockHttpException)) {
-              if (innerEx instanceof RuntimeException) {
-                throw (RuntimeException) innerEx;
-              }
-              throw new RuntimeException(innerEx);
-            }
-
-            MockHttpException httpEx = (MockHttpException) innerEx;
-            Response response = httpEx.toResponse(request, restAdapter.converter);
-
-            RetrofitError error = new MockHttpRetrofitError(httpEx.getMessage(), url, response,
-                httpEx.responseBody, methodInfo.responseType);
-            Throwable cause = restAdapter.errorHandler.handleError(error);
-            final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
-            callback.failure(e);
-          }
-        }
-      });
-    }
-  }
-
-  /**
-   * Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to {@link
-   * Thread#sleep(long)}, but does not throw {@link InterruptedException}; {@link
-   * Thread#interrupt()} events are deferred until the next interruptible operation.  Does not
-   * return until at least the specified number of milliseconds has elapsed.
-   *
-   * @param ms to sleep before returning, in milliseconds of uptime.
-   */
-  private static void sleep(long ms) {
-    // This implementation is modified from Android's SystemClock#sleep.
-
-    long start = uptimeMillis();
-    long duration = ms;
-    boolean interrupted = false;
-    while (duration > 0) {
-      try {
-        Thread.sleep(duration);
-      } catch (InterruptedException e) {
-        interrupted = true;
-      }
-      duration = start + ms - uptimeMillis();
-    }
-
-    if (interrupted) {
-      // Important: we don't want to quietly eat an interrupt() event,
-      // so we make sure to re-interrupt the thread so that the next
-      // call to Thread.sleep() or Object.wait() will be interrupted.
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private static long uptimeMillis() {
-    return System.nanoTime() / 1000000L;
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
new file mode 100644
index 000000000..d3f7e7d4f
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicReference;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+import retrofit.Retrofit;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+final class BehaviorCall<T> implements Call<T> {
+  private final Retrofit retrofit;
+  private final NetworkBehavior behavior;
+  private final ExecutorService backgroundExecutor;
+  private final Executor callbackExecutor;
+  private final Call<T> delegate;
+
+  private volatile Future<?> task;
+  private volatile boolean canceled;
+  private volatile boolean executed;
+
+  BehaviorCall(Retrofit retrofit, NetworkBehavior behavior, ExecutorService backgroundExecutor,
+      Call<T> delegate) {
+    this.retrofit = retrofit;
+    this.behavior = behavior;
+    this.backgroundExecutor = backgroundExecutor;
+    this.delegate = delegate;
+
+    Executor callbackExecutor = retrofit.callbackExecutor();
+    if (callbackExecutor == null) {
+      callbackExecutor = new Executor() {
+        @Override public void execute(Runnable command) {
+          command.run();
+        }
+      };
+    }
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public Call<T> clone() {
+    return new BehaviorCall<>(retrofit, behavior, backgroundExecutor, delegate.clone());
+  }
+
+  @Override public void enqueue(final Callback<T> callback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+    task = backgroundExecutor.submit(new Runnable() {
+      private boolean delaySleep() {
+        long sleepMs = behavior.calculateDelay(MILLISECONDS);
+        if (sleepMs > 0) {
+          try {
+            Thread.sleep(sleepMs);
+          } catch (InterruptedException e) {
+            callFailure(new InterruptedIOException("canceled"));
+            return false;
+          }
+        }
+        return true;
+      }
+
+      private void callResponse(final Response<T> response) {
+        callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            callback.onResponse(response, retrofit);
+          }
+        });
+      }
+
+      private void callFailure(final Throwable throwable) {
+        callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            callback.onFailure(throwable);
+          }
+        });
+      }
+
+      @Override public void run() {
+        if (canceled) {
+          callFailure(new InterruptedIOException("canceled"));
+        } else if (behavior.calculateIsFailure()) {
+          if (delaySleep()) {
+            callFailure(behavior.failureException());
+          }
+        } else {
+          delegate.enqueue(new Callback<T>() {
+            @Override public void onResponse(final Response<T> response, Retrofit retrofit) {
+              if (delaySleep()) {
+                callResponse(response);
+              }
+            }
+
+            @Override public void onFailure(final Throwable t) {
+              if (delaySleep()) {
+                callFailure(t);
+              }
+            }
+          });
+        }
+      }
+    });
+  }
+
+  @Override public Response<T> execute() throws IOException {
+    final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    enqueue(new Callback<T>() {
+      @Override public void onResponse(Response<T> response, Retrofit retrofit) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    try {
+      latch.await();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException("canceled");
+    }
+    Response<T> response = responseRef.get();
+    if (response != null) return response;
+    Throwable failure = failureRef.get();
+    if (failure instanceof RuntimeException) throw (RuntimeException) failure;
+    if (failure instanceof IOException) throw (IOException) failure;
+    throw new RuntimeException(failure);
+  }
+
+  @Override public void cancel() {
+    canceled = true;
+    Future<?> task = this.task;
+    if (task != null) {
+      task.cancel(true);
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
new file mode 100644
index 000000000..ee216a597
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.util.concurrent.ExecutorService;
+import retrofit.Call;
+import retrofit.Retrofit;
+
+public final class CallBehaviorAdapter implements NetworkBehavior.Adapter<Call<?>> {
+  private final Retrofit retrofit;
+  private final ExecutorService backgroundExecutor;
+
+  /**
+   * Create an instance with a normal {@link Retrofit} instance and an executor service on which
+   * the simulated delays will be created. Instances of this class should be re-used so that the
+   * behavior of every mock service is consistent.
+   */
+  public CallBehaviorAdapter(Retrofit retrofit, ExecutorService backgroundExecutor) {
+    this.retrofit = retrofit;
+    this.backgroundExecutor = backgroundExecutor;
+  }
+
+  @Override public Call<?> applyBehavior(NetworkBehavior behavior, Call<?> value) {
+    return new BehaviorCall<>(retrofit, behavior, backgroundExecutor, value);
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Calls.java b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
new file mode 100644
index 000000000..4dbab1179
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+import retrofit.Retrofit;
+
+/** Factory methods for creating {@link Call} instances which immediately respond or fail. */
+public final class Calls {
+  public static <T> Call<T> response(T successValue, Retrofit retrofit) {
+    return response(Response.success(successValue), retrofit);
+  }
+
+  public static <T> Call<T> response(final Response<T> response, final Retrofit retrofit) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        return response;
+      }
+
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onResponse(response, retrofit);
+      }
+
+      @Override public void cancel() {
+      }
+
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
+    };
+  }
+
+  public static <T> Call<T> failure(final IOException failure) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        throw failure;
+      }
+
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onFailure(failure);
+      }
+
+      @Override public void cancel() {
+      }
+
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
+    };
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
new file mode 100644
index 000000000..71aaaca6d
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+public final class MockRetrofit {
+  private final NetworkBehavior behavior;
+  private final NetworkBehavior.Adapter<Object> adapter;
+
+  @SuppressWarnings("unchecked") //
+  public MockRetrofit(NetworkBehavior behavior, NetworkBehavior.Adapter<?> adapter) {
+    this.adapter = (NetworkBehavior.Adapter<Object>) adapter;
+    this.behavior = behavior;
+  }
+
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  public <T> T create(Class<T> service, final T instance) {
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
+        new InvocationHandler() {
+          @Override public Object invoke(Object proxy, Method method, Object[] args)
+              throws Throwable {
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            method.setAccessible(true); // Just In Case™
+
+            Object value = method.invoke(instance, args);
+            return adapter.applyBehavior(behavior, value);
+          }
+        });
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
new file mode 100644
index 000000000..f3fdffb77
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+/**
+ * A simple emulation of the behavior of network calls.
+ * <p>
+ * This class models three properties of a network:
+ * <ul>
+ * <li>Delay – the time it takes before a response is received (successful or otherwise).</li>
+ * <li>Variance – the amount of fluctuation of the delay to be faster or slower.</li>
+ * <li>Failure - the percentage of operations which fail (such as {@link IOException}).</li>
+ * </ul>
+ * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
+ * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
+ * <p>
+ * By default, instances of this class will use a 2 second delay with 40% variance and failures
+ * will occur 3% of the time.
+ */
+public final class NetworkBehavior {
+  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+  private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
+  private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+
+  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
+  public interface Adapter<T> {
+    /**
+     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+     * traits when interacted with.
+     */
+    T applyBehavior(NetworkBehavior behavior, T value);
+  }
+
+  /** Create an instance with default behavior. */
+  public static NetworkBehavior create() {
+    return new NetworkBehavior(new Random());
+  }
+
+  /**
+   * Create an instance with default behavior which uses {@code random} to control variance and
+   * failure calculation.
+   */
+  public static NetworkBehavior create(Random random) {
+    if (random == null) throw new NullPointerException("random == null");
+    return new NetworkBehavior(random);
+  }
+
+  private final Random random;
+
+  private volatile long delayMs = DEFAULT_DELAY_MS;
+  private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
+  private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
+  private volatile Throwable failureException = new IOException("Mock failure!");
+
+  private NetworkBehavior(Random random) {
+    this.random = random;
+  }
+
+  /** Set the network round trip delay. */
+  public void setDelay(long amount, TimeUnit unit) {
+    if (amount < 0) {
+      throw new IllegalArgumentException("Amount must be positive value.");
+    }
+    this.delayMs = unit.toMillis(amount);
+  }
+
+  /** The network round trip delay. */
+  public long delay(TimeUnit unit) {
+    return MILLISECONDS.convert(delayMs, unit);
+  }
+
+  /** Set the plus-or-minus variance percentage of the network round trip delay. */
+  public void setVariancePercent(int variancePercent) {
+    if (variancePercent < 0 || variancePercent > 100) {
+      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+    }
+    this.variancePercent = variancePercent;
+  }
+
+  /** The plus-or-minus variance percentage of the network round trip delay. */
+  public int variancePercent() {
+    return variancePercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public void setFailurePercent(int failurePercent) {
+    if (failurePercent < 0 || failurePercent > 100) {
+      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+    }
+    this.failurePercent = failurePercent;
+  }
+
+  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public int failurePercent() {
+    return failurePercent;
+  }
+
+  /** Set the exception to be used when a failure is triggered. */
+  public void setFailureException(Throwable t) {
+    if (t == null) {
+      throw new NullPointerException("t == null");
+    }
+    this.failureException = t;
+  }
+
+  /** The exception to be used when a failure is triggered. */
+  public Throwable failureException() {
+    return failureException;
+  }
+
+  /**
+   * Randomly determine whether this call should result in a network failure in accordance with
+   * configured behavior. When true, {@link #failureException()} should be thrown.
+   */
+  public boolean calculateIsFailure() {
+    int randomValue = random.nextInt(100);
+    return randomValue < failurePercent;
+  }
+
+  /**
+   * Get the delay that should be used for delaying a response in accordance with configured
+   * behavior.
+   */
+  public long calculateDelay(TimeUnit unit) {
+    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
+    float lowerBound = 1f - delta; // 0.2f --> 0.8f
+    float upperBound = 1f + delta; // 0.2f --> 1.2f
+    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
+    long callDelayMs = (long) (delayMs * delayPercent);
+    return MILLISECONDS.convert(callDelayMs, unit);
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
deleted file mode 100644
index 6b0b7ad9f..000000000
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ /dev/null
@@ -1,603 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.Before;
-import org.junit.Test;
-import retrofit.http.GET;
-import rx.Observable;
-import rx.functions.Action1;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class MockRetrofitTest {
-  interface SyncExample {
-    @GET("/") Object doStuff();
-  }
-
-  interface AsyncExample {
-    @GET("/") void doStuff(Callback<String> cb);
-  }
-
-  interface AsyncCallbackSubtypeExample {
-    abstract class Foo implements Callback<String> {}
-
-    @GET("/") void doStuff(Foo foo);
-  }
-
-  interface ObservableExample {
-    @GET("/") Observable<String> doStuff();
-  }
-
-  private Executor httpExecutor;
-  private Executor callbackExecutor;
-  private MockRetrofit mockRetrofit;
-  private Throwable nextError;
-
-  @Before public void setUp() throws IOException {
-    httpExecutor = spy(new SynchronousExecutor());
-    callbackExecutor = spy(new SynchronousExecutor());
-
-    RestAdapter restAdapter = new RestAdapter.Builder() //
-        .callbackExecutor(callbackExecutor)
-        .baseUrl("http://example.com")
-        .errorHandler(new ErrorHandler() {
-          @Override public Throwable handleError(RetrofitError cause) {
-            if (nextError != null) {
-              Throwable error = nextError;
-              nextError = null;
-              return error;
-            }
-            return cause;
-          }
-        })
-        .build();
-
-    mockRetrofit = MockRetrofit.from(restAdapter, httpExecutor);
-
-    // Seed the random with a value so the tests are deterministic.
-    mockRetrofit.random.setSeed(2847);
-  }
-
-  @Test public void delayRestrictsRange() {
-    try {
-      mockRetrofit.setDelay(-1);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Delay must be positive value.");
-    }
-    try {
-      mockRetrofit.setDelay(Long.MAX_VALUE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith("Delay value too large.");
-    }
-  }
-
-  @Test public void varianceRestrictsRange() {
-    try {
-      mockRetrofit.setVariancePercentage(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-    try {
-      mockRetrofit.setVariancePercentage(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-  }
-
-  @Test public void errorRestrictsRange() {
-    try {
-      mockRetrofit.setErrorPercentage(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
-    }
-    try {
-      mockRetrofit.setErrorPercentage(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
-    }
-  }
-
-  @Test public void errorPercentageIsAccurate() {
-    mockRetrofit.setErrorPercentage(0);
-    for (int i = 0; i < 10000; i++) {
-      assertThat(mockRetrofit.calculateIsFailure()).isFalse();
-    }
-
-    mockRetrofit.setErrorPercentage(3);
-    int failures = 0;
-    for (int i = 0; i < 100000; i++) {
-      if (mockRetrofit.calculateIsFailure()) {
-        failures += 1;
-      }
-    }
-    assertThat(failures).isEqualTo(2964); // ~3% of 100k
-  }
-
-  @Test public void delayVarianceIsAccurate() {
-    mockRetrofit.setDelay(2000);
-
-    mockRetrofit.setVariancePercentage(0);
-    for (int i = 0; i < 100000; i++) {
-      assertThat(mockRetrofit.calculateDelayForCall()).isEqualTo(2000);
-    }
-
-    mockRetrofit.setVariancePercentage(40);
-    int lowerBound = Integer.MAX_VALUE;
-    int upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      int delay = mockRetrofit.calculateDelayForCall();
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
-    }
-    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
-    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
-  }
-
-  @Test public void errorVarianceIsAccurate() {
-    mockRetrofit.setDelay(2000);
-
-    int lowerBound = Integer.MAX_VALUE;
-    int upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      int delay = mockRetrofit.calculateDelayForError();
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
-    }
-    assertThat(upperBound).isEqualTo(5999); // 3 * 2000
-    assertThat(lowerBound).isEqualTo(0);
-  }
-
-  @Test public void syncFailureTriggersNetworkError() {
-    mockRetrofit.setErrorPercentage(100);
-    mockRetrofit.setDelay(1);
-
-    class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
-        throw new AssertionError();
-      }
-    }
-
-    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
-
-    try {
-      mockService.doStuff();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-      assertThat(e.getCause()).hasMessage("Mock network error!");
-    }
-  }
-
-  @Test public void asyncFailureTriggersNetworkError() {
-    mockRetrofit.setDelay(1);
-    mockRetrofit.setErrorPercentage(100);
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        throw new AssertionError();
-      }
-    }
-
-    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
-
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String o, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        errorRef.set(error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verify(callbackExecutor).execute(any(Runnable.class));
-
-    RetrofitError error = errorRef.get();
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-    assertThat(error.getCause()).hasMessage("Mock network error!");
-  }
-
-  @Test public void syncApiIsCalledWithDelay() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    final AtomicBoolean called = new AtomicBoolean();
-    final Object expected = new Object();
-    class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
-        called.set(true);
-        return expected;
-      }
-    }
-
-    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
-
-    long startNanos = System.nanoTime();
-    Object actual = mockService.doStuff();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-
-    assertThat(called.get()).isTrue();
-    assertThat(actual).isEqualTo(expected);
-    assertThat(tookMs).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void asyncApiIsCalledWithDelay() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hi");
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        cb.success(expected, null);
-      }
-    }
-
-    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<>();
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String result, Response response) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(result);
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verify(callbackExecutor).execute(any(Runnable.class));
-
-    assertThat(actual.get()).isNotNull().isSameAs(expected);
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void observableApiIsCalledWithDelay() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hello");
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        return Observable.just(expected);
-      }
-    }
-
-    ObservableExample mockService =
-        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<>();
-    Action1<Object> onSuccess = new Action1<Object>() {
-      @Override public void call(Object o) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(o);
-      }
-    };
-    Action1<Throwable> onError = new Action1<Throwable>() {
-      @Override public void call(Throwable throwable) {
-        throw new AssertionError();
-      }
-    };
-
-    mockService.doStuff().subscribe(onSuccess, onError);
-
-    verify(httpExecutor, atLeastOnce()).execute(any(Runnable.class));
-    verifyZeroInteractions(callbackExecutor);
-
-    assertThat(actual.get()).isNotNull().isSameAs(expected);
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-
-  @Test public void syncHttpExceptionBecomesError() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hello");
-
-    class MockSyncExample implements SyncExample {
-      @Override public String doStuff() {
-        throw new MockHttpException(404, "Not Found", expected);
-      }
-    }
-
-    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
-
-    long startNanos = System.nanoTime();
-    try {
-      mockService.doStuff();
-      fail();
-    } catch (RetrofitError e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-      assertThat(e.getResponse().code()).isEqualTo(404);
-      assertThat(e.getResponse().message()).isEqualTo("Not Found");
-      assertThat(e.getBody()).isSameAs(expected);
-      assertThat(e.getSuccessType()).isEqualTo(Object.class);
-    }
-  }
-
-  @Test public void asyncHttpExceptionBecomesError() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Greetings");
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        throw new MockHttpException(404, "Not Found", expected);
-      }
-    }
-
-    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String o, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        errorRef.set(error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verify(callbackExecutor).execute(any(Runnable.class));
-
-    RetrofitError error = errorRef.get();
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().code()).isEqualTo(404);
-    assertThat(error.getResponse().message()).isEqualTo("Not Found");
-    assertThat(error.getBody()).isSameAs(expected);
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void observableHttpExceptionBecomesError() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hi");
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        throw new MockHttpException(404, "Not Found", expected);
-      }
-    }
-
-    ObservableExample mockService =
-        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
-    mockService.doStuff().subscribe(new Action1<Object>() {
-      @Override public void call(Object o) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable error) {
-        assertThat(error).isInstanceOf(RetrofitError.class);
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        errorRef.set((RetrofitError) error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verifyZeroInteractions(callbackExecutor);
-
-    RetrofitError error = errorRef.get();
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().code()).isEqualTo(404);
-    assertThat(error.getResponse().message()).isEqualTo("Not Found");
-    assertThat(error.getBody()).isSameAs(expected);
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        throw MockHttpException.newBadRequest(null);
-      }
-    }
-
-    ObservableExample mockService =
-        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
-    mockService.doStuff().subscribe(new Action1<Object>() {
-      @Override public void call(Object o) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable error) {
-        assertThat(error).isInstanceOf(RetrofitError.class);
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        errorRef.set((RetrofitError) error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verifyZeroInteractions(callbackExecutor);
-
-    RetrofitError error = errorRef.get();
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().code()).isEqualTo(400);
-    assertThat(error.getResponse().message()).isEqualTo("Bad Request");
-    assertThat(error.getBody()).isNull();
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void syncErrorUsesErrorHandler() {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
-        throw MockHttpException.newNotFound(new Object());
-      }
-    }
-
-    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
-    nextError = new IllegalArgumentException("Test");
-
-    try {
-      mockService.doStuff();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Test");
-    }
-  }
-
-  @Test public void asyncErrorUsesErrorHandler() throws InterruptedException {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        throw MockHttpException.newNotFound(new Object());
-      }
-    }
-
-    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
-    nextError = new IllegalArgumentException("Test");
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String o, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        assertThat(error.getCause()).hasMessage("Test");
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-  }
-
-  @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
-    mockRetrofit.setDelay(100);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        throw MockHttpException.newNotFound(new Object());
-      }
-    }
-
-    ObservableExample mockService =
-        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
-    nextError = new IllegalArgumentException("Test");
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff().subscribe(new Action1<Object>() {
-      @Override public void call(Object o) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable error) {
-        assertThat(error).hasMessage("Test");
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-  }
-
-  @Test public void asyncCanUseCallbackSubtype() {
-    mockRetrofit.setDelay(1);
-    mockRetrofit.setVariancePercentage(0);
-    mockRetrofit.setErrorPercentage(0);
-
-    class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
-      @Override public void doStuff(Foo foo) {
-        foo.success("Hello!", null);
-      }
-    }
-
-    AsyncCallbackSubtypeExample mockService =
-        mockRetrofit.create(AsyncCallbackSubtypeExample.class,
-            new MockAsyncCallbackSubtypeExample());
-
-    final AtomicReference<String> actual = new AtomicReference<>();
-    mockService.doStuff(new AsyncCallbackSubtypeExample.Foo() {
-      @Override public void success(String result, Response response) {
-        actual.set(result);
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-
-    assertThat(actual.get()).isNotNull().isEqualTo("Hello!");
-  }
-}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
new file mode 100644
index 000000000..bfdcb0286
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit.mock.CallBehaviorAdapter;
+import retrofit.mock.Calls;
+import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
+
+import static java.util.concurrent.Executors.newSingleThreadExecutor;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class MockRetrofitTest {
+  interface DoWorkService {
+    Call<String> response();
+    Call<String> failure();
+  }
+
+  private final IOException mockFailure = new IOException("Timeout!");
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+  private DoWorkService service;
+
+  @Before public void setUp() {
+    final Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
+
+    DoWorkService mockService = new DoWorkService() {
+      @Override public Call<String> response() {
+        return Calls.response("Response!", retrofit);
+      }
+
+      @Override public Call<String> failure() {
+        return Calls.failure(mockFailure);
+      }
+    };
+
+    NetworkBehavior.Adapter<?> adapter =
+        new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
+    service = mockRetrofit.create(DoWorkService.class, mockService);
+  }
+
+  @Test public void syncFailureThrowsAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Call<String> call = service.response();
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(e).isSameAs(behavior.failureException());
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    }
+  }
+
+  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Call<String> call = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void syncSuccessReturnsAfterDelay() throws IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.response();
+
+    long startNanos = System.nanoTime();
+    Response<String> response = call.execute();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+
+    assertThat(response.body()).isEqualTo("Response!");
+    assertThat(tookMs).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(response.body());
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        throw new AssertionError();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Response!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void syncFailureThrownAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.failure();
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+      assertThat(e).isSameAs(mockFailure);
+    }
+  }
+
+  @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.failure();
+
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    final long startNanos = System.nanoTime();
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(failureRef.get()).isSameAs(mockFailure);
+  }
+
+  @Test public void syncCanBeCanceled() throws IOException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    new Thread(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(100);
+          call.cancel();
+        } catch (InterruptedException ignored) {
+        }
+      }
+    }).start();
+
+    try {
+      call.execute();
+      fail();
+    } catch (InterruptedIOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void asyncCanBeCanceled() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // TODO we shouldn't need to sleep
+    Thread.sleep(100); // Ensure the task has started.
+    call.cancel();
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  }
+
+  @Test public void syncCanceledBeforeStart() throws IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (InterruptedIOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+    call.cancel();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
new file mode 100644
index 000000000..916e8cf5c
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.util.Random;
+import org.junit.Test;
+import retrofit.mock.NetworkBehavior;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class NetworkBehaviorTest {
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+
+  @Test public void delayMustBePositive() {
+    try {
+      behavior.setDelay(-1, SECONDS);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Amount must be positive value.");
+    }
+  }
+
+  @Test public void varianceRestrictsRange() {
+    try {
+      behavior.setVariancePercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setVariancePercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void failureRestrictsRange() {
+    try {
+      behavior.setFailurePercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setFailurePercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void failurePercentageIsAccurate() {
+    behavior.setFailurePercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsFailure()).isFalse();
+    }
+
+    behavior.setFailurePercent(3);
+    int failures = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsFailure()) {
+        failures += 1;
+      }
+    }
+    assertThat(failures).isEqualTo(2964); // ~3% of 100k
+  }
+
+  @Test public void delayVarianceIsAccurate() {
+    behavior.setDelay(2, SECONDS);
+
+    behavior.setVariancePercent(0);
+    for (int i = 0; i < 100000; i++) {
+      assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
+    }
+
+    behavior.setVariancePercent(40);
+    long lowerBound = Integer.MAX_VALUE;
+    long upperBound = Integer.MIN_VALUE;
+    for (int i = 0; i < 100000; i++) {
+      long delay = behavior.calculateDelay(MILLISECONDS);
+      if (delay > upperBound) {
+        upperBound = delay;
+      }
+      if (delay < lowerBound) {
+        lowerBound = delay;
+      }
+    }
+    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
+    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
+  }
+}
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index b4e355270..a6d9f5496 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -25,6 +25,12 @@
       <optional>true</optional>
     </dependency>
 
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <optional>true</optional>
+    </dependency>
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/retrofit/src/main/java/retrofit/BuiltInConverters.java b/retrofit/src/main/java/retrofit/BuiltInConverters.java
new file mode 100644
index 000000000..be2f81d5e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/BuiltInConverters.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit.http.Streaming;
+
+import static retrofit.Utils.closeQuietly;
+
+final class BuiltInConverters extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (ResponseBody.class.equals(type)) {
+      boolean isStreaming = Utils.isAnnotationPresent(annotations, Streaming.class);
+      return new OkHttpResponseBodyConverter(isStreaming);
+    }
+    if (Void.class.equals(type)) {
+      return new VoidConverter();
+    }
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (type instanceof Class && RequestBody.class.isAssignableFrom((Class<?>) type)) {
+      return new OkHttpRequestBodyConverter();
+    }
+    return null;
+  }
+
+  static final class VoidConverter implements Converter<ResponseBody, Void> {
+    @Override public Void convert(ResponseBody value) throws IOException {
+      value.close();
+      return null;
+    }
+  }
+
+  static final class OkHttpRequestBodyConverter implements Converter<RequestBody, RequestBody> {
+    @Override public RequestBody convert(RequestBody value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class OkHttpResponseBodyConverter implements Converter<ResponseBody, ResponseBody> {
+    private final boolean isStreaming;
+
+    OkHttpResponseBodyConverter(boolean isStreaming) {
+      this.isStreaming = isStreaming;
+    }
+
+    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+      if (isStreaming) {
+        return value;
+      }
+
+      // Buffer the entire body to avoid future I/O.
+      try {
+        return Utils.readBodyToBytesIfNecessary(value);
+      } finally {
+        closeQuietly(value);
+      }
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index 30b09ba3e..9e96e45c5 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -17,9 +17,20 @@
 
 import java.io.IOException;
 
+/**
+ * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
+ * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
+ * calls with the same parameters to the same webserver; this may be used to implement polling or
+ * to retry a failed call.
+ *
+ * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
+ * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
+ * is busy writing its request or reading its response may receive a {@link IOException}; this is
+ * working as designed.
+ */
 public interface Call<T> extends Cloneable {
-  void enqueue(Callback<T> callback);
   Response<T> execute() throws IOException;
+  void enqueue(Callback<T> callback);
   void cancel();
   Call<T> clone();
 }
diff --git a/retrofit/src/main/java/retrofit/CallAdapter.java b/retrofit/src/main/java/retrofit/CallAdapter.java
index 51a1678f1..d8dba7b00 100644
--- a/retrofit/src/main/java/retrofit/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -15,13 +15,29 @@
  */
 package retrofit;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
+/** Adapts a {@link Call} into the type of {@code T}. */
 public interface CallAdapter<T> {
+  /**
+   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+   * is used to prepare the {@code call} passed to {@code #adapt}.
+   *
+   * <p>Note that this is typically not the same type as the {@code returnType} provided to
+   * this call adapter's factory.
+   */
   Type responseType();
-  Object adapt(Call<T> call);
+
+  /** Returns an instance of the {@code T} which adapts the execution of {@code call}. */
+  <R> T adapt(Call<R> call);
 
   interface Factory {
-    CallAdapter<?> get(Type returnType);
+    /**
+     * Returns a call adapter for interface methods that return {@code returnType}, or null if this
+     * factory doesn't adapt that type.
+     */
+    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index e62e20d07..71ccd0e95 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -30,8 +30,8 @@
  */
 public interface Callback<T> {
   /** Successful HTTP response. */
-  void success(Response<T> response);
+  void onResponse(Response<T> response, Retrofit retrofit);
 
   /** Invoked when a network or unexpected exception occurred during the HTTP request. */
-  void failure(Throwable t);
+  void onFailure(Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
index 7405a9898..d4c2f228e 100644
--- a/retrofit/src/main/java/retrofit/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -18,17 +18,31 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** Convert objects to and from their representation as HTTP bodies. */
-public interface Converter<T> {
-  /** Convert an HTTP response body to a concrete object of the specified type. */
-  T fromBody(ResponseBody body) throws IOException;
+/**
+ * Convert objects to and from their representation as HTTP bodies. Register a converter with
+ * Retrofit using {@link Retrofit.Builder#addConverterFactory(Factory)}.
+ */
+public interface Converter<F, T> {
+  T convert(F value) throws IOException;
 
-  /** Convert an object to an appropriate representation for HTTP transport. */
-  RequestBody toBody(T value);
+  abstract class Factory {
+    /**
+     * Create a {@link Converter} for converting an HTTP response body to {@code type} or null if it
+     * cannot be handled by this factory.
+     */
+    public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+      return null;
+    }
 
-  interface Factory {
-    Converter<?> get(Type type);
+    /**
+     * Create a {@link Converter} for converting {@code type} to an HTTP request body or null if it
+     * cannot be handled by this factory.
+     */
+    public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+      return null;
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
new file mode 100644
index 000000000..64f9bf913
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A call adapter that uses the same thread for both I/O and application-level callbacks. For
+ * synchronous calls this is the application thread making the request; for asynchronous calls this
+ * is a thread provided by OkHttp's dispatcher.
+ */
+final class DefaultCallAdapter implements CallAdapter<Call<?>> {
+  static final Factory FACTORY = new Factory() {
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      if (Utils.getRawType(returnType) != Call.class) {
+        return null;
+      }
+      Type responseType = Utils.getCallResponseType(returnType);
+      return new DefaultCallAdapter(responseType);
+    }
+  };
+
+  private final Type responseType;
+
+  DefaultCallAdapter(Type responseType) {
+    this.responseType = responseType;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public <R> Call<R> adapt(Call<R> call) {
+    return call;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
deleted file mode 100644
index 52d0e819c..000000000
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-
-final class ExceptionCatchingRequestBody extends ResponseBody {
-  private final ResponseBody delegate;
-  private IOException thrownException;
-
-  ExceptionCatchingRequestBody(ResponseBody delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() throws IOException {
-    try {
-      return delegate.contentLength();
-    } catch (IOException e) {
-      thrownException = e;
-      throw e;
-    }
-  }
-
-  @Override public BufferedSource source() throws IOException {
-    BufferedSource delegateSource;
-    try {
-      delegateSource = delegate.source();
-    } catch (IOException e) {
-      thrownException = e;
-      throw e;
-    }
-    return Okio.buffer(new ForwardingSource(delegateSource) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        try {
-          return super.read(sink, byteCount);
-        } catch (IOException e) {
-          thrownException = e;
-          throw e;
-        }
-      }
-    });
-  }
-
-  @Override public void close() throws IOException {
-    delegate.close();
-  }
-
-  void throwIfCaught() throws IOException {
-    if (thrownException != null) {
-      throw thrownException;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
index 8196101e3..06a29ddae 100644
--- a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -16,6 +16,7 @@
 package retrofit;
 
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
 
@@ -26,21 +27,18 @@
     this.callbackExecutor = callbackExecutor;
   }
 
-  @Override public String toString() {
-    return "ExecutorCallAdapterFactory[" + callbackExecutor + ']';
-  }
-
-  @Override public CallAdapter<?> get(Type returnType) {
+  @Override
+  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (Utils.getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object>() {
+    return new CallAdapter<Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public Call<Object> adapt(Call<Object> call) {
+      @Override public <R> Call<R> adapt(Call<R> call) {
         return new ExecutorCallbackCall<>(callbackExecutor, call);
       }
     };
@@ -82,18 +80,18 @@
       this.delegate = delegate;
     }
 
-    @Override public void success(final Response<T> response) {
+    @Override public void onResponse(final Response<T> response, final Retrofit retrofit) {
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          delegate.success(response);
+          delegate.onResponse(response, retrofit);
         }
       });
     }
 
-    @Override public void failure(final Throwable t) {
+    @Override public void onFailure(final Throwable t) {
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          delegate.failure(t);
+          delegate.onFailure(t);
         }
       });
     }
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
index f0231aef8..4ec92c145 100644
--- a/retrofit/src/main/java/retrofit/MethodHandler.java
+++ b/retrofit/src/main/java/retrofit/MethodHandler.java
@@ -15,83 +15,63 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import retrofit.http.Streaming;
-
-import static retrofit.Utils.methodError;
 
 final class MethodHandler<T> {
   @SuppressWarnings("unchecked")
-  static MethodHandler<?> create(Method method, OkHttpClient client, BaseUrl baseUrl,
-      CallAdapter.Factory callAdapterFactory, Converter.Factory converterFactory) {
-    CallAdapter<Object> callAdapter =
-        (CallAdapter<Object>) createCallAdapter(method, callAdapterFactory);
-    Converter<Object> responseConverter =
-        (Converter<Object>) createResponseConverter(method, callAdapter.responseType(),
-            converterFactory);
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactory);
-    return new MethodHandler<>(client, requestFactory, callAdapter, responseConverter);
+  static MethodHandler<?> create(Retrofit retrofit, Method method) {
+    CallAdapter<Object> callAdapter = (CallAdapter<Object>) createCallAdapter(method, retrofit);
+    Type responseType = callAdapter.responseType();
+    Converter<ResponseBody, Object> responseConverter =
+        (Converter<ResponseBody, Object>) createResponseConverter(method, retrofit, responseType);
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
+    return new MethodHandler<>(retrofit, requestFactory, callAdapter, responseConverter);
   }
 
-  private static CallAdapter<?> createCallAdapter(Method method,
-      CallAdapter.Factory adapterFactory) {
+  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
-      throw methodError(method,
+      throw Utils.methodError(method,
           "Method return type must not include a type variable or wildcard: %s", returnType);
     }
-
     if (returnType == void.class) {
-      throw methodError(method, "Service methods cannot return void.");
+      throw Utils.methodError(method, "Service methods cannot return void.");
     }
-
-    CallAdapter<?> adapter = adapterFactory.get(returnType);
-    if (adapter == null) {
-      throw methodError(method, "Call adapter factory '%s' was unable to handle return type %s",
-          adapterFactory, returnType);
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
     }
-    return adapter;
   }
 
-  private static Converter<?> createResponseConverter(Method method, Type responseType,
-      Converter.Factory converterFactory) {
-    if (responseType == ResponseBody.class) {
-      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
-      return new OkHttpResponseBodyConverter(isStreaming);
-    }
-
-    if (converterFactory == null) {
-      throw methodError(method, "Method response type is "
-          + responseType
-          + " but no converter factory registered. "
-          + "Either add a converter factory to the Retrofit instance or use ResponseBody.");
-    }
-
-    Converter<?> converter = converterFactory.get(responseType);
-    if (converter == null) {
-      throw methodError(method, "Converter factory '%s' was unable to handle response type %s",
-          converterFactory, responseType);
+  private static Converter<ResponseBody, ?> createResponseConverter(Method method,
+      Retrofit retrofit, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw Utils.methodError(e, method, "Unable to create converter for %s", responseType);
     }
-    return converter;
   }
 
-  private final OkHttpClient client;
+  private final Retrofit retrofit;
   private final RequestFactory requestFactory;
   private final CallAdapter<T> callAdapter;
-  private final Converter<T> responseConverter;
+  private final Converter<ResponseBody, T> responseConverter;
 
-  private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
-      CallAdapter<T> callAdapter, Converter<T> responseConverter) {
-    this.client = client;
+  private MethodHandler(Retrofit retrofit, RequestFactory requestFactory,
+      CallAdapter<T> callAdapter, Converter<ResponseBody, T> responseConverter) {
+    this.retrofit = retrofit;
     this.requestFactory = requestFactory;
     this.callAdapter = callAdapter;
     this.responseConverter = responseConverter;
   }
 
   Object invoke(Object... args) {
-    return callAdapter.adapt(new OkHttpCall<>(client, requestFactory, responseConverter, args));
+    return callAdapter.adapt(new OkHttpCall<>(retrofit, requestFactory, responseConverter, args));
   }
 }
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index 6ba1ca996..e649fee74 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -15,25 +15,30 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
 
 import static retrofit.Utils.closeQuietly;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final OkHttpClient client;
+  private final Retrofit retrofit;
   private final RequestFactory requestFactory;
-  private final Converter<T> responseConverter;
+  private final Converter<ResponseBody, T> responseConverter;
   private final Object[] args;
 
   private volatile com.squareup.okhttp.Call rawCall;
   private boolean executed; // Guarded by this.
+  private volatile boolean canceled;
 
-  OkHttpCall(OkHttpClient client, RequestFactory requestFactory, Converter<T> responseConverter,
-      Object[] args) {
-    this.client = client;
+  OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,
+      Converter<ResponseBody, T> responseConverter, Object[] args) {
+    this.retrofit = retrofit;
     this.requestFactory = requestFactory;
     this.responseConverter = responseConverter;
     this.args = args;
@@ -41,10 +46,10 @@
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(client, requestFactory, responseConverter, args);
+    return new OkHttpCall<>(retrofit, requestFactory, responseConverter, args);
   }
 
-  public void enqueue(final Callback<T> callback) {
+  @Override public void enqueue(final Callback<T> callback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
       executed = true;
@@ -54,15 +59,18 @@ public void enqueue(final Callback<T> callback) {
     try {
       rawCall = createRawCall();
     } catch (Throwable t) {
-      callback.failure(t);
+      callback.onFailure(t);
       return;
     }
+    if (canceled) {
+      rawCall.cancel();
+    }
     this.rawCall = rawCall;
 
     rawCall.enqueue(new com.squareup.okhttp.Callback() {
       private void callFailure(Throwable e) {
         try {
-          callback.failure(e);
+          callback.onFailure(e);
         } catch (Throwable t) {
           t.printStackTrace();
         }
@@ -70,7 +78,7 @@ private void callFailure(Throwable e) {
 
       private void callSuccess(Response<T> response) {
         try {
-          callback.success(response);
+          callback.onResponse(response, retrofit);
         } catch (Throwable t) {
           t.printStackTrace();
         }
@@ -81,10 +89,10 @@ private void callSuccess(Response<T> response) {
       }
 
       @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
-        final Response<T> response;
+        Response<T> response;
         try {
           response = parseResponse(rawResponse);
-        } catch (final Throwable e) {
+        } catch (Throwable e) {
           callFailure(e);
           return;
         }
@@ -99,14 +107,17 @@ private void callSuccess(Response<T> response) {
       executed = true;
     }
 
-    final com.squareup.okhttp.Call rawCall = createRawCall();
+    com.squareup.okhttp.Call rawCall = createRawCall();
+    if (canceled) {
+      rawCall.cancel();
+    }
     this.rawCall = rawCall;
 
     return parseResponse(rawCall.execute());
   }
 
   private com.squareup.okhttp.Call createRawCall() {
-    return client.newCall(requestFactory.create(args));
+    return retrofit.client().newCall(requestFactory.create(args));
   }
 
   private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
@@ -134,7 +145,7 @@ private void callSuccess(Response<T> response) {
 
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
-      T body = responseConverter.fromBody(catchingBody);
+      T body = responseConverter.convert(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -145,10 +156,84 @@ private void callSuccess(Response<T> response) {
   }
 
   public void cancel() {
+    canceled = true;
     com.squareup.okhttp.Call rawCall = this.rawCall;
-    if (rawCall == null) {
-      throw new IllegalStateException("enqueue or execute must be called first");
+    if (rawCall != null) {
+      rawCall.cancel();
+    }
+  }
+
+  static final class NoContentResponseBody extends ResponseBody {
+    private final MediaType contentType;
+    private final long contentLength;
+
+    NoContentResponseBody(MediaType contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public long contentLength() throws IOException {
+      return contentLength;
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      throw new IllegalStateException("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  static final class ExceptionCatchingRequestBody extends ResponseBody {
+    private final ResponseBody delegate;
+    private IOException thrownException;
+
+    ExceptionCatchingRequestBody(ResponseBody delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public MediaType contentType() {
+      return delegate.contentType();
+    }
+
+    @Override public long contentLength() throws IOException {
+      try {
+        return delegate.contentLength();
+      } catch (IOException e) {
+        thrownException = e;
+        throw e;
+      }
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      BufferedSource delegateSource;
+      try {
+        delegateSource = delegate.source();
+      } catch (IOException e) {
+        thrownException = e;
+        throw e;
+      }
+      return Okio.buffer(new ForwardingSource(delegateSource) {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          try {
+            return super.read(sink, byteCount);
+          } catch (IOException e) {
+            thrownException = e;
+            throw e;
+          }
+        }
+      });
+    }
+
+    @Override public void close() throws IOException {
+      delegate.close();
+    }
+
+    void throwIfCaught() throws IOException {
+      if (thrownException != null) {
+        throw thrownException;
+      }
     }
-    rawCall.cancel();
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 4f694322b..b28337158 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -18,10 +18,10 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import com.squareup.okhttp.OkHttpClient;
-import java.lang.reflect.Type;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -38,7 +38,11 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-
+    try {
+      Class.forName("java.util.Optional");
+      return new Java8();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
@@ -46,20 +50,36 @@ private static Platform findPlatform() {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
-    return new NothingCallAdapterFactory();
+    return DefaultCallAdapter.FACTORY;
+  }
+
+  boolean isDefaultMethod(Method method) {
+    return false;
+  }
+
+  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+      throws Throwable {
+    throw new UnsupportedOperationException();
   }
 
-  OkHttpClient defaultClient() {
-    OkHttpClient client = new OkHttpClient();
-    client.setConnectTimeout(15, TimeUnit.SECONDS);
-    client.setReadTimeout(15, TimeUnit.SECONDS);
-    client.setWriteTimeout(15, TimeUnit.SECONDS);
-    return client;
+  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+  static class Java8 extends Platform {
+    @Override boolean isDefaultMethod(Method method) {
+      return method.isDefault();
+    }
+
+    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+        Object... args) throws Throwable {
+      return MethodHandles.lookup()
+          .in(declaringClass)
+          .unreflectSpecial(method, declaringClass)
+          .bindTo(object)
+          .invokeWithArguments(args);
+    }
   }
 
-  /** Provides sane defaults for operation on Android. */
   static class Android extends Platform {
-    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
       if (callbackExecutor == null) {
         callbackExecutor = new MainThreadExecutor();
       }
@@ -72,40 +92,6 @@ OkHttpClient defaultClient() {
       @Override public void execute(Runnable r) {
         handler.post(r);
       }
-
-      @Override public String toString() {
-        return "MainThreadExecutor";
-      }
-    }
-  }
-
-  static final class NothingCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<?> get(Type returnType) {
-      if (Utils.getRawType(returnType) != Call.class) {
-        return null;
-      }
-      Type responseType = Utils.getCallResponseType(returnType);
-      return new NothingCallAdapter<>(responseType);
-    }
-
-    @Override public String toString() {
-      return "Default";
-    }
-
-    static final class NothingCallAdapter<T> implements CallAdapter<T> {
-      private final Type responseType;
-
-      NothingCallAdapter(Type responseType) {
-        this.responseType = responseType;
-      }
-
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public Call<T> adapt(Call<T> call) {
-        return call;
-      }
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index b620f3aad..65eed2c1a 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -23,11 +23,14 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
+import okio.Buffer;
 import okio.BufferedSink;
 
 final class RequestBuilder {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+
   private final String method;
 
   private final HttpUrl baseUrl;
@@ -35,7 +38,7 @@
   private HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType mediaType;
+  private MediaType contentType;
 
   private final boolean hasBody;
   private MultipartBuilder multipartBuilder;
@@ -43,20 +46,17 @@
   private RequestBody body;
 
   RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
-
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
+    this.requestBuilder = new Request.Builder();
+    this.contentType = contentType;
+    this.hasBody = hasBody;
 
-    Request.Builder requestBuilder = new Request.Builder();
     if (headers != null) {
       requestBuilder.headers(headers);
     }
-    this.requestBuilder = requestBuilder;
-    this.mediaType = mediaType;
-
-    this.hasBody = hasBody;
 
     if (isFormEncoded) {
       // Will be set to 'body' in 'build'.
@@ -64,6 +64,7 @@
     } else if (isMultipart) {
       // Will be set to 'body' in 'build'.
       multipartBuilder = new MultipartBuilder();
+      multipartBuilder.type(MultipartBuilder.FORM);
     }
   }
 
@@ -73,7 +74,7 @@ void setRelativeUrl(String relativeUrl) {
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      mediaType = MediaType.parse(value);
+      contentType = MediaType.parse(value);
     } else {
       requestBuilder.addHeader(name, value);
     }
@@ -84,20 +85,55 @@ void addPathParam(String name, String value, boolean encoded) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    try {
-      if (!encoded) {
-        String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
-        // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
-        // encode spaces rather than +. Query encoding difference specified in HTML spec.
-        // Any remaining plus signs represent spaces as already URLEncoded.
-        encodedValue = encodedValue.replace("+", "%20");
-        relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));
+  }
+
+  static String canonicalize(String input, boolean alreadyEncoded) {
+    int codePoint;
+    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, 0, i);
+        canonicalize(out, input, i, limit, alreadyEncoded);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters required encoding.
+    return input;
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit, boolean alreadyEncoded) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
       } else {
-        relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
       }
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
     }
   }
 
@@ -154,12 +190,12 @@ Request build() {
       }
     }
 
-    MediaType mediaType = this.mediaType;
-    if (mediaType != null) {
+    MediaType contentType = this.contentType;
+    if (contentType != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, mediaType);
+        body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        requestBuilder.addHeader("Content-Type", mediaType.toString());
+        requestBuilder.addHeader("Content-Type", contentType.toString());
       }
     }
 
@@ -169,17 +205,17 @@ Request build() {
         .build();
   }
 
-  private static class MediaTypeOverridingRequestBody extends RequestBody {
+  private static class ContentTypeOverridingRequestBody extends RequestBody {
     private final RequestBody delegate;
-    private final MediaType mediaType;
+    private final MediaType contentType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, MediaType mediaType) {
+    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
       this.delegate = delegate;
-      this.mediaType = mediaType;
+      this.contentType = contentType;
     }
 
     @Override public MediaType contentType() {
-      return mediaType;
+      return contentType;
     }
 
     @Override public long contentLength() throws IOException {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
index bc8b1a472..eea1b0520 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilderAction.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
@@ -16,6 +16,9 @@
 package retrofit;
 
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.util.Map;
 
@@ -189,9 +192,9 @@
 
   static final class Part<T> extends RequestBuilderAction {
     private final Headers headers;
-    private final Converter<T> converter;
+    private final Converter<T, RequestBody> converter;
 
-    Part(Headers headers, Converter<T> converter) {
+    Part(Headers headers, Converter<T, RequestBody> converter) {
       this.headers = headers;
       this.converter = converter;
     }
@@ -199,18 +202,26 @@
     @Override void perform(RequestBuilder builder, Object value) {
       if (value == null) return; // Skip null values.
 
-      //noinspection unchecked
-      builder.addPart(headers, converter.toBody((T) value));
+      RequestBody body;
+      try {
+        //noinspection unchecked
+        body = converter.convert((T) value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody");
+      }
+      builder.addPart(headers, body);
     }
   }
 
   static final class PartMap extends RequestBuilderAction {
-    private final Converter.Factory converterFactory;
+    private final Retrofit retrofit;
     private final String transferEncoding;
+    private final Annotation[] annotations;
 
-    PartMap(Converter.Factory converterFactory, String transferEncoding) {
-      this.converterFactory = converterFactory;
+    PartMap(Retrofit retrofit, String transferEncoding, Annotation[] annotations) {
+      this.retrofit = retrofit;
       this.transferEncoding = transferEncoding;
+      this.annotations = annotations;
     }
 
     @Override void perform(RequestBuilder builder, Object value) {
@@ -228,20 +239,28 @@
         }
 
         Headers headers = Headers.of(
-            "Content-Disposition", "name=\"" + entryKey + "\"",
+            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
             "Content-Transfer-Encoding", transferEncoding);
+
+        Class<?> entryClass = entryValue.getClass();
         //noinspection unchecked
-        Converter<Object> converter =
-            (Converter<Object>) converterFactory.get(entryValue.getClass());
-        builder.addPart(headers, converter.toBody(entryValue));
+        Converter<Object, RequestBody> converter =
+            (Converter<Object, RequestBody>) retrofit.requestConverter(entryClass, annotations);
+        RequestBody body;
+        try {
+          body = converter.convert(entryValue);
+        } catch (IOException e) {
+          throw new RuntimeException("Unable to convert " + entryValue + " to RequestBody");
+        }
+        builder.addPart(headers, body);
       }
     }
   }
 
   static final class Body<T> extends RequestBuilderAction {
-    private final Converter<T> converter;
+    private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T> converter) {
+    Body(Converter<T, RequestBody> converter) {
       this.converter = converter;
     }
 
@@ -249,8 +268,14 @@
       if (value == null) {
         throw new IllegalArgumentException("Body parameter value must not be null.");
       }
-      //noinspection unchecked
-      builder.setBody(converter.toBody((T) value));
+      RequestBody body;
+      try {
+        //noinspection unchecked
+        body = converter.convert((T) value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody");
+      }
+      builder.setBody(body);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
index 99f0891e8..0e1668198 100644
--- a/retrofit/src/main/java/retrofit/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit/RequestFactory.java
@@ -24,20 +24,20 @@
   private final BaseUrl baseUrl;
   private final String relativeUrl;
   private final Headers headers;
-  private final MediaType mediaType;
+  private final MediaType contentType;
   private final boolean hasBody;
   private final boolean isFormEncoded;
   private final boolean isMultipart;
   private final RequestBuilderAction[] requestBuilderActions;
 
   RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
       RequestBuilderAction[] requestBuilderActions) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
     this.headers = headers;
-    this.mediaType = mediaType;
+    this.contentType = contentType;
     this.hasBody = hasBody;
     this.isFormEncoded = isFormEncoded;
     this.isMultipart = isMultipart;
@@ -46,11 +46,18 @@
 
   Request create(Object... args) {
     RequestBuilder requestBuilder =
-        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, mediaType, hasBody,
+        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
             isFormEncoded, isMultipart);
 
     if (args != null) {
       RequestBuilderAction[] actions = requestBuilderActions;
+      if (actions.length != args.length) {
+        throw new IllegalArgumentException("Argument count ("
+            + args.length
+            + ") doesn't match action count ("
+            + actions.length
+            + ")");
+      }
       for (int i = 0, count = args.length; i < count; i++) {
         actions[i].perform(requestBuilder, args[i]);
       }
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
index bdac016cd..4d807ded0 100644
--- a/retrofit/src/main/java/retrofit/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -48,18 +48,17 @@
 
 import static retrofit.Utils.methodError;
 
-/** Request metadata about a service interface declaration. */
 final class RequestFactoryParser {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-  static RequestFactory parse(Method method, BaseUrl baseUrl, Converter.Factory converterFactory) {
+  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
     RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations();
-    parser.parseParameters(converterFactory);
-    return parser.toRequestFactory(baseUrl);
+    parser.parseMethodAnnotations(responseType);
+    parser.parseParameters(retrofit);
+    return parser.toRequestFactory(retrofit.baseUrl());
   }
 
   private final Method method;
@@ -70,7 +69,7 @@ static RequestFactory parse(Method method, BaseUrl baseUrl, Converter.Factory co
   private boolean isMultipart;
   private String relativeUrl;
   private com.squareup.okhttp.Headers headers;
-  private MediaType mediaType;
+  private MediaType contentType;
   private RequestBuilderAction[] requestBuilderActions;
 
   private Set<String> relativeUrlParamNames;
@@ -80,15 +79,20 @@ private RequestFactoryParser(Method method) {
   }
 
   private RequestFactory toRequestFactory(BaseUrl baseUrl) {
-    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, mediaType, hasBody,
+    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
         isFormEncoded, isMultipart, requestBuilderActions);
   }
 
+  private RuntimeException parameterError(Throwable cause, int index, String message,
+      Object... args) {
+    return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
+  }
+
   private RuntimeException parameterError(int index, String message, Object... args) {
     return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
   }
 
-  private void parseMethodAnnotations() {
+  private void parseMethodAnnotations(Type responseType) {
     for (Annotation annotation : method.getAnnotations()) {
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
@@ -96,6 +100,9 @@ private void parseMethodAnnotations() {
         parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
       } else if (annotation instanceof HEAD) {
         parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+        if (!Void.class.equals(responseType)) {
+          throw methodError(method, "HEAD method must use Void as response type.");
+        }
       } else if (annotation instanceof PATCH) {
         parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
       } else if (annotation instanceof POST) {
@@ -179,7 +186,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
       if ("Content-Type".equalsIgnoreCase(headerName)) {
-        mediaType = MediaType.parse(headerValue);
+        contentType = MediaType.parse(headerValue);
       } else {
         builder.add(headerName, headerValue);
       }
@@ -187,7 +194,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
     return builder.build();
   }
 
-  private void parseParameters(Converter.Factory converterFactory) {
+  private void parseParameters(Retrofit retrofit) {
     Type[] methodParameterTypes = method.getGenericParameterTypes();
     Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
 
@@ -205,10 +212,7 @@ private void parseParameters(Converter.Factory converterFactory) {
       Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
       if (methodParameterAnnotations != null) {
         for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          if (requestBuilderActions[i] != null) {
-            throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
-          }
-
+          RequestBuilderAction action = null;
           if (methodParameterAnnotation instanceof Url) {
             if (gotUrl) {
               throw parameterError(i, "Multiple @Url method annotations found.");
@@ -226,7 +230,7 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
             }
             gotUrl = true;
-            requestBuilderActions[i] = new RequestBuilderAction.Url();
+            action = new RequestBuilderAction.Url();
 
           } else if (methodParameterAnnotation instanceof Path) {
             if (gotQuery) {
@@ -244,12 +248,11 @@ private void parseParameters(Converter.Factory converterFactory) {
             Path path = (Path) methodParameterAnnotation;
             String name = path.value();
             validatePathName(i, name);
-            requestBuilderActions[i] = new RequestBuilderAction.Path(name, path.encoded());
+            action = new RequestBuilderAction.Path(name, path.encoded());
 
           } else if (methodParameterAnnotation instanceof Query) {
             Query query = (Query) methodParameterAnnotation;
-            requestBuilderActions[i] =
-                new RequestBuilderAction.Query(query.value(), query.encoded());
+            action = new RequestBuilderAction.Query(query.value(), query.encoded());
             gotQuery = true;
 
           } else if (methodParameterAnnotation instanceof QueryMap) {
@@ -257,19 +260,18 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "@QueryMap parameter type must be Map.");
             }
             QueryMap queryMap = (QueryMap) methodParameterAnnotation;
-            requestBuilderActions[i] = new RequestBuilderAction.QueryMap(queryMap.encoded());
+            action = new RequestBuilderAction.QueryMap(queryMap.encoded());
 
           } else if (methodParameterAnnotation instanceof Header) {
             Header header = (Header) methodParameterAnnotation;
-            requestBuilderActions[i] = new RequestBuilderAction.Header(header.value());
+            action = new RequestBuilderAction.Header(header.value());
 
           } else if (methodParameterAnnotation instanceof Field) {
             if (!isFormEncoded) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
             Field field = (Field) methodParameterAnnotation;
-            requestBuilderActions[i] =
-                new RequestBuilderAction.Field(field.value(), field.encoded());
+            action = new RequestBuilderAction.Field(field.value(), field.encoded());
             gotField = true;
 
           } else if (methodParameterAnnotation instanceof FieldMap) {
@@ -280,7 +282,7 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "@FieldMap parameter type must be Map.");
             }
             FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
-            requestBuilderActions[i] = new RequestBuilderAction.FieldMap(fieldMap.encoded());
+            action = new RequestBuilderAction.FieldMap(fieldMap.encoded());
             gotField = true;
 
           } else if (methodParameterAnnotation instanceof Part) {
@@ -289,21 +291,17 @@ private void parseParameters(Converter.Factory converterFactory) {
             }
             Part part = (Part) methodParameterAnnotation;
             com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "name=\"" + part.value() + "\"",
+                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
                 "Content-Transfer-Encoding", part.encoding());
-            Converter<?> converter;
-            if (methodParameterType == RequestBody.class) {
-              converter = new OkHttpRequestBodyConverter();
-            } else {
-              if (converterFactory == null) {
-                throw parameterError(i, "@Part parameter is %s"
-                    + " but no converter factory registered. Either add a converter factory"
-                    + " to the Retrofit instance or use RequestBody.",
-                    methodParameterType);
-              }
-              converter = converterFactory.get(methodParameterType);
+            Converter<?, RequestBody> converter;
+            try {
+              converter =
+                  retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+              throw parameterError(e, i, "Unable to create @Part converter for %s",
+                  methodParameterType);
             }
-            requestBuilderActions[i] = new RequestBuilderAction.Part<>(headers, converter);
+            action = new RequestBuilderAction.Part<>(headers, converter);
             gotPart = true;
 
           } else if (methodParameterAnnotation instanceof PartMap) {
@@ -315,8 +313,8 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
             PartMap partMap = (PartMap) methodParameterAnnotation;
-            requestBuilderActions[i] =
-                new RequestBuilderAction.PartMap(converterFactory, partMap.encoding());
+            action = new RequestBuilderAction.PartMap(retrofit, partMap.encoding(),
+                methodParameterAnnotations);
             gotPart = true;
 
           } else if (methodParameterAnnotation instanceof Body) {
@@ -328,22 +326,24 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "Multiple @Body method annotations found.");
             }
 
-            Converter<?> converter;
-            if (methodParameterType == RequestBody.class) {
-              converter = new OkHttpRequestBodyConverter();
-            } else {
-              if (converterFactory == null) {
-                throw parameterError(i, "@Body parameter is %s"
-                        + " but no converter factory registered. Either add a converter factory"
-                        + " to the Retrofit instance or use RequestBody.",
-                    methodParameterType);
-              }
-              converter = converterFactory.get(methodParameterType);
+            Converter<?, RequestBody> converter;
+            try {
+              converter =
+                  retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+              throw parameterError(e, i, "Unable to create @Body converter for %s",
+                  methodParameterType);
             }
-
-            requestBuilderActions[i] = new RequestBuilderAction.Body<>(converter);
+            action = new RequestBuilderAction.Body<>(converter);
             gotBody = true;
           }
+
+          if (action != null) {
+            if (requestBuilderActions[i] != null) {
+              throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
+            }
+            requestBuilderActions[i] = action;
+          }
         }
       }
 
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
index b3a63e616..f653ca5d1 100644
--- a/retrofit/src/main/java/retrofit/Response.java
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -29,7 +29,7 @@
   /**
    * TODO
    */
-  public static <T> Response<T> fakeSuccess(T body) {
+  public static <T> Response<T> success(T body) {
     return success(body, new com.squareup.okhttp.Response.Builder() //
         .code(200)
         .protocol(Protocol.HTTP_1_1)
@@ -48,7 +48,7 @@
   /**
    * TODO
    */
-  public static <T> Response<T> fakeError(int code, ResponseBody body) {
+  public static <T> Response<T> error(int code, ResponseBody body) {
     return error(body, new com.squareup.okhttp.Response.Builder() //
         .code(code)
         .protocol(Protocol.HTTP_1_1)
@@ -84,6 +84,11 @@ public int code() {
     return rawResponse.code();
   }
 
+  /** HTTP status message. */
+  public String message() {
+    return rawResponse.message();
+  }
+
   public Headers headers() {
     return rawResponse.headers();
   }
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index b50751631..f9024b5a7 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -19,10 +19,15 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import retrofit.http.HTTP;
@@ -48,10 +53,8 @@
  * {@link retrofit.http.Query @Query}.
  * <p>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
- * will be converted to request representation by a call to
- * {@link Converter#toBody(Object) toBody}
- * on the supplied {@link Converter} for this instance. A {@link RequestBody} can also be used
- * which will not use the {@code Converter}.
+ * will be converted to request representation by one of the {@link Converter.Factory} instances.
+ * A {@link RequestBody} can also be used for a raw representation.
  * <p>
  * Alternative request body formats are supported by method annotations and corresponding parameter
  * annotations:
@@ -67,9 +70,9 @@
  * annotate a parameter with {@link Header @Header}.
  * <p>
  * By default, methods return a {@link Call} which represents the HTTP request. The generic
- * parameter of the call is the response body type and will be converted by a call to
- * {@link Converter#fromBody(ResponseBody) fromBody} on the supplied {@link Converter} for
- * this instance. {@link ResponseBody} can also be used which will not use the {@code Converter}.
+ * parameter of the call is the response body type and will be converted by one of the
+ * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+ * representation. {@link Void} can be used if you do not care about the body contents.
  * <p>
  * For example:
  * <pre>
@@ -90,43 +93,62 @@
 
   private final OkHttpClient client;
   private final BaseUrl baseUrl;
-  private final Converter.Factory converterFactory;
-  private final CallAdapter.Factory adapterFactory;
+  private final List<Converter.Factory> converterFactories;
+  private final List<CallAdapter.Factory> adapterFactories;
   private final Executor callbackExecutor;
+  private final boolean validateEagerly;
 
-  private Retrofit(OkHttpClient client, BaseUrl baseUrl, Converter.Factory converterFactory,
-      CallAdapter.Factory adapterFactory, Executor callbackExecutor) {
+  private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
+      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
+      boolean validateEagerly) {
     this.client = client;
     this.baseUrl = baseUrl;
-    this.converterFactory = converterFactory;
-    this.adapterFactory = adapterFactory;
+    this.converterFactories = converterFactories;
+    this.adapterFactories = adapterFactories;
     this.callbackExecutor = callbackExecutor;
+    this.validateEagerly = validateEagerly;
   }
 
   /** Create an implementation of the API defined by the {@code service} interface. */
-  @SuppressWarnings("unchecked") // Single interface proxy creation guarded by parameter safety.
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  public <T> T create(final Class<T> service) {
+    Utils.validateServiceInterface(service);
+    if (validateEagerly) {
+      eagerlyValidateMethods(service);
+    }
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        handler);
+        new InvocationHandler() {
+          private final Platform platform = Platform.get();
+
+          @Override public Object invoke(Object proxy, Method method, Object... args)
+              throws Throwable {
+            // If the method is a method from Object then defer to normal invocation.
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            if (platform.isDefaultMethod(method)) {
+              return platform.invokeDefaultMethod(method, service, proxy, args);
+            }
+            return loadMethodHandler(method).invoke(args);
+          }
+        });
   }
 
-  private final InvocationHandler handler = new InvocationHandler() {
-    @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
+  private void eagerlyValidateMethods(Class<?> service) {
+    Platform platform = Platform.get();
+    for (Method method : service.getDeclaredMethods()) {
+      if (!platform.isDefaultMethod(method)) {
+        loadMethodHandler(method);
       }
-      return loadMethodHandler(method).invoke(args);
     }
-  };
+  }
 
   MethodHandler<?> loadMethodHandler(Method method) {
     MethodHandler<?> handler;
     synchronized (methodHandlerCache) {
       handler = methodHandlerCache.get(method);
       if (handler == null) {
-        handler = MethodHandler.create(method, client, baseUrl, adapterFactory, converterFactory);
+        handler = MethodHandler.create(this, method);
         methodHandlerCache.put(method, handler);
       }
     }
@@ -141,17 +163,107 @@ public BaseUrl baseUrl() {
     return baseUrl;
   }
 
+  public List<CallAdapter.Factory> callAdapterFactories() {
+    return Collections.unmodifiableList(adapterFactories);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories}.
+   */
+  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+    return nextCallAdapter(null, returnType, annotations);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories} except {@code skipPast}.
+   */
+  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+      Annotation[] annotations) {
+    checkNotNull(returnType, "returnType == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = adapterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      if (adapter != null) {
+        return adapter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+        .append(returnType)
+        .append(". Tried:");
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+    }
+    if (skipPast != null) {
+      builder.append("\nSkipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+      }
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
   /**
    * TODO
-   * <p>
-   * May be null.
    */
-  public Converter.Factory converterFactory() {
-    return converterFactory;
+  public List<Converter.Factory> converterFactories() {
+    return Collections.unmodifiableList(converterFactories);
   }
 
-  public CallAdapter.Factory callAdapterFactory() {
-    return adapterFactory;
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+   * {@linkplain #converterFactories() factories}.
+   */
+  public <T> Converter<T, RequestBody> requestConverter(Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<?, RequestBody> converter =
+          converterFactories.get(i).toRequestBody(type, annotations);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<T, RequestBody>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+        .append(type)
+        .append(". Tried:");
+    for (Converter.Factory converterFactory : converterFactories) {
+      builder.append("\n * ").append(converterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+   * {@linkplain #converterFactories() factories}.
+   */
+  public <T> Converter<ResponseBody, T> responseConverter(Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<ResponseBody, ?> converter =
+          converterFactories.get(i).fromResponseBody(type, annotations);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<ResponseBody, T>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+        .append(type)
+        .append(". Tried:");
+    for (Converter.Factory converterFactory : converterFactories) {
+      builder.append("\n * ").append(converterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
   }
 
   public Executor callbackExecutor() {
@@ -167,9 +279,16 @@ public Executor callbackExecutor() {
   public static final class Builder {
     private OkHttpClient client;
     private BaseUrl baseUrl;
-    private Converter.Factory converterFactory;
-    private CallAdapter.Factory adapterFactory;
+    private List<Converter.Factory> converterFactories = new ArrayList<>();
+    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
     private Executor callbackExecutor;
+    private boolean validateEagerly;
+
+    public Builder() {
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverters());
+    }
 
     /** The HTTP client used for requests. */
     public Builder client(OkHttpClient client) {
@@ -203,17 +322,17 @@ public Builder baseUrl(BaseUrl baseUrl) {
       return this;
     }
 
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder converterFactory(Converter.Factory converterFactory) {
-      this.converterFactory = checkNotNull(converterFactory, "converterFactory == null");
+    /** Add converter factory for serialization and deserialization of objects. */
+    public Builder addConverterFactory(Converter.Factory converterFactory) {
+      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
       return this;
     }
 
     /**
      * TODO
      */
-    public Builder callAdapterFactory(CallAdapter.Factory factory) {
-      this.adapterFactory = checkNotNull(factory, "factory == null");
+    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+      adapterFactories.add(checkNotNull(factory, "factory == null"));
       return this;
     }
 
@@ -226,21 +345,35 @@ public Builder callbackExecutor(Executor callbackExecutor) {
       return this;
     }
 
+    /**
+     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+     * the configuration of all methods in the supplied interface.
+     */
+    public Builder validateEagerly() {
+      validateEagerly = true;
+      return this;
+    }
+
     /** Create the {@link Retrofit} instances. */
     public Retrofit build() {
       if (baseUrl == null) {
         throw new IllegalStateException("Base URL required.");
       }
 
-      // Set any platform-appropriate defaults for unspecified components.
+      OkHttpClient client = this.client;
       if (client == null) {
-        client = Platform.get().defaultClient();
-      }
-      if (adapterFactory == null) {
-        adapterFactory = Platform.get().defaultCallAdapterFactory(callbackExecutor);
+        client = new OkHttpClient();
       }
 
-      return new Retrofit(client, baseUrl, converterFactory, adapterFactory, callbackExecutor);
+      // Make a defensive copy of the adapters and add the default Call adapter.
+      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+
+      // Make a defensive copy of the converters.
+      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
+          validateEagerly);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index e90cd3c73..ee8912bbe 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.ResponseBody;
 import java.io.Closeable;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
@@ -48,6 +49,17 @@ static void closeQuietly(Closeable closeable) {
     }
   }
 
+  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
+  static boolean isAnnotationPresent(Annotation[] annotations,
+      Class<? extends Annotation> cls) {
+    for (Annotation annotation : annotations) {
+      if (cls.isInstance(annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Replace a {@link Response} with an identical copy whose body is backed by a
    * {@link Buffer} rather than a {@link Source}.
@@ -58,22 +70,22 @@ static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws I
     }
 
     BufferedSource source = body.source();
-    final Buffer buffer = new Buffer();
+    Buffer buffer = new Buffer();
     buffer.writeAll(source);
     source.close();
 
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  static <T> void validateServiceClass(Class<T> service) {
+  static <T> void validateServiceInterface(Class<T> service) {
     if (!service.isInterface()) {
-      throw new IllegalArgumentException("Only interface baseUrl definitions are supported.");
+      throw new IllegalArgumentException("API declarations must be interfaces.");
     }
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
     // the recommended pattern.
     if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");
+      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
     }
   }
 
@@ -152,12 +164,20 @@ public static boolean hasUnresolvableType(Type type) {
   }
 
   static RuntimeException methodError(Method method, String message, Object... args) {
+    return methodError(null, method, message, args);
+  }
+
+  static RuntimeException methodError(Throwable cause, Method method, String message,
+      Object... args) {
     message = String.format(message, args);
-    return new IllegalArgumentException(message
+    IllegalArgumentException e = new IllegalArgumentException(message
         + "\n    for method "
         + method.getDeclaringClass().getSimpleName()
         + "."
         + method.getName());
+    e.initCause(cause);
+    return e;
+
   }
 
   static Type getCallResponseType(Type returnType) {
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index 9ae6f7adc..ab7176d99 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -22,7 +22,11 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a HEAD request to a REST path relative to base URL. */
+/**
+ * Make a HEAD request to a REST path relative to base URL.
+ * <p>
+ * Note: HEAD requests must use {@link Void} as the response type since there is no body content.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index fb1a77fb5..0f5913777 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -29,8 +30,8 @@
  * <ul>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
- * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index faf8abe25..338b308bd 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -29,8 +30,8 @@
  * <ul>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
- * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * <pre>
@@ -46,6 +47,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of this part. */
+  /** The {@code Content-Transfer-Encoding} of the parts. */
   String encoding() default "binary";
 }
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
index 4b930662e..586c799f6 100644
--- a/retrofit/src/test/java/retrofit/CallTest.java
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -20,9 +20,10 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
@@ -37,7 +38,7 @@
 import retrofit.http.POST;
 import retrofit.http.Streaming;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
@@ -46,7 +47,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class CallTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
     @GET("/") Call<String> getString();
@@ -57,8 +58,8 @@
 
   @Test public void http200Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -71,22 +72,24 @@
 
   @Test public void http200Async() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final AtomicReference<Retrofit> retrofitRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void success(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         responseRef.set(response);
+        retrofitRef.set(retrofit);
         latch.countDown();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         t.printStackTrace();
       }
     });
@@ -95,12 +98,14 @@
     Response<String> response = responseRef.get();
     assertThat(response.isSuccess()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
+
+    assertThat(retrofitRef.get()).isSameAs(retrofit);
   }
 
   @Test public void http404Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -114,8 +119,8 @@
 
   @Test public void http404Async() throws InterruptedException, IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -124,12 +129,12 @@
     final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void success(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         responseRef.set(response);
         latch.countDown();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         t.printStackTrace();
       }
     });
@@ -143,8 +148,8 @@
 
   @Test public void transportProblemSync() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -160,8 +165,8 @@
 
   @Test public void transportProblemAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -170,11 +175,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.getString().enqueue(new Callback<String>() {
-      @Override public void success(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -187,11 +192,12 @@
 
   @Test public void conversionProblemOutgoingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public RequestBody toBody(Object value) {
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -211,11 +217,12 @@
 
   @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public RequestBody toBody(Object value) {
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -227,11 +234,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void success(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -244,11 +251,12 @@
 
   @Test public void conversionProblemIncomingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public String fromBody(ResponseBody body) throws IOException {
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -286,14 +294,15 @@
     });
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .client(client)
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public String fromBody(ResponseBody body) throws IOException {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
                 try {
-                  return super.fromBody(body);
+                  return value.string();
                 } catch (IOException e) {
                   // Some serialization libraries mask transport problems in runtime exceptions. Bad!
                   throw new RuntimeException("wrapper", e);
@@ -318,11 +327,12 @@
 
   @Test public void conversionProblemIncomingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public String fromBody(ResponseBody body) throws IOException {
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -336,11 +346,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void success(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -352,11 +362,16 @@
   }
 
   @Test public void http204SkipsConverter() throws IOException {
-    final Converter converter = spy(new ToStringConverterFactory.StringConverter());
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter get(Type type) {
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
             return converter;
           }
         })
@@ -372,11 +387,16 @@
   }
 
   @Test public void http205SkipsConverter() throws IOException {
-    final Converter converter = spy(new ToStringConverterFactory.StringConverter());
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter get(Type type) {
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
             return converter;
           }
         })
@@ -393,8 +413,8 @@
 
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -406,8 +426,8 @@
 
   @Test public void responseBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -419,50 +439,52 @@
 
   @Test public void responseBodyBuffers() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
-    server.enqueue(new MockResponse().setBody("1234").throttleBody(1, 500, MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
 
-    long exeuteStart = System.nanoTime();
-    Response<ResponseBody> response = example.getBody().execute();
-    long executeTook = System.nanoTime() - exeuteStart;
-    assertThat(executeTook).isGreaterThan(MILLISECONDS.toNanos(1000));
-
-    long readStart = System.nanoTime();
-    String body = response.body().string();
-    long readTook = System.nanoTime() - readStart;
-    assertThat(readTook).isLessThan(MILLISECONDS.toNanos(500));
-    assertThat(body).isEqualTo("1234");
+    Call<ResponseBody> buffered = example.getBody();
+    // When buffering we will detect all socket problems before returning the Response.
+    try {
+      buffered.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
   }
 
   @Test public void responseBodyStreams() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
-    server.enqueue(new MockResponse().setBody("1234").throttleBody(1, 500, MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
 
-    long exeuteStart = System.nanoTime();
     Response<ResponseBody> response = example.getStreamingBody().execute();
-    long executeTook = System.nanoTime() - exeuteStart;
-    assertThat(executeTook).isLessThan(MILLISECONDS.toNanos(500));
-
-    long readStart = System.nanoTime();
-    String body = response.body().string();
-    long readTook = System.nanoTime() - readStart;
-    assertThat(readTook).isGreaterThan(MILLISECONDS.toNanos(1000));
-    assertThat(body).isEqualTo("1234");
+
+    ResponseBody streamedBody = response.body();
+    // When streaming we only detect socket problems as the ResponseBody is read.
+    try {
+      streamedBody.string();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
   }
 
   @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -483,8 +505,8 @@
 
   @Test public void emptyResponse() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -497,47 +519,71 @@
     assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
   }
 
-  @Test public void cancelThrowsBeforeExecute() {
+  @Test public void cancelBeforeExecute() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
     Call<String> call = service.getString();
 
+    call.cancel();
+
     try {
-      call.cancel();
+      call.execute();
       fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("enqueue or execute must be called first");
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Canceled");
     }
   }
 
+  @Test public void cancelBeforeEnqueue() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+    Call<String> call = service.getString();
+
+    call.cancel();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    latch.await();
+    assertThat(failureRef.get()).hasMessage("Canceled");
+  }
+
   @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
 
     server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hello"));
 
     Call<String> call = service.getString();
     assertThat(call.execute().body()).isEqualTo("Hi");
 
     Call<String> cloned = call.clone();
-    try {
-      cloned.cancel();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("enqueue or execute must be called first");
-    }
+    assertThat(cloned.execute().body()).isEqualTo("Hello");
   }
 
   @Test public void cancelRequest() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
 
@@ -548,11 +594,11 @@
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<String>() {
-      @Override public void success(Response<String> response) {
+      @Override public void onResponse(Response<String> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         failureRef.set(t);
         latch.countDown();
       }
diff --git a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
index 6c95f8882..98a165596 100644
--- a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.reflect.TypeToken;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
@@ -32,6 +33,11 @@
 
 @SuppressWarnings("unchecked")
 public final class ExecutorCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final Retrofit retrofit = new Retrofit.Builder()
+      .baseUrl("http://localhost:1")
+      .build();
   private final Callback<String> callback = mock(Callback.class);
   private final Executor callbackExecutor = spy(new Executor() {
     @Override public void execute(Runnable runnable) {
@@ -42,7 +48,7 @@
 
   @Test public void rawTypeThrows() {
     try {
-      factory.get(Call.class);
+      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
@@ -52,7 +58,7 @@
   @Test public void responseThrows() {
     Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
     try {
-      factory.get(returnType);
+      factory.get(returnType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
@@ -62,18 +68,21 @@
 
   @Test public void responseType() {
     Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType).responseType()) //
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
   }
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    final Response<String> response = Response.fakeSuccess("Hi");
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
         return response;
@@ -84,37 +93,40 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    final Response<String> response = Response.fakeSuccess("Hi");
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.success(response);
+        callback.onResponse(response, retrofit);
       }
     });
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(response);
+    verify(callback).onResponse(response, retrofit);
   }
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
-        callback.failure(throwable);
+        callback.onFailure(throwable);
       }
     });
     call.enqueue(callback);
     verify(callbackExecutor).execute(any(Runnable.class));
     verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).failure(throwable);
+    verify(callback).onFailure(throwable);
     verifyNoMoreInteractions(callback);
   }
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
     Call<String> call = (Call<String>) adapter.adapt(delegate);
     Call<String> cloned = call.clone();
@@ -125,7 +137,8 @@
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
     Call<String> call = (Call<String>) adapter.adapt(delegate);
     call.cancel();
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index d097628f6..0d56c016e 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -1,10 +1,13 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
@@ -13,6 +16,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -48,7 +52,7 @@
   @Test public void customMethodNoBody() {
     class Example {
       @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -63,7 +67,7 @@
   @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -80,7 +84,7 @@
       @Multipart //
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -98,7 +102,7 @@
       @FormUrlEncoded //
       @Multipart //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -114,7 +118,7 @@
   @Test public void invalidPathParam() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Path("hey!") String thing) {
+      Call<ResponseBody> method(@Path("hey!") String thing) {
         return null;
       }
     }
@@ -132,7 +136,7 @@
   @Test public void pathParamNotAllowedInQuery() throws Exception {
     class Example {
       @GET("/foo?bar={bar}") //
-      Call<Object> method(@Path("bar") String thing) {
+      Call<ResponseBody> method(@Path("bar") String thing) {
         return null;
       }
     }
@@ -149,7 +153,7 @@
   @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Body @Query("nope") Object o) {
+      Call<ResponseBody> method(@Body @Query("nope") String o) {
         return null;
       }
     }
@@ -162,11 +166,24 @@
     }
   }
 
+  @interface NonNull {}
+
+  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "yep");
+    assertThat(request.urlString()).isEqualTo("http://example.com/?maybe=yep");
+  }
+
   @Test public void twoMethodsFail() {
     class Example {
       @PATCH("/foo") //
       @POST("/foo") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -182,7 +199,7 @@
 
   @Test public void lackingMethod() {
     class Example {
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -198,7 +215,7 @@
   @Test public void implicitMultipartForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Part("a") int a) {
+      Call<ResponseBody> method(@Part("a") int a) {
         return null;
       }
     }
@@ -214,7 +231,7 @@
   @Test public void implicitMultipartWithPartMapForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@PartMap Map<String, String> params) {
+      Call<ResponseBody> method(@PartMap Map<String, String> params) {
         return null;
       }
     }
@@ -231,7 +248,7 @@
     class Example {
       @Multipart //
       @GET("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -248,7 +265,7 @@
     class Example {
       @Multipart //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -264,7 +281,7 @@
   @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Field("a") int a) {
+      Call<ResponseBody> method(@Field("a") int a) {
         return null;
       }
     }
@@ -280,7 +297,7 @@
   @Test public void implicitFormEncodingByFieldMapForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@FieldMap Map<String, String> a) {
+      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
         return null;
       }
     }
@@ -297,7 +314,7 @@
     class Example {
       @FormUrlEncoded //
       @GET("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -314,7 +331,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -330,7 +347,7 @@
     class Example {
       @GET("/") //
       @Headers({}) //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -346,7 +363,7 @@
     class Example {
       @GET("/") //
       @Headers("Malformed") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -362,7 +379,7 @@
   @Test public void pathParamNonPathParamAndTypedBytes() {
     class Example {
       @PUT("/{a}") //
-      Call<Object> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
         return null;
       }
     }
@@ -378,7 +395,7 @@
   @Test public void parameterWithoutAnnotation() {
     class Example {
       @GET("/") //
-      Call<Object> method(String a) {
+      Call<ResponseBody> method(String a) {
         return null;
       }
     }
@@ -394,7 +411,7 @@
   @Test public void nonBodyHttpMethodWithSingleEntity() {
     class Example {
       @GET("/") //
-      Call<Object> method(@Body Object o) {
+      Call<ResponseBody> method(@Body String o) {
         return null;
       }
     }
@@ -410,7 +427,7 @@
   @Test public void queryMapMustBeAMap() {
     class Example {
       @GET("/") //
-      Call<Object> method(@QueryMap List<String> a) {
+      Call<ResponseBody> method(@QueryMap List<String> a) {
         return null;
       }
     }
@@ -426,7 +443,7 @@
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
-      Call<Object> method(@QueryMap Map<String, String> a) {
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
         return null;
       }
     }
@@ -446,7 +463,7 @@
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
-      Call<Object> method(@Body int o1, @Body int o2) {
+      Call<ResponseBody> method(@Body String o1, @Body String o2) {
         return null;
       }
     }
@@ -463,7 +480,7 @@
     class Example {
       @Multipart //
       @PUT("/") //
-      Call<Object> method(@Part("one") int o1, @Body int o2) {
+      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
         return null;
       }
     }
@@ -479,7 +496,7 @@
   @Test public void get() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -493,7 +510,7 @@
   @Test public void delete() {
     class Example {
       @DELETE("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -507,7 +524,7 @@
   @Test public void head() {
     class Example {
       @HEAD("/foo/bar/") //
-      Call<Object> method() {
+      Call<Void> method() {
         return null;
       }
     }
@@ -518,10 +535,25 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void headWithoutVoidThrows() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "HEAD method must use Void as response type.\n    for method Example.method");
+    }
+  }
+
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -536,7 +568,7 @@
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -551,7 +583,7 @@
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -566,7 +598,7 @@
   @Test public void getWithPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -580,7 +612,7 @@
   @Test public void getWithUnusedAndInvalidNamedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -594,7 +626,7 @@
   @Test public void getWithEncodedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path(value = "ping", encoded = true) String ping) {
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
         return null;
       }
     }
@@ -608,7 +640,7 @@
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -623,7 +655,7 @@
   @Test public void getWithQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -637,7 +669,7 @@
   @Test public void getWithEncodedQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
         return null;
       }
     }
@@ -651,7 +683,7 @@
   @Test public void queryParamOptionalOmitsQuery() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -662,7 +694,7 @@
   @Test public void queryParamOptional() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("foo") String foo, @Query("ping") String ping,
+      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
           @Query("kit") String kit) {
         return null;
       }
@@ -674,7 +706,7 @@
   @Test public void getWithQueryUrlAndParam() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -688,7 +720,7 @@
   @Test public void getWithQuery() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -702,7 +734,7 @@
   @Test public void getWithPathAndQueryParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit,
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
           @Query("riff") String riff) {
         return null;
       }
@@ -718,7 +750,7 @@
   @Test public void getWithQueryThenPathThrows() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Query("kit") String kit, @Path("ping") String ping) {
+      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
         return null;
       }
     }
@@ -735,7 +767,7 @@
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -750,7 +782,7 @@
   @Test public void getWithPathAndQueryAmpersandParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -758,14 +790,14 @@
     Request request = buildRequest(Example.class, "pong&", "kat&");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
     assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryHashParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -780,7 +812,7 @@
   @Test public void getWithQueryParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") List<Object> keys) {
+      Call<ResponseBody> method(@Query("key") List<Object> keys) {
         return null;
       }
     }
@@ -796,7 +828,7 @@
   @Test public void getWithQueryParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") Object[] keys) {
+      Call<ResponseBody> method(@Query("key") Object[] keys) {
         return null;
       }
     }
@@ -812,7 +844,7 @@
   @Test public void getWithQueryParamPrimitiveArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") int[] keys) {
+      Call<ResponseBody> method(@Query("key") int[] keys) {
         return null;
       }
     }
@@ -828,7 +860,7 @@
   @Test public void getWithQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@QueryMap Map<String, Object> query) {
+      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
         return null;
       }
     }
@@ -848,7 +880,7 @@
   @Test public void getWithEncodedQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@QueryMap(encoded = true) Map<String, Object> query) {
+      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
         return null;
       }
     }
@@ -868,7 +900,7 @@
   @Test public void getWithUrl() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -883,7 +915,7 @@
   @Test public void getAbsoluteUrl() {
     class Example {
       @GET("http://example2.com/foo/bar/")
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -898,7 +930,7 @@
   @Test public void getWithUrlAbsolute() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -913,7 +945,7 @@
   @Test public void getWithUrlAbsoluteSameHost() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -928,7 +960,7 @@
   @Test public void getWithNonStringUrlThrows() {
     class Example {
       @GET
-      Call<Object> method(@Url Object url) {
+      Call<ResponseBody> method(@Url Object url) {
         return null;
       }
     }
@@ -945,7 +977,7 @@
   @Test public void getUrlAndUrlParamThrows() {
     class Example {
       @GET("foo/bar")
-      Call<Object> method(@Url Object url) {
+      Call<ResponseBody> method(@Url Object url) {
         return null;
       }
     }
@@ -962,7 +994,7 @@
   @Test public void getWithoutUrlThrows() {
     class Example {
       @GET
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -979,7 +1011,7 @@
   @Test public void getWithUrlThenPathThrows() {
     class Example {
       @GET
-      Call<Object> method(@Url String url, @Path("hey") String hey) {
+      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
         return null;
       }
     }
@@ -996,7 +1028,7 @@
   @Test public void getWithPathThenUrlThrows() {
     class Example {
       @GET
-      Call<Object> method(@Path("hey") String hey, @Url Object url) {
+      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
         return null;
       }
     }
@@ -1013,7 +1045,7 @@
   @Test public void getWithQueryThenUrlThrows() {
     class Example {
       @GET("foo/bar")
-      Call<Object> method(@Query("hey") String hey, @Url Object url) {
+      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
         return null;
       }
     }
@@ -1030,7 +1062,7 @@
   @Test public void getWithUrlThenQuery() {
     class Example {
       @GET
-      Call<Object> method(@Url String url, @Query("hey") String hey) {
+      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
         return null;
       }
     }
@@ -1044,7 +1076,7 @@
   @Test public void postWithUrl() {
     class Example {
       @POST
-      Call<Object> method(@Url String url, @Body RequestBody body) {
+      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
         return null;
       }
     }
@@ -1059,7 +1091,7 @@
   @Test public void normalPostWithPathParam() {
     class Example {
       @POST("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
         return null;
       }
     }
@@ -1074,7 +1106,7 @@
   @Test public void emptyBody() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1089,7 +1121,7 @@
   @Test public void customMethodEmptyBody() {
     class Example {
       @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1103,7 +1135,7 @@
   @Test public void bodyResponseBody() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1118,7 +1150,7 @@
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1133,7 +1165,7 @@
   @Test public void bodyWithPathParams() {
     class Example {
       @POST("/foo/bar/{ping}/{kit}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
         return null;
       }
     }
@@ -1149,7 +1181,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
         return null;
       }
     }
@@ -1166,10 +1198,12 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"\r\n")
         .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
   }
@@ -1178,7 +1212,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
+      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
           @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
         return null;
       }
@@ -1195,11 +1229,15 @@
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
-    assertThat(bodyString).contains("name=\"ping\"\r\n")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\npong\r\n--");
 
-    assertThat(bodyString).contains("name=\"kit\"")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 7-bit")
         .contains("\r\nkat\r\n--");
   }
@@ -1208,7 +1246,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap Map<String, Object> parts) {
         return null;
       }
     }
@@ -1229,10 +1267,12 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"\r\n")
         .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
 
@@ -1243,7 +1283,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
         return null;
       }
     }
@@ -1263,11 +1303,15 @@
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
-    assertThat(bodyString).contains("name=\"ping\"\r\n")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\npong\r\n--");
 
-    assertThat(bodyString).contains("name=\"kit\"")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\nkat\r\n--");
 
@@ -1278,7 +1322,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap Map<String, Object> parts) {
         return null;
       }
     }
@@ -1299,7 +1343,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap List<Object> parts) {
+      Call<ResponseBody> method(@PartMap List<Object> parts) {
         return null;
       }
     }
@@ -1317,7 +1361,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
         return null;
       }
     }
@@ -1332,6 +1376,7 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"")
         .contains("\r\npong\r\n--");
   }
@@ -1340,7 +1385,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") RequestBody ping) {
+      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
         return null;
       }
     }
@@ -1356,7 +1401,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping) {
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
         return null;
       }
     }
@@ -1368,7 +1413,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field(value = "na%20me", encoded = true) String foo) {
+      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
         return null;
       }
     }
@@ -1380,7 +1425,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping,
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
           @Field("kit") String kit) {
         return null;
       }
@@ -1393,7 +1438,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1407,7 +1452,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1421,7 +1466,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1435,7 +1480,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
         return null;
       }
     }
@@ -1452,7 +1497,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@FieldMap Map<String, Object> fieldMap) {
+      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
         return null;
       }
     }
@@ -1470,7 +1515,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method(@FieldMap Map<String, Object> a) {
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
         return null;
       }
     }
@@ -1492,7 +1537,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method(@FieldMap List<String> a) {
+      Call<ResponseBody> method(@FieldMap List<String> a) {
         return null;
       }
     }
@@ -1512,7 +1557,7 @@
           "ping: pong",
           "kit: kat"
       })
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1529,7 +1574,7 @@
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("kit") BigInteger kit) {
+      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
@@ -1546,7 +1591,7 @@
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Call<Object> method(@Header("kit") String kit) {
+      Call<ResponseBody> method(@Header("kit") String kit) {
         return null;
       }
     }
@@ -1563,7 +1608,7 @@
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("foo") List<String> kit) {
+      Call<ResponseBody> method(@Header("foo") List<String> kit) {
         return null;
       }
     }
@@ -1579,7 +1624,7 @@
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("foo") String[] kit) {
+      Call<ResponseBody> method(@Header("foo") String[] kit) {
         return null;
       }
     }
@@ -1596,7 +1641,7 @@
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1609,7 +1654,7 @@
     class Example {
       @DELETE("/") //
       @Headers("Content-Type: text/not-plain") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1620,7 +1665,7 @@
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
@@ -1641,16 +1686,34 @@ private static void assertBody(RequestBody body, String expected) {
   }
 
   private Request buildRequest(Class<?> cls, Object... args) {
-    Method method = TestingUtils.onlyMethod(cls);
+    OkHttpClient client = new OkHttpClient();
 
-    BaseUrl baseUrl = new BaseUrl() {
-      @Override public HttpUrl url() {
-        return HttpUrl.parse("http://example.com/");
+    final AtomicReference<Request> requestRef = new AtomicReference<>();
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        requestRef.set(chain.request());
+        throw new UnsupportedOperationException("Not implemented");
       }
-    };
-    Converter.Factory converterFactory = new ToStringConverterFactory();
+    });
 
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactory);
-    return requestFactory.create(args);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory())
+        .client(client)
+        .build();
+
+    Method method = TestingUtils.onlyMethod(cls);
+    MethodHandler<?> handler = retrofit.loadMethodHandler(method);
+    Call<?> invoke = (Call<?>) handler.invoke(args);
+    try {
+      invoke.execute();
+      throw new AssertionError();
+    } catch (UnsupportedOperationException ignored) {
+      return requestRef.get();
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
index bce1762df..b129d735f 100644
--- a/retrofit/src/test/java/retrofit/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -7,8 +7,10 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.List;
@@ -19,6 +21,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit.http.Body;
@@ -26,23 +29,26 @@
 import retrofit.http.POST;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class RetrofitTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   interface CallMethod {
     @GET("/") Call<String> disallowed();
     @POST("/") Call<ResponseBody> disallowed(@Body String body);
-    @GET("/") Call<ResponseBody> allowed();
-    @POST("/") Call<ResponseBody> allowed(@Body RequestBody body);
+    @GET("/") Call<ResponseBody> getResponseBody();
+    @GET("/") Call<Void> getVoid();
+    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
   }
   interface FutureMethod {
     @GET("/") Future<String> method();
@@ -62,11 +68,18 @@
   interface VoidService {
     @GET("/") void nope();
   }
+  interface Annotated {
+    @GET("/") @Foo Call<String> method();
+    @POST("/") Call<ResponseBody> parameter(@Foo @Body String param);
+
+    @Retention(RUNTIME)
+    @interface Foo {}
+  }
 
   @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
 
@@ -77,19 +90,19 @@
 
   @Test public void interfaceWithExtendIsNotSupported() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     try {
       retrofit.create(Extending.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
     }
   }
 
   @Test public void voidReturnTypeNotAllowed() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     VoidService service = retrofit.create(VoidService.class);
 
@@ -102,29 +115,45 @@
     }
   }
 
-  @Test public void callReturnTypeAdapterAddedByDefault() {
+  @Test public void validateEagerlyFailsAtCreation() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .validateEagerly()
+        .build();
+
+    try {
+      retrofit.create(VoidService.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
+  @Test public void callCallAdapterAddedByDefault() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.allowed()).isNotNull();
+    assertThat(example.getResponseBody()).isNotNull();
   }
 
-  @Test public void callReturnTypeCustomAdapter() {
+  @Test public void callCallCustomAdapter() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType) {
+      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         if (Utils.getRawType(returnType) != Call.class) {
           return null;
         }
-        return new CallAdapter<Object>() {
+        return new CallAdapter<Call<?>>() {
           @Override public Type responseType() {
             return Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
           }
 
-          @Override public Object adapt(Call<Object> call) {
+          @Override public <R> Call<R> adapt(Call<R> call) {
             adapterCalled.set(true);
             return call;
           }
@@ -133,27 +162,28 @@
     }
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .callAdapterFactory(new MyCallAdapterFactory())
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(new MyCallAdapterFactory())
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.allowed()).isNotNull();
+    assertThat(example.getResponseBody()).isNotNull();
     assertThat(factoryCalled.get()).isTrue();
     assertThat(adapterCalled.get()).isTrue();
   }
 
-  @Test public void customReturnTypeAdapter() {
+  @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType) {
+      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         if (Utils.getRawType(returnType) != String.class) {
           return null;
         }
-        return new CallAdapter<Object>() {
+        return new CallAdapter<String>() {
           @Override public Type responseType() {
             return String.class;
           }
 
-          @Override public String adapt(Call<Object> call) {
+          @Override public <R> String adapt(Call<R> call) {
             return "Hi!";
           }
         };
@@ -161,32 +191,96 @@
     }
 
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
-        .callAdapterFactory(new GreetingCallAdapterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new GreetingCallAdapterFactory())
         .build();
     StringService example = retrofit.create(StringService.class);
     assertThat(example.get()).isEqualTo("Hi!");
   }
 
-  @Test public void customReturnTypeAdapterMissingThrows() {
+  @Test public void methodAnnotationsPassedToCallAdapter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+        return null;
+      }
+    }
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void customCallAdapterMissingThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
         .build();
     FutureMethod example = retrofit.create(FutureMethod.class);
     try {
       example.method();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call adapter factory 'Default' was unable to"
-              + " handle return type java.util.concurrent.Future<java.lang.String>\n"
+      assertThat(e).hasMessage(
+          "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
               + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>. Tried:\n"
+              + " * retrofit.DefaultCallAdapter$1");
     }
   }
 
+  @Test public void methodAnnotationsPassedToConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().fromResponseBody(type, annotations);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void parameterAnnotationsPassedToConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().toRequestBody(type, annotations);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.parameter(null); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
   @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
     try {
@@ -194,15 +288,17 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Body parameter is class java.lang.String but no converter factory registered. Either"
-              + " add a converter factory to the Retrofit instance or use RequestBody. (parameter #1)\n"
+          "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
               + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters");
     }
   }
 
   @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
 
@@ -212,25 +308,18 @@
       example.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Method response type is class java.lang.String but no converter factory registered. "
-              + "Either add a converter factory to the Retrofit instance or use ResponseBody.\n"
-              + "    for method CallMethod.disallowed");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters");
     }
   }
 
   @Test public void converterReturningNullThrows() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new Converter.Factory() {
-          @Override public Converter<?> get(Type type) {
-            return null;
-          }
-
-          @Override public String toString() {
-            return "Nully";
-          }
-        })
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {})
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
 
@@ -238,34 +327,49 @@
       service.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Converter factory 'Nully' was unable to handle response type class java.lang.String\n"
-              + "    for method CallMethod.disallowed");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.RetrofitTest$1");
     }
   }
 
   @Test public void requestBodyOutgoingAllowed() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    Response<ResponseBody> response = example.allowed().execute();
+    Response<ResponseBody> response = example.getResponseBody().execute();
     assertThat(response.body().string()).isEqualTo("Hi");
   }
 
+  @Test public void voidOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Void> response = example.getVoid().execute();
+    assertThat(response.body()).isNull();
+  }
+
   @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
     RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.allowed(body).execute();
+    Response<ResponseBody> response = example.postRequestBody(body).execute();
     assertThat(response.body().string()).isEqualTo("Hi");
 
     assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
@@ -273,8 +377,8 @@
 
   @Test public void unresolvableTypeThrows() {
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
-        .converterFactory(new ToStringConverterFactory())
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Unresolvable example = retrofit.create(Unresolvable.class);
 
@@ -410,32 +514,130 @@
 
   @Test public void converterNullThrows() {
     try {
-      new Retrofit.Builder().converterFactory(null);
+      new Retrofit.Builder().addConverterFactory(null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("converterFactory == null");
     }
   }
 
-  @Test public void converterNoDefault() {
+  @Test public void converterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    List<Converter.Factory> converterFactories = retrofit.converterFactories();
+    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+  }
+
+  @Test public void requestConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).toRequestBody(type, annotations);
+
+    Converter<?, RequestBody> actualAdapter = retrofit.requestConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).toRequestBody(type, annotations);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void requestConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter.Factory factory1 = spy(new Converter.Factory() {
+      @Override
+      public Converter<?, RequestBody> toRequestBody(Type returnType, Annotation[] annotations) {
+        return null;
+      }
+    });
+
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
+        .addConverterFactory(factory1)
         .build();
-    assertThat(retrofit.converterFactory()).isNull();
+
+    try {
+      retrofit.requestConverter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate RequestBody converter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).toRequestBody(type, annotations);
+    verifyNoMoreInteractions(factory1);
+  }
+
+  @Test public void responseConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).fromResponseBody(type, annotations);
+
+    Converter<ResponseBody, ?> actualAdapter = retrofit.responseConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).fromResponseBody(type, annotations);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void responseConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter.Factory factory1 = spy(new Converter.Factory() {
+      @Override
+      public Converter<ResponseBody, ?> fromResponseBody(Type returnType, Annotation[] annotations) {
+        return null;
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.responseConverter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).fromResponseBody(type, annotations);
+    verifyNoMoreInteractions(factory1);
   }
 
   @Test public void converterFactoryPropagated() {
     Converter.Factory factory = mock(Converter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .converterFactory(factory)
+        .addConverterFactory(factory)
         .build();
-    assertThat(retrofit.converterFactory()).isSameAs(factory);
+    assertThat(retrofit.converterFactories()).contains(factory);
   }
 
   @Test public void callAdapterFactoryNullThrows() {
     try {
-      new Retrofit.Builder().callAdapterFactory(null);
+      new Retrofit.Builder().addCallAdapterFactory(null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("factory == null");
@@ -446,16 +648,158 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
-    assertThat(retrofit.callAdapterFactory()).isNotNull();
+    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
   }
 
   @Test public void callAdapterFactoryPropagated() {
     CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .callAdapterFactory(factory)
+        .addCallAdapterFactory(factory)
+        .build();
+    assertThat(retrofit.callAdapterFactories()).contains(factory);
+  }
+
+  @Test public void callAdapterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegate() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .build();
+
+    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .addCallAdapterFactory(factory3)
+        .build();
+
+    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+    verify(factory3).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory3);
+  }
+
+  @Test public void callAdapterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
         .build();
-    assertThat(retrofit.callAdapterFactory()).isSameAs(factory);
+
+    doReturn(null).when(factory).get(type, annotations, retrofit);
+
+    try {
+      retrofit.callAdapter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate call adapter for class java.lang.String. Tried:");
+    }
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.callAdapter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining("Skipped:")
+          .hasMessageStartingWith(
+              "Could not locate call adapter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
   }
 
   @Test public void callbackExecutorNullThrows() {
@@ -490,21 +834,21 @@
       }
     });
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .callbackExecutor(executor)
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.allowed();
+    Call<ResponseBody> call = service.getResponseBody();
 
     server.enqueue(new MockResponse());
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void success(Response<ResponseBody> response) {
+      @Override public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
         latch.countDown();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         t.printStackTrace();
       }
     });
@@ -521,21 +865,21 @@
       }
     });
     Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.getUrl("/").toString())
+        .baseUrl(server.url("/"))
         .callbackExecutor(executor)
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.allowed();
+    Call<ResponseBody> call = service.getResponseBody();
 
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new Callback<ResponseBody>() {
-      @Override public void success(Response<ResponseBody> response) {
+      @Override public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
         throw new AssertionError();
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         latch.countDown();
       }
     });
diff --git a/retrofit/src/test/java/retrofit/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
index 291622d94..35919c867 100644
--- a/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
@@ -19,22 +19,32 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-class ToStringConverterFactory implements Converter.Factory {
+class ToStringConverterFactory extends Converter.Factory {
   private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
-  @Override public Converter get(Type type) {
-    return new StringConverter();
-  }
-
-  static class StringConverter implements Converter<Object> {
-    @Override public String fromBody(ResponseBody body) throws IOException {
-      return body.string();
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (String.class.equals(type)) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
+        }
+      };
     }
+    return null;
+  }
 
-    @Override public RequestBody toBody(Object value) {
-      return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (String.class.equals(type)) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
+          return RequestBody.create(MEDIA_TYPE, value);
+        }
+      };
     }
+    return null;
   }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index f60dae06c..cedb3a385 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -19,11 +19,20 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <!--<dependency>-->
-      <!--<groupId>com.squareup.retrofit</groupId>-->
-      <!--<artifactId>retrofit-mock</artifactId>-->
-      <!--<version>${project.version}</version>-->
-    <!--</dependency>-->
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit-mock</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>converter-gson</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
index b58b9b0ad..ca6d972cc 100644
--- a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -19,6 +19,7 @@
 import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
@@ -35,7 +36,8 @@
  */
 public final class CustomCallAdapter {
   public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<?> get(Type returnType) {
+    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit) {
       TypeToken<?> token = TypeToken.of(returnType);
       if (token.getRawType() != ListenableFuture.class) {
         return null;
@@ -47,13 +49,13 @@
       }
       final Type responseType = componentType.getType();
 
-      return new CallAdapter<Object>() {
+      return new CallAdapter<ListenableFuture<?>>() {
         @Override public Type responseType() {
           return responseType;
         }
 
-        @Override public ListenableFuture<?> adapt(Call<Object> call) {
-          CallFuture<Object> future = new CallFuture<>(call);
+        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
+          CallFuture<R> future = new CallFuture<>(call);
           call.enqueue(future);
           return future;
         }
@@ -71,7 +73,7 @@ private CallFuture(Call<T> call) {
         call.cancel();
       }
 
-      @Override public void success(Response<T> response) {
+      @Override public void onResponse(Response<T> response, Retrofit retrofit) {
         if (response.isSuccess()) {
           set(response.body());
         } else {
@@ -79,7 +81,7 @@ private CallFuture(Call<T> call) {
         }
       }
 
-      @Override public void failure(Throwable t) {
+      @Override public void onFailure(Throwable t) {
         setException(t);
       }
     }
@@ -97,7 +99,7 @@ private CallFuture(Call<T> call) {
   public static void main(String... args) {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://httpbin.org")
-        .callAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
         .build();
 
     HttpBinService service = retrofit.create(HttpBinService.class);
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
new file mode 100644
index 000000000..21765b13f
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import retrofit.Call;
+import retrofit.Converter;
+import retrofit.GsonConverterFactory;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+public final class DeserializeErrorBody {
+  interface Service {
+    @GET("/user") Call<User> getUser();
+  }
+
+  static class User {
+    // normal fields...
+  }
+
+  static class Error {
+    String message;
+  }
+
+  public static void main(String... args) throws IOException {
+    // Create a local web server which response with a 404 and JSON body.
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse()
+        .setResponseCode(404)
+        .setBody("{\"message\":\"Unable to locate resource\"}"));
+
+    // Create our Service instance with a Retrofit pointing at the local web server and Gson.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GsonConverterFactory.create())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Response<User> response = service.getUser().execute();
+
+    // Normally you would check response.isSuccess() here before doing the following, but we know
+    // this call will always fail. You could also use response.code() to determine whether to
+    // convert the error body and/or which type to use for conversion.
+
+    // Look up a converter for the Error type on the Retrofit instance.
+    Converter<ResponseBody, Error> errorConverter =
+        retrofit.responseConverter(Error.class, new Annotation[0]);
+    // Convert the error body into our Error type.
+    Error error = errorConverter.convert(response.errorBody());
+    System.out.println("ERROR: " + error.message);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/not_java/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
similarity index 62%
rename from samples/src/main/not_java/SimpleMockService.java
rename to samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 9b776ce85..2e2a47f3b 100644
--- a/samples/src/main/not_java/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -3,14 +3,21 @@
 
 import com.example.retrofit.SimpleService.Contributor;
 import com.example.retrofit.SimpleService.GitHub;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import retrofit.MockRetrofit;
+import retrofit.Call;
 import retrofit.Retrofit;
+import retrofit.mock.CallBehaviorAdapter;
+import retrofit.mock.Calls;
+import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
 
 /**
  * An example of using {@link MockRetrofit} to create a mock service implementation with
@@ -19,10 +26,12 @@
 public final class SimpleMockService {
   /** A mock implementation of the {@link GitHub} API interface. */
   static final class MockGitHub implements GitHub {
+    private final Retrofit retrofit;
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
-    public MockGitHub() {
-      ownerRepoContributors = new LinkedHashMap<>();
+    public MockGitHub(Retrofit retrofit) {
+      this.retrofit = retrofit;
+      this.ownerRepoContributors = new LinkedHashMap<>();
 
       // Seed some mock data.
       addContributor("square", "retrofit", "John Doe", 12);
@@ -32,16 +41,16 @@ public MockGitHub() {
       addContributor("square", "picasso", "Keiser Soze", 152);
     }
 
-    @Override public List<Contributor> contributors(String owner, String repo) {
+    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
+      List<Contributor> response = Collections.emptyList();
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        return Collections.emptyList();
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        return Collections.emptyList();
+      if (repoContributors != null) {
+        List<Contributor> contributors = repoContributors.get(repo);
+        if (contributors != null) {
+          response = contributors;
+        }
       }
-      return contributors;
+      return Calls.response(response, retrofit);
     }
 
     public void addContributor(String owner, String repo, String name, int contributions) {
@@ -59,18 +68,22 @@ public void addContributor(String owner, String repo, String name, int contribut
     }
   }
 
-  public static void main(String... args) {
-    // Create a very simple REST adapter which points the GitHub API.
+  public static void main(String... args) throws IOException {
+    // Create a very simple Retrofit adapter which points the GitHub API.
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(SimpleService.API_URL)
         .build();
 
-    // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRetrofit mockRetrofit = MockRetrofit.from(retrofit, Executors.newSingleThreadExecutor());
+    // Create the Behavior object which manages the fake behavior and the background executor.
+    NetworkBehavior behavior = NetworkBehavior.create();
+    ExecutorService bg = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
+        .setNameFormat("mock-retrofit-%d")
+        .setDaemon(true)
+        .build());
 
-    // Instantiate a mock object so we can interact with it later.
-    MockGitHub mockGitHub = new MockGitHub();
-    // Use the mock REST adapter and our mock object to create the API interface.
+    // Create the mock implementation and use MockRetrofit to apply the behavior to it.
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, new CallBehaviorAdapter(retrofit, bg));
+    MockGitHub mockGitHub = new MockGitHub(retrofit);
     GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
@@ -87,10 +100,11 @@ public static void main(String... args) {
     printContributors(gitHub, "square", "picasso");
   }
 
-  private static void printContributors(GitHub gitHub, String owner, String repo) {
+  private static void printContributors(GitHub gitHub, String owner, String repo)
+      throws IOException {
     System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    List<Contributor> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors) {
+    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+    for (Contributor contributor : contributors.execute().body()) {
       System.out.println(contributor.login + " (" + contributor.contributions + ")");
     }
     System.out.println();
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index a57edb3ca..1fe28dc2a 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit.Call;
+import retrofit.GsonConverterFactory;
 import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
@@ -46,6 +47,7 @@ public static void main(String... args) throws IOException {
     // Create a very simple REST adapter which points the GitHub API.
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(API_URL)
+        .addConverterFactory(GsonConverterFactory.create())
         .build();
 
     // Create an instance of our GitHub API interface.
diff --git a/website/index.html b/website/index.html
index fbbda6a98..ad0a05a75 100644
--- a/website/index.html
+++ b/website/index.html
@@ -4,7 +4,7 @@
     <meta charset="utf-8">
     <title>Retrofit</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="A type-safe REST client for Android and Java">
+    <meta name="description" content="A type-safe HTTP client for Android and Java">
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
@@ -27,13 +27,14 @@ <h1>Retrofit</h1>
               </ul>
             </menu>
           </div>
+        </div>
       </div>
     </header>
     <section id="subtitle">
       <div class="container">
         <div class="row">
           <div class="span12">
-            <h2>A type-safe <strong>REST client</strong> for Android and Java</h2>
+            <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsung! --></h2>
           </div>
         </div>
       </div>
@@ -42,232 +43,146 @@ <h2>A type-safe <strong>REST client</strong> for Android and Java</h2>
       <div class="container">
         <div class="row">
           <div class="span9">
-            <h3 id="introduction">Introduction</h3>
-            <p>Retrofit turns your REST API into a Java interface.</p>
-            <pre class="prettyprint">public interface GitHubService {
+            <section id="introduction">
+              <h3>Introduction</h3>
+              <p>Retrofit turns your HTTP API into a Java interface.</p>
+              <pre class="prettyprint">public interface GitHubService {
   @GET("/users/{user}/repos")
-  List&lt;Repo> listRepos(@Path("user") String user);
+  Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
-            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.github.com")
+              <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+              <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.github.com")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
-            <pre class="prettyprint">List&lt;Repo> repos = service.listRepos("octocat");</pre>
-            <p>Use annotations to describe the HTTP request:</p>
-            <ul>
-              <li>URL parameter replacement and query parameter support</li>
-              <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
-              <li>Multipart request body and file upload</li>
-            </ul>
-
-            <h3 id="api-declaration">API Declaration</h3>
-            <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
-
-            <h4>Request Method</h4>
-            <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-            <pre class="prettyprint">@GET("/users/list")</pre>
-            <p>You can also specify query parameters in the URL.</p>
-            <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
-            </pre>
-
-            <h4>URL Manipulation</h4>
-            <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
+              <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
+              <p>Use annotations to describe the HTTP request:</p>
+              <ul>
+                <li>URL parameter replacement and query parameter support</li>
+                <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
+                <li>Multipart request body and file upload</li>
+              </ul>
+              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
+            </section>
+
+            <section id="api-declaration">
+              <h3>API Declaration</h3>
+              <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
+
+              <h4>Request Method</h4>
+              <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
+              <pre class="prettyprint">@GET("/users/list")</pre>
+              <p>You can also specify query parameters in the URL.</p>
+              <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
+
+              <h4>URL Manipulation</h4>
+              <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId);</pre>
-            <p>Query parameters can also be added.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>Query parameters can also be added.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
-            <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
-            <h4>Request Body</h4>
-            <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
-            <pre class="prettyprint">@POST("/users/new")
-void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>Retrofit</code>'s converter.</p>
+              <h4>Request Body</h4>
+              <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
+              <pre class="prettyprint">@POST("/users/new")
+Call&lt;User> createUser(@Body User user);</pre>
+              <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
-            <h4>Form Encoded and Multipart</h4>
-            <p>Methods can also be declared to send form-encoded and multipart data.</p>
-            <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
-            <pre class="prettyprint">@FormUrlEncoded
+              <h4>Form Encoded and Multipart</h4>
+              <p>Methods can also be declared to send form-encoded and multipart data.</p>
+              <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
+              <pre class="prettyprint">@FormUrlEncoded
 @POST("/user/edit")
-User updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
-            <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
-            <pre class="prettyprint">@Multipart
+Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
+              <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
+              <pre class="prettyprint">@Multipart
 @PUT("/user/photo")
-User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description);</pre>
-            <p>Multipart parts use the <code>Retrofit</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
+              <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
 
-            <h4>Header Manipulation</h4>
-            <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
-            <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
+              <h4>Header Manipulation</h4>
+              <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
+              <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
 @GET("/widget/list")
-List&lt;Widget> widgetList();</pre>
-            <pre class="prettyprint">@Headers({
+Call&lt;List&lt;Widget>> widgetList();</pre>
+              <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
 @GET("/users/{username}")
-User getUser(@Path("username") String username);</pre>
-            <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
-            <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
-            <pre class="prettyprint">@GET("/user")
-void getUser(@Header("Authorization") String authorization, Callback&lt;User> callback)</pre>
-            <p>Headers that need to be added to every request can be specified using a <code>RequestInterceptor</code>. The following code creates a <code>RequestInterceptor</code> that will add a <code>User-Agent</code> header to every request.</p>
-            <pre class="prettyprint">RequestInterceptor requestInterceptor = new RequestInterceptor() {
-  @Override
-  public void intercept(RequestFacade request) {
-    request.addHeader("User-Agent", "Retrofit-Sample-App");
-  }
-};
-
-Retrofit retrofit = new Retrofit.Builder()
-  .setEndpoint("https://api.github.com")
-  .setRequestInterceptor(requestInterceptor)
-  .build();</pre>
-
-            <h4>Synchronous vs. Asynchronous vs. Observable</h4>
-            <p>Methods can be declared for either synchronous or asynchronous execution.</p>
-            <p>A method with a return type will be executed synchronously.</p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-Photo getUserPhoto(@Path("id") int id);</pre>
-            <p>Asynchronous execution requires the last parameter of the method be a <code>Callback</code>.</p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-void getUserPhoto(@Path("id") int id, Callback&lt;Photo> cb);</pre>
-            <p>On Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.</p>
-
-            <p>Retrofit also integrates <a href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-Observable&lt;Photo> getUserPhoto(@Path("id") int id);</pre>
-            <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
-
-            <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>Retrofit</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
-            <pre class="prettyprint">@GET("/users/list")
-List&lt;User> userList();
-
-@GET("/users/list")
-void userList(Callback&lt;List&lt;User>> cb);
-
-@GET("/users/list")
-Observable&lt;List&lt;User>> userList();</pre>
-            <p>For access to the raw HTTP response use the <code>Response</code> type.</p>
-            <pre class="prettyprint">@GET("/users/list")
-Response userList();
-
-@GET("/users/list")
-void userList(Callback&lt;Response> cb);
-
-@GET("/users/list")
-Observable&lt;Response> userList();</pre>
-
-            <h3 id="restadapter-configuration">Retrofit Configuration</h3>
-            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
-
-            <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>Retrofit</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
-            <h4>Custom Gson Converter Example</h4>
-            <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
-            <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
-            <pre class="prettyprint">Gson gson = new GsonBuilder()
-    .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
-    .registerTypeAdapter(Date.class, new DateTypeAdapter())
-    .create();
-
-Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.github.com")
-    .setConverter(new GsonConverter(gson))
-    .build();
-
-GitHubService service = retrofit.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>Retrofit</code>.</p>
-            <h4>Content format Agnostic</h4>
-            <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href="http://simple.sourceforge.net/">Simple</a>) and Protocol Buffers (using <a href="https://code.google.com/p/protobuf/">protobuf</a> or <a href="https://github.com/square/wire">Wire</a>). Please see the <a href="https://github.com/square/retrofit/tree/master/retrofit-converters">retrofit-converters</a> directory for the full listing of converters.</p>
-            <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.soundcloud.com")
-    .setConverter(new SimpleXMLConverter())
-    .build();
-
-SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
-            <h4>Custom Converters</h4>
-            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
-            <h4>Custom Error Handling</h4>
-            <p>If you need custom error handling for requests, you may provide your own <code>ErrorHandler</code>. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code</p>
-            <pre class="prettyprint">
-class MyErrorHandler implements ErrorHandler {
-  @Override public Throwable handleError(RetrofitError cause) {
-    Response r = cause.getResponse();
-    if (r != null && r.getStatus() == 401) {
-      return new UnauthorizedException(cause);
-    }
-    return cause;
-  }
-}
-
-Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.github.com")
-    .setErrorHandler(new MyErrorHandler())
-    .build();</pre>
-            <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
-
-            <h4>Logging</h4>
-            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>Retrofit</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
-            <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
-            <pre class="prettyprint">
-Retrofit retrofit = new Retrofit.Builder()
-    .setLogLevel(Retrofit.LogLevel.FULL)
-    .setEndpoint("https://api.github.com")
-    .build();</pre>
-            <p>This logging can be added or changed at any point in the <code>Retrofit</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
-
-            <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
+Call&lt;User> getUser(@Path("username") String username);</pre>
+              <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
+              <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
+              <pre class="prettyprint">@GET("/user")
+Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
+              <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
+
+              <h4>Synchronous vs. Asynchronous</h4>
+              <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
+              <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
+            </section>
+
+            <section id="restadapter-configuration">
+              <h3>Retrofit Configuration</h3>
+              <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+
+              <h4>Converters</h4>
+              <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
+              <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
+              <ul>
+                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
+                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
+                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
+                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
+                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
+                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
+              </ul>
+              <h4>Custom Converters</h4>
+              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> interface</a> and pass in an instance when building your adapter.</p>
+            </section>
+
+            <section id="download">
+              <h3>Download</h3>
+              <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+              <h4>Maven</h4>
+              <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit&lt;/groupId>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
-            <h4>Gradle</h4>
-            <pre class="prettyprint">
+              <h4>Gradle</h4>
+              <pre class="prettyprint">
 compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-            <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
+              <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-            <h4>Integration with OkHttp</h4>
-            <p>Retrofit will automatically use OkHttp (version 2.0 or newer) when it is present.</p>
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
-  &lt;artifactId>okhttp&lt;/artifactId>
-  &lt;version><span class="okhttpversion pln"><em>(insert latest version)</em></span>&lt;/version>
-&lt;/dependency>
-</pre>
-            <h4>Gradle</h4>
-<pre class="prettyprint">
-compile 'com.squareup.okhttp:okhttp:<span class="okhttpversion pln"><em>(insert latest version)</em></span>'
-</pre>
-            <h4>ProGuard</h4>
-            <p>If you are using Proguard in your project add the following lines to your configuration:</p>
-            <pre class="prettyprint">
+              <h4>ProGuard</h4>
+              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+              <pre class="prettyprint">
 -dontwarn retrofit.**
 -keep class retrofit.** { *; }
 -keepattributes Signature
 -keepattributes Exceptions
 </pre>
-            <h3 id="contributing">Contributing</h3>
-            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            </section>
+
+            <section id="contributing">
+              <h3>Contributing</h3>
+              <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
+              <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            </section>
 
-            <h3 id="license">License</h3>
-            <pre>Copyright 2013 Square, Inc.
+            <section id="license">
+              <h3>License</h3>
+              <pre>Copyright 2013 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -280,6 +195,7 @@ <h3 id="license">License</h3>
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</pre>
+            </section>
           </div>
           <div class="span3">
             <div class="content-nav" data-spy="affix" data-offset-top="80">
@@ -338,9 +254,6 @@ <h3 id="license">License</h3>
           $('.version-tag').text('v' + version);
           $('.version-href').attr('href', url);
         });
-        $.fn.artifactVersion('com.squareup.okhttp', 'okhttp', function(version, url) {
-          $('.okhttpversion').text(version);
-        });
       });
 
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
