diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4ade4be59..79750dded 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,33 @@
 Change Log
 ==========
 
+Version 2.3.0 *(2017-05-13)*
+----------------------------
+
+ *  **Retrofit now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+    **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ * New: Converters added for Java 8's and Guava's `Optional` which wrap a potentially-nullable
+   response body. These converters still rely on normal serialization library converters for parsing
+   the response bytes into an object.
+ * New: String converters that return `null` for an `@Query` or `@Field` parameter are now skipped.
+ * New: The mock module's `NetworkBehavior` now throws a custom subclass of `IOException` to more
+   clearly indicate the exception's source.
+ * RxJava 1.x converter updated to 1.3.0 which stabilizes the use of `Completable`.
+ * Fix: Add explicit handling for `OnCompleteFailedException`, `OnErrorFailedException`, and
+   `OnErrorNotImplementedException` for RxJava 1.x to ensure they're correct delivered to the
+   plugins/hooks for handling.
+ * Fix: `NoSuchElementException` thrown when unsubscribing from an RxJava 1.x `Single`.
+
+
 Version 2.2.0 *(2017-02-21)*
 ----------------------------
 
@@ -455,3 +482,6 @@ Version 1.0.0 *(2013-05-13)*
 ----------------------------
 
 Initial release.
+
+
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/README.md b/README.md
index 0688de8e5..60b96a0e2 100644
--- a/README.md
+++ b/README.md
@@ -14,12 +14,12 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>retrofit</artifactId>
-  <version>2.2.0</version>
+  <version>2.3.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit:2.2.0'
+compile 'com.squareup.retrofit2:retrofit:2.3.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -27,6 +27,15 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 Retrofit requires at minimum Java 7 or Android 2.3.
 
 
+ProGuard
+--------
+
+If you are using ProGuard you might need to add the following options:
+```
+-dontwarn okio.**
+-dontwarn javax.annotation.**
+```
+
 
 License
 =======
diff --git a/checkstyle.xml b/checkstyle.xml
index 73b55406d..4721a2fdc 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
     <module name="NewlineAtEndOfFile">
diff --git a/pom.xml b/pom.xml
index a93e7e2ec..6450ad503 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.3.0-SNAPSHOT</version>
+  <version>2.4.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -49,21 +49,21 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.6.0</okhttp.version>
+    <okhttp.version>3.9.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.2.0</rxjava.version>
+    <rxjava.version>1.3.0</rxjava.version>
     <rxjava2.version>2.0.0</rxjava2.version>
     <guava.version>19.0</guava.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.7</gson.version>
+    <gson.version>2.8.2</gson.version>
     <protobuf.version>3.0.0</protobuf.version>
     <jackson.version>2.7.2</jackson.version>
     <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.4.0</moshi.version>
+    <moshi.version>1.5.0</moshi.version>
 
     <!-- Sample Dependencies -->
     <jsoup.version>1.7.3</jsoup.version>
@@ -156,7 +156,11 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -237,7 +241,7 @@
           <dependency>
             <groupId>com.puppycrawl.tools</groupId>
             <artifactId>checkstyle</artifactId>
-            <version>7.3</version>
+            <version>7.7</version>
           </dependency>
         </dependencies>
         <configuration>
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
index 171ba8a5e..b1449e80e 100644
--- a/retrofit-adapters/guava/README.md
+++ b/retrofit-adapters/guava/README.md
@@ -4,6 +4,26 @@ Guava Adapter
 An `Adapter` for adapting [Guava][1] `ListenableFuture`.
 
 
+Usage
+-----
+
+Add `GuavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `ListenableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  ListenableFuture<User> getUser();
+}
+```
+
+
 Download
 --------
 
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index 884e97963..b5dbb1f5f 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
new file mode 100644
index 000000000..7943d1191
--- /dev/null
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.guava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 1280b727b..83424c809 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -4,6 +4,26 @@ Java8 Adapter
 An `Adapter` for adapting [Java8][1] `CompletableFuture`.
 
 
+Usage
+-----
+
+Add `Java8CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(Java8CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use `CompletableFuture` as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  CompletableFuture<User> getUser();
+}
+```
+
+
 Download
 --------
 
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 87893ff43..4bcdd6727 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
new file mode 100644
index 000000000..7e36b199e
--- /dev/null
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.java8;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index da39f934c..9c55ab105 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
index 42e1804e0..3352daf8f 100644
--- a/retrofit-adapters/rxjava/README.md
+++ b/retrofit-adapters/rxjava/README.md
@@ -9,6 +9,34 @@ Available types:
  * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
  * `Completable` where response bodies are discarded.
 
+
+Usage
+-----
+
+Add `RxJavaCallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
+
 Download
 --------
 
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index 9046f2d28..4f010a453 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>io.reactivex</groupId>
       <artifactId>rxjava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
index 2bedc367e..d91105734 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -20,6 +20,9 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
 import rx.plugins.RxJavaPlugins;
 
 final class BodyOnSubscribe<T> implements OnSubscribe<T> {
@@ -51,6 +54,10 @@
         Throwable t = new HttpException(response);
         try {
           subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
         } catch (Throwable inner) {
           Exceptions.throwIfFatal(inner);
           CompositeException composite = new CompositeException(t, inner);
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
index 34b0b004a..4162ecfab 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
@@ -23,6 +23,9 @@
 import rx.Subscription;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
 import rx.plugins.RxJavaPlugins;
 
 final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
@@ -114,10 +117,19 @@ private void deliverResponse(Response<T> response) {
       if (!isUnsubscribed()) {
         subscriber.onNext(response);
       }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+      return;
     } catch (Throwable t) {
       Exceptions.throwIfFatal(t);
       try {
         subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
       } catch (Throwable inner) {
         Exceptions.throwIfFatal(inner);
         CompositeException composite = new CompositeException(t, inner);
@@ -126,7 +138,13 @@ private void deliverResponse(Response<T> response) {
       return;
     }
     try {
-      subscriber.onCompleted();
+      if (!isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
+    } catch (OnCompletedFailedException
+        | OnErrorFailedException
+        | OnErrorNotImplementedException e) {
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
     } catch (Throwable t) {
       Exceptions.throwIfFatal(t);
       RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
@@ -139,6 +157,10 @@ void emitError(Throwable t) {
     if (!isUnsubscribed()) {
       try {
         subscriber.onError(t);
+      } catch (OnCompletedFailedException
+          | OnErrorFailedException
+          | OnErrorNotImplementedException e) {
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
       } catch (Throwable inner) {
         Exceptions.throwIfFatal(inner);
         CompositeException composite = new CompositeException(t, inner);
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 49abfae2b..29af1ff44 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -16,24 +16,27 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> error(Throwable error) {
     if (error == null) throw new NullPointerException("error == null");
     return new Result<>(null, error);
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> response(Response<T> response) {
     if (response == null) throw new NullPointerException("response == null");
     return new Result<>(response, null);
   }
 
-  private final Response<T> response;
-  private final Throwable error;
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -42,7 +45,7 @@ private Result(Response<T> response, Throwable error) {
    * The response received from executing an HTTP request. Only present when {@link #isError()} is
    * false, null otherwise.
    */
-  public Response<T> response() {
+  public @Nullable Response<T> response() {
     return response;
   }
 
@@ -54,7 +57,7 @@ private Result(Response<T> response, Throwable error) {
    * remote server. Any other exception type indicates an unexpected failure and should be
    * considered fatal (configuration error, programming error, etc.).
    */
-  public Throwable error() {
+  public @Nullable Throwable error() {
     return error;
   }
 
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
index 798df5af8..4ac19c4fe 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
@@ -20,6 +20,9 @@
 import rx.Subscriber;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.exceptions.OnErrorNotImplementedException;
 import rx.plugins.RxJavaPlugins;
 
 final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
@@ -51,6 +54,10 @@
       } catch (Throwable t) {
         try {
           subscriber.onError(t);
+        } catch (OnCompletedFailedException
+            | OnErrorFailedException
+            | OnErrorNotImplementedException e) {
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
         } catch (Throwable inner) {
           Exceptions.throwIfFatal(inner);
           CompositeException composite = new CompositeException(t, inner);
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index f14c47181..cb75bdc2b 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -16,6 +16,7 @@
 package retrofit2.adapter.rxjava;
 
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
@@ -25,15 +26,15 @@
 
 final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isSingle;
   private final boolean isCompletable;
 
-  RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
-      boolean isBody, boolean isSingle, boolean isCompletable) {
+  RxJavaCallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isSingle, boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
     this.isAsync = isAsync;
@@ -70,18 +71,8 @@
       return observable.toSingle();
     }
     if (isCompletable) {
-      return CompletableHelper.toCompletable(observable);
-    }
-    return observable;
-  }
-
-  /**
-   * Separate static class defers classloading and bytecode verification since Completable is not an
-   * RxJava stable API yet.
-   */
-  private static final class CompletableHelper {
-    static Object toCompletable(Observable<?> observable) {
       return observable.toCompletable();
     }
+    return observable;
   }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index ee297ad30..51804b76f 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.HttpException;
 import retrofit2.Response;
@@ -77,15 +78,16 @@ public static RxJavaCallAdapterFactory createAsync() {
    * Returns an instance which creates synchronous observables that
    * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
     return new RxJavaCallAdapterFactory(scheduler, false);
   }
 
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
 
-  private RxJavaCallAdapterFactory(Scheduler scheduler, boolean isAsync) {
+  private RxJavaCallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
     this.isAsync = isAsync;
   }
@@ -94,7 +96,7 @@ private RxJavaCallAdapterFactory(Scheduler scheduler, boolean isAsync) {
   public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
     boolean isSingle = rawType == Single.class;
-    boolean isCompletable = "rx.Completable".equals(rawType.getCanonicalName());
+    boolean isCompletable = rawType == Completable.class;
     if (rawType != Observable.class && !isSingle && !isCompletable) {
       return null;
     }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
new file mode 100644
index 000000000..255728495
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.rxjava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
index 2c2703769..30f04cc7c 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
@@ -29,6 +29,7 @@
 import rx.Completable;
 import rx.exceptions.CompositeException;
 import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorFailedException;
 import rx.observers.AsyncCompletableSubscriber;
 import rx.observers.TestSubscriber;
 import rx.plugins.RxJavaErrorHandler;
@@ -38,6 +39,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public final class AsyncTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -135,9 +137,45 @@
       }
     });
 
-    latch.await(1, SECONDS);
-    //noinspection ThrowableResultOfMethodCallIgnored
+    assertTrue(latch.await(1, SECONDS));
     CompositeException composite = (CompositeException) pluginRef.get();
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
+
+  @Test public void bodyThrowingInOnSafeSubscriberErrorDeliveredToPlugin()
+      throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+          latch.countDown();
+        }
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    OnErrorFailedException failed = (OnErrorFailedException) pluginRef.get();
+    CompositeException composite = (CompositeException) failed.getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..9a0dec34a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingSafeSubscriberTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
new file mode 100644
index 000000000..be4263b8c
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableThrowingTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.CompletableSubscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Void> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  static abstract class ForwardingCompletableObserver implements CompletableSubscriber {
+    private final RecordingSubscriber<Void> delegate;
+
+    ForwardingCompletableObserver(RecordingSubscriber<Void> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription d) {
+    }
+
+    @Override public void onCompleted() {
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 4a8d8652f..500c3c539 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -26,6 +26,7 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Observable;
+import rx.functions.Action1;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -133,6 +134,22 @@
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
+  @Test public void responseUnsubscribedDoesNotCallCompleted() throws InterruptedException {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response()
+        .doOnNext(new Action1<Response<String>>() {
+          @Override
+          public void call(Response<String> response) {
+            subscriber.unsubscribe();
+          }
+        })
+        .subscribe(subscriber);
+
+    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+  }
+
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
new file mode 100644
index 000000000..550d6cbc3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingSafeSubscriberTest.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnCompletedFailedException;
+import rx.exceptions.OnErrorFailedException;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingSafeSubscriberTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnCompletedFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get().getCause()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (throwable instanceof OnErrorFailedException) {
+          if (!pluginRef.compareAndSet(null, throwable)) {
+            throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+          }
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get().getCause();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
new file mode 100644
index 000000000..59c8ae5ae
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableThrowingTest.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Observable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onCompleted() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
new file mode 100644
index 000000000..5266a4f44
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleThrowingTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Single;
+import rx.SingleSubscriber;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(pluginRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> extends SingleSubscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingObserver(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onNext(value);
+      delegate.onCompleted();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
index 67564e490..0512f9fbb 100644
--- a/retrofit-adapters/rxjava2/README.md
+++ b/retrofit-adapters/rxjava2/README.md
@@ -11,6 +11,33 @@ Available types:
  * `Maybe<T>`, `Maybe<Response<T>>`, and `Maybe<Result<T>>`  where `T` is the body type.
  * `Completable` where response bodies are discarded.
 
+
+Usage
+-----
+
+Add `RxJava2CallAdapterFactory` as a `Call` adapter when building your `Retrofit` instance:
+```java
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://example.com/")
+    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+    .build();
+```
+
+Your service methods can now use any of the above types as their return type.
+```java
+interface MyService {
+  @GET("/user")
+  Observable<User> getUser();
+}
+```
+
+By default all reactive types execute their requests synchronously. There are multiple ways to
+control the threading on which a request occurs:
+
+ * Call `subscribeOn` on the returned reactive type with a `Scheduler` of your choice.
+ * Use `createAsync()` when creating the factory which will use OkHttp's internal thread pool.
+ * Use `createWithScheduler(Scheduler)` to supply a default subscription `Scheduler`.
+
 Download
 --------
 
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
index 1bc459ded..d9a14127c 100644
--- a/retrofit-adapters/rxjava2/pom.xml
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>io.reactivex.rxjava2</groupId>
       <artifactId>rxjava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
index dac56cdbb..e43d7204f 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
@@ -16,24 +16,27 @@
 package retrofit2.adapter.rxjava2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> error(Throwable error) {
     if (error == null) throw new NullPointerException("error == null");
     return new Result<>(null, error);
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static <T> Result<T> response(Response<T> response) {
     if (response == null) throw new NullPointerException("response == null");
     return new Result<>(response, null);
   }
 
-  private final Response<T> response;
-  private final Throwable error;
+  private final @Nullable Response<T> response;
+  private final @Nullable Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
+  private Result(@Nullable Response<T> response, @Nullable Throwable error) {
     this.response = response;
     this.error = error;
   }
@@ -42,7 +45,7 @@ private Result(Response<T> response, Throwable error) {
    * The response received from executing an HTTP request. Only present when {@link #isError()} is
    * false, null otherwise.
    */
-  public Response<T> response() {
+  public @Nullable Response<T> response() {
     return response;
   }
 
@@ -54,7 +57,7 @@ private Result(Response<T> response, Throwable error) {
    * remote server. Any other exception type indicates an unexpected failure and should be
    * considered fatal (configuration error, programming error, etc.).
    */
-  public Throwable error() {
+  public @Nullable Throwable error() {
     return error;
   }
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index a585e3113..eccd30da3 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -19,13 +19,14 @@
 import io.reactivex.Observable;
 import io.reactivex.Scheduler;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 
 final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
@@ -34,8 +35,8 @@
   private final boolean isMaybe;
   private final boolean isCompletable;
 
-  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
-      boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
+  RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
+      boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
       boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index e4b685999..8af54c505 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -25,6 +25,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.HttpException;
 import retrofit2.Response;
@@ -75,15 +76,16 @@ public static RxJava2CallAdapterFactory createAsync() {
    * Returns an instance which creates synchronous observables that
    * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
     return new RxJava2CallAdapterFactory(scheduler, false);
   }
 
-  private final Scheduler scheduler;
+  private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
 
-  private RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync) {
+  private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
     this.isAsync = isAsync;
   }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
new file mode 100644
index 000000000..c5fc01992
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.adapter.rxjava2;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
index 589716125..dea046f63 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
@@ -73,10 +73,10 @@
     assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mBodyClass = new TypeToken<Maybe<String>>() {}.getType();
-    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mBodyClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fBodyClass = new TypeToken<Flowable<String>>() {}.getType();
-    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fBodyClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
@@ -86,10 +86,10 @@
     assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mBodyWildcard = new TypeToken<Maybe<? extends String>>() {}.getType();
-    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fBodyWildcard = new TypeToken<Flowable<? extends String>>() {}.getType();
-    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
@@ -99,10 +99,10 @@
     assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type mBodyGeneric = new TypeToken<Maybe<List<String>>>() {}.getType();
-    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type fBodyGeneric = new TypeToken<Flowable<List<String>>>() {}.getType();
-    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
 
     Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
@@ -112,10 +112,10 @@
     assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();
-    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResponseClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();
-    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResponseClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
@@ -125,10 +125,10 @@
     assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResponseWildcard = new TypeToken<Maybe<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResponseWildcard = new TypeToken<Flowable<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
@@ -138,10 +138,10 @@
     assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResultClass = new TypeToken<Maybe<Result<String>>>() {}.getType();
-    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResultClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResultClass = new TypeToken<Flowable<Result<String>>>() {}.getType();
-    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResultClass, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
 
     Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
@@ -151,10 +151,10 @@
     assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type mResultWildcard = new TypeToken<Maybe<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(mResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
     Type fResultWildcard = new TypeToken<Flowable<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+    assertThat(factory.get(fResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(String.class);
   }
 
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index b8347a96b..823e50491 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index e6c702705..468d576d7 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -46,14 +46,15 @@ public static GsonConverterFactory create() {
    * Create an instance using {@code gson} for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static GsonConverterFactory create(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
     return new GsonConverterFactory(gson);
   }
 
   private final Gson gson;
 
   private GsonConverterFactory(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
     this.gson = gson;
   }
 
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
new file mode 100644
index 000000000..b8ad27810
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.gson;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/README.md b/retrofit-converters/guava/README.md
new file mode 100644
index 000000000..03eae96f5
--- /dev/null
+++ b/retrofit-converters/guava/README.md
@@ -0,0 +1,30 @@
+Guava Converter
+===============
+
+A `Converter` which supports Guava's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-guava&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/guava/pom.xml b/retrofit-converters/guava/pom.xml
new file mode 100644
index 000000000..9ac3c5b5e
--- /dev/null
+++ b/retrofit-converters/guava/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-guava</artifactId>
+  <name>Converter: Guava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
new file mode 100644
index 000000000..bfa033614
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class GuavaOptionalConverterFactory extends Converter.Factory {
+  public static GuavaOptionalConverterFactory create() {
+    return new GuavaOptionalConverterFactory();
+  }
+
+  private GuavaOptionalConverterFactory() {
+  }
+
+  @Nullable @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
new file mode 100644
index 000000000..72f2184db
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.fromNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
new file mode 100644
index 000000000..bd25d1fe4
--- /dev/null
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit.converter.guava;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..923252301
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/AlwaysNullConverterFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
new file mode 100644
index 000000000..27680150e
--- /dev/null
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.guava;
+
+import com.google.common.base.Optional;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GuavaOptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+}
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index b22877e60..f03526863 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-databind</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index 4b224bd97..5e5106c45 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -41,14 +41,15 @@ public static JacksonConverterFactory create() {
   }
 
   /** Create an instance using {@code mapper} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static JacksonConverterFactory create(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException("mapper == null");
     return new JacksonConverterFactory(mapper);
   }
 
   private final ObjectMapper mapper;
 
   private JacksonConverterFactory(ObjectMapper mapper) {
-    if (mapper == null) throw new NullPointerException("mapper == null");
     this.mapper = mapper;
   }
 
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
new file mode 100644
index 000000000..f747a1d6d
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.jackson;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
new file mode 100644
index 000000000..696ac23c6
--- /dev/null
+++ b/retrofit-converters/java8/README.md
@@ -0,0 +1,30 @@
+Java 8 Converter
+================
+
+A `Converter` which supports Java 8's `Optional<T>` by delegating to other converters for `T`
+and then wrapping it into `Optional`.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-java8</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-java8:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-java8&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-java8%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/java8/pom.xml b/retrofit-converters/java8/pom.xml
new file mode 100644
index 000000000..c43d2a9bd
--- /dev/null
+++ b/retrofit-converters/java8/pom.xml
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-java8</artifactId>
+  <name>Converter: Java 8</name>
+
+  <properties>
+    <java.version>1.8</java.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <configuration>
+          <signature>
+            <groupId>org.kaazing.mojo.signature</groupId>
+            <artifactId>java18</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
new file mode 100644
index 000000000..7b55ca965
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+public final class Java8OptionalConverterFactory extends Converter.Factory {
+  public static Java8OptionalConverterFactory create() {
+    return new Java8OptionalConverterFactory();
+  }
+
+  private Java8OptionalConverterFactory() {
+  }
+
+  @Nullable @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
new file mode 100644
index 000000000..438443256
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/OptionalConverter.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+  private final Converter<ResponseBody, T> delegate;
+
+  OptionalConverter(Converter<ResponseBody, T> delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public Optional<T> convert(ResponseBody value) throws IOException {
+    return Optional.ofNullable(delegate.convert(value));
+  }
+}
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
new file mode 100644
index 000000000..e883be032
--- /dev/null
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit.converter.java8;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
new file mode 100644
index 000000000..006b90624
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/AlwaysNullConverterFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class AlwaysNullConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, Object>() {
+      @Override public Object convert(ResponseBody value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..73027907b
--- /dev/null
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.converter.java8;
+
+import java.io.IOException;
+import java.util.Optional;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class Java8OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .addConverterFactory(new AlwaysNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+}
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 11ab6a2f4..51f42efca 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index 311d76d0d..b7c016190 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -49,6 +49,7 @@ public static MoshiConverterFactory create() {
   }
 
   /** Create an instance using {@code moshi} for conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static MoshiConverterFactory create(Moshi moshi) {
     if (moshi == null) throw new NullPointerException("moshi == null");
     return new MoshiConverterFactory(moshi, false, false, false);
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
new file mode 100644
index 000000000..2d5a38a51
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.moshi;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 4c49a4a88..c6258b38c 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -16,8 +16,10 @@
 
   <modules>
     <module>gson</module>
+    <module>guava</module>
     <module>protobuf</module>
     <module>jackson</module>
+    <module>java8</module>
     <module>wire</module>
     <module>simplexml</module>
     <module>scalars</module>
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 55f42504e..e70cd7fba 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>com.google.protobuf</groupId>
       <artifactId>protobuf-java</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index ec2aac452..6fb529429 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -23,6 +23,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -40,13 +41,13 @@ public static ProtoConverterFactory create() {
   }
 
   /** Create an instance which uses {@code registry} when deserializing. */
-  public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
+  public static ProtoConverterFactory createWithRegistry(@Nullable ExtensionRegistryLite registry) {
     return new ProtoConverterFactory(registry);
   }
 
-  private final ExtensionRegistryLite registry;
+  private final @Nullable ExtensionRegistryLite registry;
 
-  private ProtoConverterFactory(ExtensionRegistryLite registry) {
+  private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
     this.registry = registry;
   }
 
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index 324199458..fc840dc64 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -20,15 +20,16 @@
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
     implements Converter<ResponseBody, T> {
   private final Parser<T> parser;
-  private final ExtensionRegistryLite registry;
+  private final @Nullable ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
+  ProtoResponseBodyConverter(Parser<T> parser, @Nullable ExtensionRegistryLite registry) {
     this.parser = parser;
     this.registry = registry;
   }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
new file mode 100644
index 000000000..c976ca568
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.protobuf;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index 70d15a493..56140758a 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
new file mode 100644
index 000000000..0ea2f7740
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.scalars;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index b7f03efcf..f119e08d1 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,6 +23,11 @@
       <groupId>org.simpleframework</groupId>
       <artifactId>simple-xml</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index b7563455e..4cbe2d86f 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -47,7 +47,9 @@ public static SimpleXmlConverterFactory createNonStrict() {
   }
 
   /** Create an instance using {@code serializer} for non-strict conversion. */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    if (serializer == null) throw new NullPointerException("serializer == null");
     return new SimpleXmlConverterFactory(serializer, false);
   }
 
@@ -55,7 +57,6 @@ public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
   private final boolean strict;
 
   private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
     this.serializer = serializer;
     this.strict = strict;
   }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
new file mode 100644
index 000000000..69507b872
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.simplexml;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 9c36850ac..a965b89f8 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -34,6 +34,11 @@
         </exclusion>
       </exclusions>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
new file mode 100644
index 000000000..483b65c81
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.converter.wire;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 2e6079447..85959397a 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -19,6 +19,11 @@
       <artifactId>retrofit</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index 8ec2b7073..e7c48cf22 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.concurrent.GuardedBy;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -34,7 +35,8 @@
 
   private volatile Future<?> task;
   volatile boolean canceled;
-  private volatile boolean executed;
+  @GuardedBy("this")
+  private boolean executed;
 
   BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
     this.behavior = behavior;
@@ -51,6 +53,7 @@
     return delegate.request();
   }
 
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   @Override public void enqueue(final Callback<T> callback) {
     if (callback == null) throw new NullPointerException("callback == null");
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 21af3a6d3..b525696fb 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutorService;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -46,7 +47,7 @@
     this.service = service;
   }
 
-  public T returningResponse(Object response) {
+  public T returningResponse(@Nullable Object response) {
     return returning(Calls.response(response));
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 4a4721e6a..42947a95f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -33,7 +34,7 @@
     return new DeferredCall<>(callable);
   }
 
-  public static <T> Call<T> response(T successValue) {
+  public static <T> Call<T> response(@Nullable T successValue) {
     return new FakeCall<>(Response.success(successValue), null);
   }
 
@@ -55,7 +56,7 @@ private Calls() {
     private final AtomicBoolean canceled = new AtomicBoolean();
     private final AtomicBoolean executed = new AtomicBoolean();
 
-    FakeCall(Response<T> response, IOException error) {
+    FakeCall(@Nullable Response<T> response, @Nullable IOException error) {
       if ((response == null) == (error == null)) {
         throw new AssertionError("Only one of response or error can be set.");
       }
@@ -76,6 +77,7 @@ private Calls() {
       throw error;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     @Override public void enqueue(Callback<T> callback) {
       if (callback == null) {
         throw new NullPointerException("callback == null");
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..40185baaa 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -53,17 +53,20 @@ public Executor backgroundExecutor() {
     private NetworkBehavior behavior;
     private ExecutorService executor;
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder(Retrofit retrofit) {
       if (retrofit == null) throw new NullPointerException("retrofit == null");
       this.retrofit = retrofit;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder networkBehavior(NetworkBehavior behavior) {
       if (behavior == null) throw new NullPointerException("behavior == null");
       this.behavior = behavior;
       return this;
     }
 
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
     public Builder backgroundExecutor(ExecutorService executor) {
       if (executor == null) throw new NullPointerException("executor == null");
       this.executor = executor;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
new file mode 100644
index 000000000..d4cdfc2c0
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofitIOException.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+
+final class MockRetrofitIOException extends IOException {
+  MockRetrofitIOException() {
+    super("Failure triggered by MockRetrofit's NetworkBehavior");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index 5636e9dd5..263808dd4 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -36,8 +36,8 @@
  * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
  * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
  * <p>
- * By default, instances of this class will use a 2 second delay with 40% variance and failures
- * will occur 3% of the time.
+ * By default, instances of this class will use a 2 second delay with 40% variance. Failures
+ * will occur 3% of the time. HTTP errors will occur 0% of the time.
  */
 public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
@@ -54,6 +54,7 @@ public static NetworkBehavior create() {
    * Create an instance with default behavior which uses {@code random} to control variance and
    * failure calculation.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public static NetworkBehavior create(Random random) {
     if (random == null) throw new NullPointerException("random == null");
     return new NetworkBehavior(random);
@@ -75,7 +76,7 @@ public static NetworkBehavior create(Random random) {
   private NetworkBehavior(Random random) {
     this.random = random;
 
-    failureException = new IOException("Mock failure!");
+    failureException = new MockRetrofitIOException();
     failureException.setStackTrace(new StackTraceElement[0]);
   }
 
@@ -120,6 +121,7 @@ public int failurePercent() {
    * It is a best practice to remove the stack trace from {@code exception} since it can
    * misleadingly point to code unrelated to this class.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public void setFailureException(Throwable exception) {
     if (exception == null) {
       throw new NullPointerException("exception == null");
@@ -147,6 +149,7 @@ public void setErrorPercent(int errorPercent) {
    * Set the error response factory to be used when an error is triggered. This factory may only
    * return responses for which {@link Response#isSuccessful()} returns false.
    */
+  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
   public void setErrorFactory(Callable<Response<?>> errorFactory) {
     if (errorFactory == null) {
       throw new NullPointerException("errorFactory == null");
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
new file mode 100644
index 000000000..cb99df00c
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
@@ -0,0 +1,4 @@
+@ParametersAreNonnullByDefault
+package retrofit2.mock;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 300d57135..73de57911 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -33,7 +33,8 @@
 
   @Test public void defaultThrowable() {
     Throwable t = behavior.failureException();
-    assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage("Mock failure!");
+    assertThat(t).isInstanceOf(IOException.class)
+        .isExactlyInstanceOf(MockRetrofitIOException.class);
     assertThat(t.getStackTrace()).isEmpty();
   }
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index f4e4a45b8..6a2cea74b 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,6 +30,11 @@
       <artifactId>animal-sniffer-annotations</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 927540bf4..97d34585d 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 
 /**
  * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
@@ -64,7 +65,7 @@
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
      * cannot be handled by this factory.
      */
-    public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+    public abstract @Nullable CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
         Retrofit retrofit);
 
     /**
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 880eea9b8..37a64f8d1 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -17,7 +17,9 @@
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
@@ -47,8 +49,8 @@
      * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
      * declaration.
      */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,
+        Annotation[] annotations, Retrofit retrofit) {
       return null;
     }
 
@@ -58,7 +60,7 @@
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
      * values.
      */
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
+    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       return null;
     }
@@ -70,9 +72,25 @@
      * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
      * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
      */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,
         Retrofit retrofit) {
       return null;
     }
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 14bc700b7..c547caf6b 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,8 @@
 package retrofit2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -28,16 +30,18 @@
 
 final class OkHttpCall<T> implements Call<T> {
   private final ServiceMethod<T, ?> serviceMethod;
-  private final Object[] args;
+  private final @Nullable Object[] args;
 
   private volatile boolean canceled;
 
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
+  @GuardedBy("this")
+  private @Nullable okhttp3.Call rawCall;
+  @GuardedBy("this")
+  private @Nullable Throwable creationFailure; // Either a RuntimeException or IOException.
+  @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
+  OkHttpCall(ServiceMethod<T, ?> serviceMethod, @Nullable Object[] args) {
     this.serviceMethod = serviceMethod;
     this.args = args;
   }
@@ -114,11 +118,7 @@
       }
 
       @Override public void onFailure(okhttp3.Call call, IOException e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
-        }
+        callFailure(e);
       }
 
       private void callFailure(Throwable e) {
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index f0aa001d1..10238b026 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
@@ -25,11 +26,12 @@
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, T value) throws IOException;
+  abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
 
   final ParameterHandler<Iterable<T>> iterable() {
     return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+      @Override void apply(RequestBuilder builder, @Nullable Iterable<T> values)
+          throws IOException {
         if (values == null) return; // Skip null values.
 
         for (T value : values) {
@@ -41,7 +43,7 @@
 
   final ParameterHandler<Object> array() {
     return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, Object values) throws IOException {
+      @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException {
         if (values == null) return; // Skip null values.
 
         for (int i = 0, size = Array.getLength(values); i < size; i++) {
@@ -53,7 +55,8 @@
   }
 
   static final class RelativeUrl extends ParameterHandler<Object> {
-    @Override void apply(RequestBuilder builder, Object value) {
+    @Override void apply(RequestBuilder builder, @Nullable Object value) {
+      checkNotNull(value, "@Url parameter is null.");
       builder.setRelativeUrl(value);
     }
   }
@@ -67,9 +70,13 @@
       this.valueConverter = valueConverter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
+
+      String headerValue = valueConverter.convert(value);
+      if (headerValue == null) return; // Skip converted but null values.
+
+      builder.addHeader(name, headerValue);
     }
   }
 
@@ -84,7 +91,7 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) {
         throw new IllegalArgumentException(
             "Path parameter \"" + name + "\" value must not be null.");
@@ -104,9 +111,13 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
+
+      String queryValue = valueConverter.convert(value);
+      if (queryValue == null) return; // Skip converted but null values
+
+      builder.addQueryParam(name, queryValue, encoded);
     }
   }
 
@@ -119,7 +130,7 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
       builder.addQueryParam(nameConverter.convert(value), null, encoded);
     }
@@ -134,7 +145,8 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Query map was null.");
       }
@@ -149,7 +161,19 @@
           throw new IllegalArgumentException(
               "Query map contained null value for key '" + entryKey + "'.");
         }
-        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+
+        String convertedEntryValue = valueConverter.convert(entryValue);
+        if (convertedEntryValue == null) {
+          throw new IllegalArgumentException("Query map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
+        }
+
+        builder.addQueryParam(entryKey, convertedEntryValue, encoded);
       }
     }
   }
@@ -161,7 +185,8 @@
       this.valueConverter = valueConverter;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Header map was null.");
       }
@@ -192,9 +217,13 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
+
+      String fieldValue = valueConverter.convert(value);
+      if (fieldValue == null) return; // Skip null converted values
+
+      builder.addFormField(name, fieldValue, encoded);
     }
   }
 
@@ -207,7 +236,8 @@
       this.encoded = encoded;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Field map was null.");
       }
@@ -222,7 +252,19 @@
           throw new IllegalArgumentException(
               "Field map contained null value for key '" + entryKey + "'.");
         }
-        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+
+        String fieldEntry = valueConverter.convert(entryValue);
+        if (fieldEntry == null) {
+          throw new IllegalArgumentException("Field map value '"
+              + entryValue
+              + "' converted to null by "
+              + valueConverter.getClass().getName()
+              + " for key '"
+              + entryKey
+              + "'.");
+        }
+
+        builder.addFormField(entryKey, fieldEntry, encoded);
       }
     }
   }
@@ -236,7 +278,7 @@
       this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) return; // Skip null values.
 
       RequestBody body;
@@ -255,7 +297,8 @@
     private RawPart() {
     }
 
-    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable MultipartBody.Part value)
+        throws IOException {
       if (value != null) { // Skip null values.
         builder.addPart(value);
       }
@@ -271,7 +314,8 @@ private RawPart() {
       this.transferEncoding = transferEncoding;
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+        throws IOException {
       if (value == null) {
         throw new IllegalArgumentException("Part map was null.");
       }
@@ -303,7 +347,7 @@ private RawPart() {
       this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, T value) {
+    @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) {
         throw new IllegalArgumentException("Body parameter value must not be null.");
       }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index ad9cf533c..3c3307b70 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -22,6 +22,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
@@ -47,11 +48,11 @@ private static Platform findPlatform() {
     return new Platform();
   }
 
-  Executor defaultCallbackExecutor() {
+  @Nullable Executor defaultCallbackExecutor() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+  CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
@@ -62,8 +63,8 @@ boolean isDefaultMethod(Method method) {
     return false;
   }
 
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
+  @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+      @Nullable Object... args) throws Throwable {
     throw new UnsupportedOperationException();
   }
 
@@ -74,7 +75,7 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
     }
 
     @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
+        @Nullable Object... args) throws Throwable {
       // Because the service interface might not be public, we need to use a MethodHandle lookup
       // that ignores the visibility of the declaringClass.
       Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
@@ -91,7 +92,8 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+      if (callbackExecutor == null) throw new AssertionError();
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
 
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index d7661199f..f27db26ee 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -26,8 +27,6 @@
 import okio.Buffer;
 import okio.BufferedSink;
 
-import static retrofit2.Utils.checkNotNull;
-
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
@@ -36,19 +35,20 @@
   private final String method;
 
   private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
+  private @Nullable String relativeUrl;
+  private @Nullable HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType contentType;
+  private @Nullable MediaType contentType;
 
   private final boolean hasBody;
-  private MultipartBody.Builder multipartBuilder;
-  private FormBody.Builder formBuilder;
-  private RequestBody body;
+  private @Nullable MultipartBody.Builder multipartBuilder;
+  private @Nullable FormBody.Builder formBuilder;
+  private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
+      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
+      boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -71,7 +71,6 @@
   }
 
   void setRelativeUrl(Object relativeUrl) {
-    checkNotNull(relativeUrl, "@Url parameter is null.");
     this.relativeUrl = relativeUrl.toString();
   }
 
@@ -144,7 +143,7 @@ private static void canonicalizeForPath(Buffer out, String input, int pos, int l
     }
   }
 
-  void addQueryParam(String name, String value, boolean encoded) {
+  void addQueryParam(String name, @Nullable String value, boolean encoded) {
     if (relativeUrl != null) {
       // Do a one-time combination of the built relative URL and the base URL.
       urlBuilder = baseUrl.newBuilder(relativeUrl);
@@ -156,12 +155,15 @@ void addQueryParam(String name, String value, boolean encoded) {
     }
 
     if (encoded) {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addEncodedQueryParameter(name, value);
     } else {
+      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
       urlBuilder.addQueryParameter(name, value);
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
   void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
       formBuilder.addEncoded(name, value);
@@ -170,10 +172,12 @@ void addFormField(String name, String value, boolean encoded) {
     }
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(Headers headers, RequestBody body) {
     multipartBuilder.addPart(headers, body);
   }
 
+  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
   void addPart(MultipartBody.Part part) {
     multipartBuilder.addPart(part);
   }
@@ -189,6 +193,7 @@ Request build() {
       url = urlBuilder.build();
     } else {
       // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      //noinspection ConstantConditions Non-null if urlBuilder is null.
       url = baseUrl.resolve(relativeUrl);
       if (url == null) {
         throw new IllegalArgumentException(
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 684a6c067..0f23bd4da 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -15,6 +15,7 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -25,7 +26,7 @@
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
+  public static <T> Response<T> success(@Nullable T body) {
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -38,7 +39,7 @@
    * Create a synthetic successful response using {@code headers} with {@code body} as the
    * deserialized body.
    */
-  public static <T> Response<T> success(T body, Headers headers) {
+  public static <T> Response<T> success(@Nullable T body, Headers headers) {
     checkNotNull(headers, "headers == null");
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
@@ -53,7 +54,7 @@
    * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
    * body.
    */
-  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
+  public static <T> Response<T> success(@Nullable T body, okhttp3.Response rawResponse) {
     checkNotNull(rawResponse, "rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
@@ -69,6 +70,7 @@
     if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
     return error(body, new okhttp3.Response.Builder() //
         .code(code)
+        .message("Response.error()")
         .protocol(Protocol.HTTP_1_1)
         .request(new Request.Builder().url("http://localhost/").build())
         .build());
@@ -85,10 +87,11 @@
   }
 
   private final okhttp3.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+  private final @Nullable T body;
+  private final @Nullable ResponseBody errorBody;
 
-  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+  private Response(okhttp3.Response rawResponse, @Nullable T body,
+      @Nullable ResponseBody errorBody) {
     this.rawResponse = rawResponse;
     this.body = body;
     this.errorBody = errorBody;
@@ -120,12 +123,12 @@ public boolean isSuccessful() {
   }
 
   /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
-  public T body() {
+  public @Nullable T body() {
     return body;
   }
 
   /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
-  public ResponseBody errorBody() {
+  public @Nullable ResponseBody errorBody() {
     return errorBody;
   }
 
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index a048b01c3..0c7de96a8 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -25,6 +25,7 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -63,12 +64,12 @@
   final HttpUrl baseUrl;
   final List<Converter.Factory> converterFactories;
   final List<CallAdapter.Factory> adapterFactories;
-  final Executor callbackExecutor;
+  final @Nullable Executor callbackExecutor;
   final boolean validateEagerly;
 
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
       List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
+      @Nullable Executor callbackExecutor, boolean validateEagerly) {
     this.callFactory = callFactory;
     this.baseUrl = baseUrl;
     this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
@@ -133,7 +134,7 @@
         new InvocationHandler() {
           private final Platform platform = Platform.get();
 
-          @Override public Object invoke(Object proxy, Method method, Object[] args)
+          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
@@ -210,7 +211,7 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no call adapter available for {@code type}.
    */
-  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+  public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
       Annotation[] annotations) {
     checkNotNull(returnType, "returnType == null");
     checkNotNull(annotations, "annotations == null");
@@ -241,7 +242,7 @@ public HttpUrl baseUrl() {
   }
 
   /**
-   * Returns a list of the factories tried when creating a
+   * Returns an unmodifiable list of the factories tried when creating a
    * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
    * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
    * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
@@ -267,8 +268,9 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+  public <T> Converter<T, RequestBody> nextRequestBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
+      Annotation[] methodAnnotations) {
     checkNotNull(type, "type == null");
     checkNotNull(parameterAnnotations, "parameterAnnotations == null");
     checkNotNull(methodAnnotations, "methodAnnotations == null");
@@ -317,8 +319,8 @@ public HttpUrl baseUrl() {
    *
    * @throws IllegalArgumentException if no converter available for {@code type}.
    */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
+  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
+      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
     checkNotNull(type, "type == null");
     checkNotNull(annotations, "annotations == null");
 
@@ -375,7 +377,7 @@ public HttpUrl baseUrl() {
    * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
    * in which case callbacks should be made synchronously on the background thread.
    */
-  public Executor callbackExecutor() {
+  public @Nullable Executor callbackExecutor() {
     return callbackExecutor;
   }
 
@@ -391,18 +393,15 @@ public Builder newBuilder() {
    */
   public static final class Builder {
     private final Platform platform;
-    private okhttp3.Call.Factory callFactory;
+    private @Nullable okhttp3.Call.Factory callFactory;
     private HttpUrl baseUrl;
     private final List<Converter.Factory> converterFactories = new ArrayList<>();
     private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
+    private @Nullable Executor callbackExecutor;
     private boolean validateEagerly;
 
     Builder(Platform platform) {
       this.platform = platform;
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
     }
 
     public Builder() {
@@ -414,6 +413,8 @@ public Builder() {
       callFactory = retrofit.callFactory;
       baseUrl = retrofit.baseUrl;
       converterFactories.addAll(retrofit.converterFactories);
+      // BuiltInConverters instance added by build().
+      converterFactories.remove(0);
       adapterFactories.addAll(retrofit.adapterFactories);
       // Remove the default, platform-aware call adapter added by build().
       adapterFactories.remove(adapterFactories.size() - 1);
@@ -541,6 +542,16 @@ public Builder callbackExecutor(Executor executor) {
       return this;
     }
 
+    /** Returns a modifiable list of call adapter factories. */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+      return this.adapterFactories;
+    }
+
+    /** Returns a modifiable list of converter factories. */
+    public List<Converter.Factory> converterFactories() {
+      return this.converterFactories;
+    }
+
     /**
      * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
      * the configuration of all methods in the supplied interface.
@@ -576,7 +587,13 @@ public Retrofit build() {
       adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
 
       // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+      List<Converter.Factory> converterFactories =
+          new ArrayList<>(1 + this.converterFactories.size());
+
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverters());
+      converterFactories.addAll(this.converterFactories);
 
       return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
           callbackExecutor, validateEagerly);
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index a32f8101a..d0a19384c 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -93,7 +94,7 @@
   }
 
   /** Builds an HTTP request from method arguments. */
-  Request toRequest(Object... args) throws IOException {
+  Request toRequest(@Nullable Object... args) throws IOException {
     RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
         contentType, hasBody, isFormEncoded, isMultipart);
 
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 9c5737516..1b05c65a0 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -26,6 +26,7 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
@@ -280,7 +281,7 @@ static void checkNotPrimitive(Type type) {
     }
   }
 
-  static <T> T checkNotNull(T object, String message) {
+  static <T> T checkNotNull(@Nullable T object, String message) {
     if (object == null) {
       throw new NullPointerException(message);
     }
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 4dbd1bf11..06e369bc7 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,7 +28,9 @@
 /**
  * Named pair for a form-encoded request.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then form URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * field pair for each non-{@code null} item.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index aa1facd39..248abc15e 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -18,15 +18,19 @@
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
 import java.util.Map;
+import retrofit2.Retrofit;
 
 /**
  * Adds headers specified in the {@link Map}.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)}.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
  * <p>
  * Simple Example:
  * <pre>
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index 4d8c6f054..52af62511 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -15,16 +15,20 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Named replacement in a URL path segment. Values are converted to string using
- * {@link String#valueOf(Object)} and URL encoded.
+ * Named replacement in a URL path segment. Values are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()},
+ * if no matching string converter is installed) and then URL encoded.
  * <p>
  * Simple example:
  * <pre><code>
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 614795009..17c36c154 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,7 +28,9 @@
 /**
  * Query parameter appended to the URL.
  * <p>
- * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed)
+ * and then URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * query parameter for each non-{@code null} item.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 119a59381..fcf01652f 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -15,9 +15,12 @@
  */
 package retrofit2.http;
 
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,7 +28,8 @@
 /**
  * Query parameter keys and values appended to the URL.
  * <p>
- * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
+ * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
+ * (or {@link Object#toString()}, if no matching string converter is installed).
  * <p>
  * Simple Example:
  * <pre><code>
diff --git a/retrofit/src/main/java/retrofit2/package-info.java b/retrofit/src/main/java/retrofit2/package-info.java
index 44f5b357a..135079424 100644
--- a/retrofit/src/main/java/retrofit2/package-info.java
+++ b/retrofit/src/main/java/retrofit2/package-info.java
@@ -9,4 +9,7 @@
  * }
  * </pre>
  */
+@ParametersAreNonnullByDefault
 package retrofit2;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index a2ef1376b..66be17b17 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -35,6 +35,7 @@
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
+import retrofit2.helpers.NullObjectConverterFactory;
 import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
@@ -2578,6 +2579,84 @@
     assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
   }
 
+  @Test public void queryParamsSkippedIfConvertedToNull() throws Exception {
+    class Example {
+      @GET("/query") Call<ResponseBody> queryPath(@Query("a") Object a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Request request = buildRequest(Example.class, retrofitBuilder, "Ignored");
+
+    assertThat(request.url().toString()).doesNotContain("Ignored");
+  }
+
+  @Test public void queryParamMapsConvertedToNullShouldError() throws Exception {
+    class Example {
+      @GET("/query") Call<ResponseBody> queryPath(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Map<String, String> queryMap = Collections.singletonMap("kit", "kat");
+
+    try {
+      buildRequest(Example.class, retrofitBuilder, queryMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining(
+          "Query map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.");
+    }
+  }
+
+  @Test public void fieldParamsSkippedIfConvertedToNull() throws Exception {
+    class Example {
+      @FormUrlEncoded
+      @POST("/query") Call<ResponseBody> queryPath(@Field("a") Object a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Request request = buildRequest(Example.class, retrofitBuilder, "Ignored");
+
+    assertThat(request.url().toString()).doesNotContain("Ignored");
+  }
+
+  @Test public void fieldParamMapsConvertedToNullShouldError() throws Exception {
+    class Example {
+      @FormUrlEncoded
+      @POST("/query") Call<ResponseBody> queryPath(@FieldMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addConverterFactory(new NullObjectConverterFactory());
+
+    Map<String, String> queryMap = Collections.singletonMap("kit", "kat");
+
+    try {
+      buildRequest(Example.class, retrofitBuilder, queryMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining(
+          "Field map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.");
+    }
+  }
+
   private static void assertBody(RequestBody body, String expected) {
     assertThat(body).isNotNull();
     Buffer buffer = new Buffer();
@@ -2589,7 +2668,7 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  static <T> Request buildRequest(Class<T> cls, Object... args) {
+  static <T> Request buildRequest(Class<T> cls, Retrofit.Builder builder, Object... args) {
     final AtomicReference<Request> requestRef = new AtomicReference<>();
     okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
       @Override public okhttp3.Call newCall(Request request) {
@@ -2598,11 +2677,7 @@ private static void assertBody(RequestBody body, String expected) {
       }
     };
 
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
+    Retrofit retrofit = builder.callFactory(callFactory).build();
 
     Method method = TestingUtils.onlyMethod(cls);
     //noinspection unchecked
@@ -2621,4 +2696,12 @@ private static void assertBody(RequestBody body, String expected) {
       throw new AssertionError(e);
     }
   }
+
+  static <T> Request buildRequest(Class<T> cls, Object... args) {
+    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory());
+
+    return buildRequest(cls, retrofitBuilder, args);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 3d059b8ad..357e7ab65 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -112,7 +112,7 @@
     Response<?> response = Response.error(400, errorBody);
     assertThat(response.raw()).isNotNull();
     assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
+    assertThat(response.message()).isEqualTo("Response.error()");
     assertThat(response.headers().size()).isZero();
     assertThat(response.isSuccessful()).isFalse();
     assertThat(response.body()).isNull();
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 92dfb74ca..4b9cd8adb 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -63,6 +63,7 @@
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
 
 public final class RetrofitTest {
   @Rule public final MockWebServer server = new MockWebServer();
@@ -171,6 +172,14 @@
     assertSame(callFactory, two.callFactory());
   }
 
+  @Test public void builtInConvertersAbsentInCloneBuilder() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    assertEquals(0, retrofit.newBuilder().converterFactories().size());
+  }
+
   @Test public void responseTypeCannotBeRetrofitResponse() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -839,6 +848,23 @@
     assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
   }
 
+  @Test public void builtInConvertersFirstInClone() {
+    Converter<ResponseBody, Void> converter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+    Annotation[] annotations = new Annotation[0];
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(converter).when(factory).responseBodyConverter(Void.class, annotations, retrofit);
+
+    retrofit.newBuilder().build().responseBodyConverter(Void.class, annotations);
+
+    verifyZeroInteractions(factory);
+  }
+
   @Test public void requestConverterFactoryQueried() {
     Type type = String.class;
     Annotation[] parameterAnnotations = new Annotation[0];
@@ -1198,6 +1224,14 @@
     assertThat(nonMatchingFactory.called).isTrue();
   }
 
+  @Test public void platformAwareAdapterAbsentInCloneBuilder() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    assertEquals(0, retrofit.newBuilder().callAdapterFactories().size());
+  }
+
   @Test public void callbackExecutorNullThrows() {
     try {
       new Retrofit.Builder().callbackExecutor(null);
diff --git a/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java
new file mode 100644
index 000000000..d34988d1f
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/helpers/NullObjectConverterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/** Always converts to null. */
+public final class NullObjectConverterFactory extends Converter.Factory {
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<Object, String>() {
+      @Override public String convert(Object value) throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index 84de4c276..410ef4bfc 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index b8e20a1b1..1e213e9a1 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -77,7 +77,7 @@ public void crawlPage(HttpUrl url) {
         // Enqueue its links for visiting.
         for (String link : page.links) {
           HttpUrl linkUrl = base.resolve(link);
-          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+          if (linkUrl != null && fetchedUrls.add(linkUrl)) {
             crawlPage(linkUrl);
           }
         }
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 28e8521ac..fd05c044d 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -180,7 +180,7 @@ public static void main(String... args) {
       }
 
       @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
+        System.err.println("NETWORK ERROR " + e.getMessage());
       }
 
       @Override public void unexpectedError(Throwable t) {
