diff --git a/checkstyle.xml b/checkstyle.xml
index 5068f529a..c75dc8d30 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -49,10 +49,10 @@
         <!-- Checks for Size Violations.                    -->
         <!-- See http://checkstyle.sf.net/config_sizes.html -->
         <module name="LineLength">
-            <property name="max" value="120"/>
+            <property name="max" value="100"/>
         </module>
         <module name="MethodLength"/>
-        <module name="ParameterNumber"/>
+        <!--module name="ParameterNumber"/-->
 
 
         <!-- Checks for whitespace                               -->
@@ -60,7 +60,9 @@
         <module name="GenericWhitespace"/>
         <module name="EmptyForIteratorPad"/>
         <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceAfter">
+          <property name="tokens" value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS"/>
+        </module>
         <module name="NoWhitespaceBefore"/>
         <module name="OperatorWrap"/>
         <module name="ParenPad"/>
diff --git a/retrofit/src/main/java/retrofit/http/Callback.java b/retrofit/src/main/java/retrofit/http/Callback.java
index 1c1768f59..7b2a0ba10 100644
--- a/retrofit/src/main/java/retrofit/http/Callback.java
+++ b/retrofit/src/main/java/retrofit/http/Callback.java
@@ -1,79 +1,21 @@
-// Copyright 2010 Square, Inc.
+// Copyright 2012 Square, Inc.
 package retrofit.http;
 
 /**
- * Communicates responses to server or offline requests. Contains a callback
- * method for each possible outcome. One and only one method will be invoked in
- * response to a given request.
+ * Communicates responses to server or offline requests. Contains a callback method for each
+ * possible outcome. One and only one method will be invoked in response to a given request.
  *
  * @param <T> expected response type
  * @author Bob Lee (bob@squareup.com)
  */
 public interface Callback<T> {
 
-  /**
-   * Handles a response.
-   *
-   * @param t response
-   */
-  void call(T t);
-
-  /**
-   * The session expired or the account has been disabled. Prompt the user to
-   * log in again.
-   *
-   * @param error message to show user, or null if no message was returned
-   */
-  void sessionExpired(ServerError error);
+  /** Successful HTTP response. */
+  void success(T t);
 
   /**
-   * Couldn't reach the server. Check network settings and try again.
+   * Unsuccessful HTTP response due to network failure, non-2XX status code, or unexpected
+   * exception.
    */
-  void networkError();
-
-  /**
-   * The server returned a client error. In most cases, this is a programming
-   * error, but it can also signify a user input error.
-   *
-   * @param statusCode the HTTP response code, typically 4XX
-   */
-  void clientError(T response, int statusCode);
-
-  /**
-   * We reached the server, but it encountered an error (5xx) or its response
-   * was unparseable. Please try again later.
-   *
-   * @param error message to show user, or null if no message was returned
-   * @param statusCode the HTTP response code
-   */
-  void serverError(ServerError error, int statusCode);
-
-  /**
-   * An unexpected error occurred. Called if the framework throws an unexpected
-   * exception or if the server returns a 400 (Bad Request) error. In either
-   * case, the client software likely contains a bug; otherwise, the error
-   * would have been caught sooner. The user should try updating their client.
-   */
-  void unexpectedError(Throwable t);
-
-
-  /** JSON object for parsing server error responses. */
-  static final class ServerError {
-    public final String message;
-
-    public ServerError(String message) {
-      this.message = message;
-    }
-
-    @Override public boolean equals(Object o) {
-      if (this == o) return true;
-      if (o == null || getClass() != o.getClass()) return false;
-      ServerError that = (ServerError) o;
-      return message == null ? that.message == null : message.equals(that.message);
-    }
-
-    @Override public int hashCode() {
-      return message != null ? message.hashCode() : 0;
-    }
-  }
+  void failure(RetrofitError error);
 }
diff --git a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
index 07ae498e2..626cdfe04 100644
--- a/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
+++ b/retrofit/src/main/java/retrofit/http/CallbackRunnable.java
@@ -1,19 +1,13 @@
 // Copyright 2012 Square, Inc.
 package retrofit.http;
 
-import retrofit.http.Callback.ServerError;
-import retrofit.http.RestException.ClientHttpException;
-import retrofit.http.RestException.NetworkException;
-import retrofit.http.RestException.ServerHttpException;
-import retrofit.http.RestException.UnauthorizedHttpException;
-import retrofit.http.RestException.UnexpectedException;
-
 import java.util.concurrent.Executor;
 
 /**
- * A {@link Runnable} executed on a background thread to invoke {@link #obtainResponse()} which performs an HTTP
- * request. The response of the request, whether it be an object or exception, is then marshaled to the supplied
- * {@link Executor} in the form of a method call on a {@link Callback}.
+ * A {@link Runnable} executed on a background thread to invoke {@link #obtainResponse()} which
+ * performs an HTTP request. The response of the request, whether it be an object or exception, is
+ * then marshaled to the supplied {@link Executor} in the form of a method call on a
+ * {@link Callback}.
  */
 abstract class CallbackRunnable<T> implements Runnable {
   private final Callback<T> callback;
@@ -30,43 +24,13 @@
       final Object response = obtainResponse();
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          callback.call((T) response);
-        }
-      });
-    } catch (final ClientHttpException ce) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.clientError((T) ce.getResponse(), ce.getStatus());
-        }
-      });
-    } catch (final ServerHttpException se) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.serverError((ServerError) se.getResponse(), se.getStatus());
-        }
-      });
-    } catch (final UnauthorizedHttpException ue) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.sessionExpired((ServerError) ue.getResponse());
-        }
-      });
-    } catch (final NetworkException ne) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.networkError();
-        }
-      });
-    } catch (final UnexpectedException ue) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.unexpectedError(ue.getCause());
+          callback.success((T) response);
         }
       });
-    } catch (final Throwable t) {
+    } catch (final RetrofitError e) {
       callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          callback.unexpectedError(t);
+          callback.failure(e);
         }
       });
     }
diff --git a/retrofit/src/main/java/retrofit/http/Converter.java b/retrofit/src/main/java/retrofit/http/Converter.java
index 0090c3e5e..180590871 100644
--- a/retrofit/src/main/java/retrofit/http/Converter.java
+++ b/retrofit/src/main/java/retrofit/http/Converter.java
@@ -18,8 +18,7 @@
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
    * @throws ConversionException If conversion was unable to complete. This will trigger a call to
-   * {@link Callback#serverError(retrofit.http.Callback.ServerError, int)} or throw a
-   * {@link retrofit.http.RestException.ServerHttpException}.
+   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}.
    */
   Object to(byte[] body, Type type) throws ConversionException;
 
diff --git a/retrofit/src/main/java/retrofit/http/GsonConverter.java b/retrofit/src/main/java/retrofit/http/GsonConverter.java
index c264b6482..6dbb992be 100644
--- a/retrofit/src/main/java/retrofit/http/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/http/GsonConverter.java
@@ -12,13 +12,16 @@
 import retrofit.io.MimeType;
 import retrofit.io.TypedBytes;
 
+import static retrofit.http.RestAdapter.UTF_8;
+
 /**
  * A {@link Converter} which uses GSON for serialization and deserialization of entities.
  *
  * @author Jake Wharton (jw@squareup.com)
  */
 public class GsonConverter implements Converter {
-  public static final String ENCODING = "UTF-8"; // TODO use actual encoding
+  private static final MimeType JSON = new MimeType("application/json", "json");
+
   private final Gson gson;
 
   public GsonConverter(Gson gson) {
@@ -27,7 +30,7 @@ public GsonConverter(Gson gson) {
 
   @Override public Object to(byte[] body, Type type) throws ConversionException {
     try {
-      InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(body), ENCODING);
+      InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(body), UTF_8);
       return gson.fromJson(isr, type);
     } catch (IOException e) {
       throw new ConversionException(e);
@@ -45,14 +48,14 @@ public GsonConverter(Gson gson) {
 
     JsonTypedBytes(Gson gson, Object object) {
       try {
-        jsonBytes = gson.toJson(object).getBytes(ENCODING);
+        jsonBytes = gson.toJson(object).getBytes(UTF_8);
       } catch (UnsupportedEncodingException e) {
-        throw new IllegalArgumentException(ENCODING + " doesn't exist!?");
+        throw new IllegalStateException(UTF_8 + " encoding does not exist.");
       }
     }
 
     @Override public MimeType mimeType() {
-      return MimeType.JSON;
+      return JSON;
     }
 
     @Override public int length() {
diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
new file mode 100644
index 000000000..70ff0ff46
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -0,0 +1,43 @@
+// Copyright 2012 Square, Inc.
+package retrofit.http;
+
+/** Represents an HTTP header name/value pair. */
+public final class Header {
+  private final String name;
+  private final String value;
+
+  Header(String name, String value) {
+    this.name = name;
+    this.value = value;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public String getValue() {
+    return value;
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    Header header = (Header) o;
+
+    if (name != null ? !name.equals(header.name) : header.name != null) return false;
+    if (value != null ? !value.equals(header.value) : header.value != null) return false;
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    int result = name != null ? name.hashCode() : 0;
+    result = 31 * result + (value != null ? value.hashCode() : 0);
+    return result;
+  }
+
+  @Override public String toString() {
+    return (name != null ? name : "") + ": " + (value != null ? value : "");
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/HttpMethodType.java b/retrofit/src/main/java/retrofit/http/HttpMethodType.java
index 71d3b6089..79e755c98 100644
--- a/retrofit/src/main/java/retrofit/http/HttpMethodType.java
+++ b/retrofit/src/main/java/retrofit/http/HttpMethodType.java
@@ -77,7 +77,8 @@
 
   /** Gets a URI with no query parameters specified. */
   private static URI getUri(HttpRequestBuilder builder) throws URISyntaxException {
-    return URIUtils.createURI(builder.getScheme(), builder.getHost(), -1, builder.getRelativePath(), null, null);
+    return URIUtils.createURI(builder.getScheme(), builder.getHost(), -1, builder.getRelativePath(),
+        null, null);
   }
 
   /** Gets a URI with parameters specified as query string parameters. */
@@ -87,16 +88,14 @@ private static URI getParameterizedUri(HttpRequestBuilder builder) throws URISyn
     if (queryString != null && queryString.length() == 0) {
       queryString = null;
     }
-    return URIUtils.createURI(builder.getScheme(), builder.getHost(), -1, builder.getRelativePath(), queryString, null);
+    return URIUtils.createURI(builder.getScheme(), builder.getHost(), -1, builder.getRelativePath(),
+        queryString, null);
   }
 
   private static void addHeaders(HttpMessage message, HttpRequestBuilder builder) {
     String mimeType = builder.getMimeType();
     if (mimeType != null) {
-      // Only add a CONTENT_TYPE header if not yet set.
-      if (!message.containsHeader(HTTP.CONTENT_TYPE)) {
-        message.addHeader(HTTP.CONTENT_TYPE, mimeType);
-      }
+      message.addHeader(HTTP.CONTENT_TYPE, mimeType);
     }
     Headers headers = builder.getHeaders();
     if (headers != null) {
@@ -105,7 +104,8 @@ private static void addHeaders(HttpMessage message, HttpRequestBuilder builder)
   }
 
   /** Adds all but the last method argument as parameters of HTTP request object. */
-  private static void addParams(HttpEntityEnclosingRequestBase request, HttpRequestBuilder builder) {
+  private static void addParams(HttpEntityEnclosingRequestBase request,
+      HttpRequestBuilder builder) {
     Method method = builder.getMethod();
     Object[] args = builder.getArgs();
     Class<?>[] parameterTypes = method.getParameterTypes();
@@ -140,15 +140,10 @@ private static void addParams(HttpEntityEnclosingRequestBase request, HttpReques
     } else {
       try {
         if (builder.getSingleEntity() != null) {
-          final TypedBytesEntity entity = new TypedBytesEntity(builder.getSingleEntity());
+          TypedBytesEntity entity = new TypedBytesEntity(builder.getSingleEntity());
           request.setEntity(entity);
-          // Only add a CONTENT_TYPE header if not yet set.
-          if (!request.containsHeader(HTTP.CONTENT_TYPE)) {
-            request.addHeader(HTTP.CONTENT_TYPE, entity.getMimeType().mimeName());
-          }
         } else {
           List<NameValuePair> paramList = builder.getParamList(true);
-          // TODO: Use specified encoding. (See CallbackResponseHandler et al)
           request.setEntity(new UrlEncodedFormEntity(paramList, HTTP.UTF_8));
         }
       } catch (UnsupportedEncodingException e) {
@@ -158,11 +153,13 @@ private static void addParams(HttpEntityEnclosingRequestBase request, HttpReques
   }
 
   /** Returns true if the parameters contain a file upload. */
-  private static boolean useMultipart(Class<?>[] parameterTypes, Annotation[][] parameterAnnotations) {
+  private static boolean useMultipart(Class<?>[] parameterTypes,
+      Annotation[][] parameterAnnotations) {
     for (int i = 0; i < parameterTypes.length; i++) {
       Class<?> parameterType = parameterTypes[i];
       Annotation[] annotations = parameterAnnotations[i];
-      if (TypedBytes.class.isAssignableFrom(parameterType) && !hasSingleEntityAnnotation(annotations)) {
+      if (TypedBytes.class.isAssignableFrom(parameterType) && !hasSingleEntityAnnotation(
+          annotations)) {
         return true;
       }
     }
diff --git a/retrofit/src/main/java/retrofit/http/HttpProfiler.java b/retrofit/src/main/java/retrofit/http/HttpProfiler.java
index bf728173c..cc865b7d8 100644
--- a/retrofit/src/main/java/retrofit/http/HttpProfiler.java
+++ b/retrofit/src/main/java/retrofit/http/HttpProfiler.java
@@ -21,12 +21,13 @@
    * Invoked after an HTTP method completes. This is called from the
    * RestAdapter's background thread.
    *
-   * @param requestInfo        information about the originating HTTP request.
-   * @param elapsedTime        time in milliseconds it took the HTTP request to complete.
-   * @param statusCode         response status code.
-   * @param beforeCallData     the data returned by the corresponding {@link #beforeCall()}.
+   * @param requestInfo information about the originating HTTP request.
+   * @param elapsedTime time in milliseconds it took the HTTP request to complete.
+   * @param statusCode response status code.
+   * @param beforeCallData the data returned by the corresponding {@link #beforeCall()}.
    */
-  void afterCall(RequestInformation requestInfo, long elapsedTime, int statusCode, T beforeCallData);
+  void afterCall(RequestInformation requestInfo, long elapsedTime, int statusCode,
+      T beforeCallData);
 
   /** The HTTP method. */
   public enum Method {
@@ -45,8 +46,8 @@
     private final long contentLength;
     private final String contentType;
 
-    public RequestInformation(Method method, String baseUrl, String relativePath, long contentLength,
-        String contentType) {
+    public RequestInformation(Method method, String baseUrl, String relativePath,
+        long contentLength, String contentType) {
       this.method = method;
       this.baseUrl = baseUrl;
       this.relativePath = relativePath;
diff --git a/retrofit/src/main/java/retrofit/http/HttpRequestBuilder.java b/retrofit/src/main/java/retrofit/http/HttpRequestBuilder.java
index e7ba367bb..4c919f896 100644
--- a/retrofit/src/main/java/retrofit/http/HttpRequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/http/HttpRequestBuilder.java
@@ -1,68 +1,62 @@
 package retrofit.http;
 
-import org.apache.http.NameValuePair;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.message.BasicNameValuePair;
-import retrofit.io.TypedBytes;
-
-import javax.inject.Named;
 import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.net.URISyntaxException;
 import java.net.URLEncoder;
 import java.util.ArrayList;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import javax.inject.Named;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.message.BasicNameValuePair;
+import retrofit.io.TypedBytes;
+
+import static retrofit.http.RestAdapter.MethodDetails;
 
 /**
- * Builds HTTP requests from Java method invocations.  Handles "path parameters"
- * in the apiUrl in the form of "path/to/url/{id}/action" where a parameter
- * &#64;{@link Named}("id") is inserted into the url.  Note that this
- * replacement can be recursive if:
+ * Builds HTTP requests from Java method invocations.  Handles "path parameters" in the
+ * {@code apiUrl} in the form of "path/to/url/{id}/action" where a parameter annotated with
+ * {@code @Named("id")} is inserted into the url.  Note that this replacement can be recursive if:
  * <ol>
- * <li> multiple sets of brackets are nested ("path/to/{{key}a}
- * <li> the order of &#64;{@link Named} values go from innermost to outermost
- * <li> the values replaced correspond to &#64;{@link Named} parameters.
+ * <li>Multiple sets of brackets are nested ("path/to/{{key}a}.</li>
+ * <li>The order of {@link Named @Named} values go from innermost to outermost.</li>
+ * <li>The values replaced correspond to {@link Named @Named} parameters.</li>
  * </ol>
  */
 final class HttpRequestBuilder {
   private final Converter converter;
 
-  private Method javaMethod;
-  private boolean isSynchronous;
+  private MethodDetails methodDetails;
   private Object[] args;
   private String apiUrl;
   private String replacedRelativePath;
   private Headers headers;
   private List<NameValuePair> nonPathParams;
-  private RequestLine requestLine;
   private TypedBytes singleEntity;
 
   HttpRequestBuilder(Converter converter) {
     this.converter = converter;
   }
 
-  HttpRequestBuilder setMethod(Method method, boolean isSynchronous) {
-    this.javaMethod = method;
-    this.isSynchronous = isSynchronous;
-    requestLine = RequestLine.fromMethod(method);
+  HttpRequestBuilder setMethod(MethodDetails methodDetails) {
+    this.methodDetails = methodDetails;
     return this;
   }
 
   Method getMethod() {
-    return javaMethod;
+    return methodDetails.method;
   }
 
   boolean isSynchronous() {
-    return isSynchronous;
+    return methodDetails.isSynchronous;
   }
 
   String getRelativePath() {
-    return replacedRelativePath != null ? replacedRelativePath : requestLine.getRelativePath();
+    return replacedRelativePath != null ? replacedRelativePath : methodDetails.path;
   }
 
   HttpRequestBuilder setApiUrl(String apiUrl) {
@@ -70,7 +64,6 @@ HttpRequestBuilder setApiUrl(String apiUrl) {
     return this;
   }
 
-  /** The last argument is assumed to be the Callback and is ignored. */
   HttpRequestBuilder setArgs(Object[] args) {
     this.args = args;
     return this;
@@ -101,8 +94,8 @@ String getHost() {
 
   /**
    * Converts all but the last method argument to a list of HTTP request parameters.  If
-   * includePathParams is true, path parameters (like id in "/entity/{id}" will be included in this
-   * list.
+   * {@code includePathParams} is {@code true}, path parameters (like 'id' in "/entity/{id}") will
+   * be included in this list.
    */
   List<NameValuePair> getParamList(boolean includePathParams) {
     if (includePathParams || nonPathParams == null) return createParamList();
@@ -111,46 +104,28 @@ String getHost() {
 
   /** Converts all but the last method argument to a list of HTTP request parameters. */
   private List<NameValuePair> createParamList() {
-    Annotation[][] parameterAnnotations = javaMethod.getParameterAnnotations();
-    int count = parameterAnnotations.length;
-    if (!isSynchronous) {
-      count -= 1;
-    }
-
-    List<NameValuePair> params = new ArrayList<NameValuePair>(count);
+    List<NameValuePair> params = new ArrayList<NameValuePair>();
 
     // Add query parameter(s), if specified.
-    QueryParams queryParams = javaMethod.getAnnotation(QueryParams.class);
-    if (queryParams != null) {
-      QueryParam[] annotations = queryParams.value();
-      for (QueryParam annotation : annotations) {
-        params.add(addPair(annotation));
-      }
-    }
-
-    // Also check for a single specified query parameter.
-    QueryParam queryParam = javaMethod.getAnnotation(QueryParam.class);
-    if (queryParam != null) {
-      params.add(addPair(queryParam));
+    for (QueryParam annotation : methodDetails.pathQueryParams) {
+      params.add(new BasicNameValuePair(annotation.name(), annotation.value()));
     }
 
     // Add arguments as parameters.
-    for (int i = 0; i < count; i++) {
+    String[] pathNamedParams = methodDetails.pathNamedParams;
+    int singleEntityArgumentIndex = methodDetails.singleEntityArgumentIndex;
+    for (int i = 0; i < pathNamedParams.length; i++) {
       Object arg = args[i];
       if (arg == null) continue;
-      for (Annotation annotation : parameterAnnotations[i]) {
-        final Class<? extends Annotation> type = annotation.annotationType();
-        if (type == Named.class) {
-          String name = getName(parameterAnnotations[i], javaMethod, i);
-          params.add(new BasicNameValuePair(name, String.valueOf(arg)));
-        } else if (type == SingleEntity.class) {
-          if (arg instanceof TypedBytes) {
-            // Let the object specify its own entity representation.
-            singleEntity = (TypedBytes) arg;
-          } else {
-            // Just an object: serialize it with supplied converter
-            singleEntity = converter.from(arg);
-          }
+      if (i != singleEntityArgumentIndex) {
+        params.add(new BasicNameValuePair(pathNamedParams[i], String.valueOf(arg)));
+      } else {
+        if (arg instanceof TypedBytes) {
+          // Let the object specify its own entity representation.
+          singleEntity = (TypedBytes) arg;
+        } else {
+          // Just an object: serialize it with supplied converter.
+          singleEntity = converter.from(arg);
         }
       }
     }
@@ -171,16 +146,12 @@ public String getMimeType() {
     return singleEntity == null ? null : singleEntity.mimeType().mimeName();
   }
 
-  private BasicNameValuePair addPair(QueryParam queryParam) {
-    return new BasicNameValuePair(queryParam.name(), queryParam.value());
-  }
-
   HttpUriRequest build() throws URISyntaxException {
     // Alter parameter list if path parameters are present.
-    Set<String> pathParams = getPathParameters(requestLine.getRelativePath());
+    Set<String> pathParams = new LinkedHashSet<String>(methodDetails.pathParams);
     List<NameValuePair> paramList = createParamList();
     if (!pathParams.isEmpty()) {
-      String replacedPath = requestLine.getRelativePath();
+      String replacedPath = methodDetails.path;
 
       for (String pathParam : pathParams) {
         NameValuePair found = null;
@@ -217,7 +188,7 @@ HttpUriRequest build() throws URISyntaxException {
       }
     }
 
-    return requestLine.getHttpMethod().createFrom(this);
+    return methodDetails.httpMethod.createFrom(this);
   }
 
   private String doReplace(String replacedPath, String paramName, String newVal) {
@@ -225,24 +196,7 @@ private String doReplace(String replacedPath, String paramName, String newVal) {
     return replacedPath;
   }
 
-  /**
-   * Gets the set of unique path params used in the given uri.  If a param is used twice in the uri,
-   * it will only show up once in the set.
-   *
-   * @param path the path to search through.
-   * @return set of path params.
-   */
-  static Set<String> getPathParameters(String path) {
-    Pattern p = Pattern.compile("\\{([a-z_-]*)\\}");
-    Matcher m = p.matcher(path);
-    Set<String> patterns = new HashSet<String>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  /** Gets the parameter name from the @Named annotation. */
+  /** Gets the parameter name from the {@link Named} annotation. */
   static String getName(Annotation[] annotations, Method method, int parameterIndex) {
     return findAnnotation(annotations, Named.class, method, parameterIndex).value();
   }
diff --git a/retrofit/src/main/java/retrofit/http/Platform.java b/retrofit/src/main/java/retrofit/http/Platform.java
index f8dfd7b03..0e4ddda90 100644
--- a/retrofit/src/main/java/retrofit/http/Platform.java
+++ b/retrofit/src/main/java/retrofit/http/Platform.java
@@ -13,7 +13,7 @@
 import retrofit.android.MainThreadExecutor;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
-import static retrofit.http.RestAdapter.SynchronousExecutor;
+import static retrofit.http.Utils.SynchronousExecutor;
 import static retrofit.http.RestAdapter.THREAD_PREFIX;
 
 abstract class Platform {
diff --git a/retrofit/src/main/java/retrofit/http/RequestLine.java b/retrofit/src/main/java/retrofit/http/RequestLine.java
deleted file mode 100644
index cb4b4735f..000000000
--- a/retrofit/src/main/java/retrofit/http/RequestLine.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package retrofit.http;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-
-/**
- * Contains the desired HttpMethodType and relative path specified by a
- * service method.  See also the factory method {@link #fromMethod(Method)}.
- * @author Patrick Forhan (patrick@squareup.com)
- */
-final class RequestLine {
-  private final String relativePath;
-  private final HttpMethodType httpMethod;
-
-  private RequestLine(HttpMethodType methodType,
-      Annotation methodAnnotation) {
-    relativePath = getValue(methodAnnotation);
-    httpMethod = methodType;
-  }
-
-  String getRelativePath() {
-    return relativePath;
-  }
-
-  HttpMethodType getHttpMethod() {
-    return httpMethod;
-  }
-
-  /** Using reflection, get the value field of the specified annotation. */
-  private static String getValue(Annotation annotation) {
-    try {
-      final Method valueMethod = annotation.annotationType()
-          .getMethod("value");
-      return (String) valueMethod.invoke(annotation);
-
-    } catch (Exception ex) {
-      throw new IllegalStateException("Failed to extract URI path", ex);
-    }
-  }
-
-  /**
-   * Looks for exactly one annotation of type {@link DELETE}, {@link GET},
-   * {@link POST}, or {@link PUT} and extracts its path data.  Throws an
-   * {@link IllegalStateException} if none or multiple are found.
-   */
-  static RequestLine fromMethod(Method method) {
-    Annotation[] annotations = method.getAnnotations();
-    RequestLine found = null;
-    for (Annotation annotation : annotations) {
-      // look for an HttpMethod annotation describing the type:
-      final retrofit.http.HttpMethod typeAnnotation = annotation.annotationType()
-          .getAnnotation(retrofit.http.HttpMethod.class);
-      if (typeAnnotation != null) {
-        if (found != null) {
-          throw new IllegalStateException(
-              "Method annotated with multiple HTTP method annotations: "
-                + method.toString());
-        }
-        found = new RequestLine(typeAnnotation.value(), annotation);
-      }
-    }
-
-    if (found == null) {
-      throw new IllegalStateException(
-          "Method not annotated with GET, POST, PUT, or DELETE: "
-            + method.toString());
-    }
-    return found;
-  }
-}
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index e0412d573..4e3fc7246 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -1,39 +1,39 @@
+// Copyright 2012 Square, Inc.
 package retrofit.http;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.lang.reflect.WildcardType;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.inject.Named;
 import javax.inject.Provider;
-import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.protocol.HTTP;
 import org.apache.http.util.EntityUtils;
-import retrofit.http.Callback.ServerError;
 import retrofit.http.HttpProfiler.RequestInformation;
-import retrofit.http.RestException.ClientHttpException;
-import retrofit.http.RestException.HttpException;
-import retrofit.http.RestException.NetworkException;
-import retrofit.http.RestException.ServerHttpException;
-import retrofit.http.RestException.UnauthorizedHttpException;
-import retrofit.http.RestException.UnexpectedException;
 
-import static java.util.logging.Level.WARNING;
-import static org.apache.http.HttpStatus.SC_UNAUTHORIZED;
+import static retrofit.http.Utils.SynchronousExecutor;
 
 /**
  * Converts Java method calls to Rest calls.
@@ -45,22 +45,24 @@
   private static final Logger LOGGER = Logger.getLogger(RestAdapter.class.getName());
   private static final int LOG_CHUNK_SIZE = 4000;
   static final String THREAD_PREFIX = "Retrofit-";
+  static final String UTF_8 = "UTF-8";
 
   private final Server server;
   private final Provider<HttpClient> httpClientProvider;
   private final Executor httpExecutor;
   private final Executor callbackExecutor;
-  private final Headers headers;
+  private final Headers requestHeaders;
   private final Converter converter;
   private final HttpProfiler profiler;
 
   private RestAdapter(Server server, Provider<HttpClient> httpClientProvider, Executor httpExecutor,
-      Executor callbackExecutor, Headers headers, Converter converter, HttpProfiler profiler) {
+      Executor callbackExecutor, Headers requestHeaders, Converter converter,
+      HttpProfiler profiler) {
     this.server = server;
     this.httpClientProvider = httpClientProvider;
     this.httpExecutor = httpExecutor;
     this.callbackExecutor = callbackExecutor;
-    this.headers = headers;
+    this.requestHeaders = requestHeaders;
     this.converter = converter;
     this.profiler = profiler;
   }
@@ -68,27 +70,29 @@ private RestAdapter(Server server, Provider<HttpClient> httpClientProvider, Exec
   /**
    * Adapts a Java interface to a REST API.
    * <p/>
-   * The relative path for a given method is obtained from a {@link GET}, {@link POST}, {@link PUT}, or {@link DELETE}
-   * annotation on the method. Gets the names of URL parameters from {@link javax.inject.Named} annotations on the
-   * method parameters.
+   * The relative path for a given method is obtained from a {@link GET}, {@link POST}, {@link PUT},
+   * or {@link DELETE} annotation on the method. Gets the names of URL parameters from
+   * {@link javax.inject.Named Named} annotations on the method parameters.
    * <p/>
    * HTTP requests happen in one of two ways:
    * <ul>
-   *   <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback {@link Executor}. The last
-   *   method parameter should be of type {@link Callback}. The HTTP response will be converted to the callback's
-   *   parameter type using the specified {@link Converter}. If the callback parameter type uses a wildcard, the lower
-   *   bound will be used as the conversion type.</li>
-   *   <li>On the current thread returning the response or throwing a {@link RestException}. The HTTP response will be
-   *   converted to the method's return type using the specified {@link Converter}.</li>
+   * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
+   * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
+   * response will be converted to the callback's parameter type using the specified
+   * {@link Converter}. If the callback parameter type uses a wildcard, the lower bound will be used
+   * as the conversion type.</li>
+   * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
+   * response will be converted to the method's return type using the specified
+   * {@link Converter}.</li>
    * </ul>
    * <p/>
    * For example:
    * <pre>
    *   public interface MyApi {
    *     &#64;POST("go") // Asynchronous execution.
-   *     public void go(@Named("a") String a, @Named("b") int b, Callback&lt;? super MyResult> callback);
+   *     void go(@Named("a") String a, @Named("b") int b, Callback&lt;? super MyResult> callback);
    *     &#64;POST("go") // Synchronous execution.
-   *     public MyResult go(@Named("a") String a, @Named("b") int b);
+   *     MyResult go(@Named("a") String a, @Named("b") int b);
    *   }
    * </pre>
    *
@@ -96,77 +100,94 @@ private RestAdapter(Server server, Provider<HttpClient> httpClientProvider, Exec
    */
   @SuppressWarnings("unchecked")
   public <T> T create(Class<T> type) {
-    return (T) Proxy.newProxyInstance(type.getClassLoader(), new Class<?>[] {type}, new RestHandler());
+    return (T) Proxy.newProxyInstance(type.getClassLoader(), new Class<?>[] { type },
+        new RestHandler(type));
   }
 
   private class RestHandler implements InvocationHandler {
-    private final Map<Method, Type> responseTypeCache = new HashMap<Method, Type>();
+    private final Class<?> declaringType;
+    private final Map<Method, MethodDetails> methodDetailsCache =
+        new LinkedHashMap<Method, MethodDetails>();
+
+    RestHandler(Class<?> declaringType) {
+      this.declaringType = declaringType;
+    }
 
     @SuppressWarnings("unchecked")
-    @Override public Object invoke(Object proxy, final Method method, final Object[] args) {
-      if (methodWantsSynchronousInvocation(method)) {
-        return invokeRequest(method, args, true);
-      } else {
-        if (httpExecutor == null || callbackExecutor == null) {
-          throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
+    @Override public Object invoke(Object proxy, Method method, final Object[] args)
+        throws InvocationTargetException, IllegalAccessException {
+      // If the method is not a direct member of the interface then defer to normal invocation.
+      if (method.getDeclaringClass() != declaringType) {
+        return method.invoke(this, args);
+      }
+
+      // Load or create the details cache for the current method.
+      final MethodDetails methodDetails;
+      synchronized (methodDetailsCache) {
+        MethodDetails tempMethodDetails = methodDetailsCache.get(method);
+        if (tempMethodDetails == null) {
+          tempMethodDetails = new MethodDetails(method);
+          methodDetailsCache.put(method, tempMethodDetails);
         }
-        httpExecutor.execute(new CallbackRunnable(obtainCallback(args), callbackExecutor) {
-          @Override public Object obtainResponse() {
-            return invokeRequest(method, args, false);
-          }
-        });
-        return null; // Asynchronous methods should have return type of void.
+        methodDetails = tempMethodDetails;
+      }
+
+      if (methodDetails.isSynchronous) {
+        return invokeRequest(methodDetails, args);
       }
+
+      if (httpExecutor == null || callbackExecutor == null) {
+        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
+      }
+      Callback<?> callback = (Callback<?>) args[args.length - 1];
+      httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
+        @Override public Object obtainResponse() {
+          return invokeRequest(methodDetails, args);
+        }
+      });
+      return null; // Asynchronous methods should have return type of void.
     }
 
     /**
      * Execute an HTTP request.
      *
      * @return HTTP response object of specified {@code type}.
-     * @throws ClientHttpException if HTTP 4XX error occurred.
-     * @throws UnauthorizedHttpException if HTTP 401 error occurred.
-     * @throws ServerHttpException if HTTP 5XX error occurred.
-     * @throws NetworkException if the {@code request} URL was unreachable.
-     * @throws UnexpectedException if an unexpected exception was thrown while processing the request.
+     * @throws RetrofitError Thrown if any error occurs during the HTTP request.
      */
-    private Object invokeRequest(Method method, Object[] args, boolean isSynchronousInvocation) {
+    private Object invokeRequest(MethodDetails methodDetails, Object[] args) {
       long start = System.nanoTime();
+
+      methodDetails.init(); // Ensure all relevant method information has been loaded.
+
       String url = server.apiUrl();
       try {
         // Build the request and headers.
         final HttpUriRequest request = new HttpRequestBuilder(converter) //
-            .setMethod(method, isSynchronousInvocation)
+            .setMethod(methodDetails)
             .setArgs(args)
             .setApiUrl(url)
-            .setHeaders(headers)
+            .setHeaders(requestHeaders)
             .build();
         url = request.getURI().toString();
 
-        if (!isSynchronousInvocation) {
+        if (!methodDetails.isSynchronous) {
           // If we are executing asynchronously then update the current thread with a useful name.
           Thread.currentThread().setName(THREAD_PREFIX + url);
         }
 
-        // Determine deserialization type by method return type or generic parameter to Callback argument.
-        Type type = responseTypeCache.get(method);
-        if (type == null) {
-          type = getResponseObjectType(method, isSynchronousInvocation);
-          responseTypeCache.put(method, type);
-        }
-
         Object profilerObject = null;
         if (profiler != null) {
           profilerObject = profiler.beforeCall();
         }
 
-        LOGGER.fine("Sending " + request.getMethod() + " to " + request.getURI());
+        LOGGER.fine("Sending " + request.getMethod() + " to " + url);
         HttpResponse response = httpClientProvider.get().execute(request);
         StatusLine statusLine = response.getStatusLine();
         int statusCode = statusLine.getStatusCode();
 
         long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
         if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(server, method, request);
+          RequestInformation requestInfo = getRequestInfo(server, methodDetails, request);
           profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
         }
 
@@ -179,43 +200,222 @@ private Object invokeRequest(Method method, Object[] args, boolean isSynchronous
           logResponseBody(url, body, statusCode, elapsedTime);
         }
 
-        try {
-          if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-            return converter.to(body, type);
-          } else if (statusCode == SC_UNAUTHORIZED) { // 401 == unauthorized user
-            ServerError serverError = (ServerError) converter.to(body, ServerError.class);
-            throw new UnauthorizedHttpException(url, statusLine.getReasonPhrase(), serverError);
-          } else if (statusCode >= 500) { // 5XX == server error
-            ServerError serverError = (ServerError) converter.to(body, ServerError.class);
-            throw new ServerHttpException(url, statusCode, statusLine.getReasonPhrase(), serverError);
-          } else { // 4XX == client error
-            Object clientError = converter.to(body, type);
-            throw new ClientHttpException(url, statusCode, statusLine.getReasonPhrase(), clientError);
+        org.apache.http.Header[] realHeaders = response.getAllHeaders();
+        Header[] headers = null;
+        if (realHeaders != null) {
+          headers = new Header[realHeaders.length];
+          for (int i = 0; i < realHeaders.length; i++) {
+            org.apache.http.Header realHeader = realHeaders[i];
+            String headerName = realHeader.getName();
+            String headerValue = realHeader.getValue();
+
+            if (HTTP.CONTENT_TYPE.equalsIgnoreCase(headerName) //
+                && !UTF_8.equalsIgnoreCase(Utils.parseCharset(headerValue))) {
+              throw new IOException("Only UTF-8 charset supported.");
+            }
+
+            headers[i] = new Header(headerName, headerValue);
           }
-        } catch (ConversionException e) {
-          LOGGER.log(WARNING, e.getMessage() + " from " + url, e);
-          throw new ServerHttpException(url, statusCode, statusLine.getReasonPhrase(), e);
         }
-      } catch (HttpException e) {
-        if (LOGGER.isLoggable(Level.FINE)) {
-          LOGGER.fine("Sever returned " + e.getStatus() + ", " + e.getMessage() + ". Body: " + e.getResponse()
-              + ". Url: " + e.getUrl());
+
+        Type type = methodDetails.type;
+        if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
+          try {
+            return converter.to(body, type);
+          } catch (ConversionException e) {
+            throw RetrofitError.conversionError(url, converter, statusCode, headers, body, type, e);
+          }
         }
-        throw e; // Allow any rest-related exceptions to pass through.
+        throw RetrofitError.httpError(url, converter, statusCode, headers, body, type);
+      } catch (RetrofitError e) {
+        throw e; // Pass through our own errors.
       } catch (IOException e) {
-        LOGGER.log(WARNING, e.getMessage() + " from " + url, e);
-        throw new NetworkException(url, e);
+        throw RetrofitError.networkError(url, e);
       } catch (Throwable t) {
-        LOGGER.log(WARNING, t.getMessage() + " from " + url, t);
-        throw new UnexpectedException(url, t);
+        throw RetrofitError.unexpectedError(url, t);
+      }
+    }
+  }
+
+  /** Cached details about an interface method. */
+  static class MethodDetails {
+    private static final Pattern PATH_PARAMETERS = Pattern.compile("\\{([a-z_-]*)\\}");
+
+    final Method method;
+    final boolean isSynchronous;
+
+    private boolean loaded = false;
+
+    Type type;
+    HttpMethodType httpMethod;
+    String path;
+    Set<String> pathParams;
+    QueryParam[] pathQueryParams;
+    String[] pathNamedParams;
+    int singleEntityArgumentIndex = -1;
+
+    MethodDetails(Method method) {
+      this.method = method;
+      isSynchronous = parseResponseType();
+    }
+
+    synchronized void init() {
+      if (loaded) return;
+
+      parseMethodAnnotations();
+      parseParameterAnnotations();
+
+      loaded = true;
+    }
+
+    /** Loads {@link #httpMethod}, {@link #path}, and {@link #pathQueryParams}. */
+    private void parseMethodAnnotations() {
+      for (Annotation annotation : method.getAnnotations()) {
+        Class<? extends Annotation> annotationType = annotation.annotationType();
+
+        // Look for an HttpMethod annotation describing the request type.
+        if (annotationType == GET.class
+            || annotationType == POST.class
+            || annotationType == PUT.class
+            || annotationType == DELETE.class) {
+          if (this.httpMethod != null) {
+            throw new IllegalStateException(
+                "Method annotated with multiple HTTP method annotations: " + method);
+          }
+          this.httpMethod = annotationType.getAnnotation(HttpMethod.class).value();
+          try {
+            path = (String) annotationType.getMethod("value").invoke(annotation);
+          } catch (Exception e) {
+            throw new IllegalStateException("Failed to extract URI path.", e);
+          }
+
+          pathParams = parsePathParameters(path);
+        } else if (annotationType == QueryParams.class) {
+          if (this.pathQueryParams != null) {
+            throw new IllegalStateException(
+                "QueryParam and QueryParams annotations are mutually exclusive.");
+          }
+          this.pathQueryParams = ((QueryParams) annotation).value();
+        } else if (annotationType == QueryParam.class) {
+          if (this.pathQueryParams != null) {
+            throw new IllegalStateException(
+                "QueryParam and QueryParams annotations are mutually exclusive.");
+          }
+          this.pathQueryParams = new QueryParam[] { (QueryParam) annotation };
+        }
+      }
+
+      if (httpMethod == null) {
+        throw new IllegalStateException(
+            "Method not annotated with GET, POST, PUT, or DELETE: " + method);
+      }
+      if (pathQueryParams == null) {
+        pathQueryParams = new QueryParam[0];
+      }
+    }
+
+    /** Loads {@link #type}. Returns true if the method is synchronous. */
+    private boolean parseResponseType() {
+      // Synchronous methods have a non-void return type.
+      Type returnType = method.getGenericReturnType();
+
+      // Asynchronous methods should have a Callback type as the last argument.
+      Type lastArgType = null;
+      Class<?> lastArgClass = null;
+      Type[] parameterTypes = method.getGenericParameterTypes();
+      if (parameterTypes.length > 0) {
+        Type typeToCheck = parameterTypes[parameterTypes.length - 1];
+        lastArgType = typeToCheck;
+        if (typeToCheck instanceof ParameterizedType) {
+          typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
+        }
+        if (typeToCheck instanceof Class) {
+          lastArgClass = (Class<?>) typeToCheck;
+        }
+      }
+
+      boolean hasReturnType = returnType != void.class;
+      boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
+
+      // Check for invalid configurations.
+      if (hasReturnType && hasCallback) {
+        throw new IllegalArgumentException(
+            "Method may only have return type or Callback as last argument, not both.");
+      }
+      if (!hasReturnType && !hasCallback) {
+        throw new IllegalArgumentException(
+            "Method must have either a return type or Callback as last argument.");
+      }
+
+      if (hasReturnType) {
+        type = returnType;
+        return true;
       }
+
+      lastArgType = Utils.getGenericSupertype(lastArgType, lastArgClass, Callback.class);
+      if (lastArgType instanceof ParameterizedType) {
+        Type[] types = ((ParameterizedType) lastArgType).getActualTypeArguments();
+        for (int i = 0; i < types.length; i++) {
+          Type type = types[i];
+          if (type instanceof WildcardType) {
+            types[i] = ((WildcardType) type).getUpperBounds()[0];
+          }
+        }
+        type = types[0];
+        return false;
+      }
+      throw new IllegalArgumentException(
+          String.format("Last parameter of %s must be of type Callback<X> or Callback<? super X>.",
+              method));
+    }
+
+    /** Loads {@link #pathNamedParams} and {@link #singleEntityArgumentIndex}. */
+    private void parseParameterAnnotations() {
+      Annotation[][] parameterAnnotations = method.getParameterAnnotations();
+      int count = parameterAnnotations.length;
+      if (!isSynchronous) {
+        count -= 1; // Callback is last argument when not a synchronous method.
+      }
+
+      String[] namedParams = new String[count];
+      for (int i = 0; i < count; i++) {
+        for (Annotation parameterAnnotation : parameterAnnotations[i]) {
+          Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
+          if (annotationType == Named.class) {
+            namedParams[i] = ((Named) parameterAnnotation).value();
+          } else if (annotationType == SingleEntity.class) {
+            if (singleEntityArgumentIndex != -1) {
+              throw new IllegalStateException(
+                  "Method annotated with multiple SingleEntity method annotations: " + method);
+            }
+            singleEntityArgumentIndex = i;
+          } else {
+            throw new IllegalArgumentException(
+                "Method argument " + i + " not annotated with Named or SingleEntity: " + method);
+          }
+        }
+      }
+      pathNamedParams = namedParams;
+    }
+
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice in
+     * the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+      Matcher m = PATH_PARAMETERS.matcher(path);
+      Set<String> patterns = new LinkedHashSet<String>();
+      while (m.find()) {
+        patterns.add(m.group(1));
+      }
+      return patterns;
     }
   }
 
   private static void logResponseBody(String url, byte[] body, int statusCode, long elapsedTime)
       throws UnsupportedEncodingException {
     LOGGER.fine("---- HTTP " + statusCode + " from " + url + " (" + elapsedTime + "ms)");
-    String bodyString = new String(body, "UTF-8");
+    String bodyString = new String(body, UTF_8);
     for (int i = 0; i < body.length; i += LOG_CHUNK_SIZE) {
       int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
       LOGGER.fine(bodyString.substring(i, end));
@@ -223,13 +423,9 @@ private static void logResponseBody(String url, byte[] body, int statusCode, lon
     LOGGER.fine("---- END HTTP");
   }
 
-  private static Callback<?> obtainCallback(Object[] args) {
-    return (Callback<?>) args[args.length - 1];
-  }
-
-  private static HttpProfiler.RequestInformation getRequestInfo(Server server, Method method, HttpUriRequest request) {
-    RequestLine requestLine = RequestLine.fromMethod(method);
-    HttpMethodType httpMethod = requestLine.getHttpMethod();
+  private static HttpProfiler.RequestInformation getRequestInfo(Server server,
+      MethodDetails methodDetails, HttpUriRequest request) {
+    HttpMethodType httpMethod = methodDetails.httpMethod;
     HttpProfiler.Method profilerMethod = httpMethod.profilerMethod();
 
     long contentLength = 0;
@@ -239,79 +435,27 @@ private static void logResponseBody(String url, byte[] body, int statusCode, lon
       HttpEntity entity = entityReq.getEntity();
       contentLength = entity.getContentLength();
 
-      Header entityContentType = entity.getContentType();
+      org.apache.http.Header entityContentType = entity.getContentType();
       contentType = entityContentType != null ? entityContentType.getValue() : null;
     }
 
-    return new HttpProfiler.RequestInformation(profilerMethod, server.apiUrl(), requestLine.getRelativePath(),
+    return new HttpProfiler.RequestInformation(profilerMethod, server.apiUrl(), methodDetails.path,
         contentLength, contentType);
   }
 
-  /**
-   * Determine whether or not execution for a method should be done synchronously.
-   *
-   * @throws IllegalArgumentException if the supplied {@code method} has both a return type and {@link Callback}
-   *     argument or neither of the two.
-   */
-  static boolean methodWantsSynchronousInvocation(Method method) {
-    boolean hasReturnType = method.getReturnType() != void.class;
-
-    Class<?>[] parameterTypes = method.getParameterTypes();
-    boolean hasCallback = parameterTypes.length > 0
-        && Callback.class.isAssignableFrom(parameterTypes[parameterTypes.length - 1]);
-
-    if ((hasReturnType && hasCallback) || (!hasReturnType && !hasCallback)) {
-      throw new IllegalArgumentException("Method must have either a return type or Callback as last argument.");
-    }
-    return hasReturnType;
-  }
-
-  /** Get the callback parameter types. */
-  static Type getResponseObjectType(Method method, boolean isSynchronousInvocation) {
-    if (isSynchronousInvocation) {
-      return method.getGenericReturnType();
-    }
-
-    Type[] parameterTypes = method.getGenericParameterTypes();
-    Type callbackType = parameterTypes[parameterTypes.length - 1];
-    Class<?> callbackClass;
-    if (callbackType instanceof Class) {
-      callbackClass = (Class<?>) callbackType;
-    } else if (callbackType instanceof ParameterizedType) {
-      callbackClass = (Class<?>) ((ParameterizedType) callbackType).getRawType();
-    } else {
-      throw new ClassCastException(
-          String.format("Last parameter of %s must be a Class or ParameterizedType", method));
-    }
-    if (Callback.class.isAssignableFrom(callbackClass)) {
-      callbackType = Types.getGenericSupertype(callbackType, callbackClass, Callback.class);
-      if (callbackType instanceof ParameterizedType) {
-        Type[] types = ((ParameterizedType) callbackType).getActualTypeArguments();
-        for (int i = 0; i < types.length; i++) {
-          Type type = types[i];
-          if (type instanceof WildcardType) {
-            types[i] = ((WildcardType) type).getUpperBounds()[0];
-          }
-        }
-        return types[0];
-      }
-    }
-    throw new IllegalArgumentException(
-        String.format("Last parameter of %s must be of type Callback<X,Y,Z> or Callback<? super X,..,..>.", method));
-  }
-
   /**
    * Build a new {@link RestAdapter}.
    * <p/>
    * Calling the following methods is required before calling {@link #build()}:
    * <ul>
-   *   <li>{@link #setServer(Server)}</li>
-   *   <li>{@link #setClient(javax.inject.Provider)}</li>
-   *   <li>{@link #setConverter(Converter)}</li>
+   * <li>{@link #setServer(Server)}</li>
+   * <li>{@link #setClient(javax.inject.Provider)}</li>
+   * <li>{@link #setConverter(Converter)}</li>
    * </ul>
-   * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following is also required:
+   * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
+   * is also required:
    * <ul>
-   *   <li>{@link #setExecutors(java.util.concurrent.Executor, java.util.concurrent.Executor)}</li>
+   * <li>{@link #setExecutors(java.util.concurrent.Executor, java.util.concurrent.Executor)}</li>
    * </ul>
    */
   public static class Builder {
@@ -353,8 +497,9 @@ public Builder setClient(Provider<HttpClient> clientProvider) {
      * Executors used for asynchronous HTTP client downloads and callbacks.
      *
      * @param httpExecutor Executor on which HTTP client calls will be made.
-     * @param callbackExecutor Executor on which any {@link Callback} methods will be invoked. If this argument is
-     *                         {@code null} then callback methods will be run on the same thread as the HTTP client.
+     * @param callbackExecutor Executor on which any {@link Callback} methods will be invoked. If
+     * this argument is {@code null} then callback methods will be run on the same thread as the
+     * HTTP client.
      */
     public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
       if (httpExecutor == null) throw new NullPointerException("httpExecutor");
@@ -387,7 +532,8 @@ public RestAdapter build() {
         throw new IllegalArgumentException("Server may not be null.");
       }
       ensureSaneDefaults();
-      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, headers, converter, profiler);
+      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, headers,
+          converter, profiler);
     }
 
     private void ensureSaneDefaults() {
@@ -405,10 +551,4 @@ private void ensureSaneDefaults() {
       }
     }
   }
-
-  static class SynchronousExecutor implements Executor {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
-    }
-  }
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/RestException.java b/retrofit/src/main/java/retrofit/http/RestException.java
deleted file mode 100644
index d1aac3ee7..000000000
--- a/retrofit/src/main/java/retrofit/http/RestException.java
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright 2012 Square, Inc.
-package retrofit.http;
-
-import java.io.IOException;
-
-import static org.apache.http.HttpStatus.SC_UNAUTHORIZED;
-
-public abstract class RestException extends RuntimeException {
-  private final String url;
-
-  protected RestException(String url, String message) {
-    super(message);
-    this.url = url;
-  }
-
-  protected RestException(String url, Throwable t) {
-    super(t);
-    this.url = url;
-  }
-
-  protected RestException(String url, String message, Throwable t) {
-    super(message, t);
-    this.url = url;
-  }
-
-  public String getUrl() {
-    return url;
-  }
-
-  /** An exception that is the result of an HTTP response. */
-  public abstract static class HttpException extends RestException {
-    private final int status;
-    private final Object response;
-
-    protected HttpException(String url, int status, String message, Object response) {
-      super(url, message);
-      this.status = status;
-      this.response = response;
-    }
-
-    protected HttpException(String url, int status, String message, ConversionException cause) {
-      super(url, message, cause);
-      this.status = status;
-      this.response = null;
-    }
-
-    public int getStatus() {
-      return status;
-    }
-
-    public Object getResponse() {
-      return response;
-    }
-  }
-
-  /**
-   * The server returned a client error. In most cases, this is a programming error, but it can also signify a user
-   * input error.
-   */
-  public static class ClientHttpException extends HttpException {
-    public ClientHttpException(String url, int status, String message, Object response) {
-      super(url, status, message, response);
-    }
-  }
-
-  /**
-   * We reached the server, but it encountered an error (5xx) or its response was unparseable. Please try again later.
-   */
-  public static class ServerHttpException extends HttpException {
-    public ServerHttpException(String url, int status, String message, Object response) {
-      super(url, status, message, response);
-    }
-
-    public ServerHttpException(String url, int status, String message, ConversionException cause) {
-      super(url, status, message, cause);
-    }
-  }
-
-  /** The session expired or the account has been disabled. Prompt the user to log in again. */
-  public static class UnauthorizedHttpException extends HttpException {
-    public UnauthorizedHttpException(String url, String message, Object response) {
-      super(url, SC_UNAUTHORIZED, message, response);
-    }
-  }
-
-  /** Couldn't reach the server. Check network settings and try again. */
-  public static class NetworkException extends RestException {
-    public NetworkException(String url, IOException e) {
-      super(url, e);
-    }
-  }
-
-  /**
-   * An unexpected error occurred. Called if the framework throws an unexpected exception or if the server returns a 400
-   * (Bad Request) error. In either case, the client software likely contains a bug; otherwise, the error would have
-   * been caught sooner. The user should try updating their client.
-   */
-  public static class UnexpectedException extends RestException {
-    public UnexpectedException(String url, Throwable t) {
-      super(url, t);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/RetrofitError.java b/retrofit/src/main/java/retrofit/http/RetrofitError.java
new file mode 100644
index 000000000..280aab367
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/RetrofitError.java
@@ -0,0 +1,104 @@
+// Copyright 2012 Square, Inc.
+package retrofit.http;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+
+public class RetrofitError extends RuntimeException {
+  static RetrofitError networkError(String url, IOException exception) {
+    return new RetrofitError(url, 0, null, null, null, null, true, exception);
+  }
+
+  static RetrofitError conversionError(String url, Converter converter, int statusCode,
+      Header[] headers, byte[] body, Type successType, ConversionException exception) {
+    return new RetrofitError(url, statusCode, headers, body, converter, successType, false,
+        exception);
+  }
+
+  static RetrofitError httpError(String url, Converter converter, int statuCode, Header[] headers,
+      byte[] body, Type successType) {
+    return new RetrofitError(url, statuCode, headers, body, converter, successType, false, null);
+  }
+
+  static RetrofitError unexpectedError(String url, Throwable exception) {
+    return new RetrofitError(url, 0, null, null, null, null, false, exception);
+  }
+
+  private final String url;
+  private final Converter converter;
+  private final int statusCode;
+  private final Header[] headers;
+  private final byte[] body;
+  private final Type successType;
+  private final boolean networkError;
+  private final Throwable exception;
+
+  private RetrofitError(String url, int statusCode, Header[] headers, byte[] body,
+      Converter converter, Type successType, boolean networkError, Throwable exception) {
+    this.url = url;
+    this.converter = converter;
+    this.statusCode = statusCode;
+    this.headers = headers;
+    this.body = body;
+    this.successType = successType;
+    this.networkError = networkError;
+    this.exception = exception;
+  }
+
+  /** The request URL which produced the error. */
+  public String getUrl() {
+    return url;
+  }
+
+  /** HTTP status code of the response or 0 if no response received. */
+  public int getStatusCode() {
+    return statusCode;
+  }
+
+  /** Whether or not this error was the result of a network error. */
+  public boolean isNetworkError() {
+    return networkError;
+  }
+
+  /** List of headers returning in the HTTP response, if any. */
+  public Header[] getHeaders() {
+    return headers;
+  }
+
+  /** Raw {@code byte[]} of the HTTP response body, if any. */
+  public byte[] getRawBody() {
+    return body;
+  }
+
+  /**
+   * HTTP response body converted to the type declared by either the interface method return type or
+   * the generic type of the supplied {@link Callback} parameter.
+   */
+  public Object getBody() {
+    if (body == null) {
+      return null;
+    }
+    try {
+      return converter.to(body, successType);
+    } catch (ConversionException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** HTTP response body converted to specified {@code type}. */
+  public Object getBodyAs(Type type) {
+    if (body == null) {
+      return null;
+    }
+    try {
+      return converter.to(body, type);
+    } catch (ConversionException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** The exception which caused this error, if any. */
+  public Throwable getException() {
+    return exception;
+  }
+}
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/TypedBytesBody.java b/retrofit/src/main/java/retrofit/http/TypedBytesBody.java
index 6ecaf957e..4157ddbac 100644
--- a/retrofit/src/main/java/retrofit/http/TypedBytesBody.java
+++ b/retrofit/src/main/java/retrofit/http/TypedBytesBody.java
@@ -6,15 +6,21 @@
 import org.apache.http.entity.mime.content.AbstractContentBody;
 import retrofit.io.TypedBytes;
 
-/** Adapts ContentBody to TypedBytes. */
-public class TypedBytesBody extends AbstractContentBody {
+/** Adapts HTTP content body to {@link TypedBytes}. */
+class TypedBytesBody extends AbstractContentBody {
   private final TypedBytes typedBytes;
   private final String name;
 
   public TypedBytesBody(TypedBytes typedBytes, String baseName) {
     super(typedBytes.mimeType().mimeName());
     this.typedBytes = typedBytes;
-    this.name = baseName + "." + typedBytes.mimeType().extension();
+
+    String name = baseName;
+    String ext = typedBytes.mimeType().extension();
+    if (ext != null) {
+      name += "." + ext;
+    }
+    this.name = name;
   }
 
   @Override public long getContentLength() {
@@ -34,14 +40,12 @@ public TypedBytesBody(TypedBytes typedBytes, String baseName) {
   }
 
   @Override public void writeTo(OutputStream out) throws IOException {
-    /*
-     * Note: We probably want to differentiate I/O errors that occur
-     * while reading a file from network errors. Network operations can
-     * be retried. File operations will probably continue to fail.
-     *
-     * In the case of photo uploads, we at least check that the file
-     * exists before we even try to upload it.
-     */
+    // Note: We probably want to differentiate I/O errors that occur while reading a file from
+    // network errors. Network operations can be retried. File operations will probably continue to
+    // fail.
+    //
+    // In the case of photo uploads, we at least check that the file exists before we even try to
+    // upload it.
     typedBytes.writeTo(out);
   }
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/TypedBytesEntity.java b/retrofit/src/main/java/retrofit/http/TypedBytesEntity.java
index 3f490e02c..5d9bc4672 100644
--- a/retrofit/src/main/java/retrofit/http/TypedBytesEntity.java
+++ b/retrofit/src/main/java/retrofit/http/TypedBytesEntity.java
@@ -7,20 +7,20 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import org.apache.http.entity.AbstractHttpEntity;
-import retrofit.io.MimeType;
 import retrofit.io.TypedBytes;
 
 /**
- * Container class for when you want to pass an entire TypedBytes as a http request entity.
+ * Container class for when you want to pass an entire {@link TypedBytes} as a http request entity.
  *
  * @author Eric Denman (edenman@squareup.com)
  */
-public class TypedBytesEntity extends AbstractHttpEntity {
+class TypedBytesEntity extends AbstractHttpEntity {
 
-  private TypedBytes typedBytes;
+  private final TypedBytes typedBytes;
 
   public TypedBytesEntity(TypedBytes typedBytes) {
     this.typedBytes = typedBytes;
+    setContentType(typedBytes.mimeType().mimeName());
   }
 
   @Override public boolean isRepeatable() {
@@ -44,8 +44,4 @@ public TypedBytesEntity(TypedBytes typedBytes) {
   @Override public boolean isStreaming() {
     return false;
   }
-
-  public MimeType getMimeType() {
-    return typedBytes.mimeType();
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Types.java b/retrofit/src/main/java/retrofit/http/Utils.java
similarity index 56%
rename from retrofit/src/main/java/retrofit/http/Types.java
rename to retrofit/src/main/java/retrofit/http/Utils.java
index 99bd63461..2c01ac816 100644
--- a/retrofit/src/main/java/retrofit/http/Types.java
+++ b/retrofit/src/main/java/retrofit/http/Utils.java
@@ -1,15 +1,23 @@
-// Copyright 2008 Google, Inc.
+// Copyright 2012 Square, Inc.
 package retrofit.http;
 
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import static java.util.regex.Pattern.CASE_INSENSITIVE;
+import static retrofit.http.RestAdapter.UTF_8;
+
+final class Utils {
+  private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
 
-/** Helper methods for dealing with generic types via reflection copied from Guice's {@code MoreTypes} class.. */
-class Types {
   /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   * Returns the generic supertype for {@code supertype}. For example, given a class
+   * {@code IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>}
+   * and the result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
    */
+  // Copied from Guice's {@code MoreTypes} class. Copyright 2006 Google, Inc.
   static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
     if (toResolve == rawType) {
       return context;
@@ -43,4 +51,18 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
     // we can't resolve this further
     return toResolve;
   }
+
+  static String parseCharset(String headerValue) {
+    Matcher match = CHARSET.matcher(headerValue);
+    if (match.find()) {
+      return match.group(1).replaceAll("[\"\\\\]", "");
+    }
+    return UTF_8;
+  }
+
+  static class SynchronousExecutor implements Executor {
+    @Override public void execute(Runnable runnable) {
+      runnable.run();
+    }
+  }
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/io/MimeType.java b/retrofit/src/main/java/retrofit/io/MimeType.java
index 6dd848592..fa365ac6a 100644
--- a/retrofit/src/main/java/retrofit/io/MimeType.java
+++ b/retrofit/src/main/java/retrofit/io/MimeType.java
@@ -6,31 +6,21 @@
  *
  * @author Bob Lee (bob@squareup.com)
  */
-public enum MimeType {
-
-  JSON("application/json", "json"),
-  GIF("image/gif", "gif"),
-  PNG("image/png", "png"),
-  JPEG("image/jpeg", "jpg");
-
+public class MimeType {
   private final String typeName;
   private final String extension;
 
-  MimeType(String typeName, String extension) {
+  public MimeType(String typeName, String extension) {
     this.typeName = typeName;
     this.extension = extension;
   }
 
-  /**
-   * Returns the standard type name.
-   */
+  /** Returns the standard type name. */
   public String mimeName() {
     return typeName;
   }
 
-  /**
-   * Returns the standard file extension.
-   */
+  /** Returns the standard file extension. */
   public String extension() {
     return extension;
   }
diff --git a/retrofit/src/main/java/retrofit/io/TypedFile.java b/retrofit/src/main/java/retrofit/io/TypedFile.java
index a723a9ea0..a4f634291 100644
--- a/retrofit/src/main/java/retrofit/io/TypedFile.java
+++ b/retrofit/src/main/java/retrofit/io/TypedFile.java
@@ -61,7 +61,7 @@ public void moveTo(TypedFile destination) throws IOException {
   }
 
   @Override public String toString() {
-    return file.getAbsolutePath() + " (" + mimeType() + ")";
+    return file.getAbsolutePath() + " (" + mimeType().mimeName() + ")";
   }
 
   @Override
diff --git a/retrofit/src/test/java/retrofit/http/HttpRequestBuilderTest.java b/retrofit/src/test/java/retrofit/http/HttpRequestBuilderTest.java
index f220df8da..b13e75213 100644
--- a/retrofit/src/test/java/retrofit/http/HttpRequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/http/HttpRequestBuilderTest.java
@@ -1,53 +1,31 @@
-// Copyright 2011 Square, Inc.
+// Copyright 2012 Square, Inc.
 package retrofit.http;
 
 import com.google.gson.Gson;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.junit.Test;
-
-import javax.inject.Named;
 import java.io.ByteArrayOutputStream;
 import java.lang.reflect.Method;
 import java.net.URISyntaxException;
 import java.net.URLEncoder;
-import java.util.Set;
 import java.util.UUID;
+import javax.inject.Named;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.junit.Test;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Fail.fail;
+import static retrofit.http.RestAdapter.MethodDetails;
 
 /** @author Eric Denman (edenman@squareup.com) */
 public class HttpRequestBuilderTest {
   private static final Gson GSON = new Gson();
   private static final String API_URL = "http://taqueria.com/lengua/taco";
 
-  @Test public void testRegex() throws Exception {
-    expectParams("");
-    expectParams("foo");
-    expectParams("foo/bar");
-    expectParams("foo/bar/{taco}", "taco");
-    expectParams("foo/bar/{t}", "t");
-    expectParams("foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("foo/bar/{taco-shell}", "taco-shell");
-    expectParams("foo/bar/{taco_shell}", "taco_shell");
-  }
-
-  private void expectParams(String path, String... expected) {
-    Set<String> calculated = HttpRequestBuilder.getPathParameters(path);
-    assertThat(calculated.size()).isEqualTo(expected.length);
-    for (String val : expected) {
-      assertThat(calculated).contains(val);
-    }
-  }
-
   @Test public void testNormalGet() throws Exception {
-    Method method =
-        MyService.class.getMethod("normalGet", String.class, Callback.class);
+    Method method = getTestMethod("normalGet");
     String expectedId = UUID.randomUUID().toString();
-    Object[] args = new Object[] {expectedId, new MyCallback()};
+    Object[] args = new Object[] { expectedId, new MyCallback() };
     HttpUriRequest request = build(method, args);
 
     assertThat(request).isInstanceOf(HttpGet.class);
@@ -59,11 +37,10 @@ private void expectParams(String path, String... expected) {
   }
 
   @Test public void testGetWithPathParam() throws Exception {
-    Method method =
-        MyService.class.getMethod("getWithPathParam", String.class, String.class, Callback.class);
+    Method method = getTestMethod("getWithPathParam");
     String expectedId = UUID.randomUUID().toString();
     String category = UUID.randomUUID().toString();
-    Object[] args = new Object[] {expectedId, category, new MyCallback()};
+    Object[] args = new Object[] { expectedId, category, new MyCallback() };
     HttpUriRequest request = build(method, args);
 
     assertThat(request).isInstanceOf(HttpGet.class);
@@ -75,11 +52,10 @@ private void expectParams(String path, String... expected) {
   }
 
   @Test public void testGetWithPathParamAndWhitespaceValue() throws Exception {
-    Method method =
-        MyService.class.getMethod("getWithPathParam", String.class, String.class, Callback.class);
+    Method method = getTestMethod("getWithPathParam");
     String expectedId = "I have spaces buddy";
     String category = UUID.randomUUID().toString();
-    Object[] args = new Object[] {expectedId, category, new MyCallback()};
+    Object[] args = new Object[] { expectedId, category, new MyCallback() };
     HttpUriRequest request = build(method, args);
 
     assertThat(request).isInstanceOf(HttpGet.class);
@@ -87,15 +63,15 @@ private void expectParams(String path, String... expected) {
     HttpGet put = (HttpGet) request;
     // Make sure the url param got translated.
     final String uri = put.getURI().toString();
-    assertThat(uri).isEqualTo(API_URL + "/foo/" + URLEncoder.encode(expectedId, "UTF-8") + "/bar?category=" + category);
+    assertThat(uri).isEqualTo(
+        API_URL + "/foo/" + URLEncoder.encode(expectedId, "UTF-8") + "/bar?category=" + category);
   }
 
   @Test public void testSingleEntityWithPathParams() throws Exception {
-    Method method =
-        MyService.class.getMethod("singleEntityPut", MyJsonObj.class, String.class, Callback.class);
+    Method method = getTestMethod("singleEntityPut");
     String expectedId = UUID.randomUUID().toString();
     String bodyText = UUID.randomUUID().toString();
-    Object[] args = new Object[] {new MyJsonObj(bodyText), expectedId, new MyCallback()};
+    Object[] args = new Object[] { new MyJsonObj(bodyText), expectedId, new MyCallback() };
     HttpUriRequest request = build(method, args);
 
     assertThat(request).isInstanceOf(HttpPut.class);
@@ -113,11 +89,10 @@ private void expectParams(String path, String... expected) {
   }
 
   @Test public void testNormalPutWithPathParams() throws Exception {
-    Method method =
-        MyService.class.getMethod("normalPut", String.class, String.class, Callback.class);
+    Method method = getTestMethod("normalPut");
     String expectedId = UUID.randomUUID().toString();
     String bodyText = UUID.randomUUID().toString();
-    Object[] args = new Object[] {expectedId, bodyText, new MyCallback()};
+    Object[] args = new Object[] { expectedId, bodyText, new MyCallback() };
     HttpUriRequest request = build(method, args);
 
     assertThat(request).isInstanceOf(HttpPut.class);
@@ -135,12 +110,10 @@ private void expectParams(String path, String... expected) {
   }
 
   @Test public void testSingleEntityWithTooManyParams() throws Exception {
-    Method method =
-        MyService.class.getMethod("tooManyParams", MyJsonObj.class, String.class, String.class,
-            Callback.class);
+    Method method = getTestMethod("tooManyParams");
     String expectedId = UUID.randomUUID().toString();
     String bodyText = UUID.randomUUID().toString();
-    Object[] args = new Object[] {new MyJsonObj(bodyText), expectedId, "EXTRA", new MyCallback()};
+    Object[] args = new Object[] { new MyJsonObj(bodyText), expectedId, "EXTRA", new MyCallback() };
     try {
       build(method, args);
       fail("Didn't throw exception with too many params");
@@ -149,10 +122,9 @@ private void expectParams(String path, String... expected) {
   }
 
   @Test public void testSingleEntityWithNoPathParam() throws Exception {
-    Method method =
-        MyService.class.getMethod("singleEntityNoPathParam", MyJsonObj.class, Callback.class);
+    Method method = getTestMethod("singleEntityNoPathParam");
     String bodyText = UUID.randomUUID().toString();
-    Object[] args = new Object[] {new MyJsonObj(bodyText), new MyCallback()};
+    Object[] args = new Object[] { new MyJsonObj(bodyText), new MyCallback() };
     try {
       build(method, args);
       fail("Didn't throw exception with too few params");
@@ -161,9 +133,9 @@ private void expectParams(String path, String... expected) {
   }
 
   @Test public void testRegularWithNoPathParam() throws Exception {
-    Method method = MyService.class.getMethod("regularNoPathParam", String.class, Callback.class);
+    Method method = getTestMethod("regularNoPathParam");
     String otherParam = UUID.randomUUID().toString();
-    Object[] args = new Object[] {otherParam, new MyCallback()};
+    Object[] args = new Object[] { otherParam, new MyCallback() };
     try {
       build(method, args);
       fail("Didn't throw exception with too few params");
@@ -171,8 +143,8 @@ private void expectParams(String path, String... expected) {
     }
   }
 
-  @SuppressWarnings({"UnusedDeclaration"}) // Methods are accessed by reflection.
-  private static interface MyService {
+  @SuppressWarnings({ "UnusedDeclaration" }) // Methods are accessed by reflection.
+  private interface MyService {
     @GET("foo/bar") void normalGet(@Named("id") String id, Callback<SimpleResponse> callback);
 
     @GET("foo/{id}/bar")
@@ -195,16 +167,28 @@ void getWithPathParam(@Named("id") String id, @Named("category") String category
     void regularNoPathParam(@Named("other") String other, Callback<SimpleResponse> callback);
   }
 
+  private static Method getTestMethod(String name) {
+    Method[] methods = MyService.class.getDeclaredMethods();
+    for (Method method : methods) {
+      if (method.getName().equals(name)) {
+        return method;
+      }
+    }
+    throw new IllegalArgumentException("Unknown method '" + name + "' on MyService");
+  }
+
   private HttpUriRequest build(Method method, Object[] args) throws URISyntaxException {
+    MethodDetails methodDetails = new MethodDetails(method);
+    methodDetails.init();
     return new HttpRequestBuilder(new GsonConverter(GSON)) //
-        .setMethod(method, false)
-        .setArgs(args)
-        .setApiUrl(API_URL)
+        .setMethod(methodDetails) //
+        .setArgs(args) //
+        .setApiUrl(API_URL) //
         .build();
   }
 
   private static class MyJsonObj {
-    @SuppressWarnings({"UnusedDeclaration"}) // Accessed by json serialization.
+    @SuppressWarnings({ "UnusedDeclaration" }) // Accessed by json serialization.
     private String bodyText;
 
     public MyJsonObj(String bodyText) {
@@ -212,27 +196,10 @@ public MyJsonObj(String bodyText) {
     }
   }
 
-  private static class SimpleResponse {
-
-  }
+  private static class SimpleResponse {}
 
   private class MyCallback implements Callback<SimpleResponse> {
-    @Override public void call(SimpleResponse simpleResponse) {
-    }
-
-    @Override public void sessionExpired(ServerError error) {
-    }
-
-    @Override public void networkError() {
-    }
-
-    @Override public void clientError(SimpleResponse response, int statusCode) {
-    }
-
-    @Override public void serverError(ServerError error, int statusCode) {
-    }
-
-    @Override public void unexpectedError(Throwable t) {
-    }
+    @Override public void success(SimpleResponse simpleResponse) {}
+    @Override public void failure(RetrofitError error) {}
   }
 }
diff --git a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
index d7ead7d0a..9b3a6f03a 100644
--- a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
@@ -3,6 +3,7 @@
 
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
+import java.util.Set;
 import org.apache.http.HttpMessage;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
@@ -20,9 +21,6 @@
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.http.Callback.ServerError;
-import retrofit.http.RestException.ClientHttpException;
-import retrofit.http.RestException.ServerHttpException;
 
 import javax.inject.Named;
 import java.io.IOException;
@@ -34,7 +32,6 @@
 
 import static org.easymock.EasyMock.capture;
 import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
 import static org.easymock.EasyMock.expect;
 import static org.easymock.EasyMock.expectLastCall;
 import static org.easymock.EasyMock.isA;
@@ -42,6 +39,7 @@
 import static org.easymock.EasyMock.verify;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
+import static retrofit.http.RestAdapter.MethodDetails;
 
 public class RestAdapterTest {
   private static final String ID = "123";
@@ -53,7 +51,6 @@
   private static final String GET_DELETE_SIMPLE_URL_WITH_PARAMS = GET_DELETE_SIMPLE_URL + "?";
   private static final Gson GSON = new Gson();
   private static final Response RESPONSE = new Response("some text");
-  private static final ServerError SERVER_ERROR = new ServerError("danger, danger!");
 
   private RestAdapter restAdapter;
   private HttpClient mockHttpClient;
@@ -71,7 +68,7 @@
     mockCallback = createMock(ResponseCallback.class);
     mockResponse = createMock(HttpResponse.class);
 
-    restAdapter = new RestAdapter.Builder()
+    restAdapter = new RestAdapter.Builder() //
         .setServer("http://host/api/")
         .setClient(mockHttpClient)
         .setExecutors(mockHttpExecutor, mockCallbackExecutor)
@@ -80,6 +77,26 @@
         .build();
   }
 
+  @Test public void testRegex() throws Exception {
+    expectParams("");
+    expectParams("foo");
+    expectParams("foo/bar");
+    expectParams("foo/bar/{taco}", "taco");
+    expectParams("foo/bar/{t}", "t");
+    expectParams("foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("foo/bar/{taco-shell}", "taco-shell");
+    expectParams("foo/bar/{taco_shell}", "taco_shell");
+  }
+
+  private void expectParams(String path, String... expected) {
+    Set<String> calculated = MethodDetails.parsePathParameters(path);
+    assertThat(calculated.size()).isEqualTo(expected.length);
+    for (String val : expected) {
+      assertThat(calculated).contains(val);
+    }
+  }
+
   @Test public void testServiceDeleteSimpleAsync() throws IOException {
     expectAsyncLifecycle(HttpDelete.class, GET_DELETE_SIMPLE_URL);
     replayAll();
@@ -119,7 +136,8 @@
   }
 
   @Test public void testServiceDeleteWithFixedParamAsync() throws IOException {
-    expectAsyncLifecycle(HttpDelete.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
+    expectAsyncLifecycle(HttpDelete.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
     replayAll();
 
     DeleteService service = restAdapter.create(DeleteService.class);
@@ -128,7 +146,8 @@
   }
 
   @Test public void testServiceDeleteWithFixedParamSync() throws IOException {
-    expectSyncLifecycle(HttpDelete.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
+    expectSyncLifecycle(HttpDelete.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
     replayAll();
 
     DeleteService service = restAdapter.create(DeleteService.class);
@@ -138,7 +157,8 @@
   }
 
   @Test public void testServiceDeleteWithMultipleFixedParamAsync() throws IOException {
-    expectAsyncLifecycle(HttpDelete.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&" + "id=" + ID);
+    expectAsyncLifecycle(HttpDelete.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&" + "id=" + ID);
     replayAll();
 
     DeleteService service = restAdapter.create(DeleteService.class);
@@ -147,7 +167,8 @@
   }
 
   @Test public void testServiceDeleteWithMultipleFixedParamSync() throws IOException {
-    expectSyncLifecycle(HttpDelete.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&" + "id=" + ID);
+    expectSyncLifecycle(HttpDelete.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&" + "id=" + ID);
     replayAll();
 
     DeleteService service = restAdapter.create(DeleteService.class);
@@ -214,7 +235,8 @@
   }
 
   @Test public void testServiceGetWithFixedParamAsync() throws IOException {
-    expectAsyncLifecycle(HttpGet.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
+    expectAsyncLifecycle(HttpGet.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
     replayAll();
 
     GetService service = restAdapter.create(GetService.class);
@@ -223,7 +245,8 @@
   }
 
   @Test public void testServiceGetWithFixedParamSync() throws IOException {
-    expectSyncLifecycle(HttpGet.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
+    expectSyncLifecycle(HttpGet.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&id=" + ID);
     replayAll();
 
     GetService service = restAdapter.create(GetService.class);
@@ -233,7 +256,8 @@
   }
 
   @Test public void testServiceGetWithMultipleFixedParamsAsync() throws IOException {
-    expectAsyncLifecycle(HttpGet.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&id=" + ID);
+    expectAsyncLifecycle(HttpGet.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&id=" + ID);
     replayAll();
 
     GetService service = restAdapter.create(GetService.class);
@@ -242,7 +266,8 @@
   }
 
   @Test public void testServiceGetWithMultipleFixedParamsSync() throws IOException {
-    expectSyncLifecycle(HttpGet.class, GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&id=" + ID);
+    expectSyncLifecycle(HttpGet.class,
+        GET_DELETE_SIMPLE_URL_WITH_PARAMS + "filter=merchant&name2=value2&id=" + ID);
     replayAll();
 
     GetService service = restAdapter.create(GetService.class);
@@ -306,7 +331,7 @@
     try {
       service.post();
       fail("Expected client exception.");
-    } catch (ClientHttpException expected) {
+    } catch (RetrofitError expected) {
     }
     verifyAll();
   }
@@ -328,7 +353,7 @@
     try {
       service.post();
       fail("Expected server exception");
-    } catch (ServerHttpException expected) {
+    } catch (RetrofitError expected) {
     }
     verifyAll();
   }
@@ -430,125 +455,139 @@
 
   @Test public void testConcreteCallbackTypes() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("a");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("a").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("a"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test public void testConcreteCallbackTypesWithParams() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("b");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("b").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("b"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test public void testGenericCallbackTypes() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("c");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("c").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("c"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test public void testGenericCallbackTypesWithParams() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("d");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("d").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("d"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test public void testWildcardGenericCallbackTypes() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("e");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("e").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("e"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test public void testGenericCallbackWithGenericType() {
     Type expected = new TypeToken<List<String>>() {}.getType();
-    Method method = getTypeTestMethod("f");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("f").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("f"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Ignore // TODO support this case!
   @Test public void testExtendingGenericCallback() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("g");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    assertThat(RestAdapter.getResponseObjectType(method, false)).as("g").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("g"));
+    method.init();
+    assertThat(method.isSynchronous).isFalse();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testMissingCallbackTypes() {
-    Method method = getTypeTestMethod("h");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isFalse();
-    RestAdapter.getResponseObjectType(method, false);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("h"));
+    assertThat(method.isSynchronous).isFalse();
+    method.init();
   }
 
   @Test public void testSynchronousResponse() {
     Type expected = Response.class;
-    Method method = getTypeTestMethod("x");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isTrue();
-    assertThat(RestAdapter.getResponseObjectType(method, true)).as("x").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("x"));
+    method.init();
+    assertThat(method.isSynchronous).isTrue();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test public void testSynchronousGenericResponse() {
     Type expected = new TypeToken<List<String>>() {}.getType();
-    Method method = getTypeTestMethod("y");
-    assertThat(RestAdapter.methodWantsSynchronousInvocation(method)).isTrue();
-    assertThat(RestAdapter.getResponseObjectType(method, true)).as("y").isEqualTo(expected);
+    MethodDetails method = new MethodDetails(getTypeTestMethod("y"));
+    method.init();
+    assertThat(method.isSynchronous).isTrue();
+    assertThat(method.type).as("a").isEqualTo(expected);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testSynchronousWithAsyncCallback() {
-    RestAdapter.methodWantsSynchronousInvocation(getTypeTestMethod("z"));
+    MethodDetails method = new MethodDetails(getTypeTestMethod("z"));
+    method.init();
+  }
+
+  @Test public void testNonEndpointMethodsSucceed() {
+    TypeTestService service = restAdapter.create(TypeTestService.class);
+    assertThat(service.equals(new Object())).isFalse();
   }
 
-  //
-  // Utility Methods:
-  //
   private void replayAll() {
-    replay(mockHttpExecutor, mockHeaders, mockHttpClient, mockCallbackExecutor, mockCallback, mockResponse);
+    replay(mockHttpExecutor, mockHeaders, mockHttpClient, mockCallbackExecutor, mockCallback,
+        mockResponse);
   }
 
   private void verifyAll() {
-    verify(mockHttpExecutor, mockHeaders, mockHttpClient, mockCallbackExecutor, mockCallback, mockResponse);
+    verify(mockHttpExecutor, mockHeaders, mockHttpClient, mockCallbackExecutor, mockCallback,
+        mockResponse);
   }
 
-  private <T extends HttpUriRequest> void expectAsyncLifecycle(Class<T> requestClass, String requestUrl)
-      throws IOException {
+  private <T extends HttpUriRequest> void expectAsyncLifecycle(Class<T> requestClass,
+      String requestUrl) throws IOException {
     expectAsynchronousInvocation();
     expectHttpExecution(requestClass, requestUrl, RESPONSE, HttpStatus.SC_OK);
     expectCallbacks();
   }
 
-  private <T extends HttpUriRequest> void expectSyncLifecycle(Class<T> requestClass, String requestUrl)
-      throws IOException {
+  private <T extends HttpUriRequest> void expectSyncLifecycle(Class<T> requestClass,
+      String requestUrl) throws IOException {
     expectHttpExecution(requestClass, requestUrl, RESPONSE, HttpStatus.SC_OK);
   }
 
-  private <T extends HttpUriRequest> void expectAsyncLifecycleClientError(Class<T> requestClass, String requestUrl)
-      throws IOException {
+  private <T extends HttpUriRequest> void expectAsyncLifecycleClientError(Class<T> requestClass,
+      String requestUrl) throws IOException {
     expectAsynchronousInvocation();
     expectHttpExecution(requestClass, requestUrl, RESPONSE, HttpStatus.SC_CONFLICT);
-    expectClientErrorCallbacks(HttpStatus.SC_CONFLICT);
+    expectFailure();
   }
 
-  private <T extends HttpUriRequest> void expectSyncLifecycleClientError(Class<T> requestClass, String requestUrl)
-      throws IOException {
+  private <T extends HttpUriRequest> void expectSyncLifecycleClientError(Class<T> requestClass,
+      String requestUrl) throws IOException {
     expectHttpExecution(requestClass, requestUrl, RESPONSE, HttpStatus.SC_CONFLICT);
   }
 
-  private <T extends HttpUriRequest> void expectAsyncLifecycleServerError(Class<T> requestClass, String requestUrl)
-      throws IOException {
+  private <T extends HttpUriRequest> void expectAsyncLifecycleServerError(Class<T> requestClass,
+      String requestUrl) throws IOException {
     expectAsynchronousInvocation();
-    expectHttpExecution(requestClass, requestUrl, SERVER_ERROR, HttpStatus.SC_NOT_IMPLEMENTED);
-    expectServerErrorCallbacks(HttpStatus.SC_NOT_IMPLEMENTED);
+    expectHttpExecution(requestClass, requestUrl, new Object(), HttpStatus.SC_NOT_IMPLEMENTED);
+    expectFailure();
   }
 
-  private <T extends HttpUriRequest> void expectSyncLifecycleServerError(Class<T> requestClass, String requestUrl)
-      throws IOException {
-    expectHttpExecution(requestClass, requestUrl, SERVER_ERROR, HttpStatus.SC_NOT_IMPLEMENTED);
+  private <T extends HttpUriRequest> void expectSyncLifecycleServerError(Class<T> requestClass,
+      String requestUrl) throws IOException {
+    expectHttpExecution(requestClass, requestUrl, new Object(), HttpStatus.SC_NOT_IMPLEMENTED);
   }
 
   private void expectAsynchronousInvocation() {
@@ -556,25 +595,20 @@ private void expectAsynchronousInvocation() {
     expectExecution(mockCallbackExecutor);
   }
 
-  private <T extends HttpUriRequest> void expectHttpExecution(Class<T> requestClass, String requestUrl,
-      Object response, int status) throws IOException {
+  private <T extends HttpUriRequest> void expectHttpExecution(Class<T> requestClass,
+      String requestUrl, Object response, int status) throws IOException {
     expectSetOnWithRequest(requestClass, requestUrl);
     expectResponseCalls(GSON.toJson(response), status);
     expectHttpClientExecute();
   }
 
   private void expectCallbacks() {
-    mockCallback.call(RESPONSE);
+    mockCallback.success(RESPONSE);
     expectLastCall().once();
   }
 
-  private void expectClientErrorCallbacks(int statusCode) {
-    mockCallback.clientError(RESPONSE, statusCode);
-    expectLastCall().once();
-  }
-
-  private void expectServerErrorCallbacks(int statusCode) {
-    mockCallback.serverError(eq(SERVER_ERROR), eq(statusCode));
+  private void expectFailure() {
+    mockCallback.failure(isA(RetrofitError.class));
     expectLastCall().once();
   }
 
@@ -582,13 +616,16 @@ private void expectHttpClientExecute() throws IOException {
     expect(mockHttpClient.execute(isA(HttpUriRequest.class))).andReturn(mockResponse);
   }
 
-  private void expectResponseCalls(String jsonToReturn, int statusCode) throws UnsupportedEncodingException {
+  private void expectResponseCalls(String jsonToReturn, int statusCode)
+      throws UnsupportedEncodingException {
     expect(mockResponse.getEntity()).andReturn(new StringEntity(jsonToReturn));
-    expect(mockResponse.getStatusLine()).andReturn(new BasicStatusLine(HttpVersion.HTTP_1_1, statusCode, ""));
+    expect(mockResponse.getStatusLine()).andReturn(
+        new BasicStatusLine(HttpVersion.HTTP_1_1, statusCode, ""));
+    expect(mockResponse.getAllHeaders()).andReturn(null);
   }
 
-  private <T extends HttpUriRequest> void expectSetOnWithRequest(final Class<T> expectedRequestClass,
-        final String expectedUri) {
+  private <T extends HttpUriRequest> void expectSetOnWithRequest(
+      final Class<T> expectedRequestClass, final String expectedUri) {
     final Capture<HttpMessage> capture = new Capture<HttpMessage>();
     mockHeaders.setOn(capture(capture));
     expectLastCall().andAnswer(new IAnswer<Object>() {
@@ -619,25 +656,27 @@ private void expectExecution(Executor executor) {
     @DELETE(ENTITY) void deleteWithParam(@Named("id") String id, Callback<Response> callback);
     @DELETE(ENTITY) Response deleteWithParam(@Named("id") String id);
 
-    @DELETE(ENTITY) @QueryParam(name="filter", value="merchant")
+    @DELETE(ENTITY) @QueryParam(name = "filter", value = "merchant")
     void deleteWithFixedParam(@Named("id") String id, Callback<Response> callback);
-    @DELETE(ENTITY) @QueryParam(name="filter", value="merchant")
+
+    @DELETE(ENTITY) @QueryParam(name = "filter", value = "merchant")
     Response deleteWithFixedParam(@Named("id") String id);
 
-    @DELETE(ENTITY)
+    @DELETE(ENTITY) //
     @QueryParams({
-      @QueryParam(name="filter", value="merchant"),
-      @QueryParam(name="name2", value="value2")
-    })
-    void deleteWithMultipleFixedParams(@Named("id") String id, Callback<Response> callback);
-    @DELETE(ENTITY)
+        @QueryParam(name = "filter", value = "merchant"),
+        @QueryParam(name = "name2", value = "value2")
+    }) void deleteWithMultipleFixedParams(@Named("id") String id, Callback<Response> callback);
+
+    @DELETE(ENTITY) //
     @QueryParams({
-        @QueryParam(name="filter", value="merchant"),
-        @QueryParam(name="name2", value="value2")
-    })
-    Response deleteWithMultipleFixedParams(@Named("id") String id);
+        @QueryParam(name = "filter", value = "merchant"),
+        @QueryParam(name = "name2", value = "value2")
+    }) Response deleteWithMultipleFixedParams(@Named("id") String id);
+
+    @DELETE(ENTITY_PATH_PARAM)
+    void deleteWithPathParam(@Named("id") String id, Callback<Response> callback);
 
-    @DELETE(ENTITY_PATH_PARAM) void deleteWithPathParam(@Named("id") String id, Callback<Response> callback);
     @DELETE(ENTITY_PATH_PARAM) Response deleteWithPathParam(@Named("id") String id);
   }
 
@@ -648,25 +687,27 @@ private void expectExecution(Executor executor) {
     @GET(ENTITY) void getWithParam(@Named("id") String id, Callback<Response> callback);
     @GET(ENTITY) Response getWithParam(@Named("id") String id);
 
-    @GET(ENTITY) @QueryParam(name="filter", value="merchant")
+    @GET(ENTITY) @QueryParam(name = "filter", value = "merchant")
     void getWithFixedParam(@Named("id") String id, Callback<Response> callback);
-    @GET(ENTITY) @QueryParam(name="filter", value="merchant")
+
+    @GET(ENTITY) @QueryParam(name = "filter", value = "merchant")
     Response getWithFixedParam(@Named("id") String id);
 
-    @GET(ENTITY)
+    @GET(ENTITY) //
     @QueryParams({
-      @QueryParam(name="filter", value="merchant"),
-      @QueryParam(name="name2", value="value2")
-    })
-    void getWithMultipleFixedParams(@Named("id") String id, Callback<Response> callback);
-    @GET(ENTITY)
+        @QueryParam(name = "filter", value = "merchant"),
+        @QueryParam(name = "name2", value = "value2")
+    }) void getWithMultipleFixedParams(@Named("id") String id, Callback<Response> callback);
+
+    @GET(ENTITY) //
     @QueryParams({
-        @QueryParam(name="filter", value="merchant"),
-        @QueryParam(name="name2", value="value2")
-    })
-    Response getWithMultipleFixedParams(@Named("id") String id);
+        @QueryParam(name = "filter", value = "merchant"),
+        @QueryParam(name = "name2", value = "value2")
+    }) Response getWithMultipleFixedParams(@Named("id") String id);
+
+    @GET(ENTITY_PATH_PARAM)
+    void getWithPathParam(@Named("id") String id, Callback<Response> callback);
 
-    @GET(ENTITY_PATH_PARAM) void getWithPathParam(@Named("id") String id, Callback<Response> callback);
     @GET(ENTITY_PATH_PARAM) Response getWithPathParam(@Named("id") String id);
   }
 
@@ -677,7 +718,9 @@ private void expectExecution(Executor executor) {
     @POST(ENTITY) void postWithParam(@Named("id") String id, Callback<Response> callback);
     @POST(ENTITY) Response postWithParam(@Named("id") String id);
 
-    @POST(ENTITY_PATH_PARAM) void postWithPathParam(@Named("id") String id, Callback<Response> callback);
+    @POST(ENTITY_PATH_PARAM)
+    void postWithPathParam(@Named("id") String id, Callback<Response> callback);
+
     @POST(ENTITY_PATH_PARAM) Response postWithPathParam(@Named("id") String id);
   }
 
@@ -688,18 +731,23 @@ private void expectExecution(Executor executor) {
     @PUT(ENTITY) void putWithParam(@Named("id") String id, Callback<Response> callback);
     @PUT(ENTITY) Response putWithParam(@Named("id") String id);
 
-    @PUT(ENTITY_PATH_PARAM) void putWithPathParam(@Named("id") String id, Callback<Response> callback);
+    @PUT(ENTITY_PATH_PARAM)
+    void putWithPathParam(@Named("id") String id, Callback<Response> callback);
+
     @PUT(ENTITY_PATH_PARAM) Response putWithPathParam(@Named("id") String id);
   }
 
   private static class Response {
     final String text;
+
     public Response(String text) {
       this.text = text;
     }
+
     @Override public int hashCode() {
       return 7;
     }
+
     @Override public boolean equals(Object obj) {
       return obj instanceof Response && text.equals(((Response) obj).text);
     }
@@ -716,6 +764,7 @@ public Response(String text) {
     @GET(ENTITY) void f(Callback<List<String>> c);
     @GET(ENTITY) void g(ExtendingCallback<Response> callback);
     @GET(ENTITY) void h(@Named("id") String id);
+
     // Synchronous
     @GET(ENTITY) Response x();
     @GET(ENTITY) List<String> y();
@@ -729,7 +778,7 @@ private static Method getTypeTestMethod(String name) {
         return method;
       }
     }
-    throw new IllegalArgumentException("Unknown method '" + name + "' on " + TypeTestService.class.getSimpleName());
+    throw new IllegalArgumentException("Unknown method '" + name + "' on TypeTestService");
   }
 
   private interface ResponseCallback extends Callback<Response> {
diff --git a/retrofit/src/test/java/retrofit/http/UtilsTest.java b/retrofit/src/test/java/retrofit/http/UtilsTest.java
new file mode 100644
index 000000000..e529f7f03
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/UtilsTest.java
@@ -0,0 +1,24 @@
+// Copyright 2012 Square, Inc.
+package retrofit.http;
+
+import org.junit.Test;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.RestAdapter.UTF_8;
+import static retrofit.http.Utils.parseCharset;
+
+public class UtilsTest {
+  @Test public void testCharsetParsing() {
+    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; charset=utf-8; other=thing")).isEqualToIgnoringCase(UTF_8);
+    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase(UTF_8);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java b/retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java
index d8d2c64dc..6ba2303c0 100644
--- a/retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java
+++ b/retrofit/src/test/java/retrofit/io/TypedByteArrayTest.java
@@ -5,13 +5,14 @@
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
-
 /** @author Eric Burke (eric@squareup.com) */
 public class TypedByteArrayTest {
+  private static final MimeType GIF = new MimeType("image/gif", "gif");
+
   @Test public void testEquals() {
-    TypedByteArray a1 = new TypedByteArray(new byte[]{ 10, 20 }, MimeType.GIF);
-    TypedByteArray a2 = new TypedByteArray(new byte[]{ 10, 20 }, MimeType.GIF);
-    TypedByteArray b = new TypedByteArray(new byte[]{ 8, 12 }, MimeType.GIF);
+    TypedByteArray a1 = new TypedByteArray(new byte[] { 10, 20 }, GIF);
+    TypedByteArray a2 = new TypedByteArray(new byte[] { 10, 20 }, GIF);
+    TypedByteArray b = new TypedByteArray(new byte[] { 8, 12 }, GIF);
 
     assertThat(a1).isEqualTo(a2);
     assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
diff --git a/retrofit/src/test/java/retrofit/io/TypedFileTest.java b/retrofit/src/test/java/retrofit/io/TypedFileTest.java
index fe3e073aa..7a517d711 100644
--- a/retrofit/src/test/java/retrofit/io/TypedFileTest.java
+++ b/retrofit/src/test/java/retrofit/io/TypedFileTest.java
@@ -11,17 +11,19 @@
 
 /** @author Eric Burke (eric@squareup.com) */
 public class TypedFileTest {
+  private static final MimeType PNG = new MimeType("image/png", "png");
+
   @Test public void testNotEquals() {
-    TypedFile a = new TypedFile(new File("a.png"), MimeType.PNG);
-    TypedFile b = new TypedFile(new File("b.png"), MimeType.PNG);
+    TypedFile a = new TypedFile(new File("a.png"), PNG);
+    TypedFile b = new TypedFile(new File("b.png"), PNG);
 
     assertThat(a).isNotEqualTo(b);
     assertThat(a.hashCode()).isNotEqualTo(b.hashCode());
   }
 
   @Test public void testEquals() {
-    TypedFile a1 = new TypedFile(new File("a.png"), MimeType.PNG);
-    TypedFile a2 = new TypedFile(new File("a.png"), MimeType.PNG);
+    TypedFile a1 = new TypedFile(new File("a.png"), PNG);
+    TypedFile a2 = new TypedFile(new File("a.png"), PNG);
 
     assertThat(a1).isEqualTo(a2);
     assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
@@ -30,21 +32,20 @@
   @Test public void testToString() {
     File file = new File("/path/to/file.png");
 
-    assertThat(new TypedFile(file, MimeType.PNG).toString())
-        .isEqualTo(file.getAbsolutePath() + " (PNG)");
+    assertThat(new TypedFile(file, PNG).toString()) //
+        .isEqualTo(file.getAbsolutePath() + " (image/png)");
   }
 
   @Test public void testLength() throws IOException {
     File tempFile = File.createTempFile("foo", ".tmp");
     try {
-      TypedFile typedFile = new TypedFile(tempFile, MimeType.PNG);
+      TypedFile typedFile = new TypedFile(tempFile, PNG);
       assertThat(typedFile.length()).isZero();
 
-      writeToFile(tempFile, new byte[]{0, 1, 2, 3, 4});
+      writeToFile(tempFile, new byte[] { 0, 1, 2, 3, 4 });
 
       assertThat(tempFile.length()).isEqualTo(5);
       assertThat(typedFile.length()).isEqualTo(5);
-
     } finally {
       //noinspection ResultOfMethodCallIgnored
       tempFile.delete();
