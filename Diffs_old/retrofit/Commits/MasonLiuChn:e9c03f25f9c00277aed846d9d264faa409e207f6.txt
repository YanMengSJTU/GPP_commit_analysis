diff --git a/README.md b/README.md
index 95d3f43ea..e8d5d506b 100644
--- a/README.md
+++ b/README.md
@@ -51,6 +51,18 @@ handle Unexpected char  in header name and value
 
 TrustAllSSL
 
+8、getSSLClientIgnoreExpire
+
+trust special certificate but ignore expire
+
+9、getSSLClient
+
+trust special certificate
+
+10、about Android https ssl certificate
+
+http://blog.csdn.net/masonblog/article/details/77712047
+
 中文：
 ---------
 
@@ -101,6 +113,18 @@ onNetFailure(Call<T> call, Throwable t);
 
 设置信任所有SSL正证书
 
+8、getSSLClientIgnoreExpire
+
+信任本地指定的证书，但忽略过期时间
+
+9、getSSLClient
+
+信任本地指定的证书
+
+10、Android https ssl证书配置（使用okhttp）说明
+
+http://blog.csdn.net/masonblog/article/details/77712047
+
 Usage
 --------
 for android
@@ -111,7 +135,7 @@ repositories {
     }
 }
 dependencies {
-	compile 'com.github.MasonLiuChn:RetrofitPlus:2.3.0.3'
+	compile 'com.github.MasonLiuChn:RetrofitPlus:2.3.0.4'
 	compile('com.squareup.retrofit2:converter-gson:2.3.0') {
         	//exclude module: 'retrofit' 如果不写 group 则生成 pom 不会 add exclusion
         	exclude group: 'com.squareup.retrofit2', module: 'retrofit'
@@ -121,12 +145,12 @@ dependencies {
 
 for java
 
-- 1 .download [retrofitplus-java-2.3.0.1.jar](https://github.com/MasonLiuChn/RetrofitPlus/raw/master/retrofit-plus-demo/output/retrofitplus-java-2.3.0.1.jar)and import it.
+- 1 .download [retrofitplus-java-2.3.0.4.jar](https://github.com/MasonLiuChn/RetrofitPlus/raw/master/retrofit-plus-demo/output/retrofitplus-java-2.3.0.4.jar)and import it.
 - 2 . config okhttp and converter,like:
 
 ```groovy
 dependencies {
-	compile 'com.squareup.okhttp3:okhttp:3.8.1'
+	compile 'com.squareup.okhttp3:okhttp:3.9.1'
 	compile('com.squareup.retrofit2:converter-gson:2.3.0') {
         	//exclude module: 'retrofit' 如果不写 group 则生成 pom 不会 add exclusion
         	exclude group: 'com.squareup.retrofit2', module: 'retrofit'
diff --git a/local.properties b/local.properties
index 4802b876f..c769fb668 100644
--- a/local.properties
+++ b/local.properties
@@ -7,6 +7,6 @@
 # Location of the SDK. This is only used by Gradle.
 # For customization when using a Version Control System, please read the
 # header note.
-#Mon Jul 24 17:26:36 CST 2017
-ndk.dir=C\:\\Users\\liumeng02\\AppData\\Local\\Android\\Sdk\\ndk-bundle
-sdk.dir=C\:\\Users\\liumeng02\\AppData\\Local\\Android\\Sdk
+#Wed Nov 29 18:28:11 CST 2017
+ndk.dir=D\:\\Program Files\\Android\\sdk\\ndk-bundle
+sdk.dir=D\:\\Program Files\\Android\\sdk
diff --git a/retrofit-plus-demo/output/retrofitplus-java-2.3.0.1.jar b/retrofit-plus-demo/output/retrofitplus-java-2.3.0.4.jar
similarity index 57%
rename from retrofit-plus-demo/output/retrofitplus-java-2.3.0.1.jar
rename to retrofit-plus-demo/output/retrofitplus-java-2.3.0.4.jar
index f9390e5a1..d6d5f3961 100644
Binary files a/retrofit-plus-demo/output/retrofitplus-java-2.3.0.1.jar and b/retrofit-plus-demo/output/retrofitplus-java-2.3.0.4.jar differ
diff --git a/retrofit/build.gradle b/retrofit/build.gradle
index 7eea197b5..bf2ebbdc9 100644
--- a/retrofit/build.gradle
+++ b/retrofit/build.gradle
@@ -22,7 +22,7 @@ android {
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile 'com.squareup.okhttp3:okhttp:3.8.1'
+    compile 'com.squareup.okhttp3:okhttp:3.9.1'
     //compile 'com.android.support:appcompat-v7:23.1.1'
     provided 'org.codehaus.mojo:animal-sniffer-annotations:1.14'
     provided group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.0'
diff --git a/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java b/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
index 3c2b2aa2f..016218fe8 100644
--- a/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
+++ b/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
@@ -2,20 +2,21 @@
 
 import android.content.Context;
 import android.text.TextUtils;
+import android.util.Log;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import java.io.InputStream;
 import java.net.URLEncoder;
 import java.security.KeyStore;
+import java.security.Principal;
 import java.security.SecureRandom;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
-import java.util.Collection;
-import java.util.Iterator;
+import java.security.cert.X509Certificate;
 
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
@@ -32,10 +33,107 @@
     private OkHttpClientUtil() {
     }
 
+    public static OkHttpClient getSSLClientIgnoreExpire(OkHttpClient client, Context context, String assetsSSLFileName) {
+        InputStream inputStream = getStream(context, assetsSSLFileName);
+        try {
+            //Certificate
+            CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+            Certificate certificate = null;
+            final String pubSub;
+            final String pubIssuer;
+            certificate = certificateFactory.generateCertificate(inputStream);
+            Principal pubSubjectDN = ((X509Certificate) certificate).getSubjectDN();
+            Principal pubIssuerDN = ((X509Certificate) certificate).getIssuerDN();
+            pubSub = pubSubjectDN.getName();
+            pubIssuer = pubIssuerDN.getName();
+
+            Log.e("sssss", "--"+pubSubjectDN.getName());
+            Log.e("sssss", "--"+pubIssuerDN.getName());
+
+            // Create an SSLContext that uses our TrustManager
+            final TrustManager[] trustManagers = new TrustManager[]{
+                    new X509TrustManager() {
+                        @Override
+                        public void checkClientTrusted(X509Certificate[] chain, String authType)
+                                throws CertificateException {
+                        }
+
+                        @Override
+                        public void checkServerTrusted(X509Certificate[] chain, String authType)
+                                throws CertificateException {
+                            /**
+                             for (X509Certificate cert : chain) {
+                             // Make sure that it hasn't expired.
+                             cert.checkValidity();
+                             // Verify the certificate's public key chain.
+                             try {
+                             cert.verify(((X509Certificate) ca).getPublicKey());
+                             } catch (Exception e) {
+                             e.printStackTrace();
+                             }
+                             }
+                             */
+                            //1、判断证书是否是本地信任列表里颁发的证书
+                            try {
+                                TrustManagerFactory tmf = TrustManagerFactory.getInstance("X509");
+                                tmf.init((KeyStore) null);
+                                for (TrustManager trustManager : tmf.getTrustManagers()) {
+                                    ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);
+                                }
+                            } catch (Exception e) {
+                                throw new CertificateException(e);
+                            }
+                            //2、判断服务器证书 发布方的标识名  和 本地证书 发布方的标识名 是否一致
+                            //3、判断服务器证书 主体的标识名  和 本地证书 主体的标识名 是否一致
+                            //getIssuerDN()  获取证书的 issuer（发布方的标识名）值。
+                            //getSubjectDN()  获取证书的 subject（主体的标识名）值。
+                            Log.e("sssss", "server--"+chain[0].getSubjectDN().getName());
+                            Log.e("sssss", "server--"+chain[0].getIssuerDN().getName());
+                            if (!chain[0].getSubjectDN().getName().equals(pubSub)) {
+                                throw new CertificateException("server's SubjectDN is not equals to client's SubjectDN");
+                            }
+                            if (!chain[0].getIssuerDN().getName().equals(pubIssuer)) {
+                                throw new CertificateException("server's IssuerDN is not equals to client's IssuerDN");
+                            }
+                        }
+
+                        @Override
+                        public X509Certificate[] getAcceptedIssuers() {
+                            return new X509Certificate[0];
+                        }
+                    }
+            };
+
+            //SSLContext  and SSLSocketFactory
+            final SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, trustManagers, new java.security.SecureRandom());
+            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+
+            //okhttpclient
+            OkHttpClient.Builder builder = client.newBuilder();
+            builder.sslSocketFactory(sslSocketFactory);
+            return builder.build();
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                inputStream.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        return client;
+    }
+
     public static OkHttpClient getTrustAllSSLClient(OkHttpClient client) {
         try {
+            //Certificate
+
+            //keystore
+
             // Create a trust manager that does not validate certificate chains
-            final TrustManager[] trustAllCerts = new TrustManager[]{
+            final TrustManager[] trustManagers = new TrustManager[]{
                     new X509TrustManager() {
                         @Override
                         public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
@@ -52,17 +150,16 @@ public void checkServerTrusted(java.security.cert.X509Certificate[] chain, Strin
                     }
             };
 
-            // Install the all-trusting trust manager
             final SSLContext sslContext = SSLContext.getInstance("SSL");
-            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
-            // Create an ssl socket factory with our all-trusting manager
+            sslContext.init(null, trustManagers, new java.security.SecureRandom());
             final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
 
             OkHttpClient.Builder builder = client.newBuilder();
-            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);
+            builder.sslSocketFactory(sslSocketFactory);
             builder.hostnameVerifier(new HostnameVerifier() {
                 @Override
                 public boolean verify(String hostname, SSLSession session) {
+                    Log.e("verify", hostname);
                     return true;
                 }
             });
@@ -74,26 +171,16 @@ public boolean verify(String hostname, SSLSession session) {
     }
 
     public static OkHttpClient getSSLClient(OkHttpClient client, Context context, String assetsSSLFileName) {
-        InputStream inputStream = trustedCertificatesInputStream(context, assetsSSLFileName);
+        InputStream inputStream = getStream(context, assetsSSLFileName);
         return getSSLClientByInputStream(client, inputStream);
     }
 
     public static OkHttpClient getSSLClientByCertificateString(OkHttpClient client, String certificate) {
-        InputStream inputStream = trustedCertificatesInputStreamByCertificateString(certificate);
+        InputStream inputStream = getStream(certificate);
         return getSSLClientByInputStream(client, inputStream);
     }
 
-    private static OkHttpClient getSSLClientByInputStream(OkHttpClient client, InputStream inputStream) {
-        if (inputStream != null) {
-            SSLContext sslContext = sslContextForTrustedCertificates(inputStream);
-            if (sslContext != null) {
-                client = client.newBuilder().sslSocketFactory(sslContext.getSocketFactory()).build();
-            }
-        }
-        return client;
-    }
-
-    private static InputStream trustedCertificatesInputStream(Context context, String assetsFileName) {
+    private static InputStream getStream(Context context, String assetsFileName) {
         try {
             return context.getAssets().open(assetsFileName);
         } catch (Exception var3) {
@@ -101,7 +188,7 @@ private static InputStream trustedCertificatesInputStream(Context context, Strin
         }
     }
 
-    private static InputStream trustedCertificatesInputStreamByCertificateString(String certificate) {
+    private static InputStream getStream(String certificate) {
         try {
             return new ByteArrayInputStream(certificate.getBytes("UTF-8"));
         } catch (Exception var3) {
@@ -109,47 +196,47 @@ private static InputStream trustedCertificatesInputStreamByCertificateString(Str
         }
     }
 
-    private static SSLContext sslContextForTrustedCertificates(InputStream in) {
-        try {
-            CertificateFactory e = CertificateFactory.getInstance("X.509");
-            Collection certificates = e.generateCertificates(in);
-            if (certificates.isEmpty()) {
-                throw new IllegalArgumentException("expected non-empty set of trusted certificates");
-            } else {
-                char[] password = "password".toCharArray();
-                KeyStore keyStore = newEmptyKeyStore(password);
-                int index = 0;
-                Iterator keyManagerFactory = certificates.iterator();
-                while (keyManagerFactory.hasNext()) {
-                    Certificate trustManagerFactory = (Certificate) keyManagerFactory.next();
-                    String sslContext = Integer.toString(index++);
-                    keyStore.setCertificateEntry(sslContext, trustManagerFactory);
-                }
-
-                KeyManagerFactory var10 = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-                var10.init(keyStore, password);
-                TrustManagerFactory var11 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-                var11.init(keyStore);
-                SSLContext var12 = SSLContext.getInstance("TLS");
-                var12.init(var10.getKeyManagers(), var11.getTrustManagers(), new SecureRandom());
-                return var12;
+    private static OkHttpClient getSSLClientByInputStream(OkHttpClient client, InputStream inputStream) {
+        if (inputStream != null) {
+            SSLSocketFactory sslSocketFactory = setCertificates(inputStream);
+            if (sslSocketFactory != null) {
+                client = client.newBuilder().sslSocketFactory(sslSocketFactory).build();
             }
-        } catch (Exception var9) {
-            var9.printStackTrace();
         }
-        return null;
+        return client;
     }
 
-    private static KeyStore newEmptyKeyStore(char[] password) {
+    private static SSLSocketFactory setCertificates(InputStream... certificates) {
         try {
-            KeyStore e = KeyStore.getInstance(KeyStore.getDefaultType());
-            Object in = null;
-            e.load((InputStream) in, password);
-            return e;
-        } catch (Exception var3) {
-            var3.printStackTrace();
+            CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+
+            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            keyStore.load(null);
+
+            int index = 0;
+            for (InputStream certificate : certificates) {
+                String certificateAlias = Integer.toString(index++);
+                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));
+                try {
+                    if (certificate != null) {
+                        certificate.close();
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+
+            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            trustManagerFactory.init(keyStore);
+
+            SSLContext sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());
+
+            return sslContext.getSocketFactory();
+        } catch (Exception e) {
+            e.printStackTrace();
+            return null;
         }
-        return null;
     }
 
     /**
