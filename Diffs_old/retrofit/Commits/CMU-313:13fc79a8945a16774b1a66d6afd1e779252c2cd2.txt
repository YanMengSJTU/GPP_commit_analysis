diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index bc0761023..b46dbcee0 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -1,142 +1,43 @@
 package retrofit;
 
-import java.lang.reflect.Method;
-import java.util.concurrent.Executor;
-
 /**
  * 
  * @param <T>
  */
 public class Call<T> {
 
-	private final Method method;
-	private final Object[] args;
-	private final RequestInterceptor requestInterceptor;
-	private final ErrorHandler errorHandler;
-	private final Executor httpExecutor;
-	private final Executor callbackExecutor;
-	private RestMethodInfo methodDetails = null;
-
-	private boolean isRetriable = false;
-	private boolean isCanceled = false;
-
-	public Call(Method method, Object[] args,
-			RequestInterceptor requestInterceptor, ErrorHandler errorHandler,
-			Executor httpExecutor, Executor callbackExecutor) {
-		this.method = method;
-		this.args = args;
-		this.requestInterceptor = requestInterceptor;
-		this.errorHandler = errorHandler;
-		this.httpExecutor = httpExecutor;
-		this.callbackExecutor = callbackExecutor;
-	}
-
-	/**
-	 * Callers can synchronously call {@code execute()} which will return type
-	 * {@code T}. Exceptions will be thrown for any error, network error,
-	 * unsuccessful response, or unsuccessful deserialization of the response
-	 * body. While these exceptions will likely extend from the same supertype,
-	 * it's unclear as to whether that supertype should be checked or unchecked.
-	 * 
-	 * @return
-	 * @throws Throwable
-	 */
-	public T execute() throws Throwable {
-		if (methodDetails == null) {
-			methodDetails = new RestMethodInfo(method);
-		}
+	// RestHandler that created this Call<T> and that will carry out the actual
+	// request
+	private RestAdapter.RestHandler handler;
 
-		try {
-			// TODO create invokeRequest()
-			// return invokeRequest(requestInterceptor, methodDetails, args);
-			return null;
+	// Interceptor to call invokeRequest() with
+	private RequestInterceptor interceptor;
 
-		} catch (RetrofitError error) {
-			int status = error.getResponse().getStatus();
-			if (error.isNetworkError() || (status >= 500 && status < 600)) {
-				isRetriable = true;
-			}
+	// RestMethodInfo to call invokeRequest() with
+	private RestMethodInfo methodInfo;
 
-			Throwable newError = errorHandler.handleError(error);
-			if (newError == null) {
-				throw new IllegalStateException(
-						"Error handler returned null for wrapped exception.",
-						error);
-			}
-			throw newError;
-		}
-	}
+	// Object[] to call invokeRequest() with
+	private Object[] args;
 
 	/**
-	 * Callers can supply callbacks to this object for asynchronous notification
-	 * of the response. The traditional {@link Callback Callback} of the current
-	 * version of Retrofit will be available. One change will be that the error
-	 * object passed to {@link Callback.failure failure} will not be the same
-	 * exception as would be thrown in synchronous execution but rather
-	 * something a bit more transparent to the underlying cause.
-	 * 
-	 * @param callback
-	 * 
+	 * Constructor
 	 */
-	@SuppressWarnings("unchecked")
-	public void execute(Callback<T> callback) throws Throwable {
-		if (methodDetails == null) {
-			methodDetails = new RestMethodInfo(method);
-		}
-
-		if (httpExecutor == null || callbackExecutor == null) {
-			throw new IllegalStateException(
-					"Asynchronous invocation requires calling setExecutors.");
-		}
-		// Apply the interceptor synchronously, recording the interception so we
-		// can replay it later.
-		// This way we still defer argument serialization to the background
-		// thread.
-		final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-		requestInterceptor.intercept(interceptorTape);
-		httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
-			@Override public ResponseWrapper obtainResponse() {
-				// TODO create invokeRequest()
-				// return (ResponseWrapper) invokeRequest(interceptorTape,
-				// methodDetails, args);
-				return null;
-			}
-		});
+	public Call(RestAdapter.RestHandler handler, RequestInterceptor interceptor,
+		RestMethodInfo methodInfo, Object[] args)
+	{
+		this.handler = handler;
+		this.interceptor = interceptor;
+		this.methodInfo = methodInfo;
 	}
 
 	/**
-	 * Is a no-op after the response has been received. In all other cases the
-	 * method will set any callbacks to {@code null} (thus freeing strong
-	 * references to the enclosing class if declared anonymously) and render the
-	 * request object dead. All future interactions with the request object will
-	 * throw an exception. If the request is waiting in the executor its Future
-	 * will be cancelled so that it is never invoked.
+	 * Execute immediately
 	 */
-	public void cancel() {
-		if (isCanceled) {
-			return;
-		}
-
-		// TODO Implement cancel()
-
-		isCanceled = true;
+	public T execute() {
+		return (T)handler.invokeRequest(interceptor, methodInfo, args);
 	}
 
-	/**
-	 * Will re-submit the request onto the backing executor without passing
-	 * through any of the mutating pipeline described above. Retrying a request
-	 * is only available after a network error or 5XX response. Attempting to
-	 * retry a request that is currently in flight, after a non-5XX response,
-	 * after an unexpected error, or after calling {@code cancel()} will throw
-	 * an exception.
-	 */
-	public void retry() {
-		if (!isRetriable) {
-			throw new IllegalStateException(
-					"Retrying a request is only available after a network error or 5XX response");
-		}
-
-		// TODO Implement retry()
-
+	public int getthing() {
+		return 10;
 	}
 }
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 465b6a5f7..0cc8a1b85 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -20,8 +20,10 @@
 import java.io.StringWriter;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
+import java.lang.reflect.Constructor;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.Callable;
@@ -38,6 +40,7 @@
 import retrofit.mime.TypedByteArray;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
+import retrofit.Call;
 import rx.Observable;
 import rx.Observer;
 import rx.Scheduler;
@@ -259,7 +262,7 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
     }
   }
 
-  private class RestHandler implements InvocationHandler {
+  class RestHandler implements InvocationHandler {
     private final Map<Method, RestMethodInfo> methodDetailsCache;
 
     RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
@@ -277,6 +280,22 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
       // Load or create the details cache for the current method.
       final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
 
+      // Check if the method returns a Call<T>
+      if (methodInfo.responseObjectType instanceof ParameterizedType) {
+        ParameterizedType parameterized = (ParameterizedType)methodInfo.responseObjectType;
+        Type rawType = parameterized.getRawType();
+
+        if (rawType.equals(Call.class)) {
+          if (parameterized.getActualTypeArguments().length != 1)
+            throw new IllegalArgumentException("Call must have a generic argument type");
+
+          // Instantiate the Call<T> with its constructor
+          Constructor<Call> cons = Call.class.getDeclaredConstructor(RestAdapter.RestHandler.class,
+            RequestInterceptor.class, RestMethodInfo.class, Object[].class);
+          return cons.newInstance(this, requestInterceptor, methodInfo, args);
+        }
+      }
+
       if (methodInfo.isSynchronous) {
         try {
           return invokeRequest(requestInterceptor, methodInfo, args);
@@ -322,7 +341,7 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
      * @return HTTP response object of specified {@code type} or {@code null}.
      * @throws RetrofitError if any error occurs during the HTTP request.
      */
-    private Object invokeRequest(RequestInterceptor requestInterceptor,
+    Object invokeRequest(RequestInterceptor requestInterceptor,
         RestMethodInfo methodInfo, Object[] args) {
       methodInfo.init(); // Ensure all relevant method information has been loaded.
 
@@ -371,6 +390,19 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
 
         Type type = methodInfo.responseObjectType;
 
+        // Check if the method returns a Call<T>, and if so use its generic
+        // argument as the request return type
+        if (methodInfo.responseObjectType instanceof ParameterizedType) {
+          ParameterizedType parameterized = (ParameterizedType)methodInfo.responseObjectType;
+          Type rawType = parameterized.getRawType();
+
+          if (rawType.equals(Call.class)) {
+            type = parameterized.getActualTypeArguments()[0];
+            System.out.print(" --> ");
+            System.out.println(type);
+          }
+        }
+
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
           // Caller requested the raw Response object directly.
           if (type.equals(Response.class)) {
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
index 37cec8c18..12983e179 100644
--- a/retrofit/src/test/java/retrofit/CallTest.java
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -1,57 +1,114 @@
 package retrofit;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-
+import java.util.concurrent.Executor;
 import org.junit.Before;
 import org.junit.Test;
-
+import org.mockito.ArgumentCaptor;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import retrofit.client.Client;
+import retrofit.client.Header;
+import retrofit.client.Request;
 import retrofit.client.Response;
+import retrofit.converter.ConversionException;
+import retrofit.http.Body;
 import retrofit.http.GET;
+import retrofit.http.Headers;
+import retrofit.http.POST;
 import retrofit.http.Path;
+import retrofit.mime.TypedInput;
+import retrofit.mime.TypedOutput;
+import retrofit.mime.TypedString;
+import rx.Observable;
+import rx.util.functions.Action1;
+
+import static org.junit.Assert.*;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Matchers.same;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+import static retrofit.Profiler.RequestInformation;
+import static retrofit.RestAdapter.LogLevel.BASIC;
+import static retrofit.RestAdapter.LogLevel.FULL;
+import static retrofit.RestAdapter.LogLevel.HEADERS;
+import static retrofit.Utils.SynchronousExecutor;
 
 /**
- * Exemple of the Call object behavior. Not a working test.
+ * Example of the Call object behavior. Not a working test.
  */
 public class CallTest {
 
-	interface Api {
-		@GET("/{user}/tweets")
-		Call<List<String>> listTweets(@Path("user") String username);
-	}
-
-	private RestAdapter restAdapter;
-
-	@Before public void setUp() {
-		restAdapter = new RestAdapter.Builder()
-				.setServer("https://twitter.com").build();
-	}
+	private static final List<Header> NO_HEADERS = Collections.emptyList();
+  	private static final List<Header> TWO_HEADERS =
+      Arrays.asList(new Header("Content-Type", "application/json"),
+          new Header("Content-Length", "42"));
 
-	@Test public void test() {
-		Api api = restAdapter.create(Api.class);
+	/** Not all servers play nice and add content-type headers to responses. */
+	private static final TypedInput NO_MIME_BODY = new TypedInput() {
+		@Override public String mimeType() {
+		  return null;
+		}
 
-		Call<List<String>> c = api.listTweets("JakeWharton");
+		@Override public long length() {
+		  return 2;
+		}
 
-		try {
-			// Synchronously
-			List<String> tweets = c.execute();
+		@Override public InputStream in() throws IOException {
+		  return new ByteArrayInputStream("{}".getBytes("UTF-8"));
+		}
+	};
 
-			// Asynchronously;
-			c.execute(new Callback<List<String>>() {
+	private interface Api {
+		@GET("/")
+		Call<String> something();
+	}
 
-				@Override public void success(List<String> t, Response response) {
-					// TODO Auto-generated method stub
+	private Client mockClient;
+	private Executor mockRequestExecutor;
+	private Executor mockCallbackExecutor;
+	private Api api;
+
+	@SuppressWarnings("unchecked") // Mock profiler type erasure.
+	@Before public void setUp() throws Exception {
+		mockClient = mock(Client.class);
+		mockRequestExecutor = spy(new SynchronousExecutor());
+    	mockCallbackExecutor = spy(new SynchronousExecutor());
+
+		api = new RestAdapter.Builder()
+			.setClient(mockClient)
+			.setExecutors(mockRequestExecutor, mockCallbackExecutor)
+			.setServer("http://example.com")
+			.build()
+			.create(Api.class);
+	}
 
-				}
+	@Test public void test() throws Exception {
+		when(mockClient.execute(any(Request.class))) //
+        	.thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("Hello")));
 
-				@Override public void failure(RetrofitError error) {
-					// TODO Auto-generated method stub
+		Call<String> c = api.something();
 
-				}
-			});
+		String result = c.execute();
 
-		} catch (Throwable e) {
-			e.printStackTrace();
-		}
+		assertEquals(result, "Hello");
 	}
 
 }
