diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index 0870af1f1..4899c58ad 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -15,22 +15,18 @@
  */
 package retrofit2.adapter.rxjava2;
 
-import io.reactivex.Completable;
-import io.reactivex.Flowable;
-import io.reactivex.Maybe;
-import io.reactivex.Observable;
-import io.reactivex.Scheduler;
-import io.reactivex.Single;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import javax.annotation.Nullable;
+import io.reactivex.*;
 import retrofit2.CallAdapter;
 import retrofit2.HttpException;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava 2 for creating observables.
  * <p>
@@ -56,90 +52,93 @@
  * </ul>
  */
 public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
-  /**
-   * Returns an instance which creates synchronous observables that do not operate on any scheduler
-   * by default.
-   */
-  public static RxJava2CallAdapterFactory create() {
-    return new RxJava2CallAdapterFactory(null, false);
-  }
+    private final @Nullable
+    Scheduler scheduler;
+    private final boolean isAsync;
 
-  /**
-   * Returns an instance which creates asynchronous observables. Applying
-   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
-   */
-  public static RxJava2CallAdapterFactory createAsync() {
-    return new RxJava2CallAdapterFactory(null, true);
-  }
+    private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
+        this.scheduler = scheduler;
+        this.isAsync = isAsync;
+    }
 
-  /**
-   * Returns an instance which creates synchronous observables that
-   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
-   */
-  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
-  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
-    if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJava2CallAdapterFactory(scheduler, false);
-  }
+    /**
+     * Returns an instance which creates synchronous observables that do not operate on any scheduler
+     * by default.
+     */
+    public static RxJava2CallAdapterFactory create() {
+        return new RxJava2CallAdapterFactory(null, false);
+    }
 
-  private final @Nullable Scheduler scheduler;
-  private final boolean isAsync;
+    /**
+     * Returns an instance which creates asynchronous observables. Applying
+     * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+     */
+    public static RxJava2CallAdapterFactory createAsync() {
+        return new RxJava2CallAdapterFactory(null, true);
+    }
 
-  private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
-    this.scheduler = scheduler;
-    this.isAsync = isAsync;
-  }
+    /**
+     * Returns an instance which creates synchronous observables that
+     * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+     */
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+    public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
+        if (scheduler == null) throw new NullPointerException("scheduler == null");
+        return new RxJava2CallAdapterFactory(scheduler, false);
+    }
 
-  @Override public @Nullable CallAdapter<?, ?> get(
-      Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = getRawType(returnType);
+    @Override
+    public @Nullable
+    CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
 
-    if (rawType == Completable.class) {
-      // Completable is not parameterized (which is what the rest of this method deals with) so it
-      // can only be created with a single configuration.
-      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
-          false, true);
-    }
+        Class<?> rawType = getRawType(returnType);
 
-    boolean isFlowable = rawType == Flowable.class;
-    boolean isSingle = rawType == Single.class;
-    boolean isMaybe = rawType == Maybe.class;
-    if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
-      return null;
-    }
+        if (rawType == Completable.class) {
+            // Completable is not parameterized (which is what the rest of this method deals with) so it
+            // can only be created with a single configuration.
+            return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
+                    false, true);
+        }
 
-    boolean isResult = false;
-    boolean isBody = false;
-    Type responseType;
-    if (!(returnType instanceof ParameterizedType)) {
-      String name = isFlowable ? "Flowable"
-          : isSingle ? "Single"
-          : isMaybe ? "Maybe" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
-    }
+        boolean isFlowable = rawType == Flowable.class;
+        boolean isSingle = rawType == Single.class;
+        boolean isMaybe = rawType == Maybe.class;
+        if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
+            return null;
+        }
 
-    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = getRawType(observableType);
-    if (rawObservableType == Response.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Response must be parameterized"
-            + " as Response<Foo> or Response<? extends Foo>");
-      }
-      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-    } else if (rawObservableType == Result.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Result must be parameterized"
-            + " as Result<Foo> or Result<? extends Foo>");
-      }
-      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      isResult = true;
-    } else {
-      responseType = observableType;
-      isBody = true;
-    }
+        boolean isResult = false;
+        boolean isBody = false;
+        Type responseType;
+        if (!(returnType instanceof ParameterizedType)) {
+            String name = isFlowable ? "Flowable"
+                    : isSingle ? "Single"
+                    : isMaybe ? "Maybe" : "Observable";
+            throw new IllegalStateException(name + " return type must be parameterized"
+                    + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+        }
 
-    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
-        isSingle, isMaybe, false);
-  }
+        Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+        Class<?> rawObservableType = getRawType(observableType);
+        if (rawObservableType == Response.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Response must be parameterized"
+                        + " as Response<Foo> or Response<? extends Foo>");
+            }
+            responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+        } else if (rawObservableType == Result.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Result must be parameterized"
+                        + " as Result<Foo> or Result<? extends Foo>");
+            }
+            responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+            isResult = true;
+        } else {
+            responseType = observableType;
+            isBody = true;
+        }
+
+        return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
+                isSingle, isMaybe, false);
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 97d34585d..6ccb844e9 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -15,10 +15,10 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import javax.annotation.Nullable;
 
 /**
  * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
@@ -27,61 +27,61 @@
  * instance.
  */
 public interface CallAdapter<R, T> {
-  /**
-   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
-   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
-   * is used to prepare the {@code call} passed to {@code #adapt}.
-   * <p>
-   * Note: This is typically not the same type as the {@code returnType} provided to this call
-   * adapter's factory.
-   */
-  Type responseType();
-
-  /**
-   * Returns an instance of {@code T} which delegates to {@code call}.
-   * <p>
-   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
-   * return a new {@code Async<R>} which invoked {@code call} when run.
-   * <pre><code>
-   * &#64;Override
-   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
-   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
-   *     &#64;Override
-   *     public Response&lt;R&gt; call() throws Exception {
-   *       return call.execute();
-   *     }
-   *   });
-   * }
-   * </code></pre>
-   */
-  T adapt(Call<R> call);
-
-  /**
-   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
-   * Retrofit#create(Class) the service interface} methods.
-   */
-  abstract class Factory {
     /**
-     * Returns a call adapter for interface methods that return {@code returnType}, or null if it
-     * cannot be handled by this factory.
+     * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+     * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+     * is used to prepare the {@code call} passed to {@code #adapt}.
+     * <p>
+     * Note: This is typically not the same type as the {@code returnType} provided to this call
+     * adapter's factory.
      */
-    public abstract @Nullable CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit);
+    Type responseType();
 
     /**
-     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
-     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     * Returns an instance of {@code T} which delegates to {@code call}.
+     * <p>
+     * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+     * return a new {@code Async<R>} which invoked {@code call} when run.
+     * <pre><code>
+     * &#64;Override
+     * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+     *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
+     *     &#64;Override
+     *     public Response&lt;R&gt; call() throws Exception {
+     *       return call.execute();
+     *     }
+     *   });
+     * }
+     * </code></pre>
      */
-    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
-      return Utils.getParameterUpperBound(index, type);
-    }
+    T adapt(Call<R> call);
 
     /**
-     * Extract the raw class type from {@code type}. For example, the type representing
-     * {@code List<? extends Runnable>} returns {@code List.class}.
+     * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+     * Retrofit#create(Class) the service interface} methods.
      */
-    protected static Class<?> getRawType(Type type) {
-      return Utils.getRawType(type);
+    abstract class Factory {
+        /**
+         * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+         * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+         */
+        protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+            return Utils.getParameterUpperBound(index, type);
+        }
+
+        /**
+         * Extract the raw class type from {@code type}. For example, the type representing
+         * {@code List<? extends Runnable>} returns {@code List.class}.
+         */
+        protected static Class<?> getRawType(Type type) {
+            return Utils.getRawType(type);
+        }
+
+        /**
+         * Returns a call adapter for interface methods that return {@code returnType}, or null if it
+         * cannot be handled by this factory.
+         */
+        public abstract @Nullable
+        CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index 45608b12c..9c7c6407c 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -15,9 +15,9 @@
  */
 package retrofit2;
 
+import javax.annotation.Nullable;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-import javax.annotation.Nullable;
 
 /**
  * Creates call adapters for that uses the same thread for both I/O and application-level
@@ -30,10 +30,13 @@
     @Override
     public @Nullable
     CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        //装载方法时调用的, returnType--带泛型的返回类型;annotations--方法注解
+        //最外层返回类型必须为call
         if (getRawType(returnType) != Call.class) {
             return null;
         }
 
+        //返回类型必须带泛型,否则报错
         final Type responseType = Utils.getCallResponseType(returnType);
 
         return new CallAdapter<Object, Call<?>>() {
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index 4766db6ca..24b05e9d3 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -15,12 +15,12 @@
  */
 package retrofit2;
 
+import okhttp3.ResponseBody;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 
-import okhttp3.ResponseBody;
-
 import static retrofit2.Utils.methodError;
 
 /**
@@ -35,6 +35,7 @@
     static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(Retrofit retrofit, Method method, RequestFactory requestFactory) {
 
         CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
+
         Type responseType = callAdapter.responseType();
         if (responseType == Response.class || responseType == okhttp3.Response.class) {
             throw methodError(method, "'"
@@ -45,8 +46,7 @@
             throw methodError(method, "HEAD method must use Void as response type.");
         }
 
-        Converter<ResponseBody, ResponseT> responseConverter =
-                createResponseConverter(retrofit, method, responseType);
+        Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType);
 
         okhttp3.Call.Factory callFactory = retrofit.callFactory;
         return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
@@ -89,7 +89,6 @@ private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory ca
 
     @Override
     ReturnT invoke(Object[] args) {
-        return callAdapter.adapt(
-                new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+        return callAdapter.adapt(new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
     }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 6de7e957b..fc7a401d3 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -15,9 +15,6 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import javax.annotation.Nullable;
-import javax.annotation.concurrent.GuardedBy;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -26,292 +23,316 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
+import java.io.IOException;
+
 import static retrofit2.Utils.checkNotNull;
 import static retrofit2.Utils.throwIfFatal;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final RequestFactory requestFactory;
-  private final Object[] args;
-  private final okhttp3.Call.Factory callFactory;
-  private final Converter<ResponseBody, T> responseConverter;
-
-  private volatile boolean canceled;
-
-  @GuardedBy("this")
-  private @Nullable okhttp3.Call rawCall;
-  @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
-  private @Nullable Throwable creationFailure;
-  @GuardedBy("this")
-  private boolean executed;
-
-  OkHttpCall(RequestFactory requestFactory, Object[] args,
-      okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
-    this.requestFactory = requestFactory;
-    this.args = args;
-    this.callFactory = callFactory;
-    this.responseConverter = responseConverter;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else if (creationFailure instanceof RuntimeException) {
-        throw (RuntimeException) creationFailure;
-      } else {
-        throw (Error) creationFailure;
-      }
+    private final RequestFactory requestFactory;
+    private final Object[] args;
+    private final okhttp3.Call.Factory callFactory;
+    private final Converter<ResponseBody, T> responseConverter;
+
+    private volatile boolean canceled;
+
+    @GuardedBy("this")
+    private @Nullable
+    okhttp3.Call rawCall;
+    @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
+    private @Nullable
+    Throwable creationFailure;
+    @GuardedBy("this")
+    private boolean executed;
+
+    OkHttpCall(RequestFactory requestFactory, Object[] args,
+               okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
+        this.requestFactory = requestFactory;
+        this.args = args;
+        this.callFactory = callFactory;
+        this.responseConverter = responseConverter;
     }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException | Error e) {
-      throwIfFatal(e); // Do not assign a fatal error to creationFailure.
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    checkNotNull(callback, "callback == null");
 
-    okhttp3.Call call;
-    Throwable failure;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
+    }
 
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            return call.request();
+        }
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            } else if (creationFailure instanceof RuntimeException) {
+                throw (RuntimeException) creationFailure;
+            } else {
+                throw (Error) creationFailure;
+            }
+        }
         try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          throwIfFatal(t);
-          failure = creationFailure = t;
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException | Error e) {
+            throwIfFatal(e); // Do not assign a fatal error to creationFailure.
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
     }
 
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
-    }
-
-    if (canceled) {
-      call.cancel();
-    }
-
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          throwIfFatal(e);
-          callFailure(e);
-          return;
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        checkNotNull(callback, "callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    throwIfFatal(t);
+                    failure = creationFailure = t;
+                }
+            }
         }
 
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          throwIfFatal(t);
-          t.printStackTrace(); // TODO this is not great
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
         }
-      }
-
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        callFailure(e);
-      }
 
-      private void callFailure(Throwable e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          throwIfFatal(t);
-          t.printStackTrace(); // TODO this is not great
-        }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else if (creationFailure instanceof RuntimeException) {
-          throw (RuntimeException) creationFailure;
-        } else {
-          throw (Error) creationFailure;
+        if (canceled) {
+            call.cancel();
         }
-      }
 
-      call = rawCall;
-      if (call == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException | Error e) {
-          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
-          creationFailure = e;
-          throw e;
-        }
-      }
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    throwIfFatal(e);
+                    callFailure(e);
+                    return;
+                }
+
+                try {
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    throwIfFatal(t);
+                    t.printStackTrace(); // TODO this is not great
+                }
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                callFailure(e);
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    throwIfFatal(t);
+                    t.printStackTrace(); // TODO this is not great
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    return parseResponse(call.execute());
-  }
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                } else if (creationFailure instanceof RuntimeException) {
+                    throw (RuntimeException) creationFailure;
+                } else {
+                    throw (Error) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException | Error e) {
+                    throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
+                    creationFailure = e;
+                    throw e;
+                }
+            }
+        }
 
-  private okhttp3.Call createRawCall() throws IOException {
-    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
-    }
+        if (canceled) {
+            call.cancel();
+        }
 
-    if (code == 204 || code == 205) {
-      rawBody.close();
-      return Response.success(null, rawResponse);
+        return parseResponse(call.execute());
     }
 
-    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
-    try {
-      T body = responseConverter.convert(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+    private okhttp3.Call createRawCall() throws IOException {
+        okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
+        }
+        return call;
     }
-  }
 
-  public void cancel() {
-    canceled = true;
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        if (code == 204 || code == 205) {
+            rawBody.close();
+            return Response.success(null, rawResponse);
+        }
 
-  @Override public boolean isCanceled() {
-    if (canceled) {
-      return true;
-    }
-    synchronized (this) {
-      return rawCall != null && rawCall.isCanceled();
+        ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
+        try {
+            T body = responseConverter.convert(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
     }
-  }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final @Nullable MediaType contentType;
-    private final long contentLength;
+    public void cancel() {
+        canceled = true;
 
-    NoContentResponseBody(@Nullable MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    @Override
+    public boolean isCanceled() {
+        if (canceled) {
+            return true;
+        }
+        synchronized (this) {
+            return rawCall != null && rawCall.isCanceled();
+        }
     }
 
-    @Override public long contentLength() {
-      return contentLength;
-    }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final @Nullable
+        MediaType contentType;
+        private final long contentLength;
 
-    @Override public BufferedSource source() {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+        NoContentResponseBody(@Nullable MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-  static final class ExceptionCatchingResponseBody extends ResponseBody {
-    private final ResponseBody delegate;
-    @Nullable IOException thrownException;
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    ExceptionCatchingResponseBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public long contentLength() {
+            return contentLength;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
+        @Override
+        public BufferedSource source() {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public long contentLength() {
-      return delegate.contentLength();
-    }
+    static final class ExceptionCatchingResponseBody extends ResponseBody {
+        private final ResponseBody delegate;
+        @Nullable
+        IOException thrownException;
 
-    @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+        ExceptionCatchingResponseBody(ResponseBody delegate) {
+            this.delegate = delegate;
         }
-      });
-    }
 
-    @Override public void close() {
-      delegate.close();
-    }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index acd76bf0b..3b5717adc 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -15,389 +15,405 @@
  */
 package retrofit2;
 
+import okhttp3.Headers;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
+
+import javax.annotation.Nullable;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.util.Map;
-import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.MultipartBody;
-import okhttp3.RequestBody;
 
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
-
-  final ParameterHandler<Iterable<T>> iterable() {
-    return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, @Nullable Iterable<T> values)
-          throws IOException {
-        if (values == null) return; // Skip null values.
+    abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
+
+    final ParameterHandler<Iterable<T>> iterable() {
+        return new ParameterHandler<Iterable<T>>() {
+            @Override
+            void apply(RequestBuilder builder, @Nullable Iterable<T> values)
+                    throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (T value : values) {
+                    ParameterHandler.this.apply(builder, value);
+                }
+            }
+        };
+    }
 
-        for (T value : values) {
-          ParameterHandler.this.apply(builder, value);
-        }
-      }
-    };
-  }
-
-  final ParameterHandler<Object> array() {
-    return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (int i = 0, size = Array.getLength(values); i < size; i++) {
-          //noinspection unchecked
-          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
-        }
-      }
-    };
-  }
+    final ParameterHandler<Object> array() {
+        return new ParameterHandler<Object>() {
+            @Override
+            void apply(RequestBuilder builder, @Nullable Object values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (int i = 0, size = Array.getLength(values); i < size; i++) {
+                    //noinspection unchecked
+                    ParameterHandler.this.apply(builder, (T) Array.get(values, i));
+                }
+            }
+        };
+    }
 
-  static final class RelativeUrl extends ParameterHandler<Object> {
-    private final Method method;
-    private final int p;
+    static final class RelativeUrl extends ParameterHandler<Object> {
+        private final Method method;
+        private final int p;
 
-    RelativeUrl(Method method, int p) {
-      this.method = method;
-      this.p = p;
-    }
+        RelativeUrl(Method method, int p) {
+            this.method = method;
+            this.p = p;
+        }
 
-    @Override void apply(RequestBuilder builder, @Nullable Object value) {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "@Url parameter is null.");
-      }
-      builder.setRelativeUrl(value);
+        @Override
+        void apply(RequestBuilder builder, @Nullable Object value) {
+            if (value == null) {
+                throw Utils.parameterError(method, p, "@Url parameter is null.");
+            }
+            builder.setRelativeUrl(value);
+        }
     }
-  }
 
-  static final class Header<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
+    static final class Header<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
 
-    Header(String name, Converter<T, String> valueConverter) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-    }
+        Header(String name, Converter<T, String> valueConverter) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+        }
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
-      if (value == null) return; // Skip null values.
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+            if (value == null) return; // Skip null values.
 
-      String headerValue = valueConverter.convert(value);
-      if (headerValue == null) return; // Skip converted but null values.
+            String headerValue = valueConverter.convert(value);
+            if (headerValue == null) return; // Skip converted but null values.
 
-      builder.addHeader(name, headerValue);
-    }
-  }
-
-  static final class Path<T> extends ParameterHandler<T> {
-    private final Method method;
-    private final int p;
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-
-    Path(Method method, int p, String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.method = method;
-      this.p = p;
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+            builder.addHeader(name, headerValue);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
-      if (value == null) {
-        throw Utils.parameterError(method, p,
-                "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Path<T> extends ParameterHandler<T> {
+        private final Method method;
+        private final int p;
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-  static final class Query<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
 
-    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
+        Path(Method method, int p, String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.method = method;
+            this.p = p;
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
-      if (value == null) return; // Skip null values.
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+            if (value == null) {
+                throw Utils.parameterError(method, p,
+                        "Path parameter \"" + name + "\" value must not be null.");
+            }
+            builder.addPathParam(name, valueConverter.convert(value), encoded);
+        }
+    }
 
-      String queryValue = valueConverter.convert(value);
-      if (queryValue == null) return; // Skip converted but null values
+    static final class Query<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      builder.addQueryParam(name, queryValue, encoded);
-    }
-  }
+        Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-  static final class QueryName<T> extends ParameterHandler<T> {
-    private final Converter<T, String> nameConverter;
-    private final boolean encoded;
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+            if (value == null) return; // Skip null values.
 
-    QueryName(Converter<T, String> nameConverter, boolean encoded) {
-      this.nameConverter = nameConverter;
-      this.encoded = encoded;
-    }
+            String queryValue = valueConverter.convert(value);
+            if (queryValue == null) return; // Skip converted but null values
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addQueryParam(nameConverter.convert(value), null, encoded);
-    }
-  }
-
-  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    QueryMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
-      this.method = method;
-      this.p = p;
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+            builder.addQueryParam(name, queryValue, encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
-        throws IOException {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "Query map was null");
-      }
+    static final class QueryName<T> extends ParameterHandler<T> {
+        private final Converter<T, String> nameConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw Utils.parameterError(method, p, "Query map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Query map contained null value for key '" + entryKey + "'.");
+        QueryName(Converter<T, String> nameConverter, boolean encoded) {
+            this.nameConverter = nameConverter;
+            this.encoded = encoded;
         }
 
-        String convertedEntryValue = valueConverter.convert(entryValue);
-        if (convertedEntryValue == null) {
-          throw Utils.parameterError(method, p, "Query map value '"
-              + entryValue
-              + "' converted to null by "
-              + valueConverter.getClass().getName()
-              + " for key '"
-              + entryKey
-              + "'.");
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addQueryParam(nameConverter.convert(value), null, encoded);
         }
-
-        builder.addQueryParam(entryKey, convertedEntryValue, encoded);
-      }
     }
-  }
 
-  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
-    private final Converter<T, String> valueConverter;
+    static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Method method;
+        private final int p;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
+
+        QueryMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
+            this.method = method;
+            this.p = p;
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-    HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
-      this.method = method;
-      this.p = p;
-      this.valueConverter = valueConverter;
+        @Override
+        void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+                throws IOException {
+            if (value == null) {
+                throw Utils.parameterError(method, p, "Query map was null");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw Utils.parameterError(method, p, "Query map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw Utils.parameterError(method, p,
+                            "Query map contained null value for key '" + entryKey + "'.");
+                }
+
+                String convertedEntryValue = valueConverter.convert(entryValue);
+                if (convertedEntryValue == null) {
+                    throw Utils.parameterError(method, p, "Query map value '"
+                            + entryValue
+                            + "' converted to null by "
+                            + valueConverter.getClass().getName()
+                            + " for key '"
+                            + entryKey
+                            + "'.");
+                }
+
+                builder.addQueryParam(entryKey, convertedEntryValue, encoded);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
-        throws IOException {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "Header map was null.");
-      }
+    static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Method method;
+        private final int p;
+        private final Converter<T, String> valueConverter;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String headerName = entry.getKey();
-        if (headerName == null) {
-          throw Utils.parameterError(method, p, "Header map contained null key.");
+        HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
+            this.method = method;
+            this.p = p;
+            this.valueConverter = valueConverter;
         }
-        T headerValue = entry.getValue();
-        if (headerValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Header map contained null value for key '" + headerName + "'.");
+
+        @Override
+        void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+                throws IOException {
+            if (value == null) {
+                throw Utils.parameterError(method, p, "Header map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String headerName = entry.getKey();
+                if (headerName == null) {
+                    throw Utils.parameterError(method, p, "Header map contained null key.");
+                }
+                T headerValue = entry.getValue();
+                if (headerValue == null) {
+                    throw Utils.parameterError(method, p,
+                            "Header map contained null value for key '" + headerName + "'.");
+                }
+                builder.addHeader(headerName, valueConverter.convert(headerValue));
+            }
         }
-        builder.addHeader(headerName, valueConverter.convert(headerValue));
-      }
     }
-  }
 
-  static final class Field<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+    static final class Field<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
-    }
+        Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
-      if (value == null) return; // Skip null values.
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) throws IOException {
+            if (value == null) return; // Skip null values.
 
-      String fieldValue = valueConverter.convert(value);
-      if (fieldValue == null) return; // Skip null converted values
+            String fieldValue = valueConverter.convert(value);
+            if (fieldValue == null) return; // Skip null converted values
 
-      builder.addFormField(name, fieldValue, encoded);
-    }
-  }
-
-  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    FieldMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
-      this.method = method;
-      this.p = p;
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+            builder.addFormField(name, fieldValue, encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
-        throws IOException {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "Field map was null.");
-      }
-
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw Utils.parameterError(method, p, "Field map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Field map contained null value for key '" + entryKey + "'.");
+    static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Method method;
+        private final int p;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
+
+        FieldMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
+            this.method = method;
+            this.p = p;
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
 
-        String fieldEntry = valueConverter.convert(entryValue);
-        if (fieldEntry == null) {
-          throw Utils.parameterError(method, p, "Field map value '"
-              + entryValue
-              + "' converted to null by "
-              + valueConverter.getClass().getName()
-              + " for key '"
-              + entryKey
-              + "'.");
+        @Override
+        void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+                throws IOException {
+            if (value == null) {
+                throw Utils.parameterError(method, p, "Field map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw Utils.parameterError(method, p, "Field map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw Utils.parameterError(method, p,
+                            "Field map contained null value for key '" + entryKey + "'.");
+                }
+
+                String fieldEntry = valueConverter.convert(entryValue);
+                if (fieldEntry == null) {
+                    throw Utils.parameterError(method, p, "Field map value '"
+                            + entryValue
+                            + "' converted to null by "
+                            + valueConverter.getClass().getName()
+                            + " for key '"
+                            + entryKey
+                            + "'.");
+                }
+
+                builder.addFormField(entryKey, fieldEntry, encoded);
+            }
         }
-
-        builder.addFormField(entryKey, fieldEntry, encoded);
-      }
-    }
-  }
-
-  static final class Part<T> extends ParameterHandler<T> {
-    private final Method method;
-    private final int p;
-    private final Headers headers;
-    private final Converter<T, RequestBody> converter;
-
-    Part(Method method, int p, Headers headers, Converter<T, RequestBody> converter) {
-      this.method = method;
-      this.p = p;
-      this.headers = headers;
-      this.converter = converter;
     }
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) {
-      if (value == null) return; // Skip null values.
+    static final class Part<T> extends ParameterHandler<T> {
+        private final Method method;
+        private final int p;
+        private final Headers headers;
+        private final Converter<T, RequestBody> converter;
+
+        Part(Method method, int p, Headers headers, Converter<T, RequestBody> converter) {
+            this.method = method;
+            this.p = p;
+            this.headers = headers;
+            this.converter = converter;
+        }
 
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw Utils.parameterError(method, p, "Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.addPart(headers, body);
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) {
+            if (value == null) return; // Skip null values.
+
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw Utils.parameterError(method, p, "Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.addPart(headers, body);
+        }
     }
-  }
 
-  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
-    static final RawPart INSTANCE = new RawPart();
+    static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+        static final RawPart INSTANCE = new RawPart();
 
-    private RawPart() {
-    }
+        private RawPart() {
+        }
 
-    @Override void apply(RequestBuilder builder, @Nullable MultipartBody.Part value) {
-      if (value != null) { // Skip null values.
-        builder.addPart(value);
-      }
-    }
-  }
-
-  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
-    private final Converter<T, RequestBody> valueConverter;
-    private final String transferEncoding;
-
-    PartMap(Method method, int p,
-            Converter<T, RequestBody> valueConverter, String transferEncoding) {
-      this.method = method;
-      this.p = p;
-      this.valueConverter = valueConverter;
-      this.transferEncoding = transferEncoding;
+        @Override
+        void apply(RequestBuilder builder, @Nullable MultipartBody.Part value) {
+            if (value != null) { // Skip null values.
+                builder.addPart(value);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
-        throws IOException {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "Part map was null.");
-      }
-
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw Utils.parameterError(method, p, "Part map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Part map contained null value for key '" + entryKey + "'.");
+    static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Method method;
+        private final int p;
+        private final Converter<T, RequestBody> valueConverter;
+        private final String transferEncoding;
+
+        PartMap(Method method, int p,
+                Converter<T, RequestBody> valueConverter, String transferEncoding) {
+            this.method = method;
+            this.p = p;
+            this.valueConverter = valueConverter;
+            this.transferEncoding = transferEncoding;
         }
 
-        Headers headers = Headers.of(
-            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-
-        builder.addPart(headers, valueConverter.convert(entryValue));
-      }
+        @Override
+        void apply(RequestBuilder builder, @Nullable Map<String, T> value)
+                throws IOException {
+            if (value == null) {
+                throw Utils.parameterError(method, p, "Part map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw Utils.parameterError(method, p, "Part map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw Utils.parameterError(method, p,
+                            "Part map contained null value for key '" + entryKey + "'.");
+                }
+
+                Headers headers = Headers.of(
+                        "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+                        "Content-Transfer-Encoding", transferEncoding);
+
+                builder.addPart(headers, valueConverter.convert(entryValue));
+            }
+        }
     }
-  }
 
-  static final class Body<T> extends ParameterHandler<T> {
-    private final Method method;
-    private final int p;
-    private final Converter<T, RequestBody> converter;
+    static final class Body<T> extends ParameterHandler<T> {
+        private final Method method;
+        private final int p;
+        private final Converter<T, RequestBody> converter;
 
-    Body(Method method, int p, Converter<T, RequestBody> converter) {
-      this.method = method;
-      this.p = p;
-      this.converter = converter;
-    }
+        Body(Method method, int p, Converter<T, RequestBody> converter) {
+            this.method = method;
+            this.p = p;
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, @Nullable T value) {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "Body parameter value must not be null.");
-      }
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw Utils.parameterError(method, e, p, "Unable to convert " + value + " to RequestBody");
-      }
-      builder.setBody(body);
+        @Override
+        void apply(RequestBuilder builder, @Nullable T value) {
+            if (value == null) {
+                throw Utils.parameterError(method, p, "Body parameter value must not be null.");
+            }
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw Utils.parameterError(method, e, p, "Unable to convert " + value + " to RequestBody");
+            }
+            builder.setBody(body);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 79fac3bc1..3b47024e6 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -15,260 +15,265 @@
  */
 package retrofit2;
 
-import java.io.IOException;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import okhttp3.FormBody;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.MultipartBody;
-import okhttp3.Request;
-import okhttp3.RequestBody;
+import okhttp3.*;
 import okio.Buffer;
 import okio.BufferedSink;
 
-final class RequestBuilder {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
-
-  /**
-   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also
-   * matches dots in their percent-encoded form, {@code %2E}.
-   *
-   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code
-   * index.html}) but when alone they have a special meaning. A single dot resolves to no path
-   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding
-   * directory, so {@code /one/../three/} becomes {@code /three/}.
-   *
-   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.
-   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE
-   * /account/}.
-   */
-  private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.regex.Pattern;
 
-  private final String method;
+final class RequestBuilder {
+    private static final char[] HEX_DIGITS =
+            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+    private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
 
-  private final HttpUrl baseUrl;
-  private @Nullable String relativeUrl;
-  private @Nullable HttpUrl.Builder urlBuilder;
+    /**
+     * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also
+     * matches dots in their percent-encoded form, {@code %2E}.
+     *
+     * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code
+     * index.html}) but when alone they have a special meaning. A single dot resolves to no path
+     * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding
+     * directory, so {@code /one/../three/} becomes {@code /three/}.
+     *
+     * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.
+     * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE
+     * /account/}.
+     */
+    private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");
 
-  private final Request.Builder requestBuilder;
-  private @Nullable MediaType contentType;
+    private final String method;
 
-  private final boolean hasBody;
-  private @Nullable MultipartBody.Builder multipartBuilder;
-  private @Nullable FormBody.Builder formBuilder;
-  private @Nullable RequestBody body;
+    private final HttpUrl baseUrl;
+    private final Request.Builder requestBuilder;
+    private final boolean hasBody;
+    private @Nullable
+    String relativeUrl;
+    private @Nullable
+    HttpUrl.Builder urlBuilder;
+    private @Nullable
+    MediaType contentType;
+    private @Nullable
+    MultipartBody.Builder multipartBuilder;
+    private @Nullable
+    FormBody.Builder formBuilder;
+    private @Nullable
+    RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl,
-      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
-      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder();
-    this.contentType = contentType;
-    this.hasBody = hasBody;
+    RequestBuilder(String method, HttpUrl baseUrl,
+                   @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
+                   boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+        this.method = method;
+        this.baseUrl = baseUrl;
+        this.relativeUrl = relativeUrl;
+        this.requestBuilder = new Request.Builder();
+        this.contentType = contentType;
+        this.hasBody = hasBody;
 
-    if (headers != null) {
-      requestBuilder.headers(headers);
-    }
+        if (headers != null) {
+            requestBuilder.headers(headers);
+        }
 
-    if (isFormEncoded) {
-      // Will be set to 'body' in 'build'.
-      formBuilder = new FormBody.Builder();
-    } else if (isMultipart) {
-      // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBody.Builder();
-      multipartBuilder.setType(MultipartBody.FORM);
+        if (isFormEncoded) {
+            // Will be set to 'body' in 'build'.
+            formBuilder = new FormBody.Builder();
+        } else if (isMultipart) {
+            // Will be set to 'body' in 'build'.
+            multipartBuilder = new MultipartBody.Builder();
+            multipartBuilder.setType(MultipartBody.FORM);
+        }
     }
-  }
 
-  void setRelativeUrl(Object relativeUrl) {
-    this.relativeUrl = relativeUrl.toString();
-  }
+    private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+        int codePoint;
+        for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Slow path: the character at i requires encoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(input, 0, i);
+                canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+                return out.readUtf8();
+            }
+        }
 
-  void addHeader(String name, String value) {
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      try {
-        contentType = MediaType.get(value);
-      } catch (IllegalArgumentException e) {
-        throw new IllegalArgumentException("Malformed content type: " + value, e);
-      }
-    } else {
-      requestBuilder.addHeader(name, value);
+        // Fast path: no characters required encoding.
+        return input;
     }
-  }
 
-  void addPathParam(String name, String value, boolean encoded) {
-    if (relativeUrl == null) {
-      // The relative URL is cleared when the first query parameter is set.
-      throw new AssertionError();
-    }
-    String replacement = canonicalizeForPath(value, encoded);
-    String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);
-    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
-      throw new IllegalArgumentException(
-          "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);
+    private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+                                            boolean alreadyEncoded) {
+        Buffer utf8Buffer = null; // Lazily allocated.
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                    && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            } else if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Percent encode this character.
+                if (utf8Buffer == null) {
+                    utf8Buffer = new Buffer();
+                }
+                utf8Buffer.writeUtf8CodePoint(codePoint);
+                while (!utf8Buffer.exhausted()) {
+                    int b = utf8Buffer.readByte() & 0xff;
+                    out.writeByte('%');
+                    out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.writeByte(HEX_DIGITS[b & 0xf]);
+                }
+            } else {
+                // This character doesn't need encoding. Just copy it over.
+                out.writeUtf8CodePoint(codePoint);
+            }
+        }
     }
-    relativeUrl = newRelativeUrl;
-  }
 
-  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
-    int codePoint;
-    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, 0, i);
-        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
-        return out.readUtf8();
-      }
+    void setRelativeUrl(Object relativeUrl) {
+        this.relativeUrl = relativeUrl.toString();
     }
 
-    // Fast path: no characters required encoding.
-    return input;
-  }
+    void addHeader(String name, String value) {
+        if ("Content-Type".equalsIgnoreCase(name)) {
+            try {
+                contentType = MediaType.get(value);
+            } catch (IllegalArgumentException e) {
+                throw new IllegalArgumentException("Malformed content type: " + value, e);
+            }
+        } else {
+            requestBuilder.addHeader(name, value);
+        }
+    }
 
-  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
-      boolean alreadyEncoded) {
-    Buffer utf8Buffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
+    void addPathParam(String name, String value, boolean encoded) {
+        if (relativeUrl == null) {
+            // The relative URL is cleared when the first query parameter is set.
+            throw new AssertionError();
         }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
+        String replacement = canonicalizeForPath(value, encoded);
+        String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);
+        if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
+            throw new IllegalArgumentException(
+                    "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);
         }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
+        relativeUrl = newRelativeUrl;
     }
-  }
 
-  void addQueryParam(String name, @Nullable String value, boolean encoded) {
-    if (relativeUrl != null) {
-      // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.newBuilder(relativeUrl);
-      if (urlBuilder == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
-      relativeUrl = null;
-    }
+    void addQueryParam(String name, @Nullable String value, boolean encoded) {
+        if (relativeUrl != null) {
+            // Do a one-time combination of the built relative URL and the base URL.
+            urlBuilder = baseUrl.newBuilder(relativeUrl);
+            if (urlBuilder == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+            relativeUrl = null;
+        }
 
-    if (encoded) {
-      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
-      urlBuilder.addEncodedQueryParameter(name, value);
-    } else {
-      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
-      urlBuilder.addQueryParameter(name, value);
+        if (encoded) {
+            //noinspection ConstantConditions Checked to be non-null by above 'if' block.
+            urlBuilder.addEncodedQueryParameter(name, value);
+        } else {
+            //noinspection ConstantConditions Checked to be non-null by above 'if' block.
+            urlBuilder.addQueryParameter(name, value);
+        }
     }
-  }
 
-  @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
-  void addFormField(String name, String value, boolean encoded) {
-    if (encoded) {
-      formBuilder.addEncoded(name, value);
-    } else {
-      formBuilder.add(name, value);
+    @SuppressWarnings("ConstantConditions")
+        // Only called when isFormEncoded was true.
+    void addFormField(String name, String value, boolean encoded) {
+        if (encoded) {
+            formBuilder.addEncoded(name, value);
+        } else {
+            formBuilder.add(name, value);
+        }
     }
-  }
-
-  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
-  void addPart(Headers headers, RequestBody body) {
-    multipartBuilder.addPart(headers, body);
-  }
-
-  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
-  void addPart(MultipartBody.Part part) {
-    multipartBuilder.addPart(part);
-  }
 
-  void setBody(RequestBody body) {
-    this.body = body;
-  }
-
-  Request.Builder get() {
-    HttpUrl url;
-    HttpUrl.Builder urlBuilder = this.urlBuilder;
-    if (urlBuilder != null) {
-      url = urlBuilder.build();
-    } else {
-      // No query parameters triggered builder creation, just combine the relative URL and base URL.
-      //noinspection ConstantConditions Non-null if urlBuilder is null.
-      url = baseUrl.resolve(relativeUrl);
-      if (url == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
+    @SuppressWarnings("ConstantConditions")
+        // Only called when isMultipart was true.
+    void addPart(Headers headers, RequestBody body) {
+        multipartBuilder.addPart(headers, body);
     }
 
-    RequestBody body = this.body;
-    if (body == null) {
-      // Try to pull from one of the builders.
-      if (formBuilder != null) {
-        body = formBuilder.build();
-      } else if (multipartBuilder != null) {
-        body = multipartBuilder.build();
-      } else if (hasBody) {
-        // Body is absent, make an empty body.
-        body = RequestBody.create(null, new byte[0]);
-      }
+    @SuppressWarnings("ConstantConditions")
+        // Only called when isMultipart was true.
+    void addPart(MultipartBody.Part part) {
+        multipartBuilder.addPart(part);
     }
 
-    MediaType contentType = this.contentType;
-    if (contentType != null) {
-      if (body != null) {
-        body = new ContentTypeOverridingRequestBody(body, contentType);
-      } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
-      }
+    void setBody(RequestBody body) {
+        this.body = body;
     }
 
-    return requestBuilder
-        .url(url)
-        .method(method, body);
-  }
+    Request.Builder get() {
+        HttpUrl url;
+        HttpUrl.Builder urlBuilder = this.urlBuilder;
+        if (urlBuilder != null) {
+            url = urlBuilder.build();
+        } else {
+            // No query parameters triggered builder creation, just combine the relative URL and base URL.
+            //noinspection ConstantConditions Non-null if urlBuilder is null.
+            url = baseUrl.resolve(relativeUrl);
+            if (url == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+        }
 
-  private static class ContentTypeOverridingRequestBody extends RequestBody {
-    private final RequestBody delegate;
-    private final MediaType contentType;
+        RequestBody body = this.body;
+        if (body == null) {
+            // Try to pull from one of the builders.
+            if (formBuilder != null) {
+                body = formBuilder.build();
+            } else if (multipartBuilder != null) {
+                body = multipartBuilder.build();
+            } else if (hasBody) {
+                // Body is absent, make an empty body.
+                body = RequestBody.create(null, new byte[0]);
+            }
+        }
 
-    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
-      this.delegate = delegate;
-      this.contentType = contentType;
-    }
+        MediaType contentType = this.contentType;
+        if (contentType != null) {
+            if (body != null) {
+                body = new ContentTypeOverridingRequestBody(body, contentType);
+            } else {
+                requestBuilder.addHeader("Content-Type", contentType.toString());
+            }
+        }
 
-    @Override public MediaType contentType() {
-      return contentType;
+        return requestBuilder
+                .url(url)
+                .method(method, body);
     }
 
-    @Override public long contentLength() throws IOException {
-      return delegate.contentLength();
-    }
+    private static class ContentTypeOverridingRequestBody extends RequestBody {
+        private final RequestBody delegate;
+        private final MediaType contentType;
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      delegate.writeTo(sink);
+        ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
+            this.delegate = delegate;
+            this.contentType = contentType;
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
+
+        @Override
+        public long contentLength() throws IOException {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            delegate.writeTo(sink);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 96394aaa4..9175ffaf7 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -15,20 +15,6 @@
  */
 package retrofit2;
 
-import java.lang.annotation.Annotation;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
-import javax.annotation.Nullable;
-
-import android.util.Log;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -38,6 +24,15 @@
 import retrofit2.http.Header;
 import retrofit2.http.Url;
 
+import javax.annotation.Nullable;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executor;
+
 import static java.util.Collections.unmodifiableList;
 import static retrofit2.Utils.checkNotNull;
 
@@ -226,7 +221,8 @@ public HttpUrl baseUrl() {
 
         int start = callAdapterFactories.indexOf(skipPast) + 1;
         for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
-            CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
+            CallAdapter.Factory factory = callAdapterFactories.get(i);
+            CallAdapter<?, ?> adapter = factory.get(returnType, annotations, this);
             if (adapter != null) {
                 return adapter;
             }
@@ -433,8 +429,7 @@ public Builder() {
             }
 
             // Do not add the default, platform-aware call adapters added by build().
-            for (int i = 0,
-                 size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
+            for (int i = 0, size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
                  i < size; i++) {
                 callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
             }
@@ -604,14 +599,12 @@ public Retrofit build() {
             if (callbackExecutor == null) {
                 callbackExecutor = platform.defaultCallbackExecutor();
             }
-
             // Make a defensive copy of the adapters and add the default Call adapter.
             List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
             callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
 
             // Make a defensive copy of the converters.
-            List<Converter.Factory> converterFactories = new ArrayList<>(
-                    1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
+            List<Converter.Factory> converterFactories = new ArrayList<>(1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
 
             // Add the built-in converter factory first. This prevents overriding its behavior but also
             // ensures correct behavior when using converters that consume all types.
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 85258222c..a80b423e7 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -15,515 +15,536 @@
  */
 package retrofit2;
 
+import okhttp3.ResponseBody;
+import okio.Buffer;
+
+import javax.annotation.Nullable;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.GenericDeclaration;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.lang.reflect.WildcardType;
+import java.lang.reflect.*;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
-import javax.annotation.Nullable;
-import okhttp3.ResponseBody;
-import okio.Buffer;
 
 final class Utils {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
-
-  private Utils() {
-    // No instances.
-  }
-
-  static RuntimeException methodError(Method method, String message, Object... args) {
-    return methodError(method, null, message, args);
-  }
-
-  static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
-      Object... args) {
-    message = String.format(message, args);
-    return new IllegalArgumentException(message
-        + "\n    for method "
-        + method.getDeclaringClass().getSimpleName()
-        + "."
-        + method.getName(), cause);
-  }
-
-  static RuntimeException parameterError(Method method,
-      Throwable cause, int p, String message, Object... args) {
-    return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
-  }
-
-  static RuntimeException parameterError(Method method, int p, String message, Object... args) {
-    return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
-  }
-
-  static Class<?> getRawType(Type type) {
-    checkNotNull(type, "type == null");
-
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-    }
-    if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-    }
-    if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
+    static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+    private Utils() {
+        // No instances.
     }
-    if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    static RuntimeException methodError(Method method, String message, Object... args) {
+        return methodError(method, null, message, args);
     }
 
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      Object ownerA = pa.getOwnerType();
-      Object ownerB = pb.getOwnerType();
-      return (ownerA == ownerB || (ownerA != null && ownerA.equals(ownerB)))
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
+    static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
+                                        Object... args) {
+        message = String.format(message, args);
+        return new IllegalArgumentException(message
+                + "\n    for method "
+                + method.getDeclaringClass().getSimpleName()
+                + "."
+                + method.getName(), cause);
     }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
+
+    static RuntimeException parameterError(Method method,
+                                           Throwable cause, int p, String message, Object... args) {
+        return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
     }
 
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
+    static RuntimeException parameterError(Method method, int p, String message, Object... args) {
+        return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
     }
 
-    // We can't resolve this further.
-    return toResolve;
-  }
+    static Class<?> getRawType(Type type) {
+        checkNotNull(type, "type == null");
 
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
-    }
-    throw new NoSuchElementException();
-  }
-
-  static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
+        if (type instanceof Class<?>) {
+            // Type is a normal class.
+            return (Class<?>) type;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+
+            // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+            // suspects some pathological case related to nested classes exists.
+            Type rawType = parameterizedType.getRawType();
+            if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+            return (Class<?>) rawType;
+        }
+        if (type instanceof GenericArrayType) {
+            Type componentType = ((GenericArrayType) type).getGenericComponentType();
+            return Array.newInstance(getRawType(componentType), 0).getClass();
+        }
+        if (type instanceof TypeVariable) {
+            // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+            // type that's more general than necessary is okay.
+            return Object.class;
+        }
+        if (type instanceof WildcardType) {
+            return getRawType(((WildcardType) type).getUpperBounds()[0]);
         }
 
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+    }
+
+    /**
+     * Returns true if {@code a} and {@code b} are equal.
+     */
+    static boolean equals(Type a, Type b) {
+        if (a == b) {
+            return true; // Also handles (a == null && b == null).
+
+        } else if (a instanceof Class) {
+            return a.equals(b); // Class already specifies equals().
+
+        } else if (a instanceof ParameterizedType) {
+            if (!(b instanceof ParameterizedType)) return false;
+            ParameterizedType pa = (ParameterizedType) a;
+            ParameterizedType pb = (ParameterizedType) b;
+            Object ownerA = pa.getOwnerType();
+            Object ownerB = pb.getOwnerType();
+            return (ownerA == ownerB || (ownerA != null && ownerA.equals(ownerB)))
+                    && pa.getRawType().equals(pb.getRawType())
+                    && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+        } else if (a instanceof GenericArrayType) {
+            if (!(b instanceof GenericArrayType)) return false;
+            GenericArrayType ga = (GenericArrayType) a;
+            GenericArrayType gb = (GenericArrayType) b;
+            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+        } else if (a instanceof WildcardType) {
+            if (!(b instanceof WildcardType)) return false;
+            WildcardType wa = (WildcardType) a;
+            WildcardType wb = (WildcardType) b;
+            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+                    && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+        } else if (a instanceof TypeVariable) {
+            if (!(b instanceof TypeVariable)) return false;
+            TypeVariable<?> va = (TypeVariable<?>) a;
+            TypeVariable<?> vb = (TypeVariable<?>) b;
+            return va.getGenericDeclaration() == vb.getGenericDeclaration()
+                    && va.getName().equals(vb.getName());
+
+        } else {
+            return false; // This isn't a type we support!
+        }
+    }
 
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
+    /**
+     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+     */
+    static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+        if (toResolve == rawType) return context;
+
+        // We skip searching through interfaces if unknown is an interface.
+        if (toResolve.isInterface()) {
+            Class<?>[] interfaces = rawType.getInterfaces();
+            for (int i = 0, length = interfaces.length; i < length; i++) {
+                if (interfaces[i] == toResolve) {
+                    return rawType.getGenericInterfaces()[i];
+                } else if (toResolve.isAssignableFrom(interfaces[i])) {
+                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+                }
+            }
+        }
 
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
+        // Check our supertypes.
+        if (!rawType.isInterface()) {
+            while (rawType != Object.class) {
+                Class<?> rawSupertype = rawType.getSuperclass();
+                if (rawSupertype == toResolve) {
+                    return rawType.getGenericSuperclass();
+                } else if (toResolve.isAssignableFrom(rawSupertype)) {
+                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+                }
+                rawType = rawSupertype;
+            }
         }
-        return original;
 
-      } else {
+        // We can't resolve this further.
         return toResolve;
-      }
     }
-  }
 
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
+    private static int indexOf(Object[] array, Object toFind) {
+        for (int i = 0; i < array.length; i++) {
+            if (toFind.equals(array[i])) return i;
+        }
+        throw new NoSuchElementException();
+    }
+
+    static String typeToString(Type type) {
+        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+    }
+
+    /**
+     * Returns the generic form of {@code supertype}. For example, if this is {@code
+     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+     * Iterable.class}.
+     *
+     * @param supertype a superclass of, or interface implemented by, this.
+     */
+    static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+        if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+        return resolve(context, contextRawType,
+                getGenericSupertype(context, contextRawType, supertype));
+    }
+
+    static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+        // This implementation is made a little more complicated in an attempt to avoid object-creation.
+        while (true) {
+            if (toResolve instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+                if (toResolve == typeVariable) {
+                    return toResolve;
+                }
+
+            } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+                Class<?> original = (Class<?>) toResolve;
+                Type componentType = original.getComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof GenericArrayType) {
+                GenericArrayType original = (GenericArrayType) toResolve;
+                Type componentType = original.getGenericComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof ParameterizedType) {
+                ParameterizedType original = (ParameterizedType) toResolve;
+                Type ownerType = original.getOwnerType();
+                Type newOwnerType = resolve(context, contextRawType, ownerType);
+                boolean changed = newOwnerType != ownerType;
+
+                Type[] args = original.getActualTypeArguments();
+                for (int t = 0, length = args.length; t < length; t++) {
+                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+                    if (resolvedTypeArgument != args[t]) {
+                        if (!changed) {
+                            args = args.clone();
+                            changed = true;
+                        }
+                        args[t] = resolvedTypeArgument;
+                    }
+                }
+
+                return changed
+                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+                        : original;
+
+            } else if (toResolve instanceof WildcardType) {
+                WildcardType original = (WildcardType) toResolve;
+                Type[] originalLowerBound = original.getLowerBounds();
+                Type[] originalUpperBound = original.getUpperBounds();
+
+                if (originalLowerBound.length == 1) {
+                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+                    if (lowerBound != originalLowerBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{Object.class}, new Type[]{lowerBound});
+                    }
+                } else if (originalUpperBound.length == 1) {
+                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+                    if (upperBound != originalUpperBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{upperBound}, EMPTY_TYPE_ARRAY);
+                    }
+                }
+                return original;
+
+            } else {
+                return toResolve;
+            }
+        }
+    }
 
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
+    private static Type resolveTypeVariable(
+            Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+        Class<?> declaredByRaw = declaringClassOf(unknown);
 
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
+        // We can't reduce this further.
+        if (declaredByRaw == null) return unknown;
 
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
-    }
-  }
+        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+        if (declaredBy instanceof ParameterizedType) {
+            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+        }
 
-  static <T> T checkNotNull(@Nullable T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
-    }
-    return object;
-  }
-
-  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
-  static boolean isAnnotationPresent(Annotation[] annotations,
-      Class<? extends Annotation> cls) {
-    for (Annotation annotation : annotations) {
-      if (cls.isInstance(annotation)) {
-        return true;
-      }
+        return unknown;
     }
-    return false;
-  }
-
-  static ResponseBody buffer(final ResponseBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.source().readAll(buffer);
-    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
-  }
-
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("API declarations must be interfaces.");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
-    }
-  }
 
-  static Type getParameterUpperBound(int index, ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    if (index < 0 || index >= types.length) {
-      throw new IllegalArgumentException(
-          "Index " + index + " not in range [0," + types.length + ") for " + type);
-    }
-    Type paramType = types[index];
-    if (paramType instanceof WildcardType) {
-      return ((WildcardType) paramType).getUpperBounds()[0];
+    /**
+     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+     * a class.
+     */
+    private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
     }
-    return paramType;
-  }
 
-  static boolean hasUnresolvableType(@Nullable Type type) {
-    if (type instanceof Class<?>) {
-      return false;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
-        if (hasUnresolvableType(typeArgument)) {
-          return true;
-        }
-      }
-      return false;
-    }
-    if (type instanceof GenericArrayType) {
-      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
-    }
-    if (type instanceof TypeVariable) {
-      return true;
-    }
-    if (type instanceof WildcardType) {
-      return true;
-    }
-    String className = type == null ? "null" : type.getClass().getName();
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-        + "GenericArrayType, but <" + type + "> is of type " + className);
-  }
-
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-    return getParameterUpperBound(0, (ParameterizedType) returnType);
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      for (Type typeArgument : typeArguments) {
-        checkNotNull(typeArgument, "typeArgument == null");
-        checkNotPrimitive(typeArgument);
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
+    static void checkNotPrimitive(Type type) {
+        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+            throw new IllegalArgumentException();
+        }
     }
 
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
+    static <T> T checkNotNull(@Nullable T object, String message) {
+        if (object == null) {
+            throw new NullPointerException(message);
+        }
+        return object;
     }
 
-    @Override public Type getRawType() {
-      return rawType;
+    /**
+     * Returns true if {@code annotations} contains an instance of {@code cls}.
+     */
+    static boolean isAnnotationPresent(Annotation[] annotations,
+                                       Class<? extends Annotation> cls) {
+        for (Annotation annotation : annotations) {
+            if (cls.isInstance(annotation)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    @Override public Type getOwnerType() {
-      return ownerType;
+    static ResponseBody buffer(final ResponseBody body) throws IOException {
+        Buffer buffer = new Buffer();
+        body.source().readAll(buffer);
+        return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    static <T> void validateServiceInterface(Class<T> service) {
+        if (!service.isInterface()) {
+            throw new IllegalArgumentException("API declarations must be interfaces.");
+        }
+        // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+        // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+        // the recommended pattern.
+        if (service.getInterfaces().length > 0) {
+            throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+        }
     }
 
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments)
-          ^ rawType.hashCode()
-          ^ (ownerType != null ? ownerType.hashCode() : 0);
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    static Type getParameterUpperBound(int index, ParameterizedType type) {
+        Type[] types = type.getActualTypeArguments();
+        if (index < 0 || index >= types.length) {
+            throw new IllegalArgumentException(
+                    "Index " + index + " not in range [0," + types.length + ") for " + type);
+        }
+        Type paramType = types[index];
+        if (paramType instanceof WildcardType) {
+            return ((WildcardType) paramType).getUpperBounds()[0];
+        }
+        return paramType;
     }
 
-    @Override public String toString() {
-      if (typeArguments.length == 0) return typeToString(rawType);
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
+    static boolean hasUnresolvableType(@Nullable Type type) {
+        if (type instanceof Class<?>) {
+            return false;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+                if (hasUnresolvableType(typeArgument)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        if (type instanceof GenericArrayType) {
+            return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+        }
+        if (type instanceof TypeVariable) {
+            return true;
+        }
+        if (type instanceof WildcardType) {
+            return true;
+        }
+        String className = type == null ? "null" : type.getClass().getName();
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+
+    /**
+     * @param returnType 带泛型的返回类型
+     * @return getParameterUpperBound
+     */
+    static Type getCallResponseType(Type returnType) {
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalArgumentException(
+                    "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+        return getParameterUpperBound(0, (ParameterizedType) returnType);
+    }
+
+    // https://github.com/ReactiveX/RxJava/blob/6a44e5d0543a48f1c378dc833a155f3f71333bc2/
+    // src/main/java/io/reactivex/exceptions/Exceptions.java#L66
+    static void throwIfFatal(Throwable t) {
+        if (t instanceof VirtualMachineError) {
+            throw (VirtualMachineError) t;
+        } else if (t instanceof ThreadDeath) {
+            throw (ThreadDeath) t;
+        } else if (t instanceof LinkageError) {
+            throw (LinkageError) t;
+        }
     }
-  }
 
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
+    private static final class ParameterizedTypeImpl implements ParameterizedType {
+        private final Type ownerType;
+        private final Type rawType;
+        private final Type[] typeArguments;
 
-    GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
+        ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
+            // Require an owner type if the raw type needs it.
+            if (rawType instanceof Class<?>
+                    && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+                throw new IllegalArgumentException();
+            }
 
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
+            for (Type typeArgument : typeArguments) {
+                checkNotNull(typeArgument, "typeArgument == null");
+                checkNotPrimitive(typeArgument);
+            }
 
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Utils.equals(this, (GenericArrayType) o);
-    }
+            this.ownerType = ownerType;
+            this.rawType = rawType;
+            this.typeArguments = typeArguments.clone();
+        }
 
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
+        @Override
+        public Type[] getActualTypeArguments() {
+            return typeArguments.clone();
+        }
 
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
+        @Override
+        public Type getRawType() {
+            return rawType;
+        }
 
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
+        @Override
+        public Type getOwnerType() {
+            return ownerType;
+        }
 
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+        }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
-    }
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(typeArguments)
+                    ^ rawType.hashCode()
+                    ^ (ownerType != null ? ownerType.hashCode() : 0);
+        }
 
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        @Override
+        public String toString() {
+            if (typeArguments.length == 0) return typeToString(rawType);
+            StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+            result.append(typeToString(rawType));
+            result.append("<").append(typeToString(typeArguments[0]));
+            for (int i = 1; i < typeArguments.length; i++) {
+                result.append(", ").append(typeToString(typeArguments[i]));
+            }
+            return result.append(">").toString();
+        }
     }
 
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
+    private static final class GenericArrayTypeImpl implements GenericArrayType {
+        private final Type componentType;
+
+        GenericArrayTypeImpl(Type componentType) {
+            this.componentType = componentType;
+        }
+
+        @Override
+        public Type getGenericComponentType() {
+            return componentType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof GenericArrayType
+                    && Utils.equals(this, (GenericArrayType) o);
+        }
+
+        @Override
+        public int hashCode() {
+            return componentType.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return typeToString(componentType) + "[]";
+        }
     }
-  }
-
-  // https://github.com/ReactiveX/RxJava/blob/6a44e5d0543a48f1c378dc833a155f3f71333bc2/
-  // src/main/java/io/reactivex/exceptions/Exceptions.java#L66
-  static void throwIfFatal(Throwable t) {
-    if (t instanceof VirtualMachineError) {
-      throw (VirtualMachineError) t;
-    } else if (t instanceof ThreadDeath) {
-      throw (ThreadDeath) t;
-    } else if (t instanceof LinkageError) {
-      throw (LinkageError) t;
+
+    /**
+     * The WildcardType interface supports multiple upper bounds and multiple
+     * lower bounds. We only support what the Java 6 language needs - at most one
+     * bound. If a lower bound is set, the upper bound must be Object.class.
+     */
+    private static final class WildcardTypeImpl implements WildcardType {
+        private final Type upperBound;
+        private final Type lowerBound;
+
+        WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+            if (lowerBounds.length > 1) throw new IllegalArgumentException();
+            if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+            if (lowerBounds.length == 1) {
+                if (lowerBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(lowerBounds[0]);
+                if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+                this.lowerBound = lowerBounds[0];
+                this.upperBound = Object.class;
+            } else {
+                if (upperBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(upperBounds[0]);
+                this.lowerBound = null;
+                this.upperBound = upperBounds[0];
+            }
+        }
+
+        @Override
+        public Type[] getUpperBounds() {
+            return new Type[]{upperBound};
+        }
+
+        @Override
+        public Type[] getLowerBounds() {
+            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        }
+
+        @Override
+        public String toString() {
+            if (lowerBound != null) return "? super " + typeToString(lowerBound);
+            if (upperBound == Object.class) return "?";
+            return "? extends " + typeToString(upperBound);
+        }
     }
-  }
 }
diff --git a/samples/src/main/java/com/example/IRequestApi.java b/samples/src/main/java/com/example/IRequestApi.java
index b7c277d9b..6d43ee3c0 100644
--- a/samples/src/main/java/com/example/IRequestApi.java
+++ b/samples/src/main/java/com/example/IRequestApi.java
@@ -1,17 +1,21 @@
 package com.example;
 
+import okhttp3.RequestBody;
 import retrofit2.Call;
-import retrofit2.http.GET;
-import retrofit2.http.Query;
+import retrofit2.http.*;
 
 import java.util.Map;
 
 public interface IRequestApi<P> {
-    @GET("hello")
-    Call<String> get(@Query("param") String url);
+    @GET(value = "hello")
+    Call<String> get(@Query(value = "param") String url);
 
-    @GET("hello")
-    Call<String> get2(@Query("param") String url);
+    @POST("hello")
+    Call<String> post1(@Body RequestBody body);
+
+    @FormUrlEncoded
+    @POST("hello")
+    Call<String> post2(@Field(value = "param", encoded = true) String param);
 
     @GET("hello")
     Call<String> get3(@Query("param") String url);
diff --git a/samples/src/main/java/com/example/Main.java b/samples/src/main/java/com/example/Main.java
index 132c4ec34..ed86c44f8 100644
--- a/samples/src/main/java/com/example/Main.java
+++ b/samples/src/main/java/com/example/Main.java
@@ -3,7 +3,6 @@
 import com.google.gson.Gson;
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
-import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.logging.HttpLoggingInterceptor;
 import retrofit2.Call;
@@ -60,18 +59,6 @@ public void onFailure(Call<String> call, Throwable t) {
                 System.out.println(call);
             }
         });
-        Call<String> call2 = iRequestApi.get2("3333");
-        call2.enqueue(new Callback<String>() {
-            @Override
-            public void onResponse(Call<String> call, Response<String> response) {
-                System.out.println(call);
-            }
-
-            @Override
-            public void onFailure(Call<String> call, Throwable t) {
-                System.out.println(call);
-            }
-        });
 
     }
 
diff --git a/samples/src/main/java/com/example/MethodTest.java b/samples/src/main/java/com/example/MethodTest.java
index 2ec1b06e4..34b288361 100644
--- a/samples/src/main/java/com/example/MethodTest.java
+++ b/samples/src/main/java/com/example/MethodTest.java
@@ -1,28 +1,6 @@
 package com.example;
 
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.Arrays;
-import java.util.Collections;
-
 public class MethodTest {
     public static void main(String[] args) {
-        Class clazz = IRequestApi.class;
-        Method[] declaredMethods = clazz.getDeclaredMethods();
-        for (Method method : declaredMethods) {
-            Annotation[] annotations = method.getAnnotations();
-            System.out.println(Arrays.asList(annotations));
-            System.out.println("----------");
-            Type[] genericParameterTypes = method.getGenericParameterTypes();
-            System.out.println(Arrays.asList(genericParameterTypes));
-            System.out.println(genericParameterTypes.length);
-            System.out.println("----------");
-            Annotation[][] parameterAnnotations = method.getParameterAnnotations();
-            for (Annotation[] parameterAnnotation : parameterAnnotations) {
-                System.out.println(Arrays.asList(parameterAnnotation));
-            }
-            System.out.println("=======================");
-        }
     }
 }
