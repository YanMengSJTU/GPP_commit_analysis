diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index 468d576d7..6479da287 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -18,13 +18,17 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
+import javax.annotation.Nullable;
+
 /**
  * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
  * <p>
@@ -34,41 +38,50 @@
  * last to allow the other converters a chance to see their types.
  */
 public final class GsonConverterFactory extends Converter.Factory {
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public static GsonConverterFactory create() {
-    return create(new Gson());
-  }
+    /**
+     * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+     * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+     */
+    public static GsonConverterFactory create() {
+        return create(new Gson());
+    }
+
+    /**
+     * Create an instance using {@code gson} for conversion. Encoding to JSON and
+     * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+     */
+    @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
+    public static GsonConverterFactory create(Gson gson) {
+        if (gson == null) throw new NullPointerException("gson == null");
+        return new GsonConverterFactory(gson);
+    }
+
+    private final Gson gson;
 
-  /**
-   * Create an instance using {@code gson} for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  @SuppressWarnings("ConstantConditions") // Guarding public API nullability.
-  public static GsonConverterFactory create(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
-    return new GsonConverterFactory(gson);
-  }
+    private GsonConverterFactory(Gson gson) {
+        this.gson = gson;
+    }
 
-  private final Gson gson;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+        return new GsonResponseBodyConverter<>(gson, adapter);
+    }
 
-  private GsonConverterFactory(Gson gson) {
-    this.gson = gson;
-  }
+    @Nullable
+    @Override
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
+        // 在这里对集合进行统一的处理
+        // define customer class to converter to list[0]
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonResponseBodyConverter<>(gson, adapter);
-  }
+        return super.stringConverter(type, annotations, retrofit);
+    }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonRequestBodyConverter<>(gson, adapter);
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+        return new GsonRequestBodyConverter<>(gson, adapter);
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index 6e9d9d7b2..ffbd2e44f 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -126,7 +126,6 @@ private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory ca
 
     @Override
     ReturnT invoke(Object[] args) {
-        return callAdapter.adapt(
-                new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+        return callAdapter.adapt(new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
     }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 4106a77ca..bca1cb9ea 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -32,6 +32,8 @@
 
 /**
  * Retrofit实现的一个请求回调
+ * <p>
+ * request to ok http call
  *
  * @param <T>
  */
@@ -128,11 +130,14 @@ public void enqueue(final Callback<T> callback) {
             call.cancel();
         }
 
+        // in self thread sync request
         call.enqueue(new okhttp3.Callback() {
             @Override
             public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
+                // rawResponse is okhttp response parse to retrofit response
                 Response<T> response;
                 try {
+                    // parse response
                     response = parseResponse(rawResponse);
                 } catch (Throwable e) {
                     throwIfFatal(e);
@@ -206,7 +211,8 @@ public synchronized boolean isExecuted() {
 
     private okhttp3.Call createRawCall() throws IOException {
         // 这里就是使用okhttp3发起请求了
-        okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
+        // the callFactory is OkHttpClient
+        okhttp3.Call call = callFactory.newCall(requestFactory.create(args)/**convert to okhttp3.Request*/);
         if (call == null) {
             throw new NullPointerException("Call.Factory returned null.");
         }
@@ -226,15 +232,21 @@ public synchronized boolean isExecuted() {
 
         // Remove the body's source (the only stateful object) so we can pass the response along.
         // TODO 删除正文的源（唯一的有状态对象），以便我们可以传递响应。
+        // no content response body ?
         rawResponse = rawResponse.newBuilder()
                 .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
                 .build();
 
+        // status code
         int code = rawResponse.code();
+        // less than 200 and more than the 300 is error
         if (code < 200 || code >= 300) {
             try {
                 // Buffer the entire body to avoid future I/O.
+                // convert buffer to ResponseBody
                 ResponseBody bufferedBody = Utils.buffer(rawBody);
+
+                //  throw error
                 return Response.error(bufferedBody, rawResponse);
             } finally {
                 rawBody.close();
@@ -242,13 +254,16 @@ public synchronized boolean isExecuted() {
         }
 
         // 没有body的情况
+        // 204 is no content,205 is reset content
         if (code == 204 || code == 205) {
             rawBody.close();
             return Response.success(null, rawResponse);
         }
-
+        // catch exception response body
+        // convert buffer
         ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
         try {
+            // use our  customer covert
             T body = responseConverter.convert(catchingBody);
             return Response.success(body, rawResponse);
         } catch (RuntimeException e) {
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 79fac3bc1..a8f389d1c 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -29,246 +30,260 @@
 import okio.BufferedSink;
 
 final class RequestBuilder {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
-
-  /**
-   * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also
-   * matches dots in their percent-encoded form, {@code %2E}.
-   *
-   * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code
-   * index.html}) but when alone they have a special meaning. A single dot resolves to no path
-   * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding
-   * directory, so {@code /one/../three/} becomes {@code /three/}.
-   *
-   * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.
-   * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE
-   * /account/}.
-   */
-  private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");
-
-  private final String method;
-
-  private final HttpUrl baseUrl;
-  private @Nullable String relativeUrl;
-  private @Nullable HttpUrl.Builder urlBuilder;
-
-  private final Request.Builder requestBuilder;
-  private @Nullable MediaType contentType;
-
-  private final boolean hasBody;
-  private @Nullable MultipartBody.Builder multipartBuilder;
-  private @Nullable FormBody.Builder formBuilder;
-  private @Nullable RequestBody body;
-
-  RequestBuilder(String method, HttpUrl baseUrl,
-      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
-      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder();
-    this.contentType = contentType;
-    this.hasBody = hasBody;
-
-    if (headers != null) {
-      requestBuilder.headers(headers);
+    private static final char[] HEX_DIGITS =
+            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+    private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+
+    /**
+     * Matches strings that contain {@code .} or {@code ..} as a complete path segment. This also
+     * matches dots in their percent-encoded form, {@code %2E}.
+     *
+     * <p>It is okay to have these strings within a larger path segment (like {@code a..z} or {@code
+     * index.html}) but when alone they have a special meaning. A single dot resolves to no path
+     * segment so {@code /one/./three/} becomes {@code /one/three/}. A double-dot pops the preceding
+     * directory, so {@code /one/../three/} becomes {@code /three/}.
+     *
+     * <p>We forbid these in Retrofit paths because they're likely to have the unintended effect.
+     * For example, passing {@code ..} to {@code DELETE /account/book/{isbn}/} yields {@code DELETE
+     * /account/}.
+     */
+    private static final Pattern PATH_TRAVERSAL = Pattern.compile("(.*/)?(\\.|%2e|%2E){1,2}(/.*)?");
+
+    private final String method;
+
+    private final HttpUrl baseUrl;
+    private @Nullable
+    String relativeUrl;
+    private @Nullable
+    HttpUrl.Builder urlBuilder;
+
+    private final Request.Builder requestBuilder;
+    private @Nullable
+    MediaType contentType;
+
+    private final boolean hasBody;
+    private @Nullable
+    MultipartBody.Builder multipartBuilder;
+    private @Nullable
+    FormBody.Builder formBuilder;
+    private @Nullable
+    RequestBody body;
+
+    RequestBuilder(String method, HttpUrl baseUrl,
+                   @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
+                   boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+        this.method = method;
+        this.baseUrl = baseUrl;
+        this.relativeUrl = relativeUrl;
+        this.requestBuilder = new Request.Builder();
+        this.contentType = contentType;
+        this.hasBody = hasBody;
+
+        if (headers != null) {
+            requestBuilder.headers(headers);
+        }
+
+        if (isFormEncoded) {
+            // Will be set to 'body' in 'build'.
+            formBuilder = new FormBody.Builder();
+        } else if (isMultipart) {
+            // Will be set to 'body' in 'build'.
+            multipartBuilder = new MultipartBody.Builder();
+            multipartBuilder.setType(MultipartBody.FORM);
+        }
     }
 
-    if (isFormEncoded) {
-      // Will be set to 'body' in 'build'.
-      formBuilder = new FormBody.Builder();
-    } else if (isMultipart) {
-      // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBody.Builder();
-      multipartBuilder.setType(MultipartBody.FORM);
+    void setRelativeUrl(Object relativeUrl) {
+        this.relativeUrl = relativeUrl.toString();
     }
-  }
-
-  void setRelativeUrl(Object relativeUrl) {
-    this.relativeUrl = relativeUrl.toString();
-  }
-
-  void addHeader(String name, String value) {
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      try {
-        contentType = MediaType.get(value);
-      } catch (IllegalArgumentException e) {
-        throw new IllegalArgumentException("Malformed content type: " + value, e);
-      }
-    } else {
-      requestBuilder.addHeader(name, value);
+
+    void addHeader(String name, String value) {
+        if ("Content-Type".equalsIgnoreCase(name)) {
+            try {
+                contentType = MediaType.get(value);
+            } catch (IllegalArgumentException e) {
+                throw new IllegalArgumentException("Malformed content type: " + value, e);
+            }
+        } else {
+            requestBuilder.addHeader(name, value);
+        }
     }
-  }
 
-  void addPathParam(String name, String value, boolean encoded) {
-    if (relativeUrl == null) {
-      // The relative URL is cleared when the first query parameter is set.
-      throw new AssertionError();
+    void addPathParam(String name, String value, boolean encoded) {
+        if (relativeUrl == null) {
+            // The relative URL is cleared when the first query parameter is set.
+            throw new AssertionError();
+        }
+        String replacement = canonicalizeForPath(value, encoded);
+        String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);
+        if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
+            throw new IllegalArgumentException(
+                    "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);
+        }
+        relativeUrl = newRelativeUrl;
     }
-    String replacement = canonicalizeForPath(value, encoded);
-    String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacement);
-    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
-      throw new IllegalArgumentException(
-          "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value);
+
+    private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+        // encode every char
+        // TODO unNow
+        int codePoint;
+        for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Slow path: the character at i requires encoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(input, 0, i);
+                canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+                return out.readUtf8();
+            }
+        }
+
+        // Fast path: no characters required encoding.
+        return input;
     }
-    relativeUrl = newRelativeUrl;
-  }
-
-  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
-    int codePoint;
-    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, 0, i);
-        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
-        return out.readUtf8();
-      }
+
+    private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+                                            boolean alreadyEncoded) {
+        Buffer utf8Buffer = null; // Lazily allocated.
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                    && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            } else if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Percent encode this character.
+                if (utf8Buffer == null) {
+                    utf8Buffer = new Buffer();
+                }
+                utf8Buffer.writeUtf8CodePoint(codePoint);
+                while (!utf8Buffer.exhausted()) {
+                    int b = utf8Buffer.readByte() & 0xff;
+                    out.writeByte('%');
+                    out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.writeByte(HEX_DIGITS[b & 0xf]);
+                }
+            } else {
+                // This character doesn't need encoding. Just copy it over.
+                out.writeUtf8CodePoint(codePoint);
+            }
+        }
     }
 
-    // Fast path: no characters required encoding.
-    return input;
-  }
-
-  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
-      boolean alreadyEncoded) {
-    Buffer utf8Buffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
+    void addQueryParam(String name, @Nullable String value, boolean encoded) {
+        if (relativeUrl != null) {
+            // Do a one-time combination of the built relative URL and the base URL.
+            urlBuilder = baseUrl.newBuilder(relativeUrl);
+            if (urlBuilder == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+            relativeUrl = null;
         }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
+
+        if (encoded) {
+            //noinspection ConstantConditions Checked to be non-null by above 'if' block.
+            urlBuilder.addEncodedQueryParameter(name, value);
+        } else {
+            //noinspection ConstantConditions Checked to be non-null by above 'if' block.
+            urlBuilder.addQueryParameter(name, value);
         }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
-    }
-  }
-
-  void addQueryParam(String name, @Nullable String value, boolean encoded) {
-    if (relativeUrl != null) {
-      // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.newBuilder(relativeUrl);
-      if (urlBuilder == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
-      relativeUrl = null;
     }
 
-    if (encoded) {
-      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
-      urlBuilder.addEncodedQueryParameter(name, value);
-    } else {
-      //noinspection ConstantConditions Checked to be non-null by above 'if' block.
-      urlBuilder.addQueryParameter(name, value);
-    }
-  }
-
-  @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
-  void addFormField(String name, String value, boolean encoded) {
-    if (encoded) {
-      formBuilder.addEncoded(name, value);
-    } else {
-      formBuilder.add(name, value);
+    @SuppressWarnings("ConstantConditions")
+        // Only called when isFormEncoded was true.
+    void addFormField(String name, String value, boolean encoded) {
+        if (encoded) {
+            formBuilder.addEncoded(name, value);
+        } else {
+            formBuilder.add(name, value);
+        }
     }
-  }
-
-  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
-  void addPart(Headers headers, RequestBody body) {
-    multipartBuilder.addPart(headers, body);
-  }
-
-  @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
-  void addPart(MultipartBody.Part part) {
-    multipartBuilder.addPart(part);
-  }
-
-  void setBody(RequestBody body) {
-    this.body = body;
-  }
-
-  Request.Builder get() {
-    HttpUrl url;
-    HttpUrl.Builder urlBuilder = this.urlBuilder;
-    if (urlBuilder != null) {
-      url = urlBuilder.build();
-    } else {
-      // No query parameters triggered builder creation, just combine the relative URL and base URL.
-      //noinspection ConstantConditions Non-null if urlBuilder is null.
-      url = baseUrl.resolve(relativeUrl);
-      if (url == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
+
+    @SuppressWarnings("ConstantConditions")
+        // Only called when isMultipart was true.
+    void addPart(Headers headers, RequestBody body) {
+        multipartBuilder.addPart(headers, body);
     }
 
-    RequestBody body = this.body;
-    if (body == null) {
-      // Try to pull from one of the builders.
-      if (formBuilder != null) {
-        body = formBuilder.build();
-      } else if (multipartBuilder != null) {
-        body = multipartBuilder.build();
-      } else if (hasBody) {
-        // Body is absent, make an empty body.
-        body = RequestBody.create(null, new byte[0]);
-      }
+    @SuppressWarnings("ConstantConditions")
+        // Only called when isMultipart was true.
+    void addPart(MultipartBody.Part part) {
+        multipartBuilder.addPart(part);
     }
 
-    MediaType contentType = this.contentType;
-    if (contentType != null) {
-      if (body != null) {
-        body = new ContentTypeOverridingRequestBody(body, contentType);
-      } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
-      }
+    void setBody(RequestBody body) {
+        this.body = body;
     }
 
-    return requestBuilder
-        .url(url)
-        .method(method, body);
-  }
+    Request.Builder get() {
+        HttpUrl url;
+        HttpUrl.Builder urlBuilder = this.urlBuilder;
+        if (urlBuilder != null) {
+            url = urlBuilder.build();
+        } else {
+            // No query parameters triggered builder creation, just combine the relative URL and base URL.
+            //noinspection ConstantConditions Non-null if urlBuilder is null.
+            url = baseUrl.resolve(relativeUrl);
+            if (url == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+        }
 
-  private static class ContentTypeOverridingRequestBody extends RequestBody {
-    private final RequestBody delegate;
-    private final MediaType contentType;
+        RequestBody body = this.body;
+        if (body == null) {
+            // Try to pull from one of the builders.
+            if (formBuilder != null) {
+                body = formBuilder.build();
+            } else if (multipartBuilder != null) {
+                body = multipartBuilder.build();
+            } else if (hasBody) {
+                // Body is absent, make an empty body.
+                body = RequestBody.create(null, new byte[0]);
+            }
+        }
 
-    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
-      this.delegate = delegate;
-      this.contentType = contentType;
-    }
+        MediaType contentType = this.contentType;
+        if (contentType != null) {
+            if (body != null) {
+                body = new ContentTypeOverridingRequestBody(body, contentType);
+            } else {
+                requestBuilder.addHeader("Content-Type", contentType.toString());
+            }
+        }
 
-    @Override public MediaType contentType() {
-      return contentType;
+        return requestBuilder
+                .url(url)
+                .method(method, body);
     }
 
-    @Override public long contentLength() throws IOException {
-      return delegate.contentLength();
-    }
+    private static class ContentTypeOverridingRequestBody extends RequestBody {
+        private final RequestBody delegate;
+        private final MediaType contentType;
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      delegate.writeTo(sink);
+        ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
+            this.delegate = delegate;
+            this.contentType = contentType;
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
+
+        @Override
+        public long contentLength() throws IOException {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            delegate.writeTo(sink);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index d10e58c28..557e33052 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -123,6 +123,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
         parameterHandlers = builder.parameterHandlers;
     }
 
+    // convert paramter
     okhttp3.Request create(Object[] args) throws IOException {
         @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
                 ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
@@ -629,9 +630,10 @@ private Headers parseHeaders(String[] headers) {
                 boolean encoded = field.encoded();
 
                 gotField = true;
-
                 Class<?> rawParameterType = Utils.getRawType(type);
                 if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    // the param is list
+
                     if (!(type instanceof ParameterizedType)) {
                         throw parameterError(method, position, rawParameterType.getSimpleName()
                                 + " must include generic type (e.g., "
@@ -639,11 +641,21 @@ private Headers parseHeaders(String[] headers) {
                                 + "<String>)");
                     }
                     ParameterizedType parameterizedType = (ParameterizedType) type;
+
+
                     Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-                    Converter<?, String> converter =
-                            retrofit.stringConverter(iterableType, annotations);
+
+                    // 这里对集合进行转换
+                    // if than null,return default  BuiltInConverters
+                    Converter<?, String> converter = retrofit.stringConverter(iterableType, annotations);
+
+
                     return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+
+
+
                 } else if (rawParameterType.isArray()) {
+                    // is array
                     Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
                     Converter<?, String> converter =
                             retrofit.stringConverter(arrayComponentType, annotations);
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index d31adafe2..5ca68c253 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -409,8 +409,7 @@ public HttpUrl baseUrl() {
         checkNotNull(annotations, "annotations == null");
 
         for (int i = 0, count = converterFactories.size(); i < count; i++) {
-            Converter<?, String> converter =
-                    converterFactories.get(i).stringConverter(type, annotations, this);
+            Converter<?, String> converter = converterFactories.get(i).stringConverter(type, annotations, this);
             if (converter != null) {
                 //noinspection unchecked
                 return (Converter<T, String>) converter;
