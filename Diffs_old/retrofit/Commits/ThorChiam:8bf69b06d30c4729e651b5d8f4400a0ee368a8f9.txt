diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 439cb6527..90f420afa 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -25,257 +26,271 @@
 import okio.Okio;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T, ?> serviceMethod;
-  private final Object[] args;
-
-  private volatile boolean canceled;
-
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
-  private boolean executed;
-
-  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
-    this.serviceMethod = serviceMethod;
-    this.args = args;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(serviceMethod, args);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else {
-        throw (RuntimeException) creationFailure;
-      }
-    }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException e) {
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
+    private final ServiceMethod<T, ?> serviceMethod;
+    private final Object[] args;
 
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    private volatile boolean canceled;
 
-    okhttp3.Call call;
-    Throwable failure;
+    // All guarded by this.
+    private okhttp3.Call rawCall;
+    private Throwable creationFailure; // Either a RuntimeException or IOException.
+    private boolean executed;
 
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
+    OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
+        this.serviceMethod = serviceMethod;
+        this.args = args;
+    }
 
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(serviceMethod, args);
+    }
+
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            return call.request();
+        }
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            } else {
+                throw (RuntimeException) creationFailure;
+            }
+        }
         try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          failure = creationFailure = t;
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException e) {
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
     }
 
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    failure = creationFailure = t;
+                }
+            }
+        }
+
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
+        }
+
+        if (canceled) {
+            call.cancel();
+        }
+
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
+                    throws IOException {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    callFailure(e);
+                    return;
+                }
+                callSuccess(response);
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callSuccess(Response<T> response) {
+                try {
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
-          throws IOException {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                } else {
+                    throw (RuntimeException) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException e) {
+                    creationFailure = e;
+                    throw e;
+                }
+            }
         }
-        callSuccess(response);
-      }
 
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (canceled) {
+            call.cancel();
         }
-      }
 
-      private void callFailure(Throwable e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        return parseResponse(call.execute());
+    }
+
+    private okhttp3.Call createRawCall() throws IOException {
+        Request request = serviceMethod.toRequest(args);
+        okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
         }
-      }
+        return call;
+    }
 
-      private void callSuccess(Response<T> response) {
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          t.printStackTrace();
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else {
-          throw (RuntimeException) creationFailure;
+
+        if (code == 204 || code == 205) {
+            rawBody.close();
+            return Response.success(null, rawResponse);
         }
-      }
 
-      call = rawCall;
-      if (call == null) {
+        ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
         try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException e) {
-          creationFailure = e;
-          throw e;
+            T body = serviceMethod.toResponse(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
         }
-      }
-    }
-
-    if (canceled) {
-      call.cancel();
     }
 
-    return parseResponse(call.execute());
-  }
+    public void cancel() {
+        canceled = true;
 
-  private okhttp3.Call createRawCall() throws IOException {
-    Request request = serviceMethod.toRequest(args);
-    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    if (code == 204 || code == 205) {
-      rawBody.close();
-      return Response.success(null, rawResponse);
+    @Override
+    public boolean isCanceled() {
+        if (canceled) {
+            return true;
+        }
+        synchronized (this) {
+            return rawCall != null && rawCall.isCanceled();
+        }
     }
 
-//    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
-    try {
-      T body = serviceMethod.toResponse(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-//      catchingBody.throwIfCaught();
-      throw e;
-    }
-  }
+    static final class ExceptionCatchingRequestBody extends ResponseBody {
+        private final ResponseBody delegate;
+        IOException thrownException;
 
-  public void cancel() {
-    canceled = true;
+        ExceptionCatchingRequestBody(ResponseBody delegate) {
+            this.delegate = delegate;
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-  @Override public boolean isCanceled() {
-    if (canceled) {
-      return true;
-    }
-    synchronized (this) {
-      return rawCall != null && rawCall.isCanceled();
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
-
-//  static final class ExceptionCatchingRequestBody extends ResponseBody {
-//    private final ResponseBody delegate;
-//    IOException thrownException;
-//
-//    ExceptionCatchingRequestBody(ResponseBody delegate) {
-//      this.delegate = delegate;
-//    }
-//
-//    @Override public MediaType contentType() {
-//      return null;
-//    }
-//
-//    @Override public long contentLength() {
-//      return null;
-//    }
-//
-//    @Override public BufferedSource source() {
-//      return Okio.buffer(new ForwardingSource(delegate.source()) {
-//        @Override public long read(Buffer sink, long byteCount) throws IOException {
-//          try {
-//            return super.read(sink, byteCount);
-//          } catch (IOException e) {
-//            thrownException = e;
-//            throw e;
-//          }
-//        }
-//      });
-//    }
-//
-//    @Override public void close() {
-//      delegate.close();
-//    }
-//
-//    void throwIfCaught() throws IOException {
-//      if (thrownException != null) {
-//        throw thrownException;
-//      }
-//    }
-//  }
 }
