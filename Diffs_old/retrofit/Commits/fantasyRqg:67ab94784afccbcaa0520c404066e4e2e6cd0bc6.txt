diff --git a/pom.xml b/pom.xml
index b99efb76b..a891f26ba 100644
--- a/pom.xml
+++ b/pom.xml
@@ -14,256 +14,257 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
+    <parent>
+        <groupId>org.sonatype.oss</groupId>
+        <artifactId>oss-parent</artifactId>
+        <version>7</version>
+    </parent>
 
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>parent</artifactId>
-  <version>2.0.3-SNAPSHOT</version>
-  <packaging>pom</packaging>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.3-SNAPSHOT</version>
+    <packaging>pom</packaging>
 
-  <name>Retrofit (Parent)</name>
-  <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
-  <url>http://github.com/square/retrofit/</url>
+    <name>Retrofit (Parent)</name>
+    <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
+    <url>http://github.com/square/retrofit/</url>
 
-  <modules>
-    <module>retrofit</module>
-    <module>retrofit-adapters</module>
-    <module>retrofit-converters</module>
-    <module>retrofit-mock</module>
-    <module>samples</module>
-  </modules>
+    <modules>
+        <module>retrofit</module>
+        <module>retrofit-adapters</module>
+        <module>retrofit-converters</module>
+        <module>retrofit-mock</module>
+        <module>samples</module>
+    </modules>
 
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
-    <!-- Compilation -->
-    <java.version>1.7</java.version>
+        <!-- Compilation -->
+        <java.version>1.7</java.version>
 
-    <!-- Dependencies -->
-    <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.2.0</okhttp.version>
-    <animal.sniffer.version>1.14</animal.sniffer.version>
+        <!-- Dependencies -->
+        <android.version>4.1.1.4</android.version>
+        <okhttp.version>3.2.0</okhttp.version>
+        <animal.sniffer.version>1.14</animal.sniffer.version>
 
-    <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.1</rxjava.version>
+        <!-- Adapter Dependencies -->
+        <rxjava.version>1.1.1</rxjava.version>
 
-    <!-- Converter Dependencies -->
-    <gson.version>2.6.1</gson.version>
-    <protobuf.version>2.6.1</protobuf.version>
-    <jackson.version>2.7.2</jackson.version>
-    <wire.version>2.1.1</wire.version>
-    <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.1.0</moshi.version>
+        <!-- Converter Dependencies -->
+        <gson.version>2.6.1</gson.version>
+        <protobuf.version>2.6.1</protobuf.version>
+        <jackson.version>2.7.2</jackson.version>
+        <wire.version>2.1.1</wire.version>
+        <simplexml.version>2.7.1</simplexml.version>
+        <moshi.version>1.1.0</moshi.version>
 
-    <!-- Sample Dependencies -->
-    <jsoup.version>1.7.3</jsoup.version>
+        <!-- Sample Dependencies -->
+        <jsoup.version>1.7.3</jsoup.version>
 
-    <!-- Test Dependencies -->
-    <junit.version>4.12</junit.version>
-    <assertj.version>1.7.0</assertj.version>
-    <mockito.version>1.9.5</mockito.version>
-    <guava.version>19.0</guava.version>
-    <robolectric.version>3.0</robolectric.version>
-  </properties>
+        <!-- Test Dependencies -->
+        <junit.version>4.12</junit.version>
+        <assertj.version>1.7.0</assertj.version>
+        <mockito.version>1.9.5</mockito.version>
+        <guava.version>19.0</guava.version>
+        <robolectric.version>3.0</robolectric.version>
+    </properties>
 
-  <scm>
-    <url>http://github.com/square/retrofit</url>
-    <connection>scm:git:git://github.com/square/retrofit.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
+    <scm>
+        <url>http://github.com/square/retrofit</url>
+        <connection>scm:git:git://github.com/square/retrofit.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
+        <tag>HEAD</tag>
+    </scm>
 
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>http://github.com/square/retrofit/issues</url>
-  </issueManagement>
+    <issueManagement>
+        <system>GitHub Issues</system>
+        <url>http://github.com/square/retrofit/issues</url>
+    </issueManagement>
 
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
+    <licenses>
+        <license>
+            <name>Apache 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+        </license>
+    </licenses>
 
-  <organization>
-    <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
-  </organization>
+    <organization>
+        <name>Square, Inc.</name>
+        <url>http://squareup.com</url>
+    </organization>
 
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-annotations</artifactId>
-        <version>${animal.sniffer.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp3</groupId>
-        <artifactId>okhttp</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.reactivex</groupId>
-        <artifactId>rxjava</artifactId>
-        <version>${rxjava.version}</version>
-      </dependency>
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>com.google.android</groupId>
+                <artifactId>android</artifactId>
+                <version>${android.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-annotations</artifactId>
+                <version>${animal.sniffer.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.okhttp3</groupId>
+                <artifactId>okhttp</artifactId>
+                <version>${okhttp.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.code.gson</groupId>
+                <artifactId>gson</artifactId>
+                <version>${gson.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>io.reactivex</groupId>
+                <artifactId>rxjava</artifactId>
+                <version>${rxjava.version}</version>
+            </dependency>
 
-      <dependency>
-        <groupId>com.google.protobuf</groupId>
-        <artifactId>protobuf-java</artifactId>
-        <version>${protobuf.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.fasterxml.jackson.core</groupId>
-        <artifactId>jackson-databind</artifactId>
-        <version>${jackson.version}</version>
-     </dependency>
-      <dependency>
-        <groupId>com.squareup.wire</groupId>
-        <artifactId>wire-runtime</artifactId>
-        <version>${wire.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.simpleframework</groupId>
-        <artifactId>simple-xml</artifactId>
-        <version>${simplexml.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.moshi</groupId>
-        <artifactId>moshi</artifactId>
-        <version>${moshi.version}</version>
-      </dependency>
+            <dependency>
+                <groupId>com.google.protobuf</groupId>
+                <artifactId>protobuf-java</artifactId>
+                <version>${protobuf.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.fasterxml.jackson.core</groupId>
+                <artifactId>jackson-databind</artifactId>
+                <version>${jackson.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.wire</groupId>
+                <artifactId>wire-runtime</artifactId>
+                <version>${wire.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.simpleframework</groupId>
+                <artifactId>simple-xml</artifactId>
+                <version>${simplexml.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.moshi</groupId>
+                <artifactId>moshi</artifactId>
+                <version>${moshi.version}</version>
+            </dependency>
 
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.assertj</groupId>
-        <artifactId>assertj-core</artifactId>
-        <version>${assertj.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.mockito</groupId>
-        <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp3</groupId>
-        <artifactId>mockwebserver</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.robolectric</groupId>
-        <artifactId>robolectric</artifactId>
-        <version>${robolectric.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
+            <dependency>
+                <groupId>junit</groupId>
+                <artifactId>junit</artifactId>
+                <version>${junit.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.assertj</groupId>
+                <artifactId>assertj-core</artifactId>
+                <version>${assertj.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.mockito</groupId>
+                <artifactId>mockito-core</artifactId>
+                <version>${mockito.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+                <version>${guava.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.okhttp3</groupId>
+                <artifactId>mockwebserver</artifactId>
+                <version>${okhttp.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.robolectric</groupId>
+                <artifactId>robolectric</artifactId>
+                <version>${robolectric.version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
 
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
-          <configuration>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
+    <build>
+        <pluginManagement>
+            <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-compiler-plugin</artifactId>
+                    <version>3.0</version>
+                    <configuration>
+                        <source>${java.version}</source>
+                        <target>${java.version}</target>
+                    </configuration>
+                </plugin>
+            </plugins>
+        </pluginManagement>
 
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5</version>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-release-plugin</artifactId>
+                <version>2.5</version>
+                <configuration>
+                    <autoVersionSubmodules>true</autoVersionSubmodules>
+                </configuration>
+            </plugin>
 
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.15</version>
-        <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>verify</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-checkstyle-plugin</artifactId>
+                <version>2.15</version>
+                <configuration>
+                    <failsOnError>true</failsOnError>
+                    <configLocation>checkstyle.xml</configLocation>
+                    <consoleOutput>true</consoleOutput>
+                </configuration>
+                <executions>
+                    <execution>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>checkstyle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
 
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.3</version>
-        <executions>
-          <execution>
-            <id>attach-javadocs</id>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <version>2.10.3</version>
+                <executions>
+                    <execution>
+                        <id>attach-javadocs</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
 
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <executions>
-          <execution>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.1</version>
-          </signature>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-maven-plugin</artifactId>
+                <version>${animal.sniffer.version}</version>
+                <executions>
+                    <execution>
+                        <phase>test</phase>
+                        <goals>
+                            <goal>check</goal>
+                        </goals>
+                    </execution>
+                </executions>
+                <configuration>
+                    <signature>
+                        <groupId>org.codehaus.mojo.signature</groupId>
+                        <artifactId>java16</artifactId>
+                        <version>1.1</version>
+                    </signature>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index a80f03897..071bf4a1d 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -1,65 +1,66 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit</artifactId>
-  <name>Retrofit</name>
+    <artifactId>retrofit</artifactId>
+    <name>Retrofit</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <optional>true</optional>
+        </dependency>
 
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <optional>true</optional>
-    </dependency>
+        <dependency>
+            <groupId>org.codehaus.mojo</groupId>
+            <artifactId>animal-sniffer-annotations</artifactId>
+            <optional>true</optional>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.robolectric</groupId>
-      <artifactId>robolectric</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.robolectric</groupId>
+            <artifactId>robolectric</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index d580c00fb..5e4344c8f 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,96 +18,104 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == ResponseBody.class) {
-      if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
-        return StreamingResponseBodyConverter.INSTANCE;
-      }
-      return BufferingResponseBodyConverter.INSTANCE;
-    }
-    if (type == Void.class) {
-      return VoidResponseBodyConverter.INSTANCE;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (type == ResponseBody.class) {
+            if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
+                return StreamingResponseBodyConverter.INSTANCE;
+            }
+            return BufferingResponseBodyConverter.INSTANCE;
+        }
+        if (type == Void.class) {
+            return VoidResponseBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
-      return RequestBodyConverter.INSTANCE;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+            return RequestBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class) {
-      return StringConverter.INSTANCE;
+    @Override
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                Retrofit retrofit) {
+        if (type == String.class) {
+            return StringConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  static final class StringConverter implements Converter<String, String> {
-    static final StringConverter INSTANCE = new StringConverter();
+    static final class StringConverter implements Converter<String, String> {
+        static final StringConverter INSTANCE = new StringConverter();
 
-    @Override public String convert(String value) throws IOException {
-      return value;
+        @Override
+        public String convert(String value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
-    static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
+    static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
+        static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
-    @Override public Void convert(ResponseBody value) throws IOException {
-      value.close();
-      return null;
+        @Override
+        public Void convert(ResponseBody value) throws IOException {
+            value.close();
+            return null;
+        }
     }
-  }
 
-  static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
-    static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
+    static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
+        static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
-    @Override public RequestBody convert(RequestBody value) throws IOException {
-      return value;
+        @Override
+        public RequestBody convert(RequestBody value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class StreamingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
+    static final class StreamingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      return value;
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            return value;
+        }
     }
-  }
-
-  static final class BufferingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
-
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        return Utils.buffer(value);
-      } finally {
-        value.close();
-      }
+
+    static final class BufferingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
+
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                return Utils.buffer(value);
+            } finally {
+                value.close();
+            }
+        }
     }
-  }
 
-  static final class ToStringConverter implements Converter<Object, String> {
-    static final ToStringConverter INSTANCE = new ToStringConverter();
+    static final class ToStringConverter implements Converter<Object, String> {
+        static final ToStringConverter INSTANCE = new ToStringConverter();
 
-    @Override public String convert(Object value) {
-      return value.toString();
+        @Override
+        public String convert(Object value) {
+            return value.toString();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..7f3630895 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 
 /**
@@ -23,7 +24,7 @@
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
  * to retry a failed call.
- *
+ * <p>
  * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
@@ -32,42 +33,46 @@
  * @param <T> Successful response body type.
  */
 public interface Call<T> extends Cloneable {
-  /**
-   * Synchronously send the request and return its response.
-   *
-   * @throws IOException if a problem occurred talking to the server.
-   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
-   * or decoding the response.
-   */
-  Response<T> execute() throws IOException;
+    /**
+     * Synchronously send the request and return its response.
+     *
+     * @throws IOException      if a problem occurred talking to the server.
+     * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+     *                          or decoding the response.
+     */
+    Response<T> execute() throws IOException;
 
-  /**
-   * Asynchronously send the request and notify {@code callback} of its response or if an error
-   * occurred talking to the server, creating the request, or processing the response.
-   */
-  void enqueue(Callback<T> callback);
+    /**
+     * Asynchronously send the request and notify {@code callback} of its response or if an error
+     * occurred talking to the server, creating the request, or processing the response.
+     */
+    void enqueue(Callback<T> callback);
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+     */
+    boolean isExecuted();
 
-  /**
-   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
-   * yet been executed it never will be.
-   */
-  void cancel();
+    /**
+     * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+     * yet been executed it never will be.
+     */
+    void cancel();
 
-  /** True if {@link #cancel()} was called. */
-  boolean isCanceled();
+    /**
+     * True if {@link #cancel()} was called.
+     */
+    boolean isCanceled();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call<T> clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     */
+    Call<T> clone();
 
-  /** The original HTTP request. */
-  Request request();
+    /**
+     * The original HTTP request.
+     */
+    Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 2f56683b8..8da4c5849 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -25,61 +25,61 @@
  * the {@link Retrofit} instance.
  */
 public interface CallAdapter<T> {
-  /**
-   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
-   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
-   * is used to prepare the {@code call} passed to {@code #adapt}.
-   * <p>
-   * Note: This is typically not the same type as the {@code returnType} provided to this call
-   * adapter's factory.
-   */
-  Type responseType();
-
-  /**
-   * Returns an instance of {@code T} which delegates to {@code call}.
-   * <p>
-   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
-   * return a new {@code Async<R>} which invoked {@code call} when run.
-   * <pre><code>
-   * &#64;Override
-   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
-   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
-   *     &#64;Override
-   *     public Response&lt;R&gt; call() throws Exception {
-   *       return call.execute();
-   *     }
-   *   });
-   * }
-   * </code></pre>
-   */
-  <R> T adapt(Call<R> call);
-
-  /**
-   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
-   * Retrofit#create(Class) the service interface} methods.
-   */
-  abstract class Factory {
     /**
-     * Returns a call adapter for interface methods that return {@code returnType}, or null if it
-     * cannot be handled by this factory.
+     * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+     * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+     * is used to prepare the {@code call} passed to {@code #adapt}.
+     * <p>
+     * Note: This is typically not the same type as the {@code returnType} provided to this call
+     * adapter's factory.
      */
-    public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit);
+    Type responseType();
 
     /**
-     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
-     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     * Returns an instance of {@code T} which delegates to {@code call}.
+     * <p>
+     * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+     * return a new {@code Async<R>} which invoked {@code call} when run.
+     * <pre><code>
+     * &#64;Override
+     * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+     *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
+     *     &#64;Override
+     *     public Response&lt;R&gt; call() throws Exception {
+     *       return call.execute();
+     *     }
+     *   });
+     * }
+     * </code></pre>
      */
-    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
-      return Utils.getParameterUpperBound(index, type);
-    }
+    <R> T adapt(Call<R> call);
 
     /**
-     * Extract the raw class type from {@code type}. For example, the type representing
-     * {@code List<? extends Runnable>} returns {@code List.class}.
+     * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+     * Retrofit#create(Class) the service interface} methods.
      */
-    protected static Class<?> getRawType(Type type) {
-      return Utils.getRawType(type);
+    abstract class Factory {
+        /**
+         * Returns a call adapter for interface methods that return {@code returnType}, or null if it
+         * cannot be handled by this factory.
+         */
+        public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
+                                           Retrofit retrofit);
+
+        /**
+         * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+         * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+         */
+        protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+            return Utils.getParameterUpperBound(index, type);
+        }
+
+        /**
+         * Extract the raw class type from {@code type}. For example, the type representing
+         * {@code List<? extends Runnable>} returns {@code List.class}.
+         */
+        protected static Class<?> getRawType(Type type) {
+            return Utils.getRawType(type);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 62c93a621..8e75d0441 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -29,17 +29,17 @@
  * @param <T> Successful response body type.
  */
 public interface Callback<T> {
-  /**
-   * Invoked for a received HTTP response.
-   * <p>
-   * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
-   * Call {@link Response#isSuccessful()} to determine if the response indicates success.
-   */
-  void onResponse(Call<T> call, Response<T> response);
+    /**
+     * Invoked for a received HTTP response.
+     * <p>
+     * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
+     * Call {@link Response#isSuccessful()} to determine if the response indicates success.
+     */
+    void onResponse(Call<T> call, Response<T> response);
 
-  /**
-   * Invoked when a network exception occurred talking to the server or when an unexpected
-   * exception occurred creating the request or processing the response.
-   */
-  void onFailure(Call<T> call, Throwable t);
+    /**
+     * Invoked when a network exception occurred talking to the server or when an unexpected
+     * exception occurred creating the request or processing the response.
+     */
+    void onFailure(Call<T> call, Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 604bcf086..73581b394 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
@@ -36,42 +37,44 @@
  * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
-  T convert(F value) throws IOException;
+    T convert(F value) throws IOException;
 
-  /** Creates {@link Converter} instances based on a type and target usage. */
-  abstract class Factory {
     /**
-     * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for
-     * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
-     * declaration.
+     * Creates {@link Converter} instances based on a type and target usage.
      */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return null;
-    }
+    abstract class Factory {
+        /**
+         * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for
+         * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
+         * declaration.
+         */
+        public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                                Retrofit retrofit) {
+            return null;
+        }
 
-    /**
-     * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for types
-     * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
-     * values.
-     */
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      return null;
-    }
+        /**
+         * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for types
+         * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
+         * values.
+         */
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            return null;
+        }
 
-    /**
-     * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for types
-     * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
-     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
-     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
-     */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return null;
+        /**
+         * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for types
+         * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
+         * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+         * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
+         */
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                    Retrofit retrofit) {
+            return null;
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index dd6e79244..90167e909 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -24,23 +24,25 @@
  * asynchronous calls this is a thread provided by OkHttp's dispatcher.
  */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
-  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+    static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
+        }
 
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
-        return call;
-      }
-    };
-  }
+            @Override
+            public <R> Call<R> adapt(Call<R> call) {
+                return call;
+            }
+        };
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 0c44243c6..cb678a4fd 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,91 +19,105 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public <R> Call<R> adapt(Call<R> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
     final Executor callbackExecutor;
-    final Call<T> delegate;
 
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
+    ExecutorCallAdapterFactory(Executor callbackExecutor) {
+        this.callbackExecutor = callbackExecutor;
     }
 
-    @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
+    @Override
+    public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
         }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
+            @Override
+            public <R> Call<R> adapt(Call<R> call) {
+                return new ExecutorCallbackCall<>(callbackExecutor, call);
             }
-          });
-        }
-      });
+        };
     }
 
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
+    static final class ExecutorCallbackCall<T> implements Call<T> {
+        final Executor callbackExecutor;
+        final Call<T> delegate;
 
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
+        ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+            this.callbackExecutor = callbackExecutor;
+            this.delegate = delegate;
+        }
 
-    @Override public void cancel() {
-      delegate.cancel();
-    }
+        @Override
+        public void enqueue(final Callback<T> callback) {
+            if (callback == null) throw new NullPointerException("callback == null");
+
+            delegate.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, final Response<T> response) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (delegate.isCanceled()) {
+                                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+                            } else {
+                                callback.onResponse(ExecutorCallbackCall.this, response);
+                            }
+                        }
+                    });
+                }
+
+                @Override
+                public void onFailure(Call<T> call, final Throwable t) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onFailure(ExecutorCallbackCall.this, t);
+                        }
+                    });
+                }
+            });
+        }
 
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
+        @Override
+        public boolean isExecuted() {
+            return delegate.isExecuted();
+        }
 
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
+        @Override
+        public Response<T> execute() throws IOException {
+            return delegate.execute();
+        }
+
+        @Override
+        public void cancel() {
+            delegate.cancel();
+        }
 
-    @Override public Request request() {
-      return delegate.request();
+        @Override
+        public boolean isCanceled() {
+            return delegate.isCanceled();
+        }
+
+        @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+        @Override
+        public Call<T> clone() {
+            return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+        }
+
+        @Override
+        public Request request() {
+            return delegate.request();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5aa102db2..fd25374b8 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -25,274 +26,290 @@
 import okio.Okio;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T> serviceMethod;
-  private final Object[] args;
-
-  private volatile boolean canceled;
-
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
-  private boolean executed;
-
-  OkHttpCall(ServiceMethod<T> serviceMethod, Object[] args) {
-    this.serviceMethod = serviceMethod;
-    this.args = args;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(serviceMethod, args);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else {
-        throw (RuntimeException) creationFailure;
-      }
-    }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException e) {
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
+    private final ServiceMethod<T> serviceMethod;
+    private final Object[] args;
 
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    private volatile boolean canceled;
 
-    okhttp3.Call call;
-    Throwable failure;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          failure = creationFailure = t;
-        }
-      }
-    }
+    // All guarded by this.
+    private okhttp3.Call rawCall;
+    private Throwable creationFailure; // Either a RuntimeException or IOException.
+    private boolean executed;
 
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
+    OkHttpCall(ServiceMethod<T> serviceMethod, Object[] args) {
+        this.serviceMethod = serviceMethod;
+        this.args = args;
     }
 
-    if (canceled) {
-      call.cancel();
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(serviceMethod, args);
     }
 
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
-          throws IOException {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            return call.request();
         }
-        callSuccess(response);
-      }
-
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            } else {
+                throw (RuntimeException) creationFailure;
+            }
         }
-      }
-
-      private void callFailure(Throwable e) {
         try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException e) {
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
+    }
 
-      private void callSuccess(Response<T> response) {
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          t.printStackTrace();
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    failure = creationFailure = t;
+                }
+            }
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else {
-          throw (RuntimeException) creationFailure;
+
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
         }
-      }
 
-      call = rawCall;
-      if (call == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException e) {
-          creationFailure = e;
-          throw e;
+        if (canceled) {
+            call.cancel();
         }
-      }
+
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
+                    throws IOException {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    callFailure(e);
+                    return;
+                }
+                callSuccess(response);
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callSuccess(Response<T> response) {
+                try {
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    return parseResponse(call.execute());
-  }
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                } else {
+                    throw (RuntimeException) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException e) {
+                    creationFailure = e;
+                    throw e;
+                }
+            }
+        }
 
-  private okhttp3.Call createRawCall() throws IOException {
-    Request request = serviceMethod.toRequest(args);
-    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
-    }
+        if (canceled) {
+            call.cancel();
+        }
 
-    if (code == 204 || code == 205) {
-      return Response.success(null, rawResponse);
+        return parseResponse(call.execute());
     }
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
-    try {
-      T body = serviceMethod.toResponse(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+    private okhttp3.Call createRawCall() throws IOException {
+        Request request = serviceMethod.toRequest(args);
+        okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
+        }
+        return call;
     }
-  }
 
-  public void cancel() {
-    canceled = true;
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        if (code == 204 || code == 205) {
+            return Response.success(null, rawResponse);
+        }
 
-  @Override public boolean isCanceled() {
-    return canceled;
-  }
+        ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+        try {
+            T body = serviceMethod.toResponse(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
+    }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
-    private final long contentLength;
+    public void cancel() {
+        canceled = true;
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    @Override
+    public boolean isCanceled() {
+        return canceled;
     }
 
-    @Override public long contentLength() {
-      return contentLength;
-    }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final MediaType contentType;
+        private final long contentLength;
 
-    @Override public BufferedSource source() {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+        NoContentResponseBody(MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
-    private final ResponseBody delegate;
-    IOException thrownException;
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public long contentLength() {
+            return contentLength;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
+        @Override
+        public BufferedSource source() {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public long contentLength() {
-      return delegate.contentLength();
-    }
+    static final class ExceptionCatchingRequestBody extends ResponseBody {
+        private final ResponseBody delegate;
+        IOException thrownException;
 
-    @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+        ExceptionCatchingRequestBody(ResponseBody delegate) {
+            this.delegate = delegate;
         }
-      });
-    }
 
-    @Override public void close() {
-      delegate.close();
-    }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..7044a7d9b 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
@@ -25,280 +26,294 @@
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, T value) throws IOException;
-
-  final ParameterHandler<Iterable<T>> iterable() {
-    return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (T value : values) {
-          ParameterHandler.this.apply(builder, value);
-        }
-      }
-    };
-  }
-
-  final ParameterHandler<Object> array() {
-    return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, Object values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (int i = 0, size = Array.getLength(values); i < size; i++) {
-          //noinspection unchecked
-          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
-        }
-      }
-    };
-  }
-
-  static final class RelativeUrl extends ParameterHandler<Object> {
-    @Override void apply(RequestBuilder builder, Object value) {
-      builder.setRelativeUrl(value);
+    abstract void apply(RequestBuilder builder, T value) throws IOException;
+
+    final ParameterHandler<Iterable<T>> iterable() {
+        return new ParameterHandler<Iterable<T>>() {
+            @Override
+            void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (T value : values) {
+                    ParameterHandler.this.apply(builder, value);
+                }
+            }
+        };
     }
-  }
 
-  static final class Header<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-
-    Header(String name, Converter<T, String> valueConverter) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
+    final ParameterHandler<Object> array() {
+        return new ParameterHandler<Object>() {
+            @Override
+            void apply(RequestBuilder builder, Object values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (int i = 0, size = Array.getLength(values); i < size; i++) {
+                    //noinspection unchecked
+                    ParameterHandler.this.apply(builder, (T) Array.get(values, i));
+                }
+            }
+        };
     }
-  }
 
-  static final class Path<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+    static final class RelativeUrl extends ParameterHandler<Object> {
+        @Override
+        void apply(RequestBuilder builder, Object value) {
+            builder.setRelativeUrl(value);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Header<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
 
-  static final class Query<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        Header(String name, Converter<T, String> valueConverter) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+        }
 
-    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addHeader(name, valueConverter.convert(value));
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Path<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException(
+                        "Path parameter \"" + name + "\" value must not be null.");
+            }
+            builder.addPathParam(name, valueConverter.convert(value), encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Query map was null.");
-      }
+    static final class Query<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Query map contained null value for key '" + entryKey + "'.");
+        Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
-      }
-    }
-  }
-
-  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
 
-    HeaderMap(Converter<T, String> valueConverter) {
-      this.valueConverter = valueConverter;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addQueryParam(name, valueConverter.convert(value), encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Header map was null.");
-      }
+    static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String headerName = entry.getKey();
-        if (headerName == null) {
-          throw new IllegalArgumentException("Header map contained null key.");
+        QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        T headerValue = entry.getValue();
-        if (headerValue == null) {
-          throw new IllegalArgumentException(
-              "Header map contained null value for key '" + headerName + "'.");
-        }
-        builder.addHeader(headerName, valueConverter.convert(headerValue));
-      }
-    }
-  }
 
-  static final class Field<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Query map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Query map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Query map contained null value for key '" + entryKey + "'.");
+                }
+                builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
 
-  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        HeaderMap(Converter<T, String> valueConverter) {
+            this.valueConverter = valueConverter;
+        }
 
-    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Header map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String headerName = entry.getKey();
+                if (headerName == null) {
+                    throw new IllegalArgumentException("Header map contained null key.");
+                }
+                T headerValue = entry.getValue();
+                if (headerValue == null) {
+                    throw new IllegalArgumentException(
+                            "Header map contained null value for key '" + headerName + "'.");
+                }
+                builder.addHeader(headerName, valueConverter.convert(headerValue));
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Field map was null.");
-      }
+    static final class Field<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
+        Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Field map contained null value for key '" + entryKey + "'.");
+
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addFormField(name, valueConverter.convert(value), encoded);
         }
-        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
-      }
     }
-  }
 
-  static final class Part<T> extends ParameterHandler<T> {
-    private final Headers headers;
-    private final Converter<T, RequestBody> converter;
+    static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-    Part(Headers headers, Converter<T, RequestBody> converter) {
-      this.headers = headers;
-      this.converter = converter;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) {
-      if (value == null) return; // Skip null values.
+        FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.addPart(headers, body);
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Field map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Field map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Field map contained null value for key '" + entryKey + "'.");
+                }
+                builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+            }
+        }
     }
-  }
 
-  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
-    static final RawPart INSTANCE = new RawPart();
+    static final class Part<T> extends ParameterHandler<T> {
+        private final Headers headers;
+        private final Converter<T, RequestBody> converter;
 
-    private RawPart() {
-    }
+        Part(Headers headers, Converter<T, RequestBody> converter) {
+            this.headers = headers;
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
-      if (value != null) { // Skip null values.
-        builder.addPart(value);
-      }
+        @Override
+        void apply(RequestBuilder builder, T value) {
+            if (value == null) return; // Skip null values.
+
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.addPart(headers, body);
+        }
     }
-  }
 
-  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, RequestBody> valueConverter;
-    private final String transferEncoding;
+    static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+        static final RawPart INSTANCE = new RawPart();
+
+        private RawPart() {
+        }
 
-    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
-      this.valueConverter = valueConverter;
-      this.transferEncoding = transferEncoding;
+        @Override
+        void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+            if (value != null) { // Skip null values.
+                builder.addPart(value);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Part map was null.");
-      }
+    static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, RequestBody> valueConverter;
+        private final String transferEncoding;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Part map contained null value for key '" + entryKey + "'.");
+        PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+            this.valueConverter = valueConverter;
+            this.transferEncoding = transferEncoding;
         }
 
-        Headers headers = Headers.of(
-            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-
-        builder.addPart(headers, valueConverter.convert(entryValue));
-      }
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Part map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Part map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Part map contained null value for key '" + entryKey + "'.");
+                }
+
+                Headers headers = Headers.of(
+                        "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+                        "Content-Transfer-Encoding", transferEncoding);
+
+                builder.addPart(headers, valueConverter.convert(entryValue));
+            }
+        }
     }
-  }
 
-  static final class Body<T> extends ParameterHandler<T> {
-    private final Converter<T, RequestBody> converter;
+    static final class Body<T> extends ParameterHandler<T> {
+        private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T, RequestBody> converter) {
-      this.converter = converter;
-    }
+        Body(Converter<T, RequestBody> converter) {
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, T value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.setBody(body);
+        @Override
+        void apply(RequestBuilder builder, T value) {
+            if (value == null) {
+                throw new IllegalArgumentException("Body parameter value must not be null.");
+            }
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.setBody(body);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index e67159bff..67007a1e6 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,138 +18,148 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("org.robovm.apple.foundation.NSObject");
-      return new IOS();
-    } catch (ClassNotFoundException ignored) {
-    }
-    return new Platform();
-  }
+    private static final Platform PLATFORM = findPlatform();
 
-  Executor defaultCallbackExecutor() {
-    return null;
-  }
+    static Platform get() {
+        return PLATFORM;
+    }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    private static Platform findPlatform() {
+        try {
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("org.robovm.apple.foundation.NSObject");
+            return new IOS();
+        } catch (ClassNotFoundException ignored) {
+        }
+        return new Platform();
     }
-    return DefaultCallAdapterFactory.INSTANCE;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
+
+    Executor defaultCallbackExecutor() {
+        return null;
     }
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
+    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+        if (callbackExecutor != null) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+        return DefaultCallAdapterFactory.INSTANCE;
     }
-  }
 
-  static class Android extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+            throws Throwable {
+        throw new UnsupportedOperationException();
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
 
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                   Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                    .unreflectSpecial(method, declaringClass)
+                    .bindTo(object)
+                    .invokeWithArguments(args);
+        }
     }
-  }
 
-  static class IOS extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
+    static class Android extends Platform {
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
+
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }
     }
 
-    static class MainThreadExecutor implements Executor {
-      private static Object queue;
-      private static Method addOperation;
+    static class IOS extends Platform {
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
 
-      static {
-        try {
-          // queue = NSOperationQueue.getMainQueue();
-          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
-          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
-          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
-        } catch (Exception e) {
-          throw new AssertionError(e);
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
         }
-      }
 
-      @Override public void execute(Runnable r) {
-        try {
-          // queue.addOperation(r);
-          addOperation.invoke(queue, r);
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-          throw new AssertionError(e);
-        } catch (InvocationTargetException e) {
-          Throwable cause = e.getCause();
-          if (cause instanceof RuntimeException) {
-            throw (RuntimeException) cause;
-          } else if (cause instanceof Error) {
-            throw (Error) cause;
-          }
-          throw new RuntimeException(cause);
+        static class MainThreadExecutor implements Executor {
+            private static Object queue;
+            private static Method addOperation;
+
+            static {
+                try {
+                    // queue = NSOperationQueue.getMainQueue();
+                    Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
+                    queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
+                    addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
+                } catch (Exception e) {
+                    throw new AssertionError(e);
+                }
+            }
+
+            @Override
+            public void execute(Runnable r) {
+                try {
+                    // queue.addOperation(r);
+                    addOperation.invoke(queue, r);
+                } catch (IllegalArgumentException | IllegalAccessException e) {
+                    throw new AssertionError(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    if (cause instanceof RuntimeException) {
+                        throw (RuntimeException) cause;
+                    } else if (cause instanceof Error) {
+                        throw (Error) cause;
+                    }
+                    throw new RuntimeException(cause);
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 1303418d3..b855411f4 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -27,216 +28,219 @@
 import okio.BufferedSink;
 
 final class RequestBuilder {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
-
-  private final String method;
-
-  private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
-
-  private final Request.Builder requestBuilder;
-  private MediaType contentType;
-
-  private final boolean hasBody;
-  private MultipartBody.Builder multipartBuilder;
-  private FormBody.Builder formBuilder;
-  private RequestBody body;
-
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder();
-    this.contentType = contentType;
-    this.hasBody = hasBody;
-
-    if (headers != null) {
-      requestBuilder.headers(headers);
-    }
+    private static final char[] HEX_DIGITS =
+            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+    private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+
+    private final String method;
+
+    private final HttpUrl baseUrl;
+    private String relativeUrl;
+    private HttpUrl.Builder urlBuilder;
+
+    private final Request.Builder requestBuilder;
+    private MediaType contentType;
+
+    private final boolean hasBody;
+    private MultipartBody.Builder multipartBuilder;
+    private FormBody.Builder formBuilder;
+    private RequestBody body;
+
+    RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
+                   MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+        this.method = method;
+        this.baseUrl = baseUrl;
+        this.relativeUrl = relativeUrl;
+        this.requestBuilder = new Request.Builder();
+        this.contentType = contentType;
+        this.hasBody = hasBody;
+
+        if (headers != null) {
+            requestBuilder.headers(headers);
+        }
 
-    if (isFormEncoded) {
-      // Will be set to 'body' in 'build'.
-      formBuilder = new FormBody.Builder();
-    } else if (isMultipart) {
-      // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBody.Builder();
-      multipartBuilder.setType(MultipartBody.FORM);
-    }
-  }
-
-  void setRelativeUrl(Object relativeUrl) {
-    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
-    this.relativeUrl = relativeUrl.toString();
-  }
-
-  void addHeader(String name, String value) {
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      contentType = MediaType.parse(value);
-    } else {
-      requestBuilder.addHeader(name, value);
+        if (isFormEncoded) {
+            // Will be set to 'body' in 'build'.
+            formBuilder = new FormBody.Builder();
+        } else if (isMultipart) {
+            // Will be set to 'body' in 'build'.
+            multipartBuilder = new MultipartBody.Builder();
+            multipartBuilder.setType(MultipartBody.FORM);
+        }
     }
-  }
 
-  void addPathParam(String name, String value, boolean encoded) {
-    if (relativeUrl == null) {
-      // The relative URL is cleared when the first query parameter is set.
-      throw new AssertionError();
-    }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
-  }
-
-  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
-    int codePoint;
-    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, 0, i);
-        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
-        return out.readUtf8();
-      }
+    void setRelativeUrl(Object relativeUrl) {
+        if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
+        this.relativeUrl = relativeUrl.toString();
     }
 
-    // Fast path: no characters required encoding.
-    return input;
-  }
-
-  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
-      boolean alreadyEncoded) {
-    Buffer utf8Buffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
-        }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
-        }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
+    void addHeader(String name, String value) {
+        if ("Content-Type".equalsIgnoreCase(name)) {
+            contentType = MediaType.parse(value);
+        } else {
+            requestBuilder.addHeader(name, value);
+        }
     }
-  }
-
-  void addQueryParam(String name, String value, boolean encoded) {
-    if (relativeUrl != null) {
-      // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.newBuilder(relativeUrl);
-      if (urlBuilder == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
-      relativeUrl = null;
+
+    void addPathParam(String name, String value, boolean encoded) {
+        if (relativeUrl == null) {
+            // The relative URL is cleared when the first query parameter is set.
+            throw new AssertionError();
+        }
+        relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
+    }
+
+    private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+        int codePoint;
+        for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Slow path: the character at i requires encoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(input, 0, i);
+                canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+                return out.readUtf8();
+            }
+        }
+
+        // Fast path: no characters required encoding.
+        return input;
+    }
+
+    private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+                                            boolean alreadyEncoded) {
+        Buffer utf8Buffer = null; // Lazily allocated.
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                    && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            } else if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Percent encode this character.
+                if (utf8Buffer == null) {
+                    utf8Buffer = new Buffer();
+                }
+                utf8Buffer.writeUtf8CodePoint(codePoint);
+                while (!utf8Buffer.exhausted()) {
+                    int b = utf8Buffer.readByte() & 0xff;
+                    out.writeByte('%');
+                    out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.writeByte(HEX_DIGITS[b & 0xf]);
+                }
+            } else {
+                // This character doesn't need encoding. Just copy it over.
+                out.writeUtf8CodePoint(codePoint);
+            }
+        }
     }
 
-    if (encoded) {
-      urlBuilder.addEncodedQueryParameter(name, value);
-    } else {
-      urlBuilder.addQueryParameter(name, value);
+    void addQueryParam(String name, String value, boolean encoded) {
+        if (relativeUrl != null) {
+            // Do a one-time combination of the built relative URL and the base URL.
+            urlBuilder = baseUrl.newBuilder(relativeUrl);
+            if (urlBuilder == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+            relativeUrl = null;
+        }
+
+        if (encoded) {
+            urlBuilder.addEncodedQueryParameter(name, value);
+        } else {
+            urlBuilder.addQueryParameter(name, value);
+        }
     }
-  }
 
-  void addFormField(String name, String value, boolean encoded) {
-    if (encoded) {
-      formBuilder.addEncoded(name, value);
-    } else {
-      formBuilder.add(name, value);
+    void addFormField(String name, String value, boolean encoded) {
+        if (encoded) {
+            formBuilder.addEncoded(name, value);
+        } else {
+            formBuilder.add(name, value);
+        }
     }
-  }
-
-  void addPart(Headers headers, RequestBody body) {
-    multipartBuilder.addPart(headers, body);
-  }
-
-  void addPart(MultipartBody.Part part) {
-    multipartBuilder.addPart(part);
-  }
-
-  void setBody(RequestBody body) {
-    this.body = body;
-  }
-
-  Request build() {
-    HttpUrl url;
-    HttpUrl.Builder urlBuilder = this.urlBuilder;
-    if (urlBuilder != null) {
-      url = urlBuilder.build();
-    } else {
-      // No query parameters triggered builder creation, just combine the relative URL and base URL.
-      url = baseUrl.resolve(relativeUrl);
-      if (url == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
+
+    void addPart(Headers headers, RequestBody body) {
+        multipartBuilder.addPart(headers, body);
     }
 
-    RequestBody body = this.body;
-    if (body == null) {
-      // Try to pull from one of the builders.
-      if (formBuilder != null) {
-        body = formBuilder.build();
-      } else if (multipartBuilder != null) {
-        body = multipartBuilder.build();
-      } else if (hasBody) {
-        // Body is absent, make an empty body.
-        body = RequestBody.create(null, new byte[0]);
-      }
+    void addPart(MultipartBody.Part part) {
+        multipartBuilder.addPart(part);
     }
 
-    MediaType contentType = this.contentType;
-    if (contentType != null) {
-      if (body != null) {
-        body = new ContentTypeOverridingRequestBody(body, contentType);
-      } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
-      }
+    void setBody(RequestBody body) {
+        this.body = body;
     }
 
-    return requestBuilder
-        .url(url)
-        .method(method, body)
-        .build();
-  }
+    Request build() {
+        HttpUrl url;
+        HttpUrl.Builder urlBuilder = this.urlBuilder;
+        if (urlBuilder != null) {
+            url = urlBuilder.build();
+        } else {
+            // No query parameters triggered builder creation, just combine the relative URL and base URL.
+            url = baseUrl.resolve(relativeUrl);
+            if (url == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+        }
 
-  private static class ContentTypeOverridingRequestBody extends RequestBody {
-    private final RequestBody delegate;
-    private final MediaType contentType;
+        RequestBody body = this.body;
+        if (body == null) {
+            // Try to pull from one of the builders.
+            if (formBuilder != null) {
+                body = formBuilder.build();
+            } else if (multipartBuilder != null) {
+                body = multipartBuilder.build();
+            } else if (hasBody) {
+                // Body is absent, make an empty body.
+                body = RequestBody.create(null, new byte[0]);
+            }
+        }
 
-    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
-      this.delegate = delegate;
-      this.contentType = contentType;
-    }
+        MediaType contentType = this.contentType;
+        if (contentType != null) {
+            if (body != null) {
+                body = new ContentTypeOverridingRequestBody(body, contentType);
+            } else {
+                requestBuilder.addHeader("Content-Type", contentType.toString());
+            }
+        }
 
-    @Override public MediaType contentType() {
-      return contentType;
+        return requestBuilder
+                .url(url)
+                .method(method, body)
+                .build();
     }
 
-    @Override public long contentLength() throws IOException {
-      return delegate.contentLength();
-    }
+    private static class ContentTypeOverridingRequestBody extends RequestBody {
+        private final RequestBody delegate;
+        private final MediaType contentType;
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      delegate.writeTo(sink);
+        ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
+            this.delegate = delegate;
+            this.contentType = contentType;
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
+
+        @Override
+        public long contentLength() throws IOException {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            delegate.writeTo(sink);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 939363b3d..2b7a75c4d 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -20,110 +20,130 @@
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
-/** An HTTP response. */
+/**
+ * An HTTP response.
+ */
 public final class Response<T> {
-  /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
-    return success(body, new okhttp3.Response.Builder() //
-        .code(200)
-        .message("OK")
-        .protocol(Protocol.HTTP_1_1)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
+    /**
+     * Create a synthetic successful response with {@code body} as the deserialized body.
+     */
+    public static <T> Response<T> success(T body) {
+        return success(body, new okhttp3.Response.Builder() //
+                .code(200)
+                .message("OK")
+                .protocol(Protocol.HTTP_1_1)
+                .request(new Request.Builder().url("http://localhost/").build())
+                .build());
+    }
 
-  /**
-   * Create a synthetic successful response using {@code headers} with {@code body} as the
-   * deserialized body.
-   */
-  public static <T> Response<T> success(T body, Headers headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
-    return success(body, new okhttp3.Response.Builder() //
-        .code(200)
-        .message("OK")
-        .protocol(Protocol.HTTP_1_1)
-        .headers(headers)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
+    /**
+     * Create a synthetic successful response using {@code headers} with {@code body} as the
+     * deserialized body.
+     */
+    public static <T> Response<T> success(T body, Headers headers) {
+        if (headers == null) throw new NullPointerException("headers == null");
+        return success(body, new okhttp3.Response.Builder() //
+                .code(200)
+                .message("OK")
+                .protocol(Protocol.HTTP_1_1)
+                .headers(headers)
+                .request(new Request.Builder().url("http://localhost/").build())
+                .build());
+    }
 
-  /**
-   * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
-   * body.
-   */
-  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
-    if (!rawResponse.isSuccessful()) {
-      throw new IllegalArgumentException("rawResponse must be successful response");
+    /**
+     * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
+     * body.
+     */
+    public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
+        if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+        if (!rawResponse.isSuccessful()) {
+            throw new IllegalArgumentException("rawResponse must be successful response");
+        }
+        return new Response<>(rawResponse, body, null);
     }
-    return new Response<>(rawResponse, body, null);
-  }
 
-  /**
-   * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
-   * as the error body.
-   */
-  public static <T> Response<T> error(int code, ResponseBody body) {
-    if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
-    return error(body, new okhttp3.Response.Builder() //
-        .code(code)
-        .protocol(Protocol.HTTP_1_1)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
+    /**
+     * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
+     * as the error body.
+     */
+    public static <T> Response<T> error(int code, ResponseBody body) {
+        if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
+        return error(body, new okhttp3.Response.Builder() //
+                .code(code)
+                .protocol(Protocol.HTTP_1_1)
+                .request(new Request.Builder().url("http://localhost/").build())
+                .build());
+    }
 
-  /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
-  public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
-    if (rawResponse.isSuccessful()) {
-      throw new IllegalArgumentException("rawResponse should not be successful response");
+    /**
+     * Create an error response from {@code rawResponse} with {@code body} as the error body.
+     */
+    public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
+        if (body == null) throw new NullPointerException("body == null");
+        if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+        if (rawResponse.isSuccessful()) {
+            throw new IllegalArgumentException("rawResponse should not be successful response");
+        }
+        return new Response<>(rawResponse, null, body);
     }
-    return new Response<>(rawResponse, null, body);
-  }
 
-  private final okhttp3.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+    private final okhttp3.Response rawResponse;
+    private final T body;
+    private final ResponseBody errorBody;
 
-  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
-    this.rawResponse = rawResponse;
-    this.body = body;
-    this.errorBody = errorBody;
-  }
+    private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+        this.rawResponse = rawResponse;
+        this.body = body;
+        this.errorBody = errorBody;
+    }
 
-  /** The raw response from the HTTP client. */
-  public okhttp3.Response raw() {
-    return rawResponse;
-  }
+    /**
+     * The raw response from the HTTP client.
+     */
+    public okhttp3.Response raw() {
+        return rawResponse;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return rawResponse.code();
-  }
+    /**
+     * HTTP status code.
+     */
+    public int code() {
+        return rawResponse.code();
+    }
 
-  /** HTTP status message or null if unknown. */
-  public String message() {
-    return rawResponse.message();
-  }
+    /**
+     * HTTP status message or null if unknown.
+     */
+    public String message() {
+        return rawResponse.message();
+    }
 
-  /** HTTP headers. */
-  public Headers headers() {
-    return rawResponse.headers();
-  }
+    /**
+     * HTTP headers.
+     */
+    public Headers headers() {
+        return rawResponse.headers();
+    }
 
-  /** Returns true if {@link #code()} is in the range [200..300). */
-  public boolean isSuccessful() {
-    return rawResponse.isSuccessful();
-  }
+    /**
+     * Returns true if {@link #code()} is in the range [200..300).
+     */
+    public boolean isSuccessful() {
+        return rawResponse.isSuccessful();
+    }
 
-  /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
-  public T body() {
-    return body;
-  }
+    /**
+     * The deserialized response body of a {@linkplain #isSuccessful() successful} response.
+     */
+    public T body() {
+        return body;
+    }
 
-  /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
-  public ResponseBody errorBody() {
-    return errorBody;
-  }
+    /**
+     * The raw response body of an {@linkplain #isSuccessful() unsuccessful} response.
+     */
+    public ResponseBody errorBody() {
+        return errorBody;
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index b194d4ed5..e6e87823f 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
+
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -57,514 +58,519 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
-
-  private final okhttp3.Call.Factory callFactory;
-  private final HttpUrl baseUrl;
-  private final List<Converter.Factory> converterFactories;
-  private final List<CallAdapter.Factory> adapterFactories;
-  private final Executor callbackExecutor;
-  private final boolean validateEagerly;
-
-  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
-    this.callFactory = callFactory;
-    this.baseUrl = baseUrl;
-    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
-    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
-    this.callbackExecutor = callbackExecutor;
-    this.validateEagerly = validateEagerly;
-  }
-
-  /**
-   * Create an implementation of the API endpoints defined by the {@code service} interface.
-   * <p>
-   * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
-   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
-   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
-   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
-   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
-   * parameter with {@link Url @Url}.
-   * <p>
-   * Method parameters can be used to replace parts of the URL by annotating them with
-   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
-   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
-   * {@link retrofit2.http.Query @Query}.
-   * <p>
-   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
-   * object will be converted to request representation by one of the {@link Converter.Factory}
-   * instances. A {@link RequestBody} can also be used for a raw representation.
-   * <p>
-   * Alternative request body formats are supported by method annotations and corresponding
-   * parameter annotations:
-   * <ul>
-   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
-   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
-   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
-   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
-   * </ul>
-   * <p>
-   * Additional static headers can be added for an endpoint using the
-   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
-   * header annotate a parameter with {@link Header @Header}.
-   * <p>
-   * By default, methods return a {@link Call} which represents the HTTP request. The generic
-   * parameter of the call is the response body type and will be converted by one of the
-   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
-   * representation. {@link Void} can be used if you do not care about the body contents.
-   * <p>
-   * For example:
-   * <pre>
-   * public interface CategoryService {
-   *   &#64;POST("category/{cat}/")
-   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
-   * }
-   * </pre>
-   */
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new InvocationHandler() {
-          private final Platform platform = Platform.get();
-
-          @Override public Object invoke(Object proxy, Method method, Object... args)
-              throws Throwable {
-            // If the method is a method from Object then defer to normal invocation.
-            if (method.getDeclaringClass() == Object.class) {
-              return method.invoke(this, args);
-            }
-            if (platform.isDefaultMethod(method)) {
-              return platform.invokeDefaultMethod(method, service, proxy, args);
-            }
-            ServiceMethod serviceMethod = loadServiceMethod(method);
-            OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.callAdapter.adapt(okHttpCall);
-          }
-        });
-  }
-
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
-        loadServiceMethod(method);
-      }
-    }
-  }
-
-  ServiceMethod loadServiceMethod(Method method) {
-    ServiceMethod result;
-    synchronized (serviceMethodCache) {
-      result = serviceMethodCache.get(method);
-      if (result == null) {
-        result = new ServiceMethod.Builder(this, method).build();
-        serviceMethodCache.put(method, result);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
-   * Typically an instance of {@link OkHttpClient}.
-   */
-  public okhttp3.Call.Factory callFactory() {
-    return callFactory;
-  }
-
-  /** The API base URL. */
-  public HttpUrl baseUrl() {
-    return baseUrl;
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
-   */
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return adapterFactories;
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
-    return nextCallAdapter(null, returnType, annotations);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
-      Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
-      if (adapter != null) {
-        return adapter;
-      }
+    private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
+
+    private final okhttp3.Call.Factory callFactory;
+    private final HttpUrl baseUrl;
+    private final List<Converter.Factory> converterFactories;
+    private final List<CallAdapter.Factory> adapterFactories;
+    private final Executor callbackExecutor;
+    private final boolean validateEagerly;
+
+    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+             List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+             Executor callbackExecutor, boolean validateEagerly) {
+        this.callFactory = callFactory;
+        this.baseUrl = baseUrl;
+        this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
+        this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
+        this.callbackExecutor = callbackExecutor;
+        this.validateEagerly = validateEagerly;
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(returnType)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
-   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
-   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
-   */
-  public List<Converter.Factory> converterFactories() {
-    return converterFactories;
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
-    checkNotNull(methodAnnotations, "methodAnnotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter.Factory factory = converterFactories.get(i);
-      Converter<?, RequestBody> converter =
-          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, RequestBody>) converter;
-      }
+    /**
+     * Create an implementation of the API endpoints defined by the {@code service} interface.
+     * <p>
+     * The relative path for a given method is obtained from an annotation on the method describing
+     * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+     * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+     * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+     * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+     * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+     * parameter with {@link Url @Url}.
+     * <p>
+     * Method parameters can be used to replace parts of the URL by annotating them with
+     * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+     * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+     * {@link retrofit2.http.Query @Query}.
+     * <p>
+     * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+     * object will be converted to request representation by one of the {@link Converter.Factory}
+     * instances. A {@link RequestBody} can also be used for a raw representation.
+     * <p>
+     * Alternative request body formats are supported by method annotations and corresponding
+     * parameter annotations:
+     * <ul>
+     * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+     * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+     * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+     * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+     * </ul>
+     * <p>
+     * Additional static headers can be added for an endpoint using the
+     * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+     * header annotate a parameter with {@link Header @Header}.
+     * <p>
+     * By default, methods return a {@link Call} which represents the HTTP request. The generic
+     * parameter of the call is the response body type and will be converted by one of the
+     * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+     * representation. {@link Void} can be used if you do not care about the body contents.
+     * <p>
+     * For example:
+     * <pre>
+     * public interface CategoryService {
+     *   &#64;POST("category/{cat}/")
+     *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+     * }
+     * </pre>
+     */
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> T create(final Class<T> service) {
+        Utils.validateServiceInterface(service);
+        if (validateEagerly) {
+            eagerlyValidateMethods(service);
+        }
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
+                new InvocationHandler() {
+                    private final Platform platform = Platform.get();
+
+                    @Override
+                    public Object invoke(Object proxy, Method method, Object... args)
+                            throws Throwable {
+                        // If the method is a method from Object then defer to normal invocation.
+                        if (method.getDeclaringClass() == Object.class) {
+                            return method.invoke(this, args);
+                        }
+                        if (platform.isDefaultMethod(method)) {
+                            return platform.invokeDefaultMethod(method, service, proxy, args);
+                        }
+                        ServiceMethod serviceMethod = loadServiceMethod(method);
+                        OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
+                        return serviceMethod.callAdapter.adapt(okHttpCall);
+                    }
+                });
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
-    return nextResponseBodyConverter(null, type, annotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).responseBodyConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<ResponseBody, T>) converter;
-      }
+    private void eagerlyValidateMethods(Class<?> service) {
+        Platform platform = Platform.get();
+        for (Method method : service.getDeclaredMethods()) {
+            if (!platform.isDefaultMethod(method)) {
+                loadServiceMethod(method);
+            }
+        }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
+    ServiceMethod loadServiceMethod(Method method) {
+        ServiceMethod result;
+        synchronized (serviceMethodCache) {
+            result = serviceMethodCache.get(method);
+            if (result == null) {
+                result = new ServiceMethod.Builder(this, method).build();
+                serviceMethodCache.put(method, result);
+            }
+        }
+        return result;
     }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+
+    /**
+     * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+     * Typically an instance of {@link OkHttpClient}.
+     */
+    public okhttp3.Call.Factory callFactory() {
+        return callFactory;
     }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link String} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, String>) converter;
-      }
+
+    /**
+     * The API base URL.
+     */
+    public HttpUrl baseUrl() {
+        return baseUrl;
     }
 
-    // Nothing matched. Resort to default converter which just calls toString().
-    //noinspection unchecked
-    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
-  }
-
-  /**
-   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
-   * in which case callbacks should be made synchronously on the background thread.
-   */
-  public Executor callbackExecutor() {
-    return callbackExecutor;
-  }
-
-  /**
-   * Build a new {@link Retrofit}.
-   * <p>
-   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static final class Builder {
-    private Platform platform;
-    private okhttp3.Call.Factory callFactory;
-    private HttpUrl baseUrl;
-    private List<Converter.Factory> converterFactories = new ArrayList<>();
-    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
-    private boolean validateEagerly;
-
-    Builder(Platform platform) {
-      this.platform = platform;
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
+    /**
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+     */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+        return adapterFactories;
     }
 
-    public Builder() {
-      this(Platform.get());
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
+     */
+    public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+        return nextCallAdapter(null, returnType, annotations);
     }
 
     /**
-     * The HTTP client used for requests.
-     * <p>
-     * This is a convenience method for calling {@link #callFactory}.
-     * <p>
-     * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
-     * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
-     * instance to prevent this if desired.
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
      */
-    public Builder client(OkHttpClient client) {
-      return callFactory(checkNotNull(client, "client == null"));
+    public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+                                          Annotation[] annotations) {
+        checkNotNull(returnType, "returnType == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = adapterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+            if (adapter != null) {
+                return adapter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+                .append(returnType)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * Specify a custom call factory for creating {@link Call} instances.
-     * <p>
-     * Note: Calling {@link #client} automatically sets this value.
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+     * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+     * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
      */
-    public Builder callFactory(okhttp3.Call.Factory factory) {
-      this.callFactory = checkNotNull(factory, "factory == null");
-      return this;
+    public List<Converter.Factory> converterFactories() {
+        return converterFactories;
     }
 
     /**
-     * Set the API base URL.
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories}.
      *
-     * @see #baseUrl(HttpUrl)
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+    public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
     }
 
     /**
-     * Set the API base URL.
-     * <p>
-     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
-     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
-     * {@code <a href="">} link on a website resolving on the current URL.
-     * <p>
-     * <b>Base URLs should always end in {@code /}.</b>
-     * <p>
-     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
-     * append themselves to a base which has path components.
-     * <p>
-     * <b>Correct:</b><br>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/api/foo/bar/
-     * <p>
-     * <b>Incorrect:</b><br>
-     * Base URL: http://example.com/api<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * This method enforces that {@code baseUrl} has a trailing {@code /}.
-     * <p>
-     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
-     * <p>
-     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
-     * components.
-     * <p>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * <b>Endpoint values may be a full URL.</b>
-     * <p>
-     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
-     * replace the scheme of {@code baseUrl}.
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: https://github.com/square/retrofit/<br>
-     * Result: https://github.com/square/retrofit/
-     * <p>
-     * Base URL: http://example.com<br>
-     * Endpoint: //github.com/square/retrofit/<br>
-     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      List<String> pathSegments = baseUrl.pathSegments();
-      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
-        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
-      }
-      this.baseUrl = baseUrl;
-      return this;
+    public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
+                                                                  Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+        checkNotNull(methodAnnotations, "methodAnnotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter.Factory factory = converterFactories.get(i);
+            Converter<?, RequestBody> converter =
+                    factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, RequestBody>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
-    /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory factory) {
-      converterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    /**
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
+     */
+    public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+        return nextResponseBodyConverter(null, type, annotations);
     }
 
     /**
-     * Add a call adapter factory for supporting service method return types other than {@link
-     * Call}.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
+                                                                    Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter<ResponseBody, ?> converter =
+                    converterFactories.get(i).responseBodyConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<ResponseBody, T>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
-     * your service method.
-     * <p>
-     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
-     * return types}.
+     * Returns a {@link Converter} for {@code type} to {@link String} from the available
+     * {@linkplain #converterFactories() factories}.
      */
-    public Builder callbackExecutor(Executor executor) {
-      this.callbackExecutor = checkNotNull(executor, "executor == null");
-      return this;
+    public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<?, String> converter =
+                    converterFactories.get(i).stringConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, String>) converter;
+            }
+        }
+
+        // Nothing matched. Resort to default converter which just calls toString().
+        //noinspection unchecked
+        return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
     }
 
     /**
-     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
-     * the configuration of all methods in the supplied interface.
+     * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+     * in which case callbacks should be made synchronously on the background thread.
      */
-    public Builder validateEagerly(boolean validateEagerly) {
-      this.validateEagerly = validateEagerly;
-      return this;
+    public Executor callbackExecutor() {
+        return callbackExecutor;
     }
 
     /**
-     * Create the {@link Retrofit} instance using the configured values.
+     * Build a new {@link Retrofit}.
      * <p>
-     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
-     * OkHttpClient} will be created and used.
+     * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+     * are optional.
      */
-    public Retrofit build() {
-      if (baseUrl == null) {
-        throw new IllegalStateException("Base URL required.");
-      }
-
-      okhttp3.Call.Factory callFactory = this.callFactory;
-      if (callFactory == null) {
-        callFactory = new OkHttpClient();
-      }
-
-      Executor callbackExecutor = this.callbackExecutor;
-      if (callbackExecutor == null) {
-        callbackExecutor = platform.defaultCallbackExecutor();
-      }
-
-      // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
-
-      // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
-
-      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+    public static final class Builder {
+        private Platform platform;
+        private okhttp3.Call.Factory callFactory;
+        private HttpUrl baseUrl;
+        private List<Converter.Factory> converterFactories = new ArrayList<>();
+        private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+        private Executor callbackExecutor;
+        private boolean validateEagerly;
+
+        Builder(Platform platform) {
+            this.platform = platform;
+            // Add the built-in converter factory first. This prevents overriding its behavior but also
+            // ensures correct behavior when using converters that consume all types.
+            converterFactories.add(new BuiltInConverters());
+        }
+
+        public Builder() {
+            this(Platform.get());
+        }
+
+        /**
+         * The HTTP client used for requests.
+         * <p>
+         * This is a convenience method for calling {@link #callFactory}.
+         * <p>
+         * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
+         * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
+         * instance to prevent this if desired.
+         */
+        public Builder client(OkHttpClient client) {
+            return callFactory(checkNotNull(client, "client == null"));
+        }
+
+        /**
+         * Specify a custom call factory for creating {@link Call} instances.
+         * <p>
+         * Note: Calling {@link #client} automatically sets this value.
+         */
+        public Builder callFactory(okhttp3.Call.Factory factory) {
+            this.callFactory = checkNotNull(factory, "factory == null");
+            return this;
+        }
+
+        /**
+         * Set the API base URL.
+         *
+         * @see #baseUrl(HttpUrl)
+         */
+        public Builder baseUrl(String baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+            if (httpUrl == null) {
+                throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+            }
+            return baseUrl(httpUrl);
+        }
+
+        /**
+         * Set the API base URL.
+         * <p>
+         * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+         * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+         * {@code <a href="">} link on a website resolving on the current URL.
+         * <p>
+         * <b>Base URLs should always end in {@code /}.</b>
+         * <p>
+         * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+         * append themselves to a base which has path components.
+         * <p>
+         * <b>Correct:</b><br>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/api/foo/bar/
+         * <p>
+         * <b>Incorrect:</b><br>
+         * Base URL: http://example.com/api<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * This method enforces that {@code baseUrl} has a trailing {@code /}.
+         * <p>
+         * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+         * <p>
+         * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+         * components.
+         * <p>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * <b>Endpoint values may be a full URL.</b>
+         * <p>
+         * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+         * replace the scheme of {@code baseUrl}.
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: https://github.com/square/retrofit/<br>
+         * Result: https://github.com/square/retrofit/
+         * <p>
+         * Base URL: http://example.com<br>
+         * Endpoint: //github.com/square/retrofit/<br>
+         * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+         */
+        public Builder baseUrl(HttpUrl baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            List<String> pathSegments = baseUrl.pathSegments();
+            if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+                throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+            }
+            this.baseUrl = baseUrl;
+            return this;
+        }
+
+        /**
+         * Add converter factory for serialization and deserialization of objects.
+         */
+        public Builder addConverterFactory(Converter.Factory factory) {
+            converterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * Add a call adapter factory for supporting service method return types other than {@link
+         * Call}.
+         */
+        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+            adapterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+         * your service method.
+         * <p>
+         * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+         * return types}.
+         */
+        public Builder callbackExecutor(Executor executor) {
+            this.callbackExecutor = checkNotNull(executor, "executor == null");
+            return this;
+        }
+
+        /**
+         * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+         * the configuration of all methods in the supplied interface.
+         */
+        public Builder validateEagerly(boolean validateEagerly) {
+            this.validateEagerly = validateEagerly;
+            return this;
+        }
+
+        /**
+         * Create the {@link Retrofit} instance using the configured values.
+         * <p>
+         * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+         * OkHttpClient} will be created and used.
+         */
+        public Retrofit build() {
+            if (baseUrl == null) {
+                throw new IllegalStateException("Base URL required.");
+            }
+
+            okhttp3.Call.Factory callFactory = this.callFactory;
+            if (callFactory == null) {
+                callFactory = new OkHttpClient();
+            }
+
+            Executor callbackExecutor = this.callbackExecutor;
+            if (callbackExecutor == null) {
+                callbackExecutor = platform.defaultCallbackExecutor();
+            }
+
+            // Make a defensive copy of the adapters and add the default Call adapter.
+            List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+            adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+
+            // Make a defensive copy of the converters.
+            List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+            return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
+                    callbackExecutor, validateEagerly);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index facede01f..b52410055 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -55,699 +56,705 @@
 import retrofit2.http.QueryMap;
 import retrofit2.http.Url;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
+/**
+ * Adapts an invocation of an interface method into an HTTP call.
+ */
 final class ServiceMethod<T> {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-
-  final okhttp3.Call.Factory callFactory;
-  final CallAdapter<?> callAdapter;
-
-  private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, T> responseConverter;
-  private final String httpMethod;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-
-  ServiceMethod(Builder<T> builder) {
-    this.callFactory = builder.retrofit.callFactory();
-    this.callAdapter = builder.callAdapter;
-    this.baseUrl = builder.retrofit.baseUrl();
-    this.responseConverter = builder.responseConverter;
-    this.httpMethod = builder.httpMethod;
-    this.relativeUrl = builder.relativeUrl;
-    this.headers = builder.headers;
-    this.contentType = builder.contentType;
-    this.hasBody = builder.hasBody;
-    this.isFormEncoded = builder.isFormEncoded;
-    this.isMultipart = builder.isMultipart;
-    this.parameterHandlers = builder.parameterHandlers;
-  }
-
-  /** Builds an HTTP request from method arguments. */
-  Request toRequest(Object... args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args != null ? args.length : 0;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+    static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+    final okhttp3.Call.Factory callFactory;
+    final CallAdapter<?> callAdapter;
+
+    private final HttpUrl baseUrl;
+    private final Converter<ResponseBody, T> responseConverter;
+    private final String httpMethod;
+    private final String relativeUrl;
+    private final Headers headers;
+    private final MediaType contentType;
+    private final boolean hasBody;
+    private final boolean isFormEncoded;
+    private final boolean isMultipart;
+    private final ParameterHandler<?>[] parameterHandlers;
+
+    ServiceMethod(Builder<T> builder) {
+        this.callFactory = builder.retrofit.callFactory();
+        this.callAdapter = builder.callAdapter;
+        this.baseUrl = builder.retrofit.baseUrl();
+        this.responseConverter = builder.responseConverter;
+        this.httpMethod = builder.httpMethod;
+        this.relativeUrl = builder.relativeUrl;
+        this.headers = builder.headers;
+        this.contentType = builder.contentType;
+        this.hasBody = builder.hasBody;
+        this.isFormEncoded = builder.isFormEncoded;
+        this.isMultipart = builder.isMultipart;
+        this.parameterHandlers = builder.parameterHandlers;
     }
 
-    for (int p = 0; p < argumentCount; p++) {
-      handlers[p].apply(requestBuilder, args[p]);
-    }
+    /**
+     * Builds an HTTP request from method arguments.
+     */
+    Request toRequest(Object... args) throws IOException {
+        RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+                contentType, hasBody, isFormEncoded, isMultipart);
 
-    return requestBuilder.build();
-  }
-
-  /** Builds a method return value from an HTTP response body. */
-  T toResponse(ResponseBody body) throws IOException {
-    return responseConverter.convert(body);
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder<T> {
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    Type responseType;
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotUrl;
-    String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    String relativeUrl;
-    Headers headers;
-    MediaType contentType;
-    Set<String> relativeUrlParamNames;
-    ParameterHandler<?>[] parameterHandlers;
-    Converter<ResponseBody, T> responseConverter;
-    CallAdapter<?> callAdapter;
-
-    public Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
+        @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+                ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    public ServiceMethod build() {
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError("'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
-
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
-
-      if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
-
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
-        }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
-              parameterType);
+        int argumentCount = args != null ? args.length : 0;
+        if (argumentCount != handlers.length) {
+            throw new IllegalArgumentException("Argument count (" + argumentCount
+                    + ") doesn't match expected count (" + handlers.length + ")");
         }
 
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
+        for (int p = 0; p < argumentCount; p++) {
+            handlers[p].apply(requestBuilder, args[p]);
         }
 
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
-      }
-
-      return new ServiceMethod<>(this);
+        return requestBuilder.build();
     }
 
-    private CallAdapter<?> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create call adapter for %s", returnType);
-      }
+    /**
+     * Builds a method return value from an HTTP response body.
+     */
+    T toResponse(ResponseBody body) throws IOException {
+        return responseConverter.convert(body);
     }
 
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError("HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
-
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
-        }
-      }
-
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
-
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-        }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          contentType = MediaType.parse(headerValue);
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
-
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
-      ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method. This
+     * requires potentially-expensive reflection so it is best to build each service method only once
+     * and reuse it. Builders cannot be reused.
+     */
+    static final class Builder<T> {
+        final Retrofit retrofit;
+        final Method method;
+        final Annotation[] methodAnnotations;
+        final Annotation[][] parameterAnnotationsArray;
+        final Type[] parameterTypes;
+
+        Type responseType;
+        boolean gotField;
+        boolean gotPart;
+        boolean gotBody;
+        boolean gotPath;
+        boolean gotQuery;
+        boolean gotUrl;
+        String httpMethod;
+        boolean hasBody;
+        boolean isFormEncoded;
+        boolean isMultipart;
+        String relativeUrl;
+        Headers headers;
+        MediaType contentType;
+        Set<String> relativeUrlParamNames;
+        ParameterHandler<?>[] parameterHandlers;
+        Converter<ResponseBody, T> responseConverter;
+        CallAdapter<?> callAdapter;
+
+        public Builder(Retrofit retrofit, Method method) {
+            this.retrofit = retrofit;
+            this.method = method;
+            this.methodAnnotations = method.getAnnotations();
+            this.parameterTypes = method.getGenericParameterTypes();
+            this.parameterAnnotationsArray = method.getParameterAnnotations();
+        }
+
+        public ServiceMethod build() {
+            callAdapter = createCallAdapter();
+            responseType = callAdapter.responseType();
+            if (responseType == Response.class || responseType == okhttp3.Response.class) {
+                throw methodError("'"
+                        + Utils.getRawType(responseType).getName()
+                        + "' is not a valid response body type. Did you mean ResponseBody?");
+            }
+            responseConverter = createResponseConverter();
 
-        if (annotationAction == null) {
-          continue;
-        }
+            for (Annotation annotation : methodAnnotations) {
+                parseMethodAnnotation(annotation);
+            }
 
-        if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
-        }
+            if (httpMethod == null) {
+                throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+            }
 
-        result = annotationAction;
-      }
+            if (!hasBody) {
+                if (isMultipart) {
+                    throw methodError(
+                            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+                }
+                if (isFormEncoded) {
+                    throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+                            + "request body (e.g., @POST).");
+                }
+            }
 
-      if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
-      }
+            int parameterCount = parameterAnnotationsArray.length;
+            parameterHandlers = new ParameterHandler<?>[parameterCount];
+            for (int p = 0; p < parameterCount; p++) {
+                Type parameterType = parameterTypes[p];
+                if (Utils.hasUnresolvableType(parameterType)) {
+                    throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+                            parameterType);
+                }
+
+                Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+                if (parameterAnnotations == null) {
+                    throw parameterError(p, "No Retrofit annotation found.");
+                }
+
+                parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+            }
 
-      return result;
-    }
+            if (relativeUrl == null && !gotUrl) {
+                throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+            }
+            if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+                throw methodError("Non-body HTTP method cannot contain @Body.");
+            }
+            if (isFormEncoded && !gotField) {
+                throw methodError("Form-encoded method must contain at least one @Field.");
+            }
+            if (isMultipart && !gotPart) {
+                throw methodError("Multipart method must contain at least one @Part.");
+            }
 
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+            return new ServiceMethod<>(this);
         }
 
-        gotUrl = true;
-
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
-        } else {
-          throw parameterError(p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        private CallAdapter<?> createCallAdapter() {
+            Type returnType = method.getGenericReturnType();
+            if (Utils.hasUnresolvableType(returnType)) {
+                throw methodError(
+                        "Method return type must not include a type variable or wildcard: %s", returnType);
+            }
+            if (returnType == void.class) {
+                throw methodError("Service methods cannot return void.");
+            }
+            Annotation[] annotations = method.getAnnotations();
+            try {
+                return retrofit.callAdapter(returnType, annotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                throw methodError(e, "Unable to create call adapter for %s", returnType);
+            }
         }
 
-      } else if (annotation instanceof Path) {
-        if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
+        private void parseMethodAnnotation(Annotation annotation) {
+            if (annotation instanceof DELETE) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+            } else if (annotation instanceof GET) {
+                parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+            } else if (annotation instanceof HEAD) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+                if (!Void.class.equals(responseType)) {
+                    throw methodError("HEAD method must use Void as response type.");
+                }
+            } else if (annotation instanceof PATCH) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+            } else if (annotation instanceof POST) {
+                parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+            } else if (annotation instanceof PUT) {
+                parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+            } else if (annotation instanceof OPTIONS) {
+                parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+            } else if (annotation instanceof HTTP) {
+                HTTP http = (HTTP) annotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            } else if (annotation instanceof retrofit2.http.Headers) {
+                String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError("@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotation instanceof Multipart) {
+                if (isFormEncoded) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                isMultipart = true;
+            } else if (annotation instanceof FormUrlEncoded) {
+                if (isMultipart) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                isFormEncoded = true;
+            }
         }
 
-      } else if (annotation instanceof QueryMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
-        }
+        private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+            if (this.httpMethod != null) {
+                throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+                        this.httpMethod, httpMethod);
+            }
+            this.httpMethod = httpMethod;
+            this.hasBody = hasBody;
 
-      } else if (annotation instanceof HeaderMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+            if (value.isEmpty()) {
+                return;
+            }
 
-        return new ParameterHandler.HeaderMap<>(valueConverter);
+            // Get the relative URL path and existing query string, if present.
+            int question = value.indexOf('?');
+            if (question != -1 && question < value.length() - 1) {
+                // Ensure the query string does not have any named parameters.
+                String queryParams = value.substring(question + 1);
+                Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+                if (queryParamMatcher.find()) {
+                    throw methodError("URL query string \"%s\" must not have replace block. "
+                            + "For dynamic query parameters use @Query.", queryParams);
+                }
+            }
 
-      } else if (annotation instanceof Field) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
+            this.relativeUrl = value;
+            this.relativeUrlParamNames = parsePathParameters(value);
+        }
+
+        private Headers parseHeaders(String[] headers) {
+            Headers.Builder builder = new Headers.Builder();
+            for (String header : headers) {
+                int colon = header.indexOf(':');
+                if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                    throw methodError(
+                            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+                }
+                String headerName = header.substring(0, colon);
+                String headerValue = header.substring(colon + 1).trim();
+                if ("Content-Type".equalsIgnoreCase(headerName)) {
+                    contentType = MediaType.parse(headerValue);
+                } else {
+                    builder.add(headerName, headerValue);
+                }
+            }
+            return builder.build();
         }
 
-      } else if (annotation instanceof FieldMap) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+        private ParameterHandler<?> parseParameter(
+                int p, Type parameterType, Annotation[] annotations) {
+            ParameterHandler<?> result = null;
+            for (Annotation annotation : annotations) {
+                ParameterHandler<?> annotationAction = parseParameterAnnotation(
+                        p, parameterType, annotations, annotation);
 
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+                if (annotationAction == null) {
+                    continue;
+                }
 
-      } else if (annotation instanceof Part) {
-        if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                if (result != null) {
+                    throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+                }
+
+                result = annotationAction;
             }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+
+            if (result == null) {
+                throw parameterError(p, "No Retrofit annotation found.");
             }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
+
+            return result;
+        }
+
+        private ParameterHandler<?> parseParameterAnnotation(
+                int p, Type type, Annotation[] annotations, Annotation annotation) {
+            if (annotation instanceof Url) {
+                if (gotUrl) {
+                    throw parameterError(p, "Multiple @Url method annotations found.");
+                }
+                if (gotPath) {
+                    throw parameterError(p, "@Path parameters may not be used with @Url.");
+                }
+                if (gotQuery) {
+                    throw parameterError(p, "A @Url parameter must not come after a @Query");
+                }
+                if (relativeUrl != null) {
+                    throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+                }
+
+                gotUrl = true;
+
+                if (type == HttpUrl.class
+                        || type == String.class
+                        || type == URI.class
+                        || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+                    return new ParameterHandler.RelativeUrl();
+                } else {
+                    throw parameterError(p,
+                            "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+                }
+
+            } else if (annotation instanceof Path) {
+                if (gotQuery) {
+                    throw parameterError(p, "A @Path parameter must not come after a @Query.");
+                }
+                if (gotUrl) {
+                    throw parameterError(p, "@Path parameters may not be used with @Url.");
+                }
+                if (relativeUrl == null) {
+                    throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+                }
+                gotPath = true;
+
+                Path path = (Path) annotation;
+                String name = path.value();
+                validatePathName(p, name);
+
+                Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+                return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+            } else if (annotation instanceof Query) {
+                Query query = (Query) annotation;
+                String name = query.value();
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQuery = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof QueryMap) {
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@QueryMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+            } else if (annotation instanceof Header) {
+                Header header = (Header) annotation;
+                String name = header.value();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Header<>(name, converter);
+                }
+
+            } else if (annotation instanceof HeaderMap) {
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@HeaderMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.HeaderMap<>(valueConverter);
+
+            } else if (annotation instanceof Field) {
+                if (!isFormEncoded) {
+                    throw parameterError(p, "@Field parameters can only be used with form encoding.");
+                }
+                Field field = (Field) annotation;
+                String name = field.value();
+                boolean encoded = field.encoded();
+
+                gotField = true;
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof FieldMap) {
+                if (!isFormEncoded) {
+                    throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+                }
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@FieldMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                gotField = true;
+                return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+            } else if (annotation instanceof Part) {
+                if (!isMultipart) {
+                    throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+                }
+                Part part = (Part) annotation;
+                gotPart = true;
+
+                String partName = part.value();
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (partName.isEmpty()) {
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = rawParameterType.getComponentType();
+                        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        return ParameterHandler.RawPart.INSTANCE;
+                    } else {
+                        throw parameterError(p,
+                                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                    }
+                } else {
+                    Headers headers =
+                            Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                                    "Content-Transfer-Encoding", part.encoding());
+
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                    + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                    + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                + "include a part name in the annotation.");
+                    } else {
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter);
+                    }
+                }
+
+            } else if (annotation instanceof PartMap) {
+                if (!isMultipart) {
+                    throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+                }
+                gotPart = true;
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@PartMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+                }
+
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+                    throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+                            + "Use @Part List<Part> or a different value type instead.");
+                }
+
+                Converter<?, RequestBody> valueConverter =
+                        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+                PartMap partMap = (PartMap) annotation;
+                return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+            } else if (annotation instanceof Body) {
+                if (isFormEncoded || isMultipart) {
+                    throw parameterError(p,
+                            "@Body parameters cannot be used with form or multi-part encoding.");
+                }
+                if (gotBody) {
+                    throw parameterError(p, "Multiple @Body method annotations found.");
+                }
+
+                Converter<?, RequestBody> converter;
+                try {
+                    converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                } catch (RuntimeException e) {
+                    // Wide exception range because factories are user code.
+                    throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+                }
+                gotBody = true;
+                return new ParameterHandler.Body<>(converter);
             }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+
+            return null; // Not a Retrofit annotation.
+        }
+
+        private void validatePathName(int p, String name) {
+            if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+                throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+                        PARAM_URL_REGEX.pattern(), name);
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+            // Verify URL replacement name is actually present in the URL path.
+            if (!relativeUrlParamNames.contains(name)) {
+                throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
-          }
         }
 
-      } else if (annotation instanceof PartMap) {
-        if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
-        }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        private Converter<ResponseBody, T> createResponseConverter() {
+            Annotation[] annotations = method.getAnnotations();
+            try {
+                return retrofit.responseBodyConverter(responseType, annotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                throw methodError(e, "Unable to create converter for %s", responseType);
+            }
         }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+        private RuntimeException methodError(String message, Object... args) {
+            return methodError(null, message, args);
         }
 
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
+        private RuntimeException methodError(Throwable cause, String message, Object... args) {
+            message = String.format(message, args);
+            return new IllegalArgumentException(message
+                    + "\n    for method "
+                    + method.getDeclaringClass().getSimpleName()
+                    + "."
+                    + method.getName(), cause);
         }
 
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
-
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
-
-      } else if (annotation instanceof Body) {
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
+        private RuntimeException parameterError(
+                Throwable cause, int p, String message, Object... args) {
+            return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
         }
 
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+        private RuntimeException parameterError(int p, String message, Object... args) {
+            return methodError(message + " (parameter #" + (p + 1) + ")", args);
         }
-        gotBody = true;
-        return new ParameterHandler.Body<>(converter);
-      }
-
-      return null; // Not a Retrofit annotation.
-    }
-
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
-
-    private Converter<ResponseBody, T> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create converter for %s", responseType);
-      }
     }
 
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+        Matcher m = PARAM_URL_REGEX.matcher(path);
+        Set<String> patterns = new LinkedHashSet<>();
+        while (m.find()) {
+            patterns.add(m.group(1));
+        }
+        return patterns;
     }
 
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
-
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
-    }
-
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
+    static Class<?> boxIfPrimitive(Class<?> type) {
+        if (boolean.class == type) return Boolean.class;
+        if (byte.class == type) return Byte.class;
+        if (char.class == type) return Character.class;
+        if (double.class == type) return Double.class;
+        if (float.class == type) return Float.class;
+        if (int.class == type) return Integer.class;
+        if (long.class == type) return Long.class;
+        if (short.class == type) return Short.class;
+        return type;
     }
-    return patterns;
-  }
-
-  static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 09ab09064..827a82a20 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -26,471 +26,491 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
 final class Utils {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+    static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
 
-  private Utils() {
-    // No instances.
-  }
+    private Utils() {
+        // No instances.
+    }
 
-  static Class<?> getRawType(Type type) {
-    if (type == null) throw new NullPointerException("type == null");
+    static Class<?> getRawType(Type type) {
+        if (type == null) throw new NullPointerException("type == null");
 
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-    }
-    if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-    }
-    if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-    }
-    if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-    }
+        if (type instanceof Class<?>) {
+            // Type is a normal class.
+            return (Class<?>) type;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+
+            // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+            // suspects some pathological case related to nested classes exists.
+            Type rawType = parameterizedType.getRawType();
+            if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+            return (Class<?>) rawType;
+        }
+        if (type instanceof GenericArrayType) {
+            Type componentType = ((GenericArrayType) type).getGenericComponentType();
+            return Array.newInstance(getRawType(componentType), 0).getClass();
+        }
+        if (type instanceof TypeVariable) {
+            // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+            // type that's more general than necessary is okay.
+            return Object.class;
+        }
+        if (type instanceof WildcardType) {
+            return getRawType(((WildcardType) type).getUpperBounds()[0]);
+        }
 
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
-    }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+    }
+
+    /**
+     * Returns true if {@code a} and {@code b} are equal.
+     */
+    static boolean equals(Type a, Type b) {
+        if (a == b) {
+            return true; // Also handles (a == null && b == null).
+
+        } else if (a instanceof Class) {
+            return a.equals(b); // Class already specifies equals().
+
+        } else if (a instanceof ParameterizedType) {
+            if (!(b instanceof ParameterizedType)) return false;
+            ParameterizedType pa = (ParameterizedType) a;
+            ParameterizedType pb = (ParameterizedType) b;
+            return equal(pa.getOwnerType(), pb.getOwnerType())
+                    && pa.getRawType().equals(pb.getRawType())
+                    && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+        } else if (a instanceof GenericArrayType) {
+            if (!(b instanceof GenericArrayType)) return false;
+            GenericArrayType ga = (GenericArrayType) a;
+            GenericArrayType gb = (GenericArrayType) b;
+            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+        } else if (a instanceof WildcardType) {
+            if (!(b instanceof WildcardType)) return false;
+            WildcardType wa = (WildcardType) a;
+            WildcardType wb = (WildcardType) b;
+            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+                    && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+        } else if (a instanceof TypeVariable) {
+            if (!(b instanceof TypeVariable)) return false;
+            TypeVariable<?> va = (TypeVariable<?>) a;
+            TypeVariable<?> vb = (TypeVariable<?>) b;
+            return va.getGenericDeclaration() == vb.getGenericDeclaration()
+                    && va.getName().equals(vb.getName());
+
+        } else {
+            return false; // This isn't a type we support!
+        }
     }
 
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
+    /**
+     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+     */
+    static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+        if (toResolve == rawType) return context;
+
+        // We skip searching through interfaces if unknown is an interface.
+        if (toResolve.isInterface()) {
+            Class<?>[] interfaces = rawType.getInterfaces();
+            for (int i = 0, length = interfaces.length; i < length; i++) {
+                if (interfaces[i] == toResolve) {
+                    return rawType.getGenericInterfaces()[i];
+                } else if (toResolve.isAssignableFrom(interfaces[i])) {
+                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+                }
+            }
+        }
 
-    // We can't resolve this further.
-    return toResolve;
-  }
+        // Check our supertypes.
+        if (!rawType.isInterface()) {
+            while (rawType != Object.class) {
+                Class<?> rawSupertype = rawType.getSuperclass();
+                if (rawSupertype == toResolve) {
+                    return rawType.getGenericSuperclass();
+                } else if (toResolve.isAssignableFrom(rawSupertype)) {
+                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+                }
+                rawType = rawSupertype;
+            }
+        }
 
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
+        // We can't resolve this further.
+        return toResolve;
     }
-    throw new NoSuchElementException();
-  }
-
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
+
+    private static int indexOf(Object[] array, Object toFind) {
+        for (int i = 0; i < array.length; i++) {
+            if (toFind.equals(array[i])) return i;
+        }
+        throw new NoSuchElementException();
+    }
+
+    private static boolean equal(Object a, Object b) {
+        return a == b || (a != null && a.equals(b));
+    }
+
+    static int hashCodeOrZero(Object o) {
+        return o != null ? o.hashCode() : 0;
+    }
+
+    static String typeToString(Type type) {
+        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+    }
+
+    /**
+     * Returns the generic form of {@code supertype}. For example, if this is {@code
+     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+     * Iterable.class}.
+     *
+     * @param supertype a superclass of, or interface implemented by, this.
+     */
+    static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+        if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+        return resolve(context, contextRawType,
+                getGenericSupertype(context, contextRawType, supertype));
+    }
+
+    static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+        // This implementation is made a little more complicated in an attempt to avoid object-creation.
+        while (true) {
+            if (toResolve instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+                if (toResolve == typeVariable) {
+                    return toResolve;
+                }
+
+            } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+                Class<?> original = (Class<?>) toResolve;
+                Type componentType = original.getComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof GenericArrayType) {
+                GenericArrayType original = (GenericArrayType) toResolve;
+                Type componentType = original.getGenericComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof ParameterizedType) {
+                ParameterizedType original = (ParameterizedType) toResolve;
+                Type ownerType = original.getOwnerType();
+                Type newOwnerType = resolve(context, contextRawType, ownerType);
+                boolean changed = newOwnerType != ownerType;
+
+                Type[] args = original.getActualTypeArguments();
+                for (int t = 0, length = args.length; t < length; t++) {
+                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+                    if (resolvedTypeArgument != args[t]) {
+                        if (!changed) {
+                            args = args.clone();
+                            changed = true;
+                        }
+                        args[t] = resolvedTypeArgument;
+                    }
+                }
+
+                return changed
+                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+                        : original;
+
+            } else if (toResolve instanceof WildcardType) {
+                WildcardType original = (WildcardType) toResolve;
+                Type[] originalLowerBound = original.getLowerBounds();
+                Type[] originalUpperBound = original.getUpperBounds();
+
+                if (originalLowerBound.length == 1) {
+                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+                    if (lowerBound != originalLowerBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{Object.class}, new Type[]{lowerBound});
+                    }
+                } else if (originalUpperBound.length == 1) {
+                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+                    if (upperBound != originalUpperBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{upperBound}, EMPTY_TYPE_ARRAY);
+                    }
+                }
+                return original;
+
+            } else {
+                return toResolve;
             }
-            args[t] = resolvedTypeArgument;
-          }
         }
+    }
 
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
+    private static Type resolveTypeVariable(
+            Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+        Class<?> declaredByRaw = declaringClassOf(unknown);
 
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
+        // We can't reduce this further.
+        if (declaredByRaw == null) return unknown;
 
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
+        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+        if (declaredBy instanceof ParameterizedType) {
+            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
         }
-        return original;
 
-      } else {
-        return toResolve;
-      }
+        return unknown;
     }
-  }
-
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
 
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    /**
+     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+     * a class.
+     */
+    private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
     }
 
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
+    static void checkNotPrimitive(Type type) {
+        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+            throw new IllegalArgumentException();
+        }
     }
-  }
 
-  static <T> T checkNotNull(T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
-    }
-    return object;
-  }
-
-  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
-  static boolean isAnnotationPresent(Annotation[] annotations,
-      Class<? extends Annotation> cls) {
-    for (Annotation annotation : annotations) {
-      if (cls.isInstance(annotation)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  static ResponseBody buffer(final ResponseBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.source().readAll(buffer);
-    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
-  }
-
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("API declarations must be interfaces.");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+    static <T> T checkNotNull(T object, String message) {
+        if (object == null) {
+            throw new NullPointerException(message);
+        }
+        return object;
     }
-  }
 
-  static Type getParameterUpperBound(int index, ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    if (index < 0 || index >= types.length) {
-      throw new IllegalArgumentException(
-          "Index " + index + " not in range [0," + types.length + ") for " + type);
-    }
-    Type paramType = types[index];
-    if (paramType instanceof WildcardType) {
-      return ((WildcardType) paramType).getUpperBounds()[0];
+    /**
+     * Returns true if {@code annotations} contains an instance of {@code cls}.
+     */
+    static boolean isAnnotationPresent(Annotation[] annotations,
+                                       Class<? extends Annotation> cls) {
+        for (Annotation annotation : annotations) {
+            if (cls.isInstance(annotation)) {
+                return true;
+            }
+        }
+        return false;
     }
-    return paramType;
-  }
 
-  static boolean hasUnresolvableType(Type type) {
-    if (type instanceof Class<?>) {
-      return false;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
-        if (hasUnresolvableType(typeArgument)) {
-          return true;
-        }
-      }
-      return false;
-    }
-    if (type instanceof GenericArrayType) {
-      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
-    }
-    if (type instanceof TypeVariable) {
-      return true;
-    }
-    if (type instanceof WildcardType) {
-      return true;
-    }
-    String className = type == null ? "null" : type.getClass().getName();
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-        + "GenericArrayType, but <" + type + "> is of type " + className);
-  }
-
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-    return getParameterUpperBound(0, (ParameterizedType) returnType);
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
+    static ResponseBody buffer(final ResponseBody body) throws IOException {
+        Buffer buffer = new Buffer();
+        body.source().readAll(buffer);
+        return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
     }
 
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
+    static <T> void validateServiceInterface(Class<T> service) {
+        if (!service.isInterface()) {
+            throw new IllegalArgumentException("API declarations must be interfaces.");
+        }
+        // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+        // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+        // the recommended pattern.
+        if (service.getInterfaces().length > 0) {
+            throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+        }
     }
 
-    @Override public Type getRawType() {
-      return rawType;
+    static Type getParameterUpperBound(int index, ParameterizedType type) {
+        Type[] types = type.getActualTypeArguments();
+        if (index < 0 || index >= types.length) {
+            throw new IllegalArgumentException(
+                    "Index " + index + " not in range [0," + types.length + ") for " + type);
+        }
+        Type paramType = types[index];
+        if (paramType instanceof WildcardType) {
+            return ((WildcardType) paramType).getUpperBounds()[0];
+        }
+        return paramType;
     }
 
-    @Override public Type getOwnerType() {
-      return ownerType;
+    static boolean hasUnresolvableType(Type type) {
+        if (type instanceof Class<?>) {
+            return false;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+                if (hasUnresolvableType(typeArgument)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        if (type instanceof GenericArrayType) {
+            return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+        }
+        if (type instanceof TypeVariable) {
+            return true;
+        }
+        if (type instanceof WildcardType) {
+            return true;
+        }
+        String className = type == null ? "null" : type.getClass().getName();
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + className);
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    static Type getCallResponseType(Type returnType) {
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalArgumentException(
+                    "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+        return getParameterUpperBound(0, (ParameterizedType) returnType);
     }
 
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
-    }
+    private static final class ParameterizedTypeImpl implements ParameterizedType {
+        private final Type ownerType;
+        private final Type rawType;
+        private final Type[] typeArguments;
 
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
-    }
-  }
+        public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+            // Require an owner type if the raw type needs it.
+            if (rawType instanceof Class<?>
+                    && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+                throw new IllegalArgumentException();
+            }
 
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
+            this.ownerType = ownerType;
+            this.rawType = rawType;
+            this.typeArguments = typeArguments.clone();
 
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
+            for (Type typeArgument : this.typeArguments) {
+                if (typeArgument == null) throw new NullPointerException();
+                checkNotPrimitive(typeArgument);
+            }
+        }
 
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
+        @Override
+        public Type[] getActualTypeArguments() {
+            return typeArguments.clone();
+        }
 
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Utils.equals(this, (GenericArrayType) o);
-    }
+        @Override
+        public Type getRawType() {
+            return rawType;
+        }
 
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
+        @Override
+        public Type getOwnerType() {
+            return ownerType;
+        }
 
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+        }
 
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+        }
 
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+        @Override
+        public String toString() {
+            StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+            result.append(typeToString(rawType));
+            if (typeArguments.length == 0) return result.toString();
+            result.append("<").append(typeToString(typeArguments[0]));
+            for (int i = 1; i < typeArguments.length; i++) {
+                result.append(", ").append(typeToString(typeArguments[i]));
+            }
+            return result.append(">").toString();
+        }
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
-    }
+    private static final class GenericArrayTypeImpl implements GenericArrayType {
+        private final Type componentType;
+
+        public GenericArrayTypeImpl(Type componentType) {
+            this.componentType = componentType;
+        }
+
+        @Override
+        public Type getGenericComponentType() {
+            return componentType;
+        }
 
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof GenericArrayType
+                    && Utils.equals(this, (GenericArrayType) o);
+        }
+
+        @Override
+        public int hashCode() {
+            return componentType.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return typeToString(componentType) + "[]";
+        }
     }
 
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
+    /**
+     * The WildcardType interface supports multiple upper bounds and multiple
+     * lower bounds. We only support what the Java 6 language needs - at most one
+     * bound. If a lower bound is set, the upper bound must be Object.class.
+     */
+    private static final class WildcardTypeImpl implements WildcardType {
+        private final Type upperBound;
+        private final Type lowerBound;
+
+        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+            if (lowerBounds.length > 1) throw new IllegalArgumentException();
+            if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+            if (lowerBounds.length == 1) {
+                if (lowerBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(lowerBounds[0]);
+                if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+                this.lowerBound = lowerBounds[0];
+                this.upperBound = Object.class;
+            } else {
+                if (upperBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(upperBounds[0]);
+                this.lowerBound = null;
+                this.upperBound = upperBounds[0];
+            }
+        }
+
+        @Override
+        public Type[] getUpperBounds() {
+            return new Type[]{upperBound};
+        }
+
+        @Override
+        public Type[] getLowerBounds() {
+            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        }
+
+        @Override
+        public String toString() {
+            if (lowerBound != null) return "? super " + typeToString(lowerBound);
+            if (upperBound == Object.class) return "?";
+            return "? extends " + typeToString(upperBound);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 98d1d8684..3ac9822e0 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
diff --git a/retrofit/src/main/java/retrofit2/http/DELETE.java b/retrofit/src/main/java/retrofit2/http/DELETE.java
index 4a2b3e519..2e218fc13 100644
--- a/retrofit/src/main/java/retrofit2/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit2/http/DELETE.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a DELETE request. */
+/**
+ * Make a DELETE request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 4dbd1bf11..918ae4478 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -56,8 +56,10 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Field {
-  String value();
+    String value();
 
-  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index a7eb1ee86..cd9741c50 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -43,6 +43,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
-  /** Specifies whether the names and values are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the names and values are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/GET.java b/retrofit/src/main/java/retrofit2/http/GET.java
index deca1820d..6726b55d2 100644
--- a/retrofit/src/main/java/retrofit2/http/GET.java
+++ b/retrofit/src/main/java/retrofit2/http/GET.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a GET request. */
+/**
+ * Make a GET request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface GET {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HEAD.java b/retrofit/src/main/java/retrofit2/http/HEAD.java
index 077787d4f..474bd29f1 100644
--- a/retrofit/src/main/java/retrofit2/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit2/http/HEAD.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a HEAD request. */
+/**
+ * Make a HEAD request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HEAD {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index 101eecf3b..bd8a74074 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -43,14 +44,16 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HTTP {
-  String method();
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String path() default "";
-  boolean hasBody() default false;
+    String method();
+
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String path() default "";
+
+    boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index b8f7a70ea..958712b6e 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -41,5 +41,5 @@
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Header {
-  String value();
+    String value();
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index b360f3ec3..b1d5ca81e 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -46,5 +46,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface Headers {
-  String[] value();
+    String[] value();
 }
diff --git a/retrofit/src/main/java/retrofit2/http/OPTIONS.java b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
index 17dc085e3..eabc7e3e8 100644
--- a/retrofit/src/main/java/retrofit2/http/OPTIONS.java
+++ b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make an OPTIONS request. */
+/**
+ * Make an OPTIONS request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface OPTIONS {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PATCH.java b/retrofit/src/main/java/retrofit2/http/PATCH.java
index 035276982..4fa2965a9 100644
--- a/retrofit/src/main/java/retrofit2/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit2/http/PATCH.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a PATCH request. */
+/**
+ * Make a PATCH request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PATCH {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/POST.java b/retrofit/src/main/java/retrofit2/http/POST.java
index 34352cd34..a45d1b6d5 100644
--- a/retrofit/src/main/java/retrofit2/http/POST.java
+++ b/retrofit/src/main/java/retrofit2/http/POST.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a POST request. */
+/**
+ * Make a POST request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface POST {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PUT.java b/retrofit/src/main/java/retrofit2/http/PUT.java
index 0d4437f86..3b57a79ee 100644
--- a/retrofit/src/main/java/retrofit2/http/PUT.java
+++ b/retrofit/src/main/java/retrofit2/http/PUT.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a PUT request. */
+/**
+ * Make a PUT request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PUT {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index f320c088f..971435948 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -54,11 +55,14 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Part {
-  /**
-   * The name of the part. Required for all parameter types except
-   * {@link okhttp3.MultipartBody.Part}.
-   */
-  String value() default "";
-  /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default "binary";
+    /**
+     * The name of the part. Required for all parameter types except
+     * {@link okhttp3.MultipartBody.Part}.
+     */
+    String value() default "";
+
+    /**
+     * The {@code Content-Transfer-Encoding} of this part.
+     */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 79eae2147..8f2c39406 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -51,6 +52,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of the parts. */
-  String encoding() default "binary";
+    /**
+     * The {@code Content-Transfer-Encoding} of the parts.
+     */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index 4d8c6f054..eb31d1560 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -50,10 +50,10 @@
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Path {
-  String value();
+    String value();
 
-  /**
-   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
-   */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 01d294f3a..671b8ac38 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -65,11 +65,13 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
-  /** The query parameter name. */
-  String value();
+    /**
+     * The query parameter name.
+     */
+    String value();
 
-  /**
-   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
-   */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 27e6ae836..e955eef5a 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -52,6 +52,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
-  /** Specifies whether parameter names and values are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether parameter names and values are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index 31187ca3d..f2e34c900 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 import retrofit2.Retrofit;
 
diff --git a/retrofit/src/main/java/retrofit2/http/package-info.java b/retrofit/src/main/java/retrofit2/http/package-info.java
index 2777d51b7..13ed7d48d 100644
--- a/retrofit/src/main/java/retrofit2/http/package-info.java
+++ b/retrofit/src/main/java/retrofit2/http/package-info.java
@@ -1,4 +1,6 @@
 // Copyright 2014 Square, Inc.
 
-/** Annotations for interface methods to control the HTTP request behavior. */
+/**
+ * Annotations for interface methods to control the HTTP request behavior.
+ */
 package retrofit2.http;
diff --git a/retrofit/src/test/java/retrofit2/CallAdapterTest.java b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
index d1ed83480..454aa32e7 100644
--- a/retrofit/src/test/java/retrofit2/CallAdapterTest.java
+++ b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
@@ -16,10 +16,12 @@
 package retrofit2;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.Map;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -28,69 +30,78 @@
 import static retrofit2.CallAdapter.Factory.getRawType;
 
 public final class CallAdapterTest {
-  @Test public void parameterizedTypeInvalidIndex() {
-    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    try {
-      getParameterUpperBound(-1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+    @Test
+    public void parameterizedTypeInvalidIndex() {
+        ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {
+        }.getType();
+        try {
+            getParameterUpperBound(-1, listOfString);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+        }
+        try {
+            getParameterUpperBound(1, listOfString);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+        }
     }
-    try {
-      getParameterUpperBound(1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+
+    @Test
+    public void parameterizedTypes() {
+        ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
+
+        ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
+        assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
+
+        ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
     }
-  }
-
-  @Test public void parameterizedTypes() {
-    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
-
-    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
-    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
-
-    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType();
-    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
-  }
-
-  @Test public void rawTypeThrowsOnNull() {
-    try {
-      getRawType(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("type == null");
+
+    @Test
+    public void rawTypeThrowsOnNull() {
+        try {
+            getRawType(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("type == null");
+        }
     }
-  }
 
-  @Test public void rawTypes() throws NoSuchMethodException {
-    assertThat(getRawType(String.class)).isSameAs(String.class);
+    @Test
+    public void rawTypes() throws NoSuchMethodException {
+        assertThat(getRawType(String.class)).isSameAs(String.class);
 
-    Type listOfString = new TypeToken<List<String>>() {}.getType();
-    assertThat(getRawType(listOfString)).isSameAs(List.class);
+        Type listOfString = new TypeToken<List<String>>() {
+        }.getType();
+        assertThat(getRawType(listOfString)).isSameAs(List.class);
 
-    Type stringArray = new TypeToken<String[]>() {}.getType();
-    assertThat(getRawType(stringArray)).isSameAs(String[].class);
+        Type stringArray = new TypeToken<String[]>() {
+        }.getType();
+        assertThat(getRawType(stringArray)).isSameAs(String[].class);
 
-    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
+        Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+        }.getType()).getActualTypeArguments()[0];
+        assertThat(getRawType(wild)).isSameAs(CharSequence.class);
 
-    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wildParam)).isSameAs(List.class);
+        Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
+        }.getType()).getActualTypeArguments()[0];
+        assertThat(getRawType(wildParam)).isSameAs(List.class);
 
-    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
-    assertThat(getRawType(typeVar)).isSameAs(Object.class);
-  }
+        Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
+        assertThat(getRawType(typeVar)).isSameAs(Object.class);
+    }
 
-  @SuppressWarnings("unused") // Used reflectively.
-  static class A<T> {
-    T method() {
-      return null;
+    @SuppressWarnings("unused") // Used reflectively.
+    static class A<T> {
+        T method() {
+            return null;
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index 18dd035af..07e383978 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -21,6 +21,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -50,898 +51,987 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class CallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Call<String> getString();
-    @GET("/") Call<ResponseBody> getBody();
-    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
-    @POST("/") Call<String> postString(@Body String body);
-    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
-  }
-
-  @Test public void http200Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http200Async() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Async() throws InterruptedException, IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void transportProblemSync() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void transportProblemAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Throwable failure = failureRef.get();
-    assertThat(failure).isInstanceOf(IOException.class);
-  }
-
-  @Test public void conversionProblemOutgoingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void conversionProblemIncomingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
-    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient.Builder() //
-        .addInterceptor(new Interceptor() {
-          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-            okhttp3.Response response = chain.proceed(chain.request());
-            ResponseBody body = response.body();
-            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-              @Override public long read(Buffer sink, long byteCount) throws IOException {
-                throw new IOException("cause");
-              }
-            });
-            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-            return response.newBuilder().body(body).build();
-          }
-        }).build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .client(client)
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                try {
-                  return value.string();
-                } catch (IOException e) {
-                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-                  throw new RuntimeException("wrapper", e);
-                }
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("cause");
-    }
-  }
-
-  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(204);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(205);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void executeCallOnce() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-    server.enqueue(new MockResponse());
-    Call<String> call = example.getString();
-    call.execute();
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Already executed.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("1234"));
-
-    Response<ResponseBody> response = example.getBody().execute();
-    assertThat(response.body().string()).isEqualTo("1234");
-  }
-
-  @Test public void responseBodyBuffers() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call<ResponseBody> buffered = example.getBody();
-    // When buffering we will detect all socket problems before returning the Response.
-    try {
-      buffered.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void responseBodyStreams() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Response<ResponseBody> response = example.getStreamingBody().execute();
-
-    ResponseBody streamedBody = response.body();
-    // When streaming we only detect socket problems as the ResponseBody is read.
-    try {
-      streamedBody.string();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(2);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
-    try {
-      rawBody.source();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
-    }
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(0);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
-  }
-
-  @Test public void reportsExecutedSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.execute();
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void reportsExecutedAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {}
-      @Override public void onFailure(Call<String> call, Throwable t) {}
-    });
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void cancelBeforeExecute() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Canceled");
-    }
-  }
-
-  @Test public void cancelBeforeEnqueue() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).hasMessage("Canceled");
-  }
-
-  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-    server.enqueue(new MockResponse().setBody("Hello"));
-
-    Call<String> call = service.getString();
-    assertThat(call.execute().body()).isEqualTo("Hi");
-
-    Call<String> cloned = call.clone();
-    assertThat(cloned.execute().body()).isEqualTo("Hello");
-  }
-
-  @Test public void cancelRequest() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    Call<String> call = service.getString();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
-  }
-
-  @Test public void requestBeforeExecuteCreates() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Call<String> getString();
+
+        @GET("/")
+        Call<ResponseBody> getBody();
+
+        @GET("/")
+        @Streaming
+        Call<ResponseBody> getStreamingBody();
+
+        @POST("/")
+        Call<String> postString(@Body String body);
+
+        @POST("/{a}")
+        Call<String> postRequestBody(@Path("a") Object a);
+    }
+
+    @Test
+    public void http200Sync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http200Async() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Response<String> response = responseRef.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http404Sync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.code()).isEqualTo(404);
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http404Async() throws InterruptedException, IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Response<String> response = responseRef.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.code()).isEqualTo(404);
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void transportProblemSync() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+        Call<String> call = example.getString();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException ignored) {
+        }
+    }
+
+    @Test
+    public void transportProblemAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Throwable failure = failureRef.get();
+        assertThat(failure).isInstanceOf(IOException.class);
+    }
+
+    @Test
+    public void conversionProblemOutgoingSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+                                                                          Retrofit retrofit) {
+                        return new Converter<String, RequestBody>() {
+                            @Override
+                            public RequestBody convert(String value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        Call<String> call = example.postString("Hi");
+        try {
+            call.execute();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertThat(e).hasMessage("I am broken!");
+        }
+    }
+
+    @Test
+    public void conversionProblemOutgoingAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+                                                                          Retrofit retrofit) {
+                        return new Converter<String, RequestBody>() {
+                            @Override
+                            public RequestBody convert(String value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.postString("Hi").enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+                .hasMessage("I am broken!");
+    }
+
+    @Test
+    public void conversionProblemIncomingSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.postString("Hi");
+        try {
+            call.execute();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertThat(e).hasMessage("I am broken!");
+        }
+    }
+
+    @Test
+    public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
+        // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
+        OkHttpClient client = new OkHttpClient.Builder() //
+                .addInterceptor(new Interceptor() {
+                    @Override
+                    public okhttp3.Response intercept(Chain chain) throws IOException {
+                        okhttp3.Response response = chain.proceed(chain.request());
+                        ResponseBody body = response.body();
+                        BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+                            @Override
+                            public long read(Buffer sink, long byteCount) throws IOException {
+                                throw new IOException("cause");
+                            }
+                        });
+                        body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+                        return response.newBuilder().body(body).build();
+                    }
+                }).build();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .client(client)
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                try {
+                                    return value.string();
+                                } catch (IOException e) {
+                                    // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                                    throw new RuntimeException("wrapper", e);
+                                }
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("cause");
+        }
+    }
+
+    @Test
+    public void conversionProblemIncomingAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.postString("Hi").enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+                .hasMessage("I am broken!");
+    }
+
+    @Test
+    public void http204SkipsConverter() throws IOException {
+        final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return converter;
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.code()).isEqualTo(204);
+        assertThat(response.body()).isNull();
+        verifyNoMoreInteractions(converter);
+    }
+
+    @Test
+    public void http205SkipsConverter() throws IOException {
+        final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return converter;
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.code()).isEqualTo(205);
+        assertThat(response.body()).isNull();
+        verifyNoMoreInteractions(converter);
+    }
+
+    @Test
+    public void executeCallOnce() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+        server.enqueue(new MockResponse());
+        Call<String> call = example.getString();
+        call.execute();
+        try {
+            call.execute();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Already executed.");
+        }
+    }
+
+    @Test
+    public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("1234"));
+
+        Response<ResponseBody> response = example.getBody().execute();
+        assertThat(response.body().string()).isEqualTo("1234");
+    }
+
+    @Test
+    public void responseBodyBuffers() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse()
+                .setBody("1234")
+                .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+        Call<ResponseBody> buffered = example.getBody();
+        // When buffering we will detect all socket problems before returning the Response.
+        try {
+            buffered.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("unexpected end of stream");
+        }
+    }
+
+    @Test
+    public void responseBodyStreams() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse()
+                .setBody("1234")
+                .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+        Response<ResponseBody> response = example.getStreamingBody().execute();
+
+        ResponseBody streamedBody = response.body();
+        // When streaming we only detect socket problems as the ResponseBody is read.
+        try {
+            streamedBody.string();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("unexpected end of stream");
+        }
+    }
+
+    @Test
+    public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("Hi");
+        ResponseBody rawBody = response.raw().body();
+        assertThat(rawBody.contentLength()).isEqualTo(2);
+        assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
+        try {
+            rawBody.source();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
+        }
+    }
+
+    @Test
+    public void emptyResponse() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("");
+        ResponseBody rawBody = response.raw().body();
+        assertThat(rawBody.contentLength()).isEqualTo(0);
+        assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
+    }
+
+    @Test
+    public void reportsExecutedSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        assertThat(call.isExecuted()).isFalse();
+
+        call.execute();
+        assertThat(call.isExecuted()).isTrue();
+    }
+
+    @Test
+    public void reportsExecutedAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        assertThat(call.isExecuted()).isFalse();
+
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertThat(call.isExecuted()).isTrue();
+    }
+
+    @Test
+    public void cancelBeforeExecute() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+        Call<String> call = service.getString();
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Canceled");
+        }
+    }
+
+    @Test
+    public void cancelBeforeEnqueue() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+        Call<String> call = service.getString();
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).hasMessage("Canceled");
+    }
+
+    @Test
+    public void cloningExecutedRequestDoesNotCopyState() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+        server.enqueue(new MockResponse().setBody("Hello"));
+
+        Call<String> call = service.getString();
+        assertThat(call.execute().body()).isEqualTo("Hi");
+
+        Call<String> cloned = call.clone();
+        assertThat(cloned.execute().body()).isEqualTo("Hello");
+    }
+
+    @Test
+    public void cancelRequest() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+        Call<String> call = service.getString();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+    }
+
+    @Test
+    public void requestBeforeExecuteCreates() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.request();
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
-      throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+
+        call.execute();
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
+    }
+
+    @Test
+    public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
+    }
+
+    @Test
+    public void requestAfterExecuteReturnsCachedValue() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.execute();
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+    }
+
+    @Test
+    public void requestThrowingBeforeEnqueueFailsEnqueue()
+            throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+    }
+
+    @Test
+    public void requestAfterEnqueueReturnsCachedValue() throws IOException,
+            InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterEnqueueFailingThrows() throws IOException,
+            InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index 24b871052..c403697c3 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -16,11 +16,13 @@
 package retrofit2;
 
 import com.google.common.reflect.TypeToken;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 import org.junit.Test;
 
@@ -34,137 +36,164 @@
 
 @SuppressWarnings("unchecked")
 public final class ExecutorCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final Retrofit retrofit = new Retrofit.Builder()
-      .baseUrl("http://localhost:1")
-      .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
-    }
-  });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
-
-  @Test public void rawTypeThrows() {
-    try {
-      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-  }
-
-  @Test public void responseType() {
-    Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-  }
-
-  @Test public void adaptedCallExecute() throws IOException {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
-        return response;
-      }
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+    private final Retrofit retrofit = new Retrofit.Builder()
+            .baseUrl("http://localhost:1")
+            .build();
+    private final Callback<String> callback = mock(Callback.class);
+    private final Executor callbackExecutor = spy(new Executor() {
+        @Override
+        public void execute(Runnable runnable) {
+            runnable.run();
+        }
     });
-    assertThat(call.execute()).isSameAs(response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(call, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(call, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  @Test public void adaptedCallCancel() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  static class EmptyCall implements Call<String> {
-    @Override public void enqueue(Callback<String> callback) {
-      throw new UnsupportedOperationException();
+    private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
+
+    @Test
+    public void rawTypeThrows() {
+        try {
+            factory.get(Call.class, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+    }
+
+    @Test
+    public void responseType() {
+        Type classType = new TypeToken<Call<String>>() {
+        }.getType();
+        assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type wilcardType = new TypeToken<Call<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type genericType = new TypeToken<Call<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
     }
 
-    @Override public boolean isExecuted() {
-      return false;
+    @Test
+    public void adaptedCallExecute() throws IOException {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Response<String> response = Response.success("Hi");
+        Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+            @Override
+            public Response<String> execute() throws IOException {
+                return response;
+            }
+        });
+        assertThat(call.execute()).isSameAs(response);
     }
 
-    @Override public Response<String> execute() throws IOException {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Response<String> response = Response.success("Hi");
+        EmptyCall originalCall = new EmptyCall() {
+            @Override
+            public void enqueue(Callback<String> callback) {
+                callback.onResponse(this, response);
+            }
+        };
+        Call<String> call = (Call<String>) adapter.adapt(originalCall);
+        call.enqueue(callback);
+        verify(callbackExecutor).execute(any(Runnable.class));
+        verify(callback).onResponse(call, response);
     }
 
-    @Override public void cancel() {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Throwable throwable = new IOException();
+        EmptyCall originalCall = new EmptyCall() {
+            @Override
+            public void enqueue(Callback<String> callback) {
+                callback.onFailure(this, throwable);
+            }
+        };
+        Call<String> call = (Call<String>) adapter.adapt(originalCall);
+        call.enqueue(callback);
+        verify(callbackExecutor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(callbackExecutor);
+        verify(callback).onFailure(call, throwable);
+        verifyNoMoreInteractions(callback);
     }
 
-    @Override public boolean isCanceled() {
-      return false;
+    @Test
+    public void adaptedCallCloneDeepCopy() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        Call<String> delegate = mock(Call.class);
+        Call<String> call = (Call<String>) adapter.adapt(delegate);
+        Call<String> cloned = call.clone();
+        assertThat(cloned).isNotSameAs(call);
+        verify(delegate).clone();
+        verifyNoMoreInteractions(delegate);
     }
 
-    @Override public Call<String> clone() {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallCancel() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        Call<String> delegate = mock(Call.class);
+        Call<String> call = (Call<String>) adapter.adapt(delegate);
+        call.cancel();
+        verify(delegate).cancel();
+        verifyNoMoreInteractions(delegate);
     }
 
-    @Override public Request request() {
-      throw new UnsupportedOperationException();
+    static class EmptyCall implements Call<String> {
+        @Override
+        public void enqueue(Callback<String> callback) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isExecuted() {
+            return false;
+        }
+
+        @Override
+        public Response<String> execute() throws IOException {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void cancel() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isCanceled() {
+            return false;
+        }
+
+        @Override
+        public Call<String> clone() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Request request() {
+            throw new UnsupportedOperationException();
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
index 8333969c6..3d6647329 100644
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -17,29 +17,29 @@
 
 // TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
 public final class Java8DefaultMethodsTest {
-  //@Rule public final MockWebServer server = new MockWebServer();
-  //
-  //interface Example {
-  //  @GET("/") Call<String> user(@Query("name") String name);
-  //
-  //  default Call<String> user() {
-  //    return user("hey");
-  //  }
-  //}
-  //
-  //@Test public void test() throws IOException {
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //
-  //  Retrofit retrofit = new Retrofit.Builder()
-  //      .baseUrl(server.url("/"))
-  //      .addConverterFactory(new ToStringConverterFactory())
-  //      .build();
-  //  Example example = retrofit.create(Example.class);
-  //
-  //  Response<String> response = example.user().execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //}
+    //@Rule public final MockWebServer server = new MockWebServer();
+    //
+    //interface Example {
+    //  @GET("/") Call<String> user(@Query("name") String name);
+    //
+    //  default Call<String> user() {
+    //    return user("hey");
+    //  }
+    //}
+    //
+    //@Test public void test() throws IOException {
+    //  server.enqueue(new MockResponse().setBody("Hi"));
+    //  server.enqueue(new MockResponse().setBody("Hi"));
+    //
+    //  Retrofit retrofit = new Retrofit.Builder()
+    //      .baseUrl(server.url("/"))
+    //      .addConverterFactory(new ToStringConverterFactory())
+    //      .build();
+    //  Example example = retrofit.create(Example.class);
+    //
+    //  Response<String> response = example.user().execute();
+    //  assertThat(response.body()).isEqualTo("Hi");
+    //  Response<String> response = example.user("hi").execute();
+    //  assertThat(response.body()).isEqualTo("Hi");
+    //}
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
index 63fa57b6c..915032b45 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
@@ -30,33 +30,35 @@
 @RunWith(RobolectricTestRunner.class)
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestBuilderAndroidTest {
-  @Test public void getWithAndroidUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
+    @Test
+    public void getWithAndroidUriUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Uri url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
     }
 
-    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
+    @Test
+    public void getWithAndroidUriUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Uri url) {
+                return null;
+            }
+        }
 
-  @Test public void getWithAndroidUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
+        Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
     }
-
-    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 042e08fd1..b911bcebb 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.MultipartBody;
@@ -65,2431 +66,2679 @@
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
-
-  @Test public void customMethodNoBody() {
-    class Example {
-      @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodWithBody() {
-    class Example {
-      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
-    class Example {
-      @GET("/foo?bar={bar}") //
-      Call<ResponseBody> method(@Path("bar") String thing) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body @Query("nope") String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @interface NonNull {}
-
-  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "yep");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
-    }
-  }
-
-  @Test public void lackingMethod() {
-    class Example {
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Part("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartWithPartMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@PartMap Map<String, String> params) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Field("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") //
-      @Headers({}) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenMalformed() {
-    class Example {
-      @GET("/") //
-      @Headers("Malformed") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") //
-      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(String a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapMustBeAMap() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
-  }
-
-  @Test public void queryMapRejectsNull() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullKeys() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullValues() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put("kit", null);
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void getWithHeaderMap() {
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
-        return null;
-      }
+    private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+
+    @Test
+    public void customMethodNoBody() {
+        class Example {
+            @HTTP(method = "CUSTOM1", path = "/foo")
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("CUSTOM1");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+        assertThat(request.body()).isNull();
+    }
+
+    @Ignore("https://github.com/square/okhttp/issues/229")
+    @Test
+    public void customMethodWithBody() {
+        class Example {
+            @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("CUSTOM2");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void onlyOneEncodingIsAllowedMultipartFirst() {
+        class Example {
+            @Multipart //
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one encoding annotation is allowed.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+        class Example {
+            @FormUrlEncoded //
+            @Multipart //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one encoding annotation is allowed.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void invalidPathParam() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Path("hey!") String thing) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+                            + " Found: hey! (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void pathParamNotAllowedInQuery() throws Exception {
+        class Example {
+            @GET("/foo?bar={bar}")
+                //
+            Call<ResponseBody> method(@Path("bar") String thing) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "URL query string \"bar={bar}\" must not have replace block."
+                            + " For dynamic query parameters use @Query.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipleParameterAnnotationsNotAllowed() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Body @Query("nope") String o) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @interface NonNull {
+    }
+
+    @Test
+    public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "yep");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
+    }
+
+    @Test
+    public void twoMethodsFail() {
+        class Example {
+            @PATCH("/foo") //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void lackingMethod() {
+        class Example {
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitMultipartForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Part("a") int a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitMultipartWithPartMapForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, String> params) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartFailsOnNonBodyMethod() {
+        class Example {
+            @Multipart //
+            @GET("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartFailsWithNoParts() {
+        class Example {
+            @Multipart //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multipart method must contain at least one @Part.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitFormEncodingByFieldForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Field("a") int a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitFormEncodingByFieldMapForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void formEncodingFailsOnNonBodyMethod() {
+        class Example {
+            @FormUrlEncoded //
+            @GET("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void formEncodingFailsWithNoParts() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headersFailWhenEmptyOnMethod() {
+        class Example {
+            @GET("/") //
+            @Headers({})
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headersFailWhenMalformed() {
+        class Example {
+            @GET("/") //
+            @Headers("Malformed")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void pathParamNonPathParamAndTypedBytes() {
+        class Example {
+            @PUT("/{a}")
+                //
+            Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void parameterWithoutAnnotation() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(String a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void nonBodyHttpMethodWithSingleEntity() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Body String o) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void queryMapMustBeAMap() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap List<String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void queryMapSupportsSubclasses() {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Foo a) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+    }
+
+    @Test
+    public void queryMapRejectsNull() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map was null.");
+        }
+    }
+
+    @Test
+    public void queryMapRejectsNullKeys() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        Map<String, String> queryParams = new LinkedHashMap<>();
+        queryParams.put("ping", "pong");
+        queryParams.put(null, "kat");
+
+        try {
+            buildRequest(Example.class, queryParams);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map contained null key.");
+        }
+    }
+
+    @Test
+    public void queryMapRejectsNullValues() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        Map<String, String> queryParams = new LinkedHashMap<>();
+        queryParams.put("ping", "pong");
+        queryParams.put("kit", null);
+
+        try {
+            buildRequest(Example.class, queryParams);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+        }
+    }
+
+    @Test
+    public void getWithHeaderMap() {
+        class Example {
+            @GET("/search")
+            Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+                return null;
+            }
+        }
+
+        Map<String, Object> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put("Accept-Charset", "utf-8");
+
+        Request request = buildRequest(Example.class, headers);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+        assertThat(request.body()).isNull();
+        assertThat(request.headers().size()).isEqualTo(2);
+        assertThat(request.header("Accept")).isEqualTo("text/plain");
+        assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+    }
+
+    @Test
+    public void headerMapMustBeAMap() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap List<String> headers) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headerMapSupportsSubclasses() {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @GET("/search")
+            Call<ResponseBody> method(@HeaderMap Foo headers) {
+                return null;
+            }
+        }
+
+        Foo headers = new Foo();
+        headers.put("Accept", "text/plain");
+
+        Request request = buildRequest(Example.class, headers);
+        assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+        assertThat(request.headers().size()).isEqualTo(1);
+        assertThat(request.header("Accept")).isEqualTo("text/plain");
+    }
+
+    @Test
+    public void headerMapRejectsNull() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, (Map<String, String>) null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map was null.");
+        }
+    }
+
+    @Test
+    public void headerMapRejectsNullKeys() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        Map<String, String> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put(null, "utf-8");
+
+        try {
+            buildRequest(Example.class, headers);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map contained null key.");
+        }
+    }
+
+    @Test
+    public void headerMapRejectsNullValues() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        Map<String, String> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put("Accept-Charset", null);
+
+        try {
+            buildRequest(Example.class, headers);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+        }
+    }
+
+    @Test
+    public void twoBodies() {
+        class Example {
+            @PUT("/")
+                //
+            Call<ResponseBody> method(@Body String o1, @Body String o2) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void bodyInNonBodyRequest() {
+        class Example {
+            @Multipart //
+            @PUT("/")
+                //
+            Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void get() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void delete() {
+        class Example {
+            @DELETE("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("DELETE");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertNull(request.body());
+    }
+
+    @Test
+    public void head() {
+        class Example {
+            @HEAD("/foo/bar/")
+                //
+            Call<Void> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("HEAD");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headWithoutVoidThrows() {
+        class Example {
+            @HEAD("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "HEAD method must use Void as response type.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void post() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void put() {
+        class Example {
+            @PUT("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("PUT");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void patch() {
+        class Example {
+            @PATCH("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("PATCH");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void options() {
+        class Example {
+            @OPTIONS("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("OPTIONS");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "po ng");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUnusedAndInvalidNamedPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/{kit,kat}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "po%20ng");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathSegments() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/pong/more");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathStillPreventsRequestSplitting() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/\r\npong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void pathParamRequired() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+        }
+    }
+
+    @Test
+    public void getWithQueryParam() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedQueryParam() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "p%20o%20n%20g");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void queryParamOptionalOmitsQuery() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, new Object[]{null});
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    }
+
+    @Test
+    public void queryParamOptional() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
+                                      @Query("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", null, "kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+    }
+
+    @Test
+    public void getWithQueryUrlAndParam() {
+        class Example {
+            @GET("/foo/bar/?hi=mom")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQuery() {
+        class Example {
+            @GET("/foo/bar/?hi=mom")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
+                                      @Query("riff") String riff) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", "kat", "raff");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryThenPathThrows() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "kat", "pong");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithPathAndQueryQuestionMarkParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong?", "kat?");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryAmpersandParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong&", "kat&");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryHashParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong#", "kat#");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamList() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") List<Object> keys) {
+                return null;
+            }
+        }
+
+        List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+        Request request = buildRequest(Example.class, values);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") Object[] keys) {
+                return null;
+            }
+        }
+
+        Object[] values = {1, 2, null, "three"};
+        Request request = buildRequest(Example.class, new Object[]{values});
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamPrimitiveArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") int[] keys) {
+                return null;
+            }
+        }
+
+        int[] values = {1, 2, 3};
+        Request request = buildRequest(Example.class, new Object[]{values});
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamMap() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
+                return null;
+            }
+        }
+
+        Map<String, Object> params = new LinkedHashMap<>();
+        params.put("kit", "kat");
+        params.put("ping", "pong");
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedQueryParamMap() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
+                return null;
+            }
+        }
+
+        Map<String, Object> params = new LinkedHashMap<>();
+        params.put("kit", "k%20t");
+        params.put("pi%20ng", "p%20g");
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getAbsoluteUrl() {
+        class Example {
+            @GET("http://example2.com/foo/bar/")
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithStringUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithJavaUriUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url URI url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, URI.create("foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithStringUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithJavaUriUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url URI url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUrlAbsoluteSameHost() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithHttpUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url HttpUrl url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithNullUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url HttpUrl url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, (HttpUrl) null);
+            fail();
+        } catch (NullPointerException expected) {
+            assertThat(expected).hasMessage("@Url parameter is null.");
+        }
+    }
+
+    @Test
+    public void getWithNonStringUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+                            + " (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getUrlAndUrlParamThrows() {
+        class Example {
+            @GET("foo/bar")
+            Call<ResponseBody> method(@Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithoutUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithUrlThenPathThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithPathThenUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithQueryThenUrlThrows() {
+        class Example {
+            @GET("foo/bar")
+            Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "hey", "foo/bar/");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithUrlThenQuery() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "foo/bar/", "hey!");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+    }
+
+    @Test
+    public void postWithUrl() {
+        class Example {
+            @POST
+            Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void normalPostWithPathParam() {
+        class Example {
+            @POST("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+        Request request = buildRequest(Example.class, "pong", body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
+        assertBody(request.body(), "Hi!");
+    }
+
+    @Test
+    public void emptyBody() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "");
+    }
+
+    @Ignore("https://github.com/square/okhttp/issues/229")
+    @Test
+    public void customMethodEmptyBody() {
+        class Example {
+            @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true)
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("CUSTOM");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "");
+    }
+
+    @Test
+    public void bodyResponseBody() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void bodyRequired() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+        }
+    }
+
+    @Test
+    public void bodyWithPathParams() {
+        class Example {
+            @POST("/foo/bar/{ping}/{kit}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+        Request request = buildRequest(Example.class, "pong", body, "kat");
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+        assertBody(request.body(), "Hi!");
+    }
+
+    @Test
+    public void simpleMultipart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", RequestBody.create(
+                MediaType.parse("text/plain"), "kat"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartArray() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String[] ping) {
+                return null;
+            }
+        }
+
+        Request request =
+                buildRequest(Example.class, new Object[]{new String[]{"pong1", "pong2"}});
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong1\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong2\r\n--");
+    }
+
+    @Test
+    public void multipartRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part RequestBody part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartIterableRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part List<RequestBody> part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartArrayRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part RequestBody[] part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartOkHttpPartForbidsName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartOkHttpPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
+        Request request = buildRequest(Example.class, part);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpIterablePart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+        MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+        Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"foo\"\r\n")
+                .contains("\r\nbar\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpArrayPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+        MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+        Request request =
+                buildRequest(Example.class, new Object[]{new MultipartBody.Part[]{part1, part2}});
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"foo\"\r\n")
+                .contains("\r\nbar\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpPartWithFilename() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part =
+                MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+        Request request = buildRequest(Example.class, part);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartIterable() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") List<String> ping) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong1\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong2\r\n--");
+    }
+
+    @Test
+    public void multipartIterableOkHttpPart() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartArrayOkHttpPart() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartWithEncoding() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
+                                      @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", RequestBody.create(
+                MediaType.parse("text/plain"), "kat"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("Content-Transfer-Encoding: 7-bit")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMap() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", RequestBody.create(null, "kat"));
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMapWithEncoding() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", RequestBody.create(null, "kat"));
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMapRejectsNonStringKeys() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsOkHttpPartValues() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNull() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map was null.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNullKeys() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put(null, RequestBody.create(null, "kat"));
+
+        try {
+            buildRequest(Example.class, params);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map contained null key.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNullValues() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", null);
+
+        try {
+            buildRequest(Example.class, params);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapMustBeMap() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap List<Object> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, Collections.emptyList());
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapSupportsSubclasses() throws IOException {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Foo parts) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        Buffer buffer = new Buffer();
+        request.body().writeTo(buffer);
+        assertThat(buffer.readUtf8())
+                .contains("name=\"hello\"")
+                .contains("\r\n\r\nworld\r\n--");
+    }
+
+    @Test
+    public void multipartNullRemovesPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong", null);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong\r\n--");
+    }
+
+    @Test
+    public void multipartPartOptional() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") RequestBody ping) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+        }
+    }
+
+    @Test
+    public void simpleFormEncoded() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", "pong");
+        assertBody(request.body(), "foo=bar&ping=pong");
+    }
+
+    @Test
+    public void formEncodedWithEncodedNameFieldParam() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "ba%20r");
+        assertBody(request.body(), "na%20me=ba%20r");
+    }
+
+    @Test
+    public void formEncodedFieldOptional() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
+                                      @Field("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", null, "kat");
+        assertBody(request.body(), "foo=bar&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldList() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldArray() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        Object[] values = {1, 2, null, "three"};
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldPrimitiveArray() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        int[] values = {1, 2, 3};
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+    }
+
+    @Test
+    public void formEncodedWithEncodedNameFieldParamMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("k%20it", "k%20at");
+        fieldMap.put("pin%20g", "po%20ng");
+
+        Request request = buildRequest(Example.class, fieldMap);
+        assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+    }
+
+    @Test
+    public void formEncodedFieldMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put("ping", "pong");
+
+        Request request = buildRequest(Example.class, fieldMap);
+        assertBody(request.body(), "kit=kat&ping=pong");
+    }
+
+    @Test
+    public void fieldMapRejectsNull() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map was null.");
+        }
+    }
+
+    @Test
+    public void fieldMapRejectsNullKeys() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put(null, "pong");
+
+        try {
+            buildRequest(Example.class, fieldMap);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map contained null key.");
+        }
+    }
+
+    @Test
+    public void fieldMapRejectsNullValues() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put("foo", null);
+
+        try {
+            buildRequest(Example.class, fieldMap);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+        }
+    }
+
+    @Test
+    public void fieldMapMustBeAMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap List<String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void fieldMapSupportsSubclasses() throws IOException {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Foo a) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        Buffer buffer = new Buffer();
+        request.body().writeTo(buffer);
+        assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+    }
+
+    @Test
+    public void simpleHeaders() {
+        class Example {
+            @GET("/foo/bar/")
+            @Headers({
+                    "ping: pong",
+                    "kit: kat"
+            })
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.get("ping")).isEqualTo("pong");
+        assertThat(headers.get("kit")).isEqualTo("kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamToString() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("kit") BigInteger kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, new BigInteger("1234"));
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(1);
+        assertThat(headers.get("kit")).isEqualTo("1234");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParam() {
+        class Example {
+            @GET("/foo/bar/") //
+            @Headers("ping: pong")
+                //
+            Call<ResponseBody> method(@Header("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "kat");
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.get("ping")).isEqualTo("pong");
+        assertThat(headers.get("kit")).isEqualTo("kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamList() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("foo") List<String> kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.values("foo")).containsExactly("bar", "baz");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("foo") String[] kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, (Object) new String[]{"bar", null, "baz"});
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.values("foo")).containsExactly("bar", "baz");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void contentTypeAnnotationHeaderOverrides() {
+        class Example {
+            @POST("/") //
+            @Headers("Content-Type: text/not-plain")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
+        class Example {
+            @DELETE("/") //
+            @Headers("Content-Type: text/not-plain")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void contentTypeParameterHeaderOverrides() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+        Request request = buildRequest(Example.class, "text/not-plain", body);
+        assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void malformedAnnotationRelativeUrlThrows() {
+        class Example {
+            @GET("ftp://example.org")
+            Call<ResponseBody> get() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+        }
+    }
+
+    @Test
+    public void malformedParameterRelativeUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> get(@Url String relativeUrl) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, "ftp://example.org");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+        }
+    }
+
+    private static void assertBody(RequestBody body, String expected) {
+        assertThat(body).isNotNull();
+        Buffer buffer = new Buffer();
+        try {
+            body.writeTo(buffer);
+            assertThat(buffer.readUtf8()).isEqualTo(expected);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    static Request buildRequest(Class<?> cls, Object... args) {
+        final AtomicReference<Request> requestRef = new AtomicReference<>();
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                requestRef.set(request);
+                throw new UnsupportedOperationException("Not implemented");
+            }
+        };
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(new ToStringConverterFactory())
+                .callFactory(callFactory)
+                .build();
+
+        Method method = TestingUtils.onlyMethod(cls);
+        ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
+        OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+        Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
+        try {
+            call.execute();
+            throw new AssertionError();
+        } catch (UnsupportedOperationException ignored) {
+            return requestRef.get();
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new AssertionError(e);
+        }
     }
-
-    Map<String, Object> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", "utf-8");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.body()).isNull();
-    assertThat(request.headers().size()).isEqualTo(2);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
-  }
-
-  @Test public void headerMapMustBeAMap() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap List<String> headers) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void headerMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Foo headers) {
-        return null;
-      }
-    }
-
-    Foo headers = new Foo();
-    headers.put("Accept", "text/plain");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.headers().size()).isEqualTo(1);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-  }
-
-  @Test public void headerMapRejectsNull() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (Map<String, String>) null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullKeys() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put(null, "utf-8");
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullValues() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", null);
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
-    }
-  }
-
-  @Test public void twoBodies() {
-    class Example {
-      @PUT("/") //
-      Call<ResponseBody> method(@Body String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void get() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void delete() {
-    class Example {
-      @DELETE("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("DELETE");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertNull(request.body());
-  }
-
-  @Test public void head() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<Void> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("HEAD");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headWithoutVoidThrows() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HEAD method must use Void as response type.\n    for method Example.method");
-    }
-  }
-
-  @Test public void post() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void put() {
-    class Example {
-      @PUT("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void patch() {
-    class Example {
-      @PATCH("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PATCH");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void options() {
-    class Example {
-      @OPTIONS("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("OPTIONS");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnusedAndInvalidNamedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathSegments() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/pong/more");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\npong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void pathParamRequired() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
-    }
-  }
-
-  @Test public void getWithQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p%20o%20n%20g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void queryParamOptionalOmitsQuery() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void queryParamOptional() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
-          @Query("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQuery() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
-          @Query("riff") String riff) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", "kat", "raff");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryThenPathThrows() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "kat", "pong");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong?", "kat?");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong&", "kat&");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong#", "kat#");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") List<Object> keys) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
-    Request request = buildRequest(Example.class, values);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") Object[] keys) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamPrimitiveArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") int[] keys) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "kat");
-    params.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "k%20t");
-    params.put("pi%20ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getAbsoluteUrl() {
-    class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUrlAbsoluteSameHost() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithHttpUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithNullUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (HttpUrl) null);
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
-    }
-  }
-
-  @Test public void getWithNonStringUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
-              + " (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void getUrlAndUrlParamThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithoutUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenPathThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathThenUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithQueryThenUrlThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "hey", "foo/bar/");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenQuery() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
-  }
-
-  @Test public void postWithUrl() {
-    class Example {
-      @POST
-      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void normalPostWithPathParam() {
-    class Example {
-      @POST("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void emptyBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodEmptyBody() {
-    class Example {
-      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Test public void bodyResponseBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void bodyRequired() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
-    }
-  }
-
-  @Test public void bodyWithPathParams() {
-    class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body, "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void simpleMultipart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartArray() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String[] ping) {
-        return null;
-      }
-    }
-
-    Request request =
-        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartIterableRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<RequestBody> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPartForbidsName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpIterablePart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpArrayPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request =
-        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpPartWithFilename() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part =
-        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartIterable() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<String> ping) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartIterableOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMap() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapRejectsNonStringKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsOkHttpPartValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNull() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put(null, RequestBody.create(null, "kat"));
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", null);
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void multipartPartMapMustBeMap() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap List<Object> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, Collections.emptyList());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Foo parts) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8())
-        .contains("name=\"hello\"")
-        .contains("\r\n\r\nworld\r\n--");
-  }
-
-  @Test public void multipartNullRemovesPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong", null);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong\r\n--");
-  }
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba%20r");
-    assertBody(request.body(), "na%20me=ba%20r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertBody(request.body(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("k%20it", "k%20at");
-    fieldMap.put("pin%20g", "po%20ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNull() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullValues() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void fieldMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
-  }
-
-  @Test public void simpleHeaders() {
-    class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamToString() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new BigInteger("1234"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Call<ResponseBody> method(@Header("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") List<String> kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") String[] kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void contentTypeAnnotationHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeParameterHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
-    Request request = buildRequest(Example.class, "text/not-plain", body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedAnnotationRelativeUrlThrows() {
-    class Example {
-      @GET("ftp://example.org")
-      Call<ResponseBody> get() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  @Test public void malformedParameterRelativeUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> get(@Url String relativeUrl) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, "ftp://example.org");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  private static void assertBody(RequestBody body, String expected) {
-    assertThat(body).isNotNull();
-    Buffer buffer = new Buffer();
-    try {
-      body.writeTo(buffer);
-      assertThat(buffer.readUtf8()).isEqualTo(expected);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static Request buildRequest(Class<?> cls, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
-        throw new UnsupportedOperationException("Not implemented");
-      }
-    };
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
-
-    Method method = TestingUtils.onlyMethod(cls);
-    ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
-    OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 3d059b8ad..3d2f8ce06 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -24,158 +24,172 @@
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
-  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
-      .code(200)
-      .message("OK")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
-      .code(400)
-      .message("Broken!")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-
-  @Test public void success() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successNullAllowed() {
-    Response<Object> response = Response.success(null);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void successWithHeaders() {
-    Object body = new Object();
-    Headers headers = Headers.of("foo", "bar");
-    Response<Object> response = Response.success(body, headers);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullHeadersThrows() {
-    try {
-      Response.success("", (okhttp3.Headers) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("headers == null");
+    private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
+            .code(200)
+            .message("OK")
+            .protocol(Protocol.HTTP_1_1)
+            .request(new okhttp3.Request.Builder().url("http://localhost").build())
+            .build();
+    private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
+            .code(400)
+            .message("Broken!")
+            .protocol(Protocol.HTTP_1_1)
+            .request(new okhttp3.Request.Builder().url("http://localhost").build())
+            .build();
+
+    @Test
+    public void success() {
+        Object body = new Object();
+        Response<Object> response = Response.success(body);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
     }
-  }
-
-  @Test public void successWithRawResponse() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body, successResponse);
-    assertThat(response.raw()).isSameAs(successResponse);
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullRawResponseThrows() {
-    try {
-      Response.success("", (okhttp3.Response) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
+
+    @Test
+    public void successNullAllowed() {
+        Response<Object> response = Response.success(null);
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isNull();
+    }
+
+    @Test
+    public void successWithHeaders() {
+        Object body = new Object();
+        Headers headers = Headers.of("foo", "bar");
+        Response<Object> response = Response.success(body, headers);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successWithNullHeadersThrows() {
+        try {
+            Response.success("", (okhttp3.Headers) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("headers == null");
+        }
     }
-  }
-
-  @Test public void successWithErrorRawResponseThrows() {
-    try {
-      Response.success("", errorResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse must be successful response");
+
+    @Test
+    public void successWithRawResponse() {
+        Object body = new Object();
+        Response<Object> response = Response.success(body, successResponse);
+        assertThat(response.raw()).isSameAs(successResponse);
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
     }
-  }
-
-  @Test public void error() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(400, errorBody);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Response.error(400, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
+
+    @Test
+    public void successWithNullRawResponseThrows() {
+        try {
+            Response.success("", (okhttp3.Response) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("rawResponse == null");
+        }
     }
-  }
-
-  @Test public void errorWithSuccessCodeThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(200, errorBody);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("code < 400: 200");
+
+    @Test
+    public void successWithErrorRawResponseThrows() {
+        try {
+            Response.success("", errorResponse);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("rawResponse must be successful response");
+        }
     }
-  }
-
-  @Test public void errorWithRawResponse() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(errorBody, errorResponse);
-    assertThat(response.raw()).isSameAs(errorResponse);
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isEqualTo("Broken!");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorWithRawResponseThrows() {
-    try {
-      Response.error(null, errorResponse);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
+
+    @Test
+    public void error() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        Response<?> response = Response.error(400, errorBody);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(400);
+        assertThat(response.message()).isNull();
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.body()).isNull();
+        assertThat(response.errorBody()).isSameAs(errorBody);
     }
-  }
-
-  @Test public void errorWithNullRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
+
+    @Test
+    public void nullErrorThrows() {
+        try {
+            Response.error(400, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("body == null");
+        }
     }
-  }
-
-  @Test public void errorWithSuccessRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, successResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse should not be successful response");
+
+    @Test
+    public void errorWithSuccessCodeThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(200, errorBody);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("code < 400: 200");
+        }
+    }
+
+    @Test
+    public void errorWithRawResponse() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        Response<?> response = Response.error(errorBody, errorResponse);
+        assertThat(response.raw()).isSameAs(errorResponse);
+        assertThat(response.code()).isEqualTo(400);
+        assertThat(response.message()).isEqualTo("Broken!");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.body()).isNull();
+        assertThat(response.errorBody()).isSameAs(errorBody);
+    }
+
+    @Test
+    public void nullErrorWithRawResponseThrows() {
+        try {
+            Response.error(null, errorResponse);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("body == null");
+        }
+    }
+
+    @Test
+    public void errorWithNullRawResponseThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(errorBody, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("rawResponse == null");
+        }
+    }
+
+    @Test
+    public void errorWithSuccessRawResponseThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(errorBody, successResponse);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("rawResponse should not be successful response");
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 9c17cab42..ccda1b255 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -64,1239 +65,1379 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class RetrofitTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface CallMethod {
-    @GET("/") Call<String> disallowed();
-    @POST("/") Call<ResponseBody> disallowed(@Body String body);
-
-    @GET("/") Call<retrofit2.Response> badType1();
-    @GET("/") Call<okhttp3.Response> badType2();
-
-    @GET("/") Call<ResponseBody> getResponseBody();
-    @GET("/") Call<Void> getVoid();
-    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
-    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
-    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
-  }
-  interface FutureMethod {
-    @GET("/") Future<String> method();
-  }
-  interface Extending extends CallMethod {
-  }
-  interface StringService {
-    @GET("/") String get();
-  }
-  interface UnresolvableResponseType {
-    @GET("/") <T> Call<T> typeVariable();
-    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
-    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
-    @GET("/") Call<?> wildcard();
-    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
-  }
-  interface UnresolvableParameterType {
-    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
-    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
-    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
-    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
-    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
-  }
-  interface VoidService {
-    @GET("/") void nope();
-  }
-  interface Annotated {
-    @GET("/") @Foo Call<String> method();
-    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
-    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
-
-    @Retention(RUNTIME)
-    @interface Foo {}
-  }
-  interface MutableParameters {
-    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
-  }
-
-  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
-  @Test public void objectMethodsStillWork() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    try {
-      retrofit.create(Extending.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
-    }
-  }
-
-  @Test public void responseTypeCannotBeRetrofitResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType1();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType1");
-    }
-  }
-
-  @Test public void responseTypeCannotBeOkHttpResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType2();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType2");
-    }
-  }
-
-  @Test public void voidReturnTypeNotAllowed() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    VoidService service = retrofit.create(VoidService.class);
-
-    try {
-      service.nope();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void validateEagerlyDisabledByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyDisabledByUser() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(false)
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyFailsAtCreation() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(true)
-        .build();
-
-    try {
-      retrofit.create(VoidService.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void callCallAdapterAddedByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-  }
-
-  @Test public void callCallCustomAdapter() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        if (getRawType(returnType) != Call.class) {
-          return null;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface CallMethod {
+        @GET("/")
+        Call<String> disallowed();
+
+        @POST("/")
+        Call<ResponseBody> disallowed(@Body String body);
+
+        @GET("/")
+        Call<retrofit2.Response> badType1();
+
+        @GET("/")
+        Call<okhttp3.Response> badType2();
+
+        @GET("/")
+        Call<ResponseBody> getResponseBody();
+
+        @GET("/")
+        Call<Void> getVoid();
+
+        @POST("/")
+        Call<ResponseBody> postRequestBody(@Body RequestBody body);
+
+        @GET("/")
+        Call<ResponseBody> queryString(@Query("foo") String foo);
+
+        @GET("/")
+        Call<ResponseBody> queryObject(@Query("foo") Object foo);
+    }
+
+    interface FutureMethod {
+        @GET("/")
+        Future<String> method();
+    }
+
+    interface Extending extends CallMethod {
+    }
+
+    interface StringService {
+        @GET("/")
+        String get();
+    }
+
+    interface UnresolvableResponseType {
+        @GET("/")
+        <T> Call<T> typeVariable();
+
+        @GET("/")
+        <T extends ResponseBody> Call<T> typeVariableUpperBound();
+
+        @GET("/")
+        <T> Call<List<Map<String, Set<T[]>>>> crazy();
+
+        @GET("/")
+        Call<?> wildcard();
+
+        @GET("/")
+        Call<? extends ResponseBody> wildcardUpperBound();
+    }
+
+    interface UnresolvableParameterType {
+        @POST("/")
+        <T> Call<ResponseBody> typeVariable(@Body T body);
+
+        @POST("/")
+        <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
+
+        @POST("/")
+        <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
+
+        @POST("/")
+        Call<ResponseBody> wildcard(@Body List<?> body);
+
+        @POST("/")
+        Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
+    }
+
+    interface VoidService {
+        @GET("/")
+        void nope();
+    }
+
+    interface Annotated {
+        @GET("/")
+        @Foo
+        Call<String> method();
+
+        @POST("/")
+        Call<ResponseBody> bodyParameter(@Foo @Body String param);
+
+        @GET("/")
+        Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
+
+        @Retention(RUNTIME)
+        @interface Foo {
+        }
+    }
+
+    interface MutableParameters {
+        @GET("/")
+        Call<String> method(@Query("i") AtomicInteger value);
+    }
+
+    @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+    @Test
+    public void objectMethodsStillWork() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        assertThat(example.hashCode()).isNotZero();
+        assertThat(example.equals(this)).isFalse();
+        assertThat(example.toString()).isNotEmpty();
+    }
+
+    @Test
+    public void interfaceWithExtendIsNotSupported() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        try {
+            retrofit.create(Extending.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
+        }
+    }
+
+    @Test
+    public void responseTypeCannotBeRetrofitResponse() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        try {
+            service.badType1();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+                            + "    for method CallMethod.badType1");
+        }
+    }
+
+    @Test
+    public void responseTypeCannotBeOkHttpResponse() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        try {
+            service.badType2();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+                            + "    for method CallMethod.badType2");
+        }
+    }
+
+    @Test
+    public void voidReturnTypeNotAllowed() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        VoidService service = retrofit.create(VoidService.class);
+
+        try {
+            service.nope();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageStartingWith(
+                    "Service methods cannot return void.\n    for method VoidService.nope");
+        }
+    }
+
+    @Test
+    public void validateEagerlyDisabledByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+
+        // Should not throw exception about incorrect configuration of the VoidService
+        retrofit.create(VoidService.class);
+    }
+
+    @Test
+    public void validateEagerlyDisabledByUser() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .validateEagerly(false)
+                .build();
+
+        // Should not throw exception about incorrect configuration of the VoidService
+        retrofit.create(VoidService.class);
+    }
+
+    @Test
+    public void validateEagerlyFailsAtCreation() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .validateEagerly(true)
+                .build();
+
+        try {
+            retrofit.create(VoidService.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageStartingWith(
+                    "Service methods cannot return void.\n    for method VoidService.nope");
+        }
+    }
+
+    @Test
+    public void callCallAdapterAddedByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.getResponseBody()).isNotNull();
+    }
+
+    @Test
+    public void callCallCustomAdapter() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        final AtomicBoolean adapterCalled = new AtomicBoolean();
+        class MyCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+                                      Retrofit retrofit) {
+                factoryCalled.set(true);
+                if (getRawType(returnType) != Call.class) {
+                    return null;
+                }
+                return new CallAdapter<Call<?>>() {
+                    @Override
+                    public Type responseType() {
+                        return getParameterUpperBound(0, (ParameterizedType) returnType);
+                    }
+
+                    @Override
+                    public <R> Call<R> adapt(Call<R> call) {
+                        adapterCalled.set(true);
+                        return call;
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.getResponseBody()).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+        assertThat(adapterCalled.get()).isTrue();
+    }
+
+    @Test
+    public void customCallAdapter() {
+        class GreetingCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+                                           Retrofit retrofit) {
+                if (getRawType(returnType) != String.class) {
+                    return null;
+                }
+                return new CallAdapter<String>() {
+                    @Override
+                    public Type responseType() {
+                        return String.class;
+                    }
+
+                    @Override
+                    public <R> String adapt(Call<R> call) {
+                        return "Hi!";
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .addCallAdapterFactory(new GreetingCallAdapterFactory())
+                .build();
+        StringService example = retrofit.create(StringService.class);
+        assertThat(example.get()).isEqualTo("Hi!");
+    }
+
+    @Test
+    public void methodAnnotationsPassedToCallAdapter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+                                      Retrofit retrofit) {
+                annotationsRef.set(annotations);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .addCallAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.method(); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void customCallAdapterMissingThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        FutureMethod example = retrofit.create(FutureMethod.class);
+        try {
+            example.method();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+                    + "    for method FutureMethod.method");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+    }
+
+    @Test
+    public void methodAnnotationsPassedToResponseBodyConverter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                                    Retrofit retrofit) {
+                annotationsRef.set(annotations);
+                return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.method(); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+        final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+        final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                                  Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+                parameterAnnotationsRef.set(parameterAnnotations);
+                methodAnnotationsRef.set(methodAnnotations);
+                return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+                        methodAnnotations, retrofit);
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.bodyParameter(null); // Trigger internal setup.
+
+        assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+        assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
+    }
+
+    @Test
+    public void parameterAnnotationsPassedToStringConverter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                        Retrofit retrofit) {
+                annotationsRef.set(annotations);
+
+                return new Converter<Object, String>() {
+                    @Override
+                    public String convert(Object value) throws IOException {
+                        return String.valueOf(value);
+                    }
+                };
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.queryParameter(null); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void stringConverterNotCalledForString() {
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                        Retrofit retrofit) {
+                throw new AssertionError();
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.queryString(null);
+        assertThat(call).isNotNull();
+        // We also implicitly assert the above factory was not called as it would have thrown.
+    }
+
+    @Test
+    public void stringConverterReturningNullResultsInDefault() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                        Retrofit retrofit) {
+                factoryCalled.set(true);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.queryObject(null);
+        assertThat(call).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonRequestBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        try {
+            example.disallowed("Hi!");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+                    + "    for method CallMethod.disallowed");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters");
+        }
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonResponseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        try {
+            example.disallowed();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method CallMethod.disallowed");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters");
+        }
+    }
+
+    @Test
+    public void requestBodyOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<ResponseBody> response = example.getResponseBody().execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void voidOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<Void> response = example.getVoid().execute();
+        assertThat(response.body()).isNull();
+    }
+
+    @Test
+    public void voidResponsesArePooled() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("abc"));
+        server.enqueue(new MockResponse().setBody("def"));
+
+        example.getVoid().execute();
+        example.getVoid().execute();
+
+        assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+        assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    }
+
+    @Test
+    public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+        Response<ResponseBody> response = example.postRequestBody(body).execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+
+        assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+    }
+
+    @Test
+    public void unresolvableResponseTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
+
+        try {
+            example.typeVariable();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
+        }
+        try {
+            example.typeVariableUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
+        }
+        try {
+            example.crazy();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
+                    + "    for method UnresolvableResponseType.crazy");
+        }
+        try {
+            example.wildcard();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
+        }
+        try {
+            example.wildcardUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
+                    + "    for method UnresolvableResponseType.wildcardUpperBound");
+        }
+    }
+
+    @Test
+    public void unresolvableParameterTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
+
+        try {
+            example.typeVariable(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
+        }
+        try {
+            example.typeVariableUpperBound(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
+        }
+        try {
+            example.crazy(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
+                    + "    for method UnresolvableParameterType.crazy");
+        }
+        try {
+            example.wildcard(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
+        }
+        try {
+            example.wildcardUpperBound(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
+                    + "    for method UnresolvableParameterType.wildcardUpperBound");
         }
-        return new CallAdapter<Call<?>>() {
-          @Override public Type responseType() {
-            return getParameterUpperBound(0, (ParameterizedType) returnType);
-          }
-
-          @Override public <R> Call<R> adapt(Call<R> call) {
-            adapterCalled.set(true);
-            return call;
-          }
+    }
+
+    @Test
+    public void baseUrlRequired() {
+        try {
+            new Retrofit.Builder().build();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Base URL required.");
+        }
+    }
+
+    @Test
+    public void baseUrlNullThrows() {
+        try {
+            new Retrofit.Builder().baseUrl((String) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("baseUrl == null");
+        }
+        try {
+            new Retrofit.Builder().baseUrl((HttpUrl) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("baseUrl == null");
+        }
+    }
+
+    @Test
+    public void baseUrlInvalidThrows() {
+        try {
+            new Retrofit.Builder().baseUrl("ftp://foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+        }
+    }
+
+    @Test
+    public void baseUrlNoTrailingSlashThrows() {
+        try {
+            new Retrofit.Builder().baseUrl("http://example.com/api");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+        }
+        HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+        try {
+            new Retrofit.Builder().baseUrl(parsed);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+        }
+    }
+
+    @Test
+    public void baseUrlStringPropagated() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        HttpUrl baseUrl = retrofit.baseUrl();
+        assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    }
+
+    @Test
+    public void baseHttpUrlPropagated() {
+        HttpUrl url = HttpUrl.parse("http://example.com/");
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(url)
+                .build();
+        assertThat(retrofit.baseUrl()).isSameAs(url);
+    }
+
+    @Test
+    public void clientNullThrows() {
+        try {
+            new Retrofit.Builder().client(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("client == null");
+        }
+    }
+
+    @Test
+    public void callFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com")
+                .build();
+        assertThat(retrofit.callFactory()).isNotNull();
+    }
+
+    @Test
+    public void callFactoryPropagated() {
+        okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+        assertThat(retrofit.callFactory()).isSameAs(callFactory);
+    }
+
+    @Test
+    public void callFactoryClientPropagated() {
+        OkHttpClient client = new OkHttpClient();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .client(client)
+                .build();
+        assertThat(retrofit.callFactory()).isSameAs(client);
+    }
+
+    @Test
+    public void callFactoryUsed() throws IOException {
+        okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                return new OkHttpClient().newCall(request);
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        service.getResponseBody().execute();
+        verify(callFactory).newCall(any(Request.class));
+        verifyNoMoreInteractions(callFactory);
+    }
+
+    @Test
+    public void callFactoryReturningNullThrows() throws IOException {
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                return null;
+            }
         };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-    assertThat(adapterCalled.get()).isTrue();
-  }
-
-  @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        if (getRawType(returnType) != String.class) {
-          return null;
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+        try {
+            call.execute();
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("Call.Factory returned null.");
         }
-        return new CallAdapter<String>() {
-          @Override public Type responseType() {
-            return String.class;
-          }
-
-          @Override public <R> String adapt(Call<R> call) {
-            return "Hi!";
-          }
+    }
+
+    @Test
+    public void callFactoryThrowingPropagates() {
+        final RuntimeException cause = new RuntimeException("Broken!");
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                throw cause;
+            }
         };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new GreetingCallAdapterFactory())
-        .build();
-    StringService example = retrofit.create(StringService.class);
-    assertThat(example.get()).isEqualTo("Hi!");
-  }
-
-  @Test public void methodAnnotationsPassedToCallAdapter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void customCallAdapterMissingThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    FutureMethod example = retrofit.create(FutureMethod.class);
-    try {
-      example.method();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-          + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-  }
-
-  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
-    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
-
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type,
-          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-        parameterAnnotationsRef.set(parameterAnnotations);
-        methodAnnotationsRef.set(methodAnnotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
-            methodAnnotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.bodyParameter(null); // Trigger internal setup.
-
-    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
-    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
-  }
-
-  @Test public void parameterAnnotationsPassedToStringConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-
-        return new Converter<Object, String>() {
-          @Override public String convert(Object value) throws IOException {
-            return String.valueOf(value);
-          }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+        try {
+            call.execute();
+            fail();
+        } catch (Exception e) {
+            assertThat(e).isSameAs(cause);
+        }
+    }
+
+    @Test
+    public void converterNullThrows() {
+        try {
+            new Retrofit.Builder().addConverterFactory(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("factory == null");
+        }
+    }
+
+    @Test
+    public void converterFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        List<Converter.Factory> converterFactories = retrofit.converterFactories();
+        assertThat(converterFactories).hasSize(1);
+        assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+    }
+
+    @Test
+    public void requestConverterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] parameterAnnotations = new Annotation[0];
+        Annotation[] methodAnnotations = new Annotation[1];
+
+        Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+                methodAnnotations, retrofit);
+
+        Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+                parameterAnnotations, methodAnnotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void requestConverterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.requestBodyConverter(type, annotations, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void requestConverterFactorySkippedNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+        NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory1)
+                .addConverterFactory(nonMatchingFactory2)
+                .build();
+
+        try {
+            retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory1.called).isFalse();
+        assertThat(nonMatchingFactory2.called).isTrue();
+    }
+
+    @Test
+    public void responseConverterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
+
+        Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).responseBodyConverter(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void responseConverterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.responseBodyConverter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void responseConverterFactorySkippedNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+        NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory1)
+                .addConverterFactory(nonMatchingFactory2)
+                .build();
+
+        try {
+            retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory1.called).isFalse();
+        assertThat(nonMatchingFactory2.called).isTrue();
+    }
+
+    @Test
+    public void stringConverterFactoryQueried() {
+        Type type = Object.class;
+        Annotation[] annotations = new Annotation[0];
+
+        Converter<?, String> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
+
+        Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).stringConverter(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void converterFactoryPropagated() {
+        Converter.Factory factory = mock(Converter.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+        assertThat(retrofit.converterFactories()).contains(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryNullThrows() {
+        try {
+            new Retrofit.Builder().addCallAdapterFactory(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("factory == null");
+        }
+    }
+
+    @Test
+    public void callAdapterFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callAdapterFactories()).isNotEmpty();
+    }
+
+    @Test
+    public void callAdapterFactoryPropagated() {
+        CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory)
+                .build();
+        assertThat(retrofit.callAdapterFactories()).contains(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+        CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryQueriedCanDelegate() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+        CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory1)
+                .addCallAdapterFactory(factory2)
+                .build();
+
+        doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+        CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory1).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory1);
+        verify(factory2).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory2);
+    }
+
+    @Test
+    public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+        CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+        CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory1)
+                .addCallAdapterFactory(factory2)
+                .addCallAdapterFactory(factory3)
+                .build();
+
+        doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+        CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory1).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory1);
+        verify(factory2).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory2);
+        verify(factory3).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory3);
+    }
+
+    @Test
+    public void callAdapterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.callAdapter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate call adapter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void callAdapterFactoryDelegateNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+        DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+        NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(delegatingFactory1)
+                .addCallAdapterFactory(delegatingFactory2)
+                .addCallAdapterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.callAdapter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate call adapter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+                    + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+
+        assertThat(delegatingFactory1.called).isTrue();
+        assertThat(delegatingFactory2.called).isTrue();
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void callbackExecutorNullThrows() {
+        try {
+            new Retrofit.Builder().callbackExecutor(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("executor == null");
+        }
+    }
+
+    @Test
+    public void callbackExecutorPropagatesDefaultJvm() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callbackExecutor()).isNull();
+    }
+
+    @Test
+    public void callbackExecutorPropagatesDefaultAndroid() {
+        final Executor executor = Executors.newSingleThreadExecutor();
+        Platform platform = new Platform() {
+            @Override
+            Executor defaultCallbackExecutor() {
+                return executor;
+            }
         };
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.queryParameter(null); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void stringConverterNotCalledForString() {
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        throw new AssertionError();
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryString(null);
-    assertThat(call).isNotNull();
-    // We also implicitly assert the above factory was not called as it would have thrown.
-  }
-
-  @Test public void stringConverterReturningNullResultsInDefault() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryObject(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    try {
-      example.disallowed("Hi!");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    try {
-      example.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void requestBodyOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<ResponseBody> response = example.getResponseBody().execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-  }
-
-  @Test public void voidOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<Void> response = example.getVoid().execute();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void voidResponsesArePooled() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    example.getVoid().execute();
-    example.getVoid().execute();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.postRequestBody(body).execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
-  }
-
-  @Test public void unresolvableResponseTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
-
-    try {
-      example.typeVariable();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
-          + "    for method UnresolvableResponseType.crazy");
-    }
-    try {
-      example.wildcard();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
-          + "    for method UnresolvableResponseType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void unresolvableParameterTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
-
-    try {
-      example.typeVariable(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.crazy");
-    }
-    try {
-      example.wildcard(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void baseUrlRequired() {
-    try {
-      new Retrofit.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Base URL required.");
-    }
-  }
-
-  @Test public void baseUrlNullThrows() {
-    try {
-      new Retrofit.Builder().baseUrl((String) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-    try {
-      new Retrofit.Builder().baseUrl((HttpUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-  }
-
-  @Test public void baseUrlInvalidThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("ftp://foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
-    }
-  }
-
-  @Test public void baseUrlNoTrailingSlashThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("http://example.com/api");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
-    try {
-      new Retrofit.Builder().baseUrl(parsed);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-  }
-
-  @Test public void baseUrlStringPropagated() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
-  }
-
-  @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(url)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(url);
-  }
-
-  @Test public void clientNullThrows() {
-    try {
-      new Retrofit.Builder().client(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("client == null");
-    }
-  }
-
-  @Test public void callFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    assertThat(retrofit.callFactory()).isNotNull();
-  }
-
-  @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(callFactory);
-  }
-
-  @Test public void callFactoryClientPropagated() {
-    OkHttpClient client = new OkHttpClient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .client(client)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(client);
-  }
-
-  @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return new OkHttpClient().newCall(request);
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
-  }
-
-  @Test public void callFactoryReturningNullThrows() throws IOException {
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return null;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Call.Factory returned null.");
-    }
-  }
-
-  @Test public void callFactoryThrowingPropagates() {
-    final RuntimeException cause = new RuntimeException("Broken!");
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        throw cause;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (Exception e) {
-      assertThat(e).isSameAs(cause);
-    }
-  }
-
-  @Test public void converterNullThrows() {
-    try {
-      new Retrofit.Builder().addConverterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void converterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
-    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
-  }
-
-  @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
-
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void requestConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.requestBodyConverter(type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void requestConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void responseConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.responseBodyConverter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void responseConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-    assertThat(retrofit.converterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryNullThrows() {
-    try {
-      new Retrofit.Builder().addCallAdapterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void callAdapterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
-  }
-
-  @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-    assertThat(retrofit.callAdapterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .build();
-
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .addCallAdapterFactory(factory3)
-        .build();
-
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
-  }
-
-  @Test public void callAdapterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
-    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(delegatingFactory1)
-        .addCallAdapterFactory(delegatingFactory2)
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(delegatingFactory1.called).isTrue();
-    assertThat(delegatingFactory2.called).isTrue();
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callbackExecutorNullThrows() {
-    try {
-      new Retrofit.Builder().callbackExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
-    }
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultJvm() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isNull();
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultAndroid() {
-    final Executor executor = Executors.newSingleThreadExecutor();
-    Platform platform = new Platform() {
-      @Override Executor defaultCallbackExecutor() {
-        return executor;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder(platform)
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callbackExecutor(executor)
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse());
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
-  @Test public void argumentCapture() throws Exception {
-    AtomicInteger i = new AtomicInteger();
-
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
-
-    i.set(100);
-    Call<String> call1 = mutableParameters.method(i);
-
-    i.set(101);
-    Response<String> response1 = call1.execute();
-
-    i.set(102);
-    assertEquals("a", response1.body());
-    assertEquals("/?i=101", server.takeRequest().getPath());
-
-    i.set(200);
-    Call<String> call2 = call1.clone();
-
-    i.set(201);
-    Response<String> response2 = call2.execute();
-
-    i.set(202);
-    assertEquals("b", response2.body());
-
-    assertEquals("/?i=201", server.takeRequest().getPath());
-  }
+        Retrofit retrofit = new Retrofit.Builder(platform)
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+    }
+
+    @Test
+    public void callbackExecutorPropagated() {
+        Executor executor = mock(Executor.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callbackExecutor(executor)
+                .build();
+        assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+    }
+
+    @Test
+    public void callbackExecutorUsedForSuccess() throws InterruptedException {
+        Executor executor = spy(new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                command.run();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callbackExecutor(executor)
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+
+        server.enqueue(new MockResponse());
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<ResponseBody>() {
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+        verify(executor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(executor);
+    }
+
+    @Test
+    public void callbackExecutorUsedForFailure() throws InterruptedException {
+        Executor executor = spy(new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                command.run();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callbackExecutor(executor)
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<ResponseBody>() {
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+        verify(executor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(executor);
+    }
+
+    /**
+     * Confirm that Retrofit encodes parameters when the call is executed, and not earlier.
+     */
+    @Test
+    public void argumentCapture() throws Exception {
+        AtomicInteger i = new AtomicInteger();
+
+        server.enqueue(new MockResponse().setBody("a"));
+        server.enqueue(new MockResponse().setBody("b"));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
+
+        i.set(100);
+        Call<String> call1 = mutableParameters.method(i);
+
+        i.set(101);
+        Response<String> response1 = call1.execute();
+
+        i.set(102);
+        assertEquals("a", response1.body());
+        assertEquals("/?i=101", server.takeRequest().getPath());
+
+        i.set(200);
+        Call<String> call2 = call1.clone();
+
+        i.set(201);
+        Response<String> response2 = call2.execute();
+
+        i.set(202);
+        assertEquals("b", response2.body());
+
+        assertEquals("/?i=201", server.takeRequest().getPath());
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
index c9c48f31e..61803b211 100644
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
@@ -16,32 +16,34 @@
 package retrofit2;
 
 import java.util.Set;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ServiceMethodTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
+    @Test
+    public void pathParameterParsing() throws Exception {
+        expectParams("/");
+        expectParams("/foo");
+        expectParams("/foo/bar");
+        expectParams("/foo/bar/{}");
+        expectParams("/foo/bar/{taco}", "taco");
+        expectParams("/foo/bar/{t}", "t");
+        expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+        expectParams("/foo/bar/{}/{taco}", "taco");
+        expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+        expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+        expectParams("/foo/bar/{taco-shell}", "taco-shell");
+        expectParams("/foo/bar/{taco_shell}", "taco_shell");
+        expectParams("/foo/bar/{sha256}", "sha256");
+        expectParams("/foo/bar/{TACO}", "TACO");
+        expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+        expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+    }
 
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
-    assertThat(calculated).containsExactly(expected);
-  }
+    private static void expectParams(String path, String... expected) {
+        Set<String> calculated = ServiceMethod.parsePathParameters(path);
+        assertThat(calculated).containsExactly(expected);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 3847509ea..035baa135 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -18,11 +18,11 @@
 import java.lang.reflect.Method;
 
 public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
-    Method[] declaredMethods = c.getDeclaredMethods();
-    if (declaredMethods.length == 1) {
-      return declaredMethods[0];
+    public static Method onlyMethod(Class c) {
+        Method[] declaredMethods = c.getDeclaredMethods();
+        if (declaredMethods.length == 1) {
+            return declaredMethods[0];
+        }
+        throw new IllegalArgumentException("More than one method declared.");
     }
-    throw new IllegalArgumentException("More than one method declared.");
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
index 918b0ea0f..03d23aa3a 100644
--- a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -17,15 +17,16 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return retrofit.nextCallAdapter(this, returnType, annotations);
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        called = true;
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 2b4954813..d8194e5e8 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -17,15 +17,16 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
index 343839944..439506325 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -17,30 +17,33 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingConverterFactory extends Converter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..c32178741 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,30 +26,33 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+    static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (String.class.equals(type)) {
+            return new Converter<ResponseBody, String>() {
+                @Override
+                public String convert(ResponseBody value) throws IOException {
+                    return value.string();
+                }
+            };
         }
-      };
+        return null;
     }
-    return null;
-  }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MEDIA_TYPE, value);
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (String.class.equals(type)) {
+            return new Converter<String, RequestBody>() {
+                @Override
+                public RequestBody convert(String value) throws IOException {
+                    return RequestBody.create(MEDIA_TYPE, value);
+                }
+            };
         }
-      };
+        return null;
     }
-    return null;
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
index 0189da92b..04d53ef7c 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -33,149 +34,186 @@
  * version whose callback has more granular methods.
  */
 public final class ErrorHandlingCallAdapter {
-  /** A callback which offers granular callbacks for various conditions. */
-  interface MyCallback<T> {
-    /** Called for [200, 300) responses. */
-    void success(Response<T> response);
-    /** Called for 401 responses. */
-    void unauthenticated(Response<?> response);
-    /** Called for [400, 500) responses, except 401. */
-    void clientError(Response<?> response);
-    /** Called for [500, 600) response. */
-    void serverError(Response<?> response);
-    /** Called for network errors while making the call. */
-    void networkError(IOException e);
-    /** Called for unexpected errors while making the call. */
-    void unexpectedError(Throwable t);
-  }
-
-  interface MyCall<T> {
-    void cancel();
-    void enqueue(MyCallback<T> callback);
-    MyCall<T> clone();
-
-    // Left as an exercise for the reader...
-    // TODO MyResponse<T> execute() throws MyHttpException;
-  }
-
-  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      if (getRawType(returnType) != MyCall.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
-      }
-      final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
-      final Executor callbackExecutor = retrofit.callbackExecutor();
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
-
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call, callbackExecutor);
-        }
-      };
+    /**
+     * A callback which offers granular callbacks for various conditions.
+     */
+    interface MyCallback<T> {
+        /**
+         * Called for [200, 300) responses.
+         */
+        void success(Response<T> response);
+
+        /**
+         * Called for 401 responses.
+         */
+        void unauthenticated(Response<?> response);
+
+        /**
+         * Called for [400, 500) responses, except 401.
+         */
+        void clientError(Response<?> response);
+
+        /**
+         * Called for [500, 600) response.
+         */
+        void serverError(Response<?> response);
+
+        /**
+         * Called for network errors while making the call.
+         */
+        void networkError(IOException e);
+
+        /**
+         * Called for unexpected errors while making the call.
+         */
+        void unexpectedError(Throwable t);
     }
-  }
 
-  /** Adapts a {@link Call} to {@link MyCall}. */
-  static class MyCallAdapter<T> implements MyCall<T> {
-    private final Call<T> call;
-    private final Executor callbackExecutor;
+    interface MyCall<T> {
+        void cancel();
 
-    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
-      this.call = call;
-      this.callbackExecutor = callbackExecutor;
+        void enqueue(MyCallback<T> callback);
+
+        MyCall<T> clone();
+
+        // Left as an exercise for the reader...
+        // TODO MyResponse<T> execute() throws MyHttpException;
     }
 
-    @Override public void cancel() {
-      call.cancel();
+    public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
+        @Override
+        public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+                                          Retrofit retrofit) {
+            if (getRawType(returnType) != MyCall.class) {
+                return null;
+            }
+            if (!(returnType instanceof ParameterizedType)) {
+                throw new IllegalStateException(
+                        "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
+            }
+            final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+            final Executor callbackExecutor = retrofit.callbackExecutor();
+            return new CallAdapter<MyCall<?>>() {
+                @Override
+                public Type responseType() {
+                    return responseType;
+                }
+
+                @Override
+                public <R> MyCall<R> adapt(Call<R> call) {
+                    return new MyCallAdapter<>(call, callbackExecutor);
+                }
+            };
+        }
     }
 
-    @Override public void enqueue(final MyCallback<T> callback) {
-      call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, Response<T> response) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
-
-          int code = response.code();
-          if (code >= 200 && code < 300) {
-            callback.success(response);
-          } else if (code == 401) {
-            callback.unauthenticated(response);
-          } else if (code >= 400 && code < 500) {
-            callback.clientError(response);
-          } else if (code >= 500 && code < 600) {
-            callback.serverError(response);
-          } else {
-            callback.unexpectedError(new RuntimeException("Unexpected response " + response));
-          }
+    /**
+     * Adapts a {@link Call} to {@link MyCall}.
+     */
+    static class MyCallAdapter<T> implements MyCall<T> {
+        private final Call<T> call;
+        private final Executor callbackExecutor;
+
+        MyCallAdapter(Call<T> call, Executor callbackExecutor) {
+            this.call = call;
+            this.callbackExecutor = callbackExecutor;
         }
 
-        @Override public void onFailure(Call<T> call, Throwable t) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+        @Override
+        public void cancel() {
+            call.cancel();
+        }
+
+        @Override
+        public void enqueue(final MyCallback<T> callback) {
+            call.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, Response<T> response) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    int code = response.code();
+                    if (code >= 200 && code < 300) {
+                        callback.success(response);
+                    } else if (code == 401) {
+                        callback.unauthenticated(response);
+                    } else if (code >= 400 && code < 500) {
+                        callback.clientError(response);
+                    } else if (code >= 500 && code < 600) {
+                        callback.serverError(response);
+                    } else {
+                        callback.unexpectedError(new RuntimeException("Unexpected response " + response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<T> call, Throwable t) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    if (t instanceof IOException) {
+                        callback.networkError((IOException) t);
+                    } else {
+                        callback.unexpectedError(t);
+                    }
+                }
+            });
+        }
 
-          if (t instanceof IOException) {
-            callback.networkError((IOException) t);
-          } else {
-            callback.unexpectedError(t);
-          }
+        @Override
+        public MyCall<T> clone() {
+            return new MyCallAdapter<>(call.clone(), callbackExecutor);
         }
-      });
     }
 
-    @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone(), callbackExecutor);
+    interface HttpBinService {
+        @GET("/ip")
+        MyCall<Ip> getIp();
+    }
+
+    static class Ip {
+        String origin;
+    }
+
+    public static void main(String... args) {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://httpbin.org")
+                .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+
+        HttpBinService service = retrofit.create(HttpBinService.class);
+        MyCall<Ip> ip = service.getIp();
+        ip.enqueue(new MyCallback<Ip>() {
+            @Override
+            public void success(Response<Ip> response) {
+                System.out.println("SUCCESS! " + response.body().origin);
+            }
+
+            @Override
+            public void unauthenticated(Response<?> response) {
+                System.out.println("UNAUTHENTICATED");
+            }
+
+            @Override
+            public void clientError(Response<?> response) {
+                System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void serverError(Response<?> response) {
+                System.out.println("SERVER ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void networkError(IOException e) {
+                System.err.println("NETOWRK ERROR " + e.getMessage());
+            }
+
+            @Override
+            public void unexpectedError(Throwable t) {
+                System.err.println("FATAL ERROR " + t.getMessage());
+            }
+        });
     }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    MyCall<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    MyCall<Ip> ip = service.getIp();
-    ip.enqueue(new MyCallback<Ip>() {
-      @Override public void success(Response<Ip> response) {
-        System.out.println("SUCCESS! " + response.body().origin);
-      }
-
-      @Override public void unauthenticated(Response<?> response) {
-        System.out.println("UNAUTHENTICATED");
-      }
-
-      @Override public void clientError(Response<?> response) {
-        System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void serverError(Response<?> response) {
-        System.out.println("SERVER ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
-      }
-
-      @Override public void unexpectedError(Throwable t) {
-        System.err.println("FATAL ERROR " + t.getMessage());
-      }
-    });
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index bc29f8355..c24b6ee7d 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -36,79 +37,81 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class JsonQueryParameters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  static class JsonStringConverterFactory extends Converter.Factory {
-    private final Converter.Factory delegateFactory;
+    static class JsonStringConverterFactory extends Converter.Factory {
+        private final Converter.Factory delegateFactory;
 
-    JsonStringConverterFactory(Converter.Factory delegateFactory) {
-      this.delegateFactory = delegateFactory;
-    }
+        JsonStringConverterFactory(Converter.Factory delegateFactory) {
+            this.delegateFactory = delegateFactory;
+        }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
-          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
-          // reference to it explicitly as a field.
-          Converter<?, RequestBody> delegate =
-              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
-          return new DelegateToStringConverter<>(delegate);
+        @Override
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                    Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+                    // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+                    // reference to it explicitly as a field.
+                    Converter<?, RequestBody> delegate =
+                            delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+                    return new DelegateToStringConverter<>(delegate);
+                }
+            }
+            return null;
+        }
+
+        static class DelegateToStringConverter<T> implements Converter<T, String> {
+            private final Converter<T, RequestBody> delegate;
+
+            DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+                this.delegate = delegate;
+            }
+
+            @Override
+            public String convert(T value) throws IOException {
+                Buffer buffer = new Buffer();
+                delegate.convert(value).writeTo(buffer);
+                return buffer.readUtf8();
+            }
         }
-      }
-      return null;
     }
 
-    static class DelegateToStringConverter<T> implements Converter<T, String> {
-      private final Converter<T, RequestBody> delegate;
+    static class Filter {
+        public final String userId;
 
-      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
-        this.delegate = delegate;
-      }
+        public Filter(String userId) {
+            this.userId = userId;
+        }
+    }
 
-      @Override public String convert(T value) throws IOException {
-        Buffer buffer = new Buffer();
-        delegate.convert(value).writeTo(buffer);
-        return buffer.readUtf8();
-      }
+    interface Service {
+        @GET("/filter")
+        Call<ResponseBody> example(@Json @Query("value") Filter value);
     }
-  }
 
-  static class Filter {
-    public final String userId;
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse());
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Call<ResponseBody> call = service.example(new Filter("123"));
+        Response<ResponseBody> response = call.execute();
+        // TODO handle user response...
+
+        // Print the request path that the server saw to show the JSON query param:
+        RecordedRequest recordedRequest = server.takeRequest();
+        System.out.println(recordedRequest.getPath());
 
-    public Filter(String userId) {
-      this.userId = userId;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @GET("/filter")
-    Call<ResponseBody> example(@Json @Query("value") Filter value);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse());
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Call<ResponseBody> call = service.example(new Filter("123"));
-    Response<ResponseBody> response = call.execute();
-    // TODO handle user response...
-
-    // Print the request path that the server saw to show the JSON query param:
-    RecordedRequest recordedRequest = server.takeRequest();
-    System.out.println(recordedRequest.getPath());
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..c6b9d9059 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -3,6 +3,7 @@
 
 import com.example.retrofit.SimpleService.Contributor;
 import com.example.retrofit.SimpleService.GitHub;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+
 import retrofit2.Call;
 import retrofit2.Retrofit;
 import retrofit2.mock.BehaviorDelegate;
@@ -21,89 +23,92 @@
  * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
  */
 public final class SimpleMockService {
-  /** A mock implementation of the {@link GitHub} API interface. */
-  static final class MockGitHub implements GitHub {
-    private final BehaviorDelegate<GitHub> delegate;
-    private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
-
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
-      this.delegate = delegate;
-      ownerRepoContributors = new LinkedHashMap<>();
-
-      // Seed some mock data.
-      addContributor("square", "retrofit", "John Doe", 12);
-      addContributor("square", "retrofit", "Bob Smith", 2);
-      addContributor("square", "retrofit", "Big Bird", 40);
-      addContributor("square", "picasso", "Proposition Joe", 39);
-      addContributor("square", "picasso", "Keiser Soze", 152);
-    }
+    /**
+     * A mock implementation of the {@link GitHub} API interface.
+     */
+    static final class MockGitHub implements GitHub {
+        private final BehaviorDelegate<GitHub> delegate;
+        private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
+
+        public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+            this.delegate = delegate;
+            ownerRepoContributors = new LinkedHashMap<>();
+
+            // Seed some mock data.
+            addContributor("square", "retrofit", "John Doe", 12);
+            addContributor("square", "retrofit", "Bob Smith", 2);
+            addContributor("square", "retrofit", "Big Bird", 40);
+            addContributor("square", "picasso", "Proposition Joe", 39);
+            addContributor("square", "picasso", "Keiser Soze", 152);
+        }
+
+        @Override
+        public Call<List<Contributor>> contributors(String owner, String repo) {
+            List<Contributor> response = Collections.emptyList();
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors != null) {
+                List<Contributor> contributors = repoContributors.get(repo);
+                if (contributors != null) {
+                    response = contributors;
+                }
+            }
+            return delegate.returningResponse(response).contributors(owner, repo);
+        }
 
-    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
-      List<Contributor> response = Collections.emptyList();
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors != null) {
-        List<Contributor> contributors = repoContributors.get(repo);
-        if (contributors != null) {
-          response = contributors;
+        public void addContributor(String owner, String repo, String name, int contributions) {
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors == null) {
+                repoContributors = new LinkedHashMap<>();
+                ownerRepoContributors.put(owner, repoContributors);
+            }
+            List<Contributor> contributors = repoContributors.get(repo);
+            if (contributors == null) {
+                contributors = new ArrayList<>();
+                repoContributors.put(repo, contributors);
+            }
+            contributors.add(new Contributor(name, contributions));
         }
-      }
-      return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<>();
-        ownerRepoContributors.put(owner, repoContributors);
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        contributors = new ArrayList<>();
-        repoContributors.put(repo, contributors);
-      }
-      contributors.add(new Contributor(name, contributions));
+    public static void main(String... args) throws IOException {
+        // Create a very simple Retrofit adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(SimpleService.API_URL)
+                .build();
+
+        // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
+        NetworkBehavior behavior = NetworkBehavior.create();
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+
+        BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
+        MockGitHub gitHub = new MockGitHub(delegate);
+
+        // Query for some contributors for a few repositories.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
+
+        // Using the mock-only methods, add some additional data.
+        System.out.println("Adding more mock data...\n");
+        gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+        gitHub.addContributor("square", "picasso", "Kit Kat", 53);
+
+        // Reduce the delay to make the next calls complete faster.
+        behavior.setDelay(500, TimeUnit.MILLISECONDS);
+
+        // Query for the contributors again so we can see the mock data that was added.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
     }
-  }
-
-  public static void main(String... args) throws IOException {
-    // Create a very simple Retrofit adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(SimpleService.API_URL)
-        .build();
-
-    // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
-    NetworkBehavior behavior = NetworkBehavior.create();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-
-    BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
-    MockGitHub gitHub = new MockGitHub(delegate);
-
-    // Query for some contributors for a few repositories.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-
-    // Using the mock-only methods, add some additional data.
-    System.out.println("Adding more mock data...\n");
-    gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
-    gitHub.addContributor("square", "picasso", "Kit Kat", 53);
-
-    // Reduce the delay to make the next calls complete faster.
-    behavior.setDelay(500, TimeUnit.MILLISECONDS);
-
-    // Query for the contributors again so we can see the mock data that was added.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-  }
-
-  private static void printContributors(GitHub gitHub, String owner, String repo)
-      throws IOException {
-    System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors.execute().body()) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+
+    private static void printContributors(GitHub gitHub, String owner, String repo)
+            throws IOException {
+        System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
+        Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+        for (Contributor contributor : contributors.execute().body()) {
+            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        }
+        System.out.println();
     }
-    System.out.println();
-  }
 }
