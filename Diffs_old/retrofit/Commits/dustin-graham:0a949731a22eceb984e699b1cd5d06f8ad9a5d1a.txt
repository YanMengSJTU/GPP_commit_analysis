diff --git a/pom.xml b/pom.xml
index 01b91834d..93eac365f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,21 +44,21 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <android-maven.version>3.4.0</android-maven.version>
+    <android-maven.version>3.5.1</android-maven.version>
     <java.version>1.6</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.3-SNAPSHOT</gson.version>
-    <httpcomponents.version>4.0.1</httpcomponents.version>
+    <gson.version>2.2.2</gson.version>
+    <httpmime.version>4.2.3</httpmime.version>
     <javax.inject.version>1</javax.inject.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
-    <fest.version>2.0M8</fest.version>
+    <fest.version>2.0M10</fest.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>14.0-rc3</guava.version>
+    <guava.version>14.0</guava.version>
   </properties>
 
   <scm>
@@ -114,12 +114,7 @@
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpmime</artifactId>
-        <version>${httpcomponents.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpclient</artifactId>
-        <version>${httpcomponents.version}</version>
+        <version>${httpmime.version}</version>
       </dependency>
 
       <dependency>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 1a358d137..e61e1a31b 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -20,10 +20,6 @@
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpmime</artifactId>
@@ -31,7 +27,7 @@
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
 
     <dependency>
diff --git a/retrofit/src/main/java/retrofit/http/ChangeableServer.java b/retrofit/src/main/java/retrofit/http/ChangeableServer.java
new file mode 100644
index 000000000..f247024fa
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/ChangeableServer.java
@@ -0,0 +1,40 @@
+package retrofit.http;
+
+/** A {@link Server} whose URL and name can be changed at runtime. */
+public class ChangeableServer extends Server {
+  private String url;
+  private String name;
+
+  /** Create a changeable server with the provided URL and default name. */
+  public ChangeableServer(String url) {
+    super(url);
+    this.url = url;
+    this.name = DEFAULT_NAME;
+  }
+
+  /** Create a changeable server with the provided URL and name. */
+  public ChangeableServer(String url, String name) {
+    super(url, name);
+    this.url = url;
+    this.name = name;
+  }
+
+  /** Update the URL returned by {@link #getUrl()}. */
+  public void update(String url) {
+    this.url = url;
+  }
+
+  /** Update the URL and name returned by {@link #getUrl()} and {@link #getName()}, respetively. */
+  public void update(String url, String name) {
+    this.url = url;
+    this.name = name;
+  }
+
+  @Override public String getUrl() {
+    return url;
+  }
+
+  @Override public String getName() {
+    return name;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
new file mode 100644
index 000000000..b01b70efc
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/MultipartTypedOutput.java
@@ -0,0 +1,66 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import org.apache.http.entity.mime.MIME;
+import org.apache.http.entity.mime.MultipartEntity;
+import org.apache.http.entity.mime.content.AbstractContentBody;
+import retrofit.http.mime.TypedOutput;
+
+final class MultipartTypedOutput implements TypedOutput {
+  // TODO implement our own Multipart logic instead!
+  final MultipartEntity cheat = new MultipartEntity();
+
+  void addPart(String name, TypedOutput body) {
+    cheat.addPart(name, new TypedOutputBody(body));
+  }
+
+  @Override public String mimeType() {
+    return cheat.getContentType().getValue();
+  }
+
+  @Override public long length() {
+    return cheat.getContentLength();
+  }
+
+  @Override public void writeTo(OutputStream out) throws IOException {
+    cheat.writeTo(out);
+  }
+
+  /** Adapts {@link org.apache.http.entity.mime.content.ContentBody} to {@link TypedOutput}. */
+  static class TypedOutputBody extends AbstractContentBody {
+    final TypedOutput typedBytes;
+
+    TypedOutputBody(TypedOutput typedBytes) {
+      super(typedBytes.mimeType());
+      this.typedBytes = typedBytes;
+    }
+
+    @Override public long getContentLength() {
+      return typedBytes.length();
+    }
+
+    @Override public String getFilename() {
+      return null;
+    }
+
+    @Override public String getCharset() {
+      return null;
+    }
+
+    @Override public String getTransferEncoding() {
+      return MIME.ENC_BINARY;
+    }
+
+    @Override public void writeTo(OutputStream out) throws IOException {
+      // Note: We probably want to differentiate I/O errors that occur while reading a file from
+      // network errors. Network operations can be retried. File operations will probably continue
+      // to fail.
+      //
+      // In the case of photo uploads, we at least check that the file exists before we even try to
+      // upload it.
+      typedBytes.writeTo(out);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/Platform.java b/retrofit/src/main/java/retrofit/http/Platform.java
index f4614cc3a..28ad85613 100644
--- a/retrofit/src/main/java/retrofit/http/Platform.java
+++ b/retrofit/src/main/java/retrofit/http/Platform.java
@@ -1,5 +1,6 @@
 package retrofit.http;
 
+import android.os.Build;
 import android.os.Process;
 import com.google.gson.Gson;
 import java.util.concurrent.Executor;
@@ -8,10 +9,11 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import retrofit.http.android.AndroidApacheClient;
 import retrofit.http.android.MainThreadExecutor;
-import retrofit.http.client.ApacheClient;
 import retrofit.http.client.Client;
+import retrofit.http.client.UrlConnectionClient;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
+import static java.lang.Thread.MIN_PRIORITY;
 import static retrofit.http.RestAdapter.THREAD_PREFIX;
 import static retrofit.http.Utils.SynchronousExecutor;
 
@@ -41,7 +43,7 @@ Converter defaultConverter() {
   /** Provides sane defaults for operation on the JVM. */
   private static class Base extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new ApacheClient();
+      final Client client = new UrlConnectionClient();
       return new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -56,7 +58,7 @@ Converter defaultConverter() {
         @Override public Thread newThread(final Runnable r) {
           return new Thread(new Runnable() {
             @Override public void run() {
-              Thread.currentThread().setPriority(THREAD_PRIORITY_BACKGROUND);
+              Thread.currentThread().setPriority(MIN_PRIORITY);
               r.run();
             }
           }, THREAD_PREFIX + threadCounter.getAndIncrement());
@@ -72,7 +74,12 @@ Converter defaultConverter() {
   /** Provides sane defaults for operation on Android. */
   private static class Android extends Platform {
     @Override Client.Provider defaultClient() {
-      final Client client = new AndroidApacheClient();
+      final Client client;
+      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+        client = new AndroidApacheClient();
+      } else {
+        client = new UrlConnectionClient();
+      }
       return new Client.Provider() {
         @Override public Client get() {
           return client;
diff --git a/retrofit/src/main/java/retrofit/http/RequestBuilder.java b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
index 22ac1b4cf..d73adcdd8 100644
--- a/retrofit/src/main/java/retrofit/http/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
@@ -4,10 +4,8 @@
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.util.ArrayList;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import retrofit.http.client.Request;
 import retrofit.http.mime.TypedOutput;
@@ -90,12 +88,7 @@ Request build() {
         }
       }
       if (found != null) {
-        String value;
-        try {
-          value = URLEncoder.encode(String.valueOf(found.getValue()), UTF_8);
-        } catch (UnsupportedEncodingException e) {
-          throw new AssertionError(e);
-        }
+        String value = getUrlEncodedValue(found);
         replacedPath = replacedPath.replace("{" + found.getName() + "}", value);
         paramList.remove(found);
       } else {
@@ -125,15 +118,16 @@ Request build() {
     }
 
     TypedOutput body = null;
-    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
     if (!methodInfo.restMethod.hasBody()) {
       for (int i = 0, count = paramList.size(); i < count; i++) {
         url.append((i == 0) ? '?' : '&');
         Parameter nonPathParam = paramList.get(i);
-        url.append(nonPathParam.getName()).append("=").append(nonPathParam.getValue());
+        String value = getUrlEncodedValue(nonPathParam);
+        url.append(nonPathParam.getName()).append("=").append(value);
       }
     } else if (!paramList.isEmpty()) {
       if (methodInfo.isMultipart) {
+        MultipartTypedOutput multipartBody = new MultipartTypedOutput();
         for (Parameter parameter : paramList) {
           Object value = parameter.getValue();
           TypedOutput typedOutput;
@@ -142,8 +136,9 @@ Request build() {
           } else {
             typedOutput = new TypedString(value.toString());
           }
-          bodyParams.put(parameter.getName(), typedOutput);
+          multipartBody.addPart(parameter.getName(), typedOutput);
         }
+        body = multipartBody;
       } else {
         body = converter.toBody(paramList);
       }
@@ -156,7 +151,14 @@ Request build() {
       }
     }
 
-    return new Request(methodInfo.restMethod.value(), url.toString(), headers,
-        methodInfo.isMultipart, body, bodyParams);
+    return new Request(methodInfo.restMethod.value(), url.toString(), headers, body);
+  }
+
+  private static String getUrlEncodedValue(Parameter found) {
+    try {
+      return URLEncoder.encode(String.valueOf(found.getValue()), UTF_8);
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
   }
 }
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index be4a46cea..a543af4d0 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -144,22 +144,25 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
     private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
       methodDetails.init(); // Ensure all relevant method information has been loaded.
 
-      String url = server.apiUrl();
+      String url = server.getUrl();
       try {
         Request request = new RequestBuilder(converter) //
-            .setApiUrl(server.apiUrl())
+            .setApiUrl(server.getUrl())
             .setArgs(args)
             .setHeaders(headers.get())
             .setMethodInfo(methodDetails)
             .build();
         url = request.getUrl();
-        LOGGER.fine("Sending " + request.getMethod() + " to " + url);
 
         if (!methodDetails.isSynchronous) {
           // If we are executing asynchronously then update the current thread with a useful name.
           Thread.currentThread().setName(THREAD_PREFIX + url);
         }
 
+        if (LOGGER.isLoggable(Level.FINE)) {
+          logRequest(request);
+        }
+
         Object profilerObject = null;
         if (profiler != null) {
           profilerObject = profiler.beforeCall();
@@ -178,7 +181,7 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
         TypedInput body = response.getBody();
         if (LOGGER.isLoggable(Level.FINE)) {
           // Replace the response since the logger needs to consume the entire input stream.
-          body = logResponseBody(url, response.getStatus(), body, elapsedTime);
+          body = logResponse(url, response.getStatus(), body, elapsedTime);
         }
 
         List<Header> headers = response.getHeaders();
@@ -214,10 +217,18 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
     }
   }
 
+  private static void logRequest(Request request) {
+    LOGGER.fine("---> HTTP " + request.getMethod() + " " + request.getUrl());
+    for (Header header : request.getHeaders()) {
+      LOGGER.fine(header.getName() + ": " + header.getValue());
+    }
+    LOGGER.fine("---> END HTTP");
+  }
+
   /** Log response data. Returns replacement {@link TypedInput}. */
-  private static TypedInput logResponseBody(String url, int statusCode, TypedInput body,
+  private static TypedInput logResponse(String url, int statusCode, TypedInput body,
       long elapsedTime) throws IOException {
-    LOGGER.fine("---- HTTP " + statusCode + " from " + url + " (" + elapsedTime + "ms)");
+    LOGGER.fine("<--- HTTP " + statusCode + " " + url + " (" + elapsedTime + "ms)");
 
     byte[] bodyBytes = Utils.streamToBytes(body.in());
     String bodyString = new String(bodyBytes, UTF_8);
@@ -226,7 +237,7 @@ private static TypedInput logResponseBody(String url, int statusCode, TypedInput
       LOGGER.fine(bodyString.substring(i, end));
     }
 
-    LOGGER.fine("---- END HTTP");
+    LOGGER.fine("<--- END HTTP");
 
     // Since we consumed the entire input stream, return a new, identical one from its bytes.
     return new TypedByteArray(body.mimeType(), bodyBytes);
@@ -243,7 +254,7 @@ private static TypedInput logResponseBody(String url, int statusCode, TypedInput
       contentType = body.mimeType();
     }
 
-    return new Profiler.RequestInformation(methodDetails.restMethod.value(), server.apiUrl(),
+    return new Profiler.RequestInformation(methodDetails.restMethod.value(), server.getUrl(),
         methodDetails.path, contentLength, contentType);
   }
 
diff --git a/retrofit/src/main/java/retrofit/http/Server.java b/retrofit/src/main/java/retrofit/http/Server.java
index 1fe362a22..b1c63b820 100644
--- a/retrofit/src/main/java/retrofit/http/Server.java
+++ b/retrofit/src/main/java/retrofit/http/Server.java
@@ -2,33 +2,36 @@
 package retrofit.http;
 
 /**
- * Server information. Applications may extend this class and return different URLs over time.
- * Callers should always consult the Server instance for the latest values rather than caching URLs.
+ * Represents an API endpoint URL and associated name. Callers should always consult the instance
+ * for the latest values rather than caching the returned values.
  *
  * @author Bob Lee (bob@squareup.com)
+ * @see ChangeableServer
  */
 public class Server {
-  public static final String DEFAULT_TYPE = "default";
+  public static final String DEFAULT_NAME = "default";
 
   private final String apiUrl;
   private final String type;
 
+  /** Create a server with the provided URL and default name. */
   public Server(String apiUrl) {
-    this(apiUrl, DEFAULT_TYPE);
+    this(apiUrl, DEFAULT_NAME);
   }
 
+  /** Create a server with the provided URL and name. */
   public Server(String apiUrl, String type) {
     this.apiUrl = apiUrl;
     this.type = type;
   }
 
-  /** Gets the base API url. */
-  public String apiUrl() {
+  /** The base API URL. */
+  public String getUrl() {
     return apiUrl;
   }
 
-  /** Gets a human-readable server type for differentiating between multiple instances. */
-  public String type() {
+  /** A name for differentiating between multiple API URLs. */
+  public String getName() {
     return type;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
index 0b78f650f..eb6ddafd8 100644
--- a/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
+++ b/retrofit/src/main/java/retrofit/http/client/ApacheClient.java
@@ -9,7 +9,6 @@
 import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -17,22 +16,16 @@
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.entity.AbstractHttpEntity;
-import org.apache.http.entity.mime.MIME;
-import org.apache.http.entity.mime.MultipartEntity;
-import org.apache.http.entity.mime.content.AbstractContentBody;
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
+import org.apache.http.protocol.HTTP;
 import org.apache.http.util.EntityUtils;
 import retrofit.http.Header;
 import retrofit.http.mime.TypedByteArray;
 import retrofit.http.mime.TypedOutput;
 
-import static org.apache.http.entity.mime.HttpMultipartMode.BROWSER_COMPATIBLE;
-
 /** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
 public class ApacheClient implements Client {
-  private static final String HEADER_CONTENT_TYPE = "Content-Type";
-
   private final HttpClient client;
 
   /** Creates an instance backed by {@link DefaultHttpClient}. */
@@ -74,11 +67,11 @@ static Response parseResponse(HttpResponse response) throws IOException {
     String reason = statusLine.getReasonPhrase();
 
     List<Header> headers = new ArrayList<Header>();
-    String contentType = "application/octet-stream";
+    String contentType = HTTP.OCTET_STREAM_TYPE;
     for (org.apache.http.Header header : response.getAllHeaders()) {
       String name = header.getName();
       String value = header.getValue();
-      if (name.equalsIgnoreCase(HEADER_CONTENT_TYPE)) {
+      if (name.equalsIgnoreCase(HTTP.CONTENT_TYPE)) {
         contentType = value;
       }
       headers.add(new Header(name, value));
@@ -108,20 +101,9 @@ static Response parseResponse(HttpResponse response) throws IOException {
       }
 
       // Add the content body, if any.
-      if (!request.isMultipart()) {
-        TypedOutput body = request.getBody();
-        if (body != null) {
-          setEntity(new TypedOutputEntity(body));
-        }
-      } else {
-        Map<String, TypedOutput> bodyParameters = request.getBodyParameters();
-        if (bodyParameters != null && !bodyParameters.isEmpty()) {
-          MultipartEntity entity = new MultipartEntity(BROWSER_COMPATIBLE);
-          for (Map.Entry<String, TypedOutput> entry : bodyParameters.entrySet()) {
-            entity.addPart(entry.getKey(), new TypedOutputBody(entry.getValue()));
-          }
-          setEntity(entity);
-        }
+      TypedOutput body = request.getBody();
+      if (body != null) {
+        setEntity(new TypedOutputEntity(body));
       }
     }
 
@@ -130,45 +112,9 @@ static Response parseResponse(HttpResponse response) throws IOException {
     }
   }
 
-  /** Adapts {@link org.apache.http.entity.mime.content.ContentBody} to {@link TypedOutput}. */
-  private static class TypedOutputBody extends AbstractContentBody {
-    private final TypedOutput typedBytes;
-
-    TypedOutputBody(TypedOutput typedBytes) {
-      super(typedBytes.mimeType());
-      this.typedBytes = typedBytes;
-    }
-
-    @Override public long getContentLength() {
-      return typedBytes.length();
-    }
-
-    @Override public String getFilename() {
-      return null;
-    }
-
-    @Override public String getCharset() {
-      return null;
-    }
-
-    @Override public String getTransferEncoding() {
-      return MIME.ENC_BINARY;
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      // Note: We probably want to differentiate I/O errors that occur while reading a file from
-      // network errors. Network operations can be retried. File operations will probably continue
-      // to fail.
-      //
-      // In the case of photo uploads, we at least check that the file exists before we even try to
-      // upload it.
-      typedBytes.writeTo(out);
-    }
-  }
-
   /** Container class for passing an entire {@link TypedOutput} as an {@link HttpEntity}. */
   static class TypedOutputEntity extends AbstractHttpEntity {
-    private final TypedOutput typedOutput;
+    final TypedOutput typedOutput;
 
     TypedOutputEntity(TypedOutput typedOutput) {
       this.typedOutput = typedOutput;
diff --git a/retrofit/src/main/java/retrofit/http/client/Request.java b/retrofit/src/main/java/retrofit/http/client/Request.java
index f9a47e875..dc1dc02bb 100644
--- a/retrofit/src/main/java/retrofit/http/client/Request.java
+++ b/retrofit/src/main/java/retrofit/http/client/Request.java
@@ -1,8 +1,8 @@
 package retrofit.http.client;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 import retrofit.http.Header;
 import retrofit.http.mime.TypedOutput;
 
@@ -11,12 +11,9 @@
   private final String method;
   private final String url;
   private final List<Header> headers;
-  private final boolean isMultipart;
   private final TypedOutput body;
-  private Map<String, TypedOutput> bodyParameters;
 
-  public Request(String method, String url, List<Header> headers, boolean isMultipart,
-      TypedOutput body, Map<String, TypedOutput> bodyParameters) {
+  public Request(String method, String url, List<Header> headers, TypedOutput body) {
     if (method == null) {
       throw new NullPointerException("Method must not be null.");
     }
@@ -29,16 +26,10 @@ public Request(String method, String url, List<Header> headers, boolean isMultip
     if (headers == null) {
       this.headers = Collections.emptyList();
     } else {
-      this.headers = Collections.unmodifiableList(headers);
+      this.headers = Collections.unmodifiableList(new ArrayList<Header>(headers));
     }
 
-    this.isMultipart = isMultipart;
     this.body = body;
-
-    if (bodyParameters != null) {
-      bodyParameters = Collections.unmodifiableMap(bodyParameters);
-    }
-    this.bodyParameters = bodyParameters;
   }
 
   /** HTTP method verb. */
@@ -56,21 +47,8 @@ public String getUrl() {
     return headers;
   }
 
-  /** {@code true} if the request body is multipart. */
-  public boolean isMultipart() {
-    return isMultipart;
-  }
-
-  /**
-   * Returns the request body for non-multipart requests, or {@code null} if the request has no
-   * body.
-   */
+  /** Returns the request body or {@code null}. */
   public TypedOutput getBody() {
     return body;
   }
-
-  /** Unmodifiable map of additional body parameters for multipart requests. */
-  public Map<String, TypedOutput> getBodyParameters() {
-    return bodyParameters;
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/client/TypedInputStream.java b/retrofit/src/main/java/retrofit/http/client/TypedInputStream.java
deleted file mode 100644
index 837893327..000000000
--- a/retrofit/src/main/java/retrofit/http/client/TypedInputStream.java
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.http.client;
-
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.http.mime.TypedInput;
-
-public class TypedInputStream implements TypedInput {
-
-  @Override public String mimeType() {
-    return null;
-  }
-
-  @Override public long length() {
-    return 0;
-  }
-
-  @Override public InputStream in() throws IOException {
-    return null;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
new file mode 100644
index 000000000..db40131a5
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/client/UrlConnectionClient.java
@@ -0,0 +1,93 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import retrofit.http.Header;
+import retrofit.http.mime.TypedInput;
+import retrofit.http.mime.TypedOutput;
+
+public class UrlConnectionClient implements Client {
+  @Override public Response execute(Request request) throws IOException {
+    HttpURLConnection connection = openConnection(request);
+    prepareRequest(connection, request);
+    return readResponse(connection);
+  }
+
+  protected HttpURLConnection openConnection(Request request) throws IOException {
+    return (HttpURLConnection) new URL(request.getUrl()).openConnection();
+  }
+
+  void prepareRequest(HttpURLConnection connection, Request request) throws IOException {
+    connection.setRequestMethod(request.getMethod());
+    connection.setDoInput(true);
+
+    for (Header header : request.getHeaders()) {
+      connection.addRequestProperty(header.getName(), header.getValue());
+    }
+
+    TypedOutput body = request.getBody();
+    if (body != null) {
+      connection.setDoOutput(true);
+      connection.addRequestProperty("Content-Type", body.mimeType());
+      long length = body.length();
+      if (length != -1) {
+        connection.addRequestProperty("Content-Length", String.valueOf(length));
+      }
+      body.writeTo(connection.getOutputStream());
+    }
+  }
+
+  Response readResponse(HttpURLConnection connection) throws IOException {
+    int status = connection.getResponseCode();
+    String reason = connection.getResponseMessage();
+
+    List<Header> headers = new ArrayList<Header>();
+    for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet()) {
+      String name = field.getKey();
+      for (String value : field.getValue()) {
+        headers.add(new Header(name, value));
+      }
+    }
+
+    String mimeType = connection.getContentType();
+    int length = connection.getContentLength();
+    InputStream stream;
+    if (status == 200) {
+      stream = connection.getInputStream();
+    } else {
+      stream = connection.getErrorStream();
+    }
+    TypedInput responseBody = new TypedInputStream(mimeType, length, stream);
+    return new Response(status, reason, headers, responseBody);
+  }
+
+  private static class TypedInputStream implements TypedInput {
+    private final String mimeType;
+    private final long length;
+    private final InputStream stream;
+
+    private TypedInputStream(String mimeType, long length, InputStream stream) {
+      this.mimeType = mimeType;
+      this.length = length;
+      this.stream = stream;
+    }
+
+    @Override public String mimeType() {
+      return mimeType;
+    }
+
+    @Override public long length() {
+      return length;
+    }
+
+    @Override public InputStream in() throws IOException {
+      return stream;
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
index 027527717..7de05d4f1 100644
--- a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
@@ -10,14 +10,17 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
+import org.apache.http.entity.mime.FormBodyPart;
+import org.apache.http.entity.mime.HttpMultipart;
 import org.junit.Test;
 import retrofit.http.client.Request;
-import retrofit.http.mime.TypedString;
 import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
+import static retrofit.http.MultipartTypedOutput.TypedOutputBody;
 import static retrofit.http.RestMethodInfo.NO_SINGLE_ENTITY;
 
 public class RequestBuilderTest {
@@ -31,7 +34,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void getWithPathParam() throws Exception {
@@ -45,7 +47,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void getWithQueryParam() throws Exception {
@@ -59,7 +60,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=pong");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void getWithPathAndQueryParam() throws Exception {
@@ -75,7 +75,48 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
+  }
+  
+  @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/{ping}/") //
+        .addNamedParam("ping", "pong?") //
+        .addNamedParam("kit", "kat?") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.getBody()).isNull();
+  }
+  
+  @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/{ping}/") //
+        .addNamedParam("ping", "pong&") //
+        .addNamedParam("kit", "kat&") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.getBody()).isNull();
+  }
+  
+  @Test public void getWithPathAndQueryHashParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/{ping}/") //
+        .addNamedParam("ping", "pong#") //
+        .addNamedParam("kit", "kat#") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.getBody()).isNull();
   }
 
   @Test public void getWithPathAndQueryParamAsync() throws Exception {
@@ -91,7 +132,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void normalPost() throws Exception {
@@ -105,7 +145,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void normalPostWithPathParam() throws Exception {
@@ -120,7 +159,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void singleEntity() throws Exception {
@@ -135,7 +173,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void singleEntityWithPathParams() throws Exception {
@@ -152,7 +189,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void singleEntityWithPathParamsAsync() throws Exception {
@@ -170,7 +206,6 @@
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void simpleMultipart() throws Exception {
@@ -186,10 +221,19 @@
     assertThat(request.getMethod()).isEqualTo("POST");
     assertThat(request.getHeaders()).isEmpty();
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).hasSize(2);
-    assertTypedBytes(request.getBodyParameters().get("ping"), "pong");
-    assertTypedBytes(request.getBodyParameters().get("kit"), "kat");
+
+    HttpMultipart body = TestingUtils.extractEntity(request.getBody());
+    assertThat(body.getBodyParts()).hasSize(2);
+
+    FormBodyPart part1 = (FormBodyPart) body.getBodyParts().get(0);
+    assertThat(part1.getName()).isEqualTo("ping");
+    TypedOutputBody body1 = (TypedOutputBody) part1.getBody();
+    assertTypedBytes(body1.typedBytes, "pong");
+
+    FormBodyPart part2 = (FormBodyPart) body.getBodyParts().get(1);
+    assertThat(part2.getName()).isEqualTo("kit");
+    TypedOutputBody body2 = (TypedOutputBody) part2.getBody();
+    assertTypedBytes(body2.typedBytes, "kat");
   }
 
   @Test public void simpleHeaders() throws Exception {
@@ -205,7 +249,6 @@
         .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
     assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.getBody()).isNull();
-    assertThat(request.getBodyParameters()).isEmpty();
   }
 
   @Test public void noDuplicateSlashes() throws Exception {
diff --git a/retrofit/src/test/java/retrofit/http/TestingUtils.java b/retrofit/src/test/java/retrofit/http/TestingUtils.java
index f24a69ca5..99ff53dcf 100644
--- a/retrofit/src/test/java/retrofit/http/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/http/TestingUtils.java
@@ -1,7 +1,14 @@
 // Copyright 2013 Square, Inc.
 package retrofit.http;
 
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.util.Map;
+import org.apache.http.entity.mime.HttpMultipart;
+import org.apache.http.entity.mime.MultipartEntity;
+import retrofit.http.mime.TypedOutput;
+
+import static org.fest.assertions.api.Assertions.assertThat;
 
 public class TestingUtils {
   public static Method getMethod(Class c, String name) {
@@ -12,4 +19,31 @@ public static Method getMethod(Class c, String name) {
     }
     throw new IllegalArgumentException("Unknown method '" + name + "' on " + c);
   }
+
+  public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
+    MultipartTypedOutput typedOutput = new MultipartTypedOutput();
+    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
+      typedOutput.addPart(part.getKey(), part.getValue());
+    }
+    return typedOutput;
+  }
+
+  public static HttpMultipart extractEntity(TypedOutput output)
+      throws NoSuchFieldException, IllegalAccessException {
+    if (!(output instanceof MultipartTypedOutput)) {
+      throw new IllegalArgumentException("TypedOutput was not a MultipartTypedOutput.");
+    }
+    MultipartEntity entity = ((MultipartTypedOutput) output).cheat;
+    Field httpMultipartField = MultipartEntity.class.getDeclaredField("multipart");
+    httpMultipartField.setAccessible(true);
+    return (HttpMultipart) httpMultipartField.get(entity);
+  }
+
+  public static void assertMultipart(TypedOutput typedOutput) {
+    assertThat(typedOutput).isInstanceOf(MultipartTypedOutput.class);
+  }
+
+  public static void assertBytes(byte[] bytes, String expected) throws Exception {
+    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java b/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
index f70cd4379..d2f745b98 100644
--- a/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
+++ b/retrofit/src/test/java/retrofit/http/client/ApacheClientTest.java
@@ -12,21 +12,24 @@
 import org.apache.http.HttpVersion;
 import org.apache.http.StatusLine;
 import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.entity.mime.MultipartEntity;
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.http.message.BasicStatusLine;
 import org.junit.Test;
 import retrofit.http.Header;
+import retrofit.http.TestingUtils;
 import retrofit.http.mime.TypedOutput;
 import retrofit.http.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
+import static retrofit.http.TestingUtils.assertMultipart;
+import static retrofit.http.client.ApacheClient.TypedOutputEntity;
 
 public class ApacheClientTest {
   private static final String HOST = "http://example.com";
 
   @Test public void get() {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, false, null, null);
+    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getMethod()).isEqualTo("GET");
@@ -41,7 +44,7 @@
 
   @Test public void post() throws Exception {
     TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, false, body, null);
+    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getMethod()).isEqualTo("POST");
@@ -60,7 +63,8 @@
     Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
     bodyParams.put("foo", new TypedString("bar"));
     bodyParams.put("ping", new TypedString("pong"));
-    Request request = new Request("POST", HOST + "/that/", null, true, null, bodyParams);
+    TypedOutput body = TestingUtils.createMultipart(bodyParams);
+    Request request = new Request("POST", HOST + "/that/", null, body);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getMethod()).isEqualTo("POST");
@@ -69,8 +73,8 @@
 
     assertThat(apacheRequest).isInstanceOf(HttpEntityEnclosingRequest.class);
     HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-    HttpEntity entity = entityRequest.getEntity();
-    assertThat(entity).isInstanceOf(MultipartEntity.class);
+    TypedOutputEntity entity = (TypedOutputEntity) entityRequest.getEntity();
+    assertMultipart(entity.typedOutput);
     // TODO test more?
   }
 
@@ -78,7 +82,7 @@
     List<Header> headers = new ArrayList<Header>();
     headers.add(new Header("kit", "kat"));
     headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, false, null, null);
+    Request request = new Request("GET", HOST + "/this/", headers, null);
     HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
 
     assertThat(apacheRequest.getAllHeaders()).hasSize(2);
@@ -93,7 +97,7 @@
   @Test public void response() throws Exception {
     StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 200, "OK");
     HttpResponse apacheResponse = new BasicHttpResponse(statusLine);
-    apacheResponse.setEntity(new ApacheClient.TypedOutputEntity(new TypedString("hello")));
+    apacheResponse.setEntity(new TypedOutputEntity(new TypedString("hello")));
     apacheResponse.addHeader("Content-Type", "text/plain");
     apacheResponse.addHeader("foo", "bar");
     apacheResponse.addHeader("kit", "kat");
@@ -120,8 +124,4 @@
         .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
     assertThat(response.getBody()).isNull();
   }
-
-  private static void assertBytes(byte[] bytes, String expected) throws Exception {
-    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
-  }
 }
diff --git a/retrofit/src/test/java/retrofit/http/client/DummyHttpUrlConnection.java b/retrofit/src/test/java/retrofit/http/client/DummyHttpUrlConnection.java
new file mode 100644
index 000000000..f2f94e263
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/client/DummyHttpUrlConnection.java
@@ -0,0 +1,115 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Provides POJO behavior for all of the APIs {@link retrofit.http.client.UrlConnectionClient}
+ * interacts with.
+ */
+public class DummyHttpUrlConnection extends HttpURLConnection {
+  private final Map<String, List<String>> responseHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final Map<String, List<String>> requestHeaders =
+      new LinkedHashMap<String, List<String>>();
+  private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+  private int responseCode;
+  private String responseMessage;
+  private InputStream inputStream;
+  private InputStream errorStream;
+
+  protected DummyHttpUrlConnection(String url) throws MalformedURLException {
+    super(new URL(url));
+  }
+
+  public void setResponseCode(int responseCode) {
+    this.responseCode = responseCode;
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return responseCode;
+  }
+
+  public void setResponseMessage(String responseMessage) {
+    this.responseMessage = responseMessage;
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return responseMessage;
+  }
+
+  @Override public ByteArrayOutputStream getOutputStream() throws IOException {
+    return outputStream;
+  }
+
+  public void setInputStream(InputStream inputStream) {
+    this.inputStream = inputStream;
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return inputStream;
+  }
+
+  public void setErrorStream(InputStream errorStream) {
+    this.errorStream = errorStream;
+  }
+
+  @Override public InputStream getErrorStream() {
+    return errorStream;
+  }
+
+  public void addResponseHeader(String name, String value) {
+    List<String> values = responseHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      responseHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return responseHeaders;
+  }
+
+  @Override public void addRequestProperty(String name, String value) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null) {
+      values = new ArrayList<String>();
+      requestHeaders.put(name, values);
+    }
+    values.add(value);
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return requestHeaders;
+  }
+
+  @Override public String getRequestProperty(String name) {
+    List<String> values = requestHeaders.get(name);
+    if (values == null || values.isEmpty()) {
+      return null;
+    }
+    return values.get(0);
+  }
+
+  @Override public void disconnect() {
+    throw new AssertionError("Not implemented.");
+  }
+
+  @Override public boolean usingProxy() {
+    return false;
+  }
+
+  @Override public void connect() throws IOException {
+    throw new AssertionError("Not implemented.");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
new file mode 100644
index 000000000..6a61d29a1
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/http/client/UrlConnectionClientTest.java
@@ -0,0 +1,132 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http.client;
+
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+import retrofit.http.Header;
+import retrofit.http.TestingUtils;
+import retrofit.http.mime.TypedOutput;
+import retrofit.http.mime.TypedString;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static retrofit.http.TestingUtils.assertBytes;
+
+public class UrlConnectionClientTest {
+  private static final String HOST = "http://example.com";
+
+  private UrlConnectionClient client = new UrlConnectionClient() {
+    @Override protected HttpURLConnection openConnection(Request request) throws IOException {
+      return new DummyHttpUrlConnection(request.getUrl());
+    }
+  };
+
+  @Test public void get() throws Exception {
+    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo("GET");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
+    assertThat(connection.getHeaderFields()).isEmpty();
+  }
+
+  @Test public void post() throws Exception {
+    TypedString body = new TypedString("hi");
+    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo("POST");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty("Content-Type")) //
+        .isEqualTo("text/plain; charset=UTF-8");
+    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo("2");
+    assertBytes(connection.getOutputStream().toByteArray(), "hi");
+  }
+
+  @Test public void multipart() throws Exception {
+    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
+    bodyParams.put("foo", new TypedString("bar"));
+    bodyParams.put("ping", new TypedString("pong"));
+    TypedOutput body = TestingUtils.createMultipart(bodyParams);
+    Request request = new Request("POST", HOST + "/that/", null, body);
+
+    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestMethod()).isEqualTo("POST");
+    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/that/");
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty("Content-Type")).startsWith("multipart/form-data;");
+    assertThat(connection.getRequestProperty("Content-Length")).isNotNull();
+    assertThat(connection.getOutputStream().toByteArray().length).isGreaterThan(0);
+  }
+
+  @Test public void headers() throws Exception {
+    List<Header> headers = new ArrayList<Header>();
+    headers.add(new Header("kit", "kat"));
+    headers.add(new Header("foo", "bar"));
+    Request request = new Request("GET", HOST + "/this/", headers, null);
+
+    HttpURLConnection connection = client.openConnection(request);
+    client.prepareRequest(connection, request);
+
+    assertThat(connection.getRequestProperties()).hasSize(2);
+    assertThat(connection.getRequestProperty("kit")).isEqualTo("kat");
+    assertThat(connection.getRequestProperty("foo")).isEqualTo("bar");
+  }
+
+  @Test public void response() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage("OK");
+    connection.addResponseHeader("Content-Type", "text/plain");
+    connection.addResponseHeader("foo", "bar");
+    connection.addResponseHeader("kit", "kat");
+    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo("OK");
+    assertThat(response.getHeaders()).hasSize(3) //
+        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
+            new Header("Content-Type", "text/plain"));
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
+  }
+
+  @Test public void errorResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(401);
+    connection.setResponseMessage("Not Authorized");
+    connection.addResponseHeader("Content-Type", "text/plain");
+    connection.setInputStream(new ByteArrayInputStream("input".getBytes("UTF-8")));
+    connection.setErrorStream(new ByteArrayInputStream("error".getBytes("UTF-8")));
+    Response response = client.readResponse(connection);
+
+    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "error");
+  }
+
+  @Test public void emptyResponse() throws Exception {
+    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
+    connection.setResponseCode(200);
+    connection.setResponseMessage("OK");
+    connection.addResponseHeader("foo", "bar");
+    connection.addResponseHeader("kit", "kat");
+    Response response = client.readResponse(connection);
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getReason()).isEqualTo("OK");
+    assertThat(response.getHeaders()).hasSize(2) //
+        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
+  }
+}
diff --git a/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java b/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java
index 4215ef539..1e3825c26 100644
--- a/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java
+++ b/samples/twitter-client/src/main/java/com/squareup/retrofit/sample/twitter/Client.java
@@ -7,30 +7,34 @@
 import retrofit.http.RestAdapter;
 
 public class Client {
-  private static final String API_URL = "https://api.twitter.com/1/";
+  private static final String API_URL = "https://api.github.com";
 
-  class Tweet {
-    String text;
+  class Contributor {
+    String login;
+    int contributions;
   }
 
-  interface Twitter {
-    @GET("/statuses/user_timeline.json")
-    List<Tweet> tweets(@Name("screen_name") String user);
+  interface GitHub {
+    @GET("/repos/{owner}/{repo}/contributors")
+    List<Contributor> contributors(
+        @Name("owner") String owner,
+        @Name("repo") String repo
+    );
   }
 
   public static void main(String... args) {
-    // Create a very simple REST adapter which points the Twitter API endpoint.
+    // Create a very simple REST adapter which points the GitHub API endpoint.
     RestAdapter restAdapter = new RestAdapter.Builder()
         .setServer(API_URL)
         .build();
 
-    // Create an instance of our Twitter API interface.
-    Twitter twitter = restAdapter.create(Twitter.class);
+    // Create an instance of our GitHub API interface.
+    GitHub github = restAdapter.create(GitHub.class);
 
-    // Fetch and print a list of the 20 most recent tweets for a user.
-    List<Tweet> tweets = twitter.tweets("horse_ebooks");
-    for (Tweet tweet : tweets) {
-      System.out.println(tweet.text);
+    // Fetch and print a list of the contributors to this library.
+    List<Contributor> contributors = github.contributors("square", "retrofit");
+    for (Contributor contributor : contributors) {
+      System.out.println(contributor.login + " (" + contributor.contributions + ")");
     }
   }
 }
