diff --git a/.gitignore b/.gitignore
index 133735f7b..28206a9ee 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,3 +20,4 @@ classes
 obj
 
 .DS_Store
+.gradle
diff --git a/retrofit/build.gradle b/retrofit/build.gradle
new file mode 100644
index 000000000..adb794b15
--- /dev/null
+++ b/retrofit/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'java'
+//apply plugin: 'maven'
+//
+//group = 'com.squareup.retrofit'
+//version = '2.0.0-SNAPSHOT'
+//
+//description = """Retrofit"""
+
+//sourceCompatibility = 1.6
+//targetCompatibility = 1.6
+
+//configurations.all {
+//}
+//
+//repositories {
+//
+//     maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
+//     maven { url "http://repo.maven.apache.org/maven2" }
+//}
+dependencies {
+    compile project(':okio')
+//    compile group: 'com.google.code.gson', name: 'gson', version:'2.3.1'
+//    compile group: 'com.google.android', name: 'android', version:'4.1.1.4'
+//    compile group: 'com.squareup.okhttp', name: 'okhttp', version:'2.2.0'
+//    compile group: 'io.reactivex', name: 'rxjava', version:'1.0.0'
+//    testCompile group: 'junit', name: 'junit', version:'4.11'
+//    testCompile group: 'org.assertj', name: 'assertj-core', version:'1.7.0'
+//    testCompile group: 'org.mockito', name: 'mockito-core', version:'1.9.5'
+//    testCompile group: 'com.google.guava', name: 'guava', version:'18.0'
+//    testCompile group: 'com.squareup.okhttp', name: 'mockwebserver', version:'2.2.0'
+}
diff --git a/retrofit/gradle/wrapper/gradle-wrapper.jar b/retrofit/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 000000000..c97a8bdb9
Binary files /dev/null and b/retrofit/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/retrofit/gradle/wrapper/gradle-wrapper.properties b/retrofit/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 000000000..ca19ec066
--- /dev/null
+++ b/retrofit/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Mar 20 12:37:28 PDT 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-bin.zip
diff --git a/retrofit/gradlew b/retrofit/gradlew
new file mode 100755
index 000000000..91a7e269e
--- /dev/null
+++ b/retrofit/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/retrofit/gradlew.bat b/retrofit/gradlew.bat
new file mode 100644
index 000000000..aec99730b
--- /dev/null
+++ b/retrofit/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 65f1bc5ed..d850f997a 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -15,7 +15,9 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Response;
+//import com.squareup.okhttp.Response;
+
+import retrofit.sharehttp.Response;
 
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
index db7c14d63..bfbc875b8 100644
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -1,12 +1,13 @@
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+
 import okio.Buffer;
-import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
+import okio.Source;
+import retrofit.sharehttp.MediaType;
+import retrofit.sharehttp.ResponseBody;
 
 class ExceptionCatchingRequestBody extends ResponseBody {
   private final ResponseBody delegate;
@@ -24,16 +25,17 @@
     return delegate.contentLength();
   }
 
-  @Override public BufferedSource source() {
+  @Override public Source source() {
     return Okio.buffer(new ForwardingSource(delegate.source()) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        try {
-          return super.read(sink, byteCount);
-        } catch (IOException e) {
-          thrownException = e;
-          throw e;
+        @Override
+        public long read(Buffer sink, long byteCount) throws IOException {
+            try {
+                return super.read(sink, byteCount);
+            } catch (IOException e) {
+                thrownException = e;
+                throw e;
+            }
         }
-      }
     });
   }
 
diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
index 40c0bd59a..112cf2f64 100644
--- a/retrofit/src/main/java/retrofit/MethodInfo.java
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -15,7 +15,7 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Response;
+//import com.squareup.okhttp.Response;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
@@ -46,13 +46,14 @@
 import retrofit.http.QueryMap;
 import retrofit.http.HTTP;
 import retrofit.http.Streaming;
-import rx.Observable;
+import retrofit.sharehttp.Response;
+//import rx.Observable;
 
 /** Request metadata about a service interface declaration. */
 final class MethodInfo {
   enum ExecutionType {
     ASYNC,
-    RX,
+//    RX,
     SYNC
   }
 
@@ -82,7 +83,7 @@
   String requestUrl;
   Set<String> requestUrlParamNames;
   String requestQuery;
-  com.squareup.okhttp.Headers headers;
+  retrofit.sharehttp.Headers headers;
   String contentTypeHeader;
   boolean isStreaming;
 
@@ -206,8 +207,8 @@ private void parseHttpMethodAndPath(String method, String path, boolean hasBody)
     requestQuery = query;
   }
 
-  com.squareup.okhttp.Headers parseHeaders(String[] headers) {
-    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
+  retrofit.sharehttp.Headers parseHeaders(String[] headers) {
+    retrofit.sharehttp.Headers.Builder builder = new retrofit.sharehttp.Headers.Builder();
     for (String header : headers) {
       int colon = header.indexOf(':');
       if (colon == -1 || colon == 0 || colon == header.length() - 1) {
@@ -258,14 +259,14 @@ private ExecutionType parseResponseType() {
     }
 
     if (hasReturnType) {
-      if (Platform.HAS_RX_JAVA) {
-        Class rawReturnType = Types.getRawType(returnType);
-        if (RxSupport.isObservable(rawReturnType)) {
-          returnType = RxSupport.getObservableType(returnType, rawReturnType);
-          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
-          return ExecutionType.RX;
-        }
-      }
+//      if (Platform.HAS_RX_JAVA) {
+//        Class rawReturnType = Types.getRawType(returnType);
+//        if (RxSupport.isObservable(rawReturnType)) {
+//          returnType = RxSupport.getObservableType(returnType, rawReturnType);
+//          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
+//          return ExecutionType.RX;
+//        }
+//      }
       responseObjectType = returnType;
       return ExecutionType.SYNC;
     }
@@ -426,14 +427,14 @@ private void validatePathName(int index, String name) {
     return patterns;
   }
 
-  /** Indirection to avoid log complaints if RxJava isn't present. */
-  private static final class RxSupport {
-    public static boolean isObservable(Class rawType) {
-      return rawType == Observable.class;
-    }
-
-    public static Type getObservableType(Type contextType, Class contextRawType) {
-      return Types.getSupertype(contextType, contextRawType, Observable.class);
-    }
-  }
+//  /** Indirection to avoid log complaints if RxJava isn't present. */
+//  private static final class RxSupport {
+//    public static boolean isObservable(Class rawType) {
+//      return rawType == Observable.class;
+//    }
+//
+//    public static Type getObservableType(Type contextType, Class contextRawType) {
+//      return Types.getSupertype(contextType, contextRawType, Observable.class);
+//    }
+//  }
 }
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 928fd1ae8..728533d20 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -15,46 +15,47 @@
  */
 package retrofit;
 
-import android.os.Build;
-import android.os.Handler;
-import android.os.Looper;
-import com.squareup.okhttp.OkHttpClient;
+//import android.os.Build;
+//import android.os.Handler;
+//import android.os.Looper;
+//import com.squareup.okhttp.OkHttpClient;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
+//import retrofit.converter.GsonConverter;
+import retrofit.sharehttp.ShareHttpClient;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
-  static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
+//  static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
 
   static Platform get() {
     return PLATFORM;
   }
 
   private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
+//    try {
+//      Class.forName("android.os.Build");
+//      if (Build.VERSION.SDK_INT != 0) {
+//        return new Android();
+//      }
+//    } catch (ClassNotFoundException ignored) {
+//    }
 
     return new Platform();
   }
 
   Converter defaultConverter() {
-    return new GsonConverter();
+    return null;//new GsonConverter();
   }
 
   Executor defaultCallbackExecutor() {
     return new Utils.SynchronousExecutor();
   }
 
-  OkHttpClient defaultClient() {
-    OkHttpClient client = new OkHttpClient();
+  ShareHttpClient defaultClient() {
+    ShareHttpClient client = ShareHttpClient.newInstance();
     client.setConnectTimeout(15, TimeUnit.SECONDS);
     client.setReadTimeout(15, TimeUnit.SECONDS);
     client.setWriteTimeout(15, TimeUnit.SECONDS);
@@ -62,24 +63,24 @@ OkHttpClient defaultClient() {
   }
 
   /** Provides sane defaults for operation on Android. */
-  private static class Android extends Platform {
-    @Override Executor defaultCallbackExecutor() {
-      return new Executor() {
-        private final Handler handler = new Handler(Looper.getMainLooper());
+//  private static class Android extends Platform {
+//    @Override Executor defaultCallbackExecutor() {
+//      return new Executor() {
+//        private final Handler handler = new Handler(Looper.getMainLooper());
+//
+//        @Override public void execute(Runnable r) {
+//          handler.post(r);
+//        }
+//      };
+//    }
+//  }
 
-        @Override public void execute(Runnable r) {
-          handler.post(r);
-        }
-      };
-    }
-  }
-
-  private static boolean hasRxJavaOnClasspath() {
-    try {
-      Class.forName("rx.Observable");
-      return true;
-    } catch (ClassNotFoundException ignored) {
-    }
-    return false;
-  }
+//  private static boolean hasRxJavaOnClasspath() {
+//    try {
+//      Class.forName("rx.Observable");
+//      return true;
+//    } catch (ClassNotFoundException ignored) {
+//    }
+//    return false;
+//  }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index d87332bec..5afed3b3f 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -15,23 +15,29 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
+//import com.squareup.okhttp.Headers;
+//import com.squareup.okhttp.MediaType;
+//import com.squareup.okhttp.Request;
+//import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.net.URLEncoder;
 import java.util.Map;
+//import okio.BufferedSink;
 import okio.BufferedSink;
+import okio.Sink;
 import retrofit.converter.Converter;
 import retrofit.http.Body;
 import retrofit.http.Header;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
+import retrofit.sharehttp.Headers;
+import retrofit.sharehttp.MediaType;
+import retrofit.sharehttp.Request;
+import retrofit.sharehttp.RequestBody;
 
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
   private static final Headers NO_HEADERS = Headers.of();
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 5c6882c88..1fded107b 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -15,11 +15,11 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
+//import com.squareup.okhttp.Call;
+//import com.squareup.okhttp.OkHttpClient;
+//import com.squareup.okhttp.Request;
+//import com.squareup.okhttp.Response;
+//import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -31,6 +31,11 @@
 import retrofit.converter.Converter;
 import retrofit.http.HTTP;
 import retrofit.http.Header;
+import retrofit.sharehttp.Request;
+import retrofit.sharehttp.Response;
+import retrofit.sharehttp.ResponseBody;
+import retrofit.sharehttp.ResponseCallback;
+import retrofit.sharehttp.ShareHttpClient;
 
 /**
  * Adapts a Java interface to a REST API.
@@ -107,10 +112,10 @@
   final Converter converter;
   final ErrorHandler errorHandler;
 
-  private final OkHttpClient client;
-  private RxSupport rxSupport;
+  private final ShareHttpClient client;
+//  private RxSupport rxSupport;
 
-  private RestAdapter(Endpoint endpoint, OkHttpClient client, Executor callbackExecutor,
+  private RestAdapter(Endpoint endpoint, ShareHttpClient client, Executor callbackExecutor,
       RequestInterceptor requestInterceptor, Converter converter, ErrorHandler errorHandler) {
     this.endpoint = endpoint;
     this.client = client;
@@ -173,8 +178,8 @@ static MethodInfo getMethodInfo(Map<Method, MethodInfo> cache, Method method) {
         case ASYNC:
           invokeAsync(methodInfo, request, (Callback) args[args.length - 1]);
           return null; // Async has void return type.
-        case RX:
-          return invokeRx(methodInfo, request);
+//        case RX:
+//          return invokeRx(methodInfo, request);
         default:
           throw new IllegalStateException("Unknown response type: " + methodInfo.executionType);
       }
@@ -182,7 +187,7 @@ static MethodInfo getMethodInfo(Map<Method, MethodInfo> cache, Method method) {
 
     private Object invokeSync(MethodInfo methodInfo, Request request) throws Throwable {
       try {
-        Response response = client.newCall(request).execute();
+        Response response = client.executeSync(request);
         return createResult(methodInfo, response);
       } catch (IOException e) {
         throw handleError(RetrofitError.networkFailure(request.urlString(), e));
@@ -202,52 +207,53 @@ private Throwable handleError(RetrofitError error) {
 
     private void invokeAsync(final MethodInfo methodInfo, final Request request,
         final Callback callback) {
-      Call call = client.newCall(request);
-      call.enqueue(new com.squareup.okhttp.Callback() {
-        @Override public void onFailure(Request request, IOException e) {
-          callFailure(callback, RetrofitError.networkFailure(request.urlString(), e));
-        }
+      client.executeAsync(request, new ResponseCallback() {
+          @Override
+          public void onFailure(Request request, IOException e) {
+              callFailure(callback, RetrofitError.networkFailure(request.urlString(), e));
+          }
 
-        @Override public void onResponse(Response response) {
+          @Override
+          public void onResponse(Response response) {
           try {
             Object result = createResult(methodInfo, response);
             callResponse(callback, result, response);
           } catch (RetrofitError error) {
             callFailure(callback, error);
           }
-        }
+          }
       });
     }
 
-    private Object invokeRx(final MethodInfo methodInfo, final Request request) {
-      if (rxSupport == null) {
-        if (Platform.HAS_RX_JAVA) {
-          rxSupport = new RxSupport();
-        } else {
-          throw new IllegalStateException("Found Observable return type but RxJava not present.");
-        }
-      }
-      return rxSupport.createRequestObservable(new RxSupport.Invoker() {
-        @Override public void invoke(final Callback callback) {
-          Call call = client.newCall(request);
-          call.enqueue(new com.squareup.okhttp.Callback() {
-            @Override public void onFailure(Request request, IOException e) {
-              callback.next(RetrofitError.networkFailure(request.urlString(), e));
-            }
-
-            @Override public void onResponse(Response response) {
-              try {
-                Object result = createResult(methodInfo, response);
-                callback.next(result);
-              } catch (RetrofitError error) {
-                callback.error(handleError(error));
-              }
-            }
-          });
-
-        }
-      });
-    }
+//    private Object invokeRx(final MethodInfo methodInfo, final Request request) {
+//      if (rxSupport == null) {
+//        if (Platform.HAS_RX_JAVA) {
+//          rxSupport = new RxSupport();
+//        } else {
+//          throw new IllegalStateException("Found Observable return type but RxJava not present.");
+//        }
+//      }
+//      return rxSupport.createRequestObservable(new RxSupport.Invoker() {
+//        @Override public void invoke(final Callback callback) {
+//          Call call = client.newCall(request);
+//          call.enqueue(new com.squareup.okhttp.Callback() {
+//            @Override public void onFailure(Request request, IOException e) {
+//              callback.next(RetrofitError.networkFailure(request.urlString(), e));
+//            }
+//
+//            @Override public void onResponse(Response response) {
+//              try {
+//                Object result = createResult(methodInfo, response);
+//                callback.next(result);
+//              } catch (RetrofitError error) {
+//                callback.error(handleError(error));
+//              }
+//            }
+//          });
+//
+//        }
+//      });
+//    }
 
     /**
      * Create the object to return to the caller for a response.
@@ -355,7 +361,7 @@ private Request createRequest(MethodInfo methodInfo, Object[] args) {
    */
   public static class Builder {
     private Endpoint endpoint;
-    private OkHttpClient client;
+    private ShareHttpClient client;
     private Executor callbackExecutor;
     private RequestInterceptor requestInterceptor;
     private Converter converter;
@@ -376,7 +382,7 @@ public Builder setEndpoint(Endpoint endpoint) {
     }
 
     /** The HTTP client used for requests. */
-    public Builder setClient(OkHttpClient client) {
+    public Builder setClient(ShareHttpClient client) {
       if (client == null) {
         throw new NullPointerException("Client may not be null.");
       }
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
index f604ac583..fc681009b 100644
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/RetrofitError.java
@@ -15,11 +15,13 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
+//import com.squareup.okhttp.Response;
+//import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import retrofit.converter.Converter;
+import retrofit.sharehttp.Response;
+import retrofit.sharehttp.ResponseBody;
 
 public class RetrofitError extends RuntimeException {
   public static RetrofitError networkFailure(String url, IOException exception) {
diff --git a/retrofit/src/main/java/retrofit/RxSupport.java b/retrofit/src/main/java/retrofit/RxSupport.java
index 80295b8c3..494e8efa3 100644
--- a/retrofit/src/main/java/retrofit/RxSupport.java
+++ b/retrofit/src/main/java/retrofit/RxSupport.java
@@ -1,44 +1,44 @@
 package retrofit;
 
-import rx.Observable;
-import rx.Subscriber;
+//import rx.Observable;
+//import rx.Subscriber;
 
 /**
  * Utilities for supporting RxJava Observables.
  * <p>
  * RxJava might not be on the available to use. Check {@link Platform#HAS_RX_JAVA} before calling.
  */
-final class RxSupport {
-  interface Invoker {
-    void invoke(Callback callback);
-
-    interface Callback {
-      void next(Object o);
-      void error(Throwable t);
-    }
-  }
-
-  RxSupport() {
-  }
-
-  Observable createRequestObservable(final Invoker invoker) {
-    return Observable.create(new Observable.OnSubscribe<Object>() {
-      @Override public void call(final Subscriber<? super Object> subscriber) {
-        invoker.invoke(new Invoker.Callback() {
-          @Override public void next(Object o) {
-            if (!subscriber.isUnsubscribed()) {
-              subscriber.onNext(o);
-              subscriber.onCompleted();
-            }
-          }
-
-          @Override public void error(Throwable t) {
-            if (!subscriber.isUnsubscribed()) {
-              subscriber.onError(t);
-            }
-          }
-        });
-      }
-    });
-  }
-}
+//final class RxSupport {
+//  interface Invoker {
+//    void invoke(Callback callback);
+//
+//    interface Callback {
+//      void next(Object o);
+//      void error(Throwable t);
+//    }
+//  }
+//
+//  RxSupport() {
+//  }
+//
+//  Observable createRequestObservable(final Invoker invoker) {
+//    return Observable.create(new Observable.OnSubscribe<Object>() {
+//      @Override public void call(final Subscriber<? super Object> subscriber) {
+//        invoker.invoke(new Invoker.Callback() {
+//          @Override public void next(Object o) {
+//            if (!subscriber.isUnsubscribed()) {
+//              subscriber.onNext(o);
+//              subscriber.onCompleted();
+//            }
+//          }
+//
+//          @Override public void error(Throwable t) {
+//            if (!subscriber.isUnsubscribed()) {
+//              subscriber.onError(t);
+//            }
+//          }
+//        });
+//      }
+//    });
+//  }
+//}
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index abe79ab44..cafacc97a 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,14 +16,20 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
+//import com.squareup.okhttp.MediaType;
+//import com.squareup.okhttp.Response;
+//import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.util.concurrent.Executor;
+
 import okio.Buffer;
-import okio.BufferedSource;
 import okio.Source;
+import retrofit.sharehttp.MediaType;
+import retrofit.sharehttp.Response;
+import retrofit.sharehttp.ResponseBody;
+//import okio.Buffer;
+//import okio.BufferedSource;
+//import okio.Source;
 
 final class Utils {
   static <T> T checkNotNull(T object, String message, Object... args) {
@@ -43,7 +49,7 @@ static Response readBodyToBytesIfNecessary(Response response) throws IOException
       return response;
     }
 
-    BufferedSource source = body.source();
+    Source source = body.source();
     final Buffer buffer = new Buffer();
     buffer.writeAll(source);
     source.close();
@@ -58,7 +64,7 @@ static Response readBodyToBytesIfNecessary(Response response) throws IOException
             return buffer.size();
           }
 
-          @Override public BufferedSource source() {
+          @Override public Source source() {
             return buffer.clone();
           }
         })
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/converter/Converter.java
index 8c93f9934..12bf27f0a 100644
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ b/retrofit/src/main/java/retrofit/converter/Converter.java
@@ -15,11 +15,14 @@
  */
 package retrofit.converter;
 
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
+//import com.squareup.okhttp.RequestBody;
+//import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
 
+import retrofit.sharehttp.RequestBody;
+import retrofit.sharehttp.ResponseBody;
+
 /**
  * Arbiter for converting objects to and from their representation in HTTP.
  */
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
index 7240dc15e..643b7b24e 100644
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
@@ -15,71 +15,71 @@
  */
 package retrofit.converter;
 
-import com.google.gson.Gson;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Type;
-import java.nio.charset.Charset;
-
-/**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- */
-public class GsonConverter implements Converter {
-  private final Gson gson;
-  private final Charset charset;
-  private final MediaType mediaType;
-
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter() {
-    this(new Gson());
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, Charset.forName("UTF-8"));
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
-   */
-  public GsonConverter(Gson gson, Charset charset) {
-    if (gson == null) throw new NullPointerException("gson == null");
-    if (charset == null) throw new NullPointerException("charset == null");
-    this.gson = gson;
-    this.charset = charset;
-    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    Charset charset = this.charset;
-    if (body.contentType() != null) {
-      charset = body.contentType().charset(charset);
-    }
-
-    InputStream is = body.byteStream();
-    try {
-      return gson.fromJson(new InputStreamReader(is, charset), type);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    String json = gson.toJson(object, type);
-    return RequestBody.create(mediaType, json);
-  }
-}
+//import com.google.gson.Gson;
+//import com.squareup.okhttp.MediaType;
+//import com.squareup.okhttp.RequestBody;
+//import com.squareup.okhttp.ResponseBody;
+//import java.io.IOException;
+//import java.io.InputStream;
+//import java.io.InputStreamReader;
+//import java.lang.reflect.Type;
+//import java.nio.charset.Charset;
+//
+///**
+// * A {@link Converter} which uses GSON for serialization and deserialization of entities.
+// */
+//public class GsonConverter implements Converter {
+//  private final Gson gson;
+//  private final Charset charset;
+//  private final MediaType mediaType;
+//
+//  /**
+//   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+//   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+//   */
+//  public GsonConverter() {
+//    this(new Gson());
+//  }
+//
+//  /**
+//   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
+//   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+//   */
+//  public GsonConverter(Gson gson) {
+//    this(gson, Charset.forName("UTF-8"));
+//  }
+//
+//  /**
+//   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
+//   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
+//   */
+//  public GsonConverter(Gson gson, Charset charset) {
+//    if (gson == null) throw new NullPointerException("gson == null");
+//    if (charset == null) throw new NullPointerException("charset == null");
+//    this.gson = gson;
+//    this.charset = charset;
+//    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
+//  }
+//
+//  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+//    Charset charset = this.charset;
+//    if (body.contentType() != null) {
+//      charset = body.contentType().charset(charset);
+//    }
+//
+//    InputStream is = body.byteStream();
+//    try {
+//      return gson.fromJson(new InputStreamReader(is, charset), type);
+//    } finally {
+//      try {
+//        is.close();
+//      } catch (IOException ignored) {
+//      }
+//    }
+//  }
+//
+//  @Override public RequestBody toBody(Object object, Type type) {
+//    String json = gson.toJson(object, type);
+//    return RequestBody.create(mediaType, json);
+//  }
+//}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/CacheControl.java b/retrofit/src/main/java/retrofit/sharehttp/CacheControl.java
new file mode 100644
index 000000000..2cb9641ca
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/CacheControl.java
@@ -0,0 +1,366 @@
+package retrofit.sharehttp;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These
+ * directives set policy on what responses can be stored, and which requests can
+ * be satisfied by those stored responses.
+ *
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
+ * 2616, 14.9</a>.
+ */
+public final class CacheControl {
+  /**
+   * Cache control request directives that require network validation of
+   * responses. Note that such requests may be assisted by the cache via
+   * conditional GET requests.
+   */
+  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
+
+  /**
+   * Cache control request directives that uses the cache only, even if the
+   * cached response is stale. If the response isn't available in the cache or
+   * requires server validation, the call will fail with a {@code 504
+   * Unsatisfiable Request}.
+   */
+  public static final CacheControl FORCE_CACHE = new Builder()
+      .onlyIfCached()
+      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
+      .build();
+
+  private final boolean noCache;
+  private final boolean noStore;
+  private final int maxAgeSeconds;
+  private final int sMaxAgeSeconds;
+  private final boolean isPrivate;
+  private final boolean isPublic;
+  private final boolean mustRevalidate;
+  private final int maxStaleSeconds;
+  private final int minFreshSeconds;
+  private final boolean onlyIfCached;
+  private final boolean noTransform;
+
+  String headerValue; // Lazily computed, if absent.
+
+  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
+      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
+    this.noCache = noCache;
+    this.noStore = noStore;
+    this.maxAgeSeconds = maxAgeSeconds;
+    this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPrivate = isPrivate;
+    this.isPublic = isPublic;
+    this.mustRevalidate = mustRevalidate;
+    this.maxStaleSeconds = maxStaleSeconds;
+    this.minFreshSeconds = minFreshSeconds;
+    this.onlyIfCached = onlyIfCached;
+    this.noTransform = noTransform;
+    this.headerValue = headerValue;
+  }
+
+  private CacheControl(Builder builder) {
+    this.noCache = builder.noCache;
+    this.noStore = builder.noStore;
+    this.maxAgeSeconds = builder.maxAgeSeconds;
+    this.sMaxAgeSeconds = -1;
+    this.isPrivate = false;
+    this.isPublic = false;
+    this.mustRevalidate = false;
+    this.maxStaleSeconds = builder.maxStaleSeconds;
+    this.minFreshSeconds = builder.minFreshSeconds;
+    this.onlyIfCached = builder.onlyIfCached;
+    this.noTransform = builder.noTransform;
+  }
+
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't
+   * prevent us from caching the response; it only means we have to validate the
+   * response with the origin server before returning it. We can do this with a
+   * conditional GET.
+   *
+   * <p>In a request, it means do not use a cache to satisfy the request.
+   */
+  public boolean noCache() {
+    return noCache;
+  }
+
+  /** If true, this response should not be cached. */
+  public boolean noStore() {
+    return noStore;
+  }
+
+  /**
+   * The duration past the response's served date that it can be served without
+   * validation.
+   */
+  public int maxAgeSeconds() {
+    return maxAgeSeconds;
+  }
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be
+   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
+   * this directive is not honored by this cache.
+   */
+  public int sMaxAgeSeconds() {
+    return sMaxAgeSeconds;
+  }
+
+  public boolean isPrivate() {
+    return isPrivate;
+  }
+
+  public boolean isPublic() {
+    return isPublic;
+  }
+
+  public boolean mustRevalidate() {
+    return mustRevalidate;
+  }
+
+  public int maxStaleSeconds() {
+    return maxStaleSeconds;
+  }
+
+  public int minFreshSeconds() {
+    return minFreshSeconds;
+  }
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do
+   * not use the network". It is set by a client who only wants to make a
+   * request if it can be fully satisfied by the cache. Cached responses that
+   * would require validation (ie. conditional gets) are not permitted if this
+   * header is set.
+   */
+  public boolean onlyIfCached() {
+    return onlyIfCached;
+  }
+
+  public boolean noTransform() {
+    return noTransform;
+  }
+
+  /**
+   * Returns the cache directives of {@code headers}. This honors both
+   * Cache-Control and Pragma headers if they are present.
+   */
+  public static CacheControl parse(Headers headers) {
+    boolean noCache = false;
+    boolean noStore = false;
+    int maxAgeSeconds = -1;
+    int sMaxAgeSeconds = -1;
+    boolean isPrivate = false;
+    boolean isPublic = false;
+    boolean mustRevalidate = false;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached = false;
+    boolean noTransform = false;
+
+    boolean canUseHeaderValue = true;
+    String headerValue = null;
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+
+      if (name.equalsIgnoreCase("Cache-Control")) {
+        if (headerValue != null) {
+          // Multiple cache-control headers means we can't use the raw value.
+          canUseHeaderValue = false;
+        } else {
+          headerValue = value;
+        }
+      } else if (name.equalsIgnoreCase("Pragma")) {
+        // Might specify additional cache-control params. We invalidate just in case.
+        canUseHeaderValue = false;
+      } else {
+        continue;
+      }
+
+      int pos = 0;
+      while (pos < value.length()) {
+        int tokenStart = pos;
+        pos = HeaderParser.skipUntil(value, pos, "=,;");
+        String directive = value.substring(tokenStart, pos).trim();
+        String parameter;
+
+        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
+          pos++; // consume ',' or ';' (if necessary)
+          parameter = null;
+        } else {
+          pos++; // consume '='
+          pos = HeaderParser.skipWhitespace(value, pos);
+
+          // quoted string
+          if (pos < value.length() && value.charAt(pos) == '\"') {
+            pos++; // consume '"' open quote
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(value, pos, "\"");
+            parameter = value.substring(parameterStart, pos);
+            pos++; // consume '"' close quote (if necessary)
+
+            // unquoted string
+          } else {
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(value, pos, ",;");
+            parameter = value.substring(parameterStart, pos).trim();
+          }
+        }
+
+        if ("no-cache".equalsIgnoreCase(directive)) {
+          noCache = true;
+        } else if ("no-store".equalsIgnoreCase(directive)) {
+          noStore = true;
+        } else if ("max-age".equalsIgnoreCase(directive)) {
+          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("s-maxage".equalsIgnoreCase(directive)) {
+          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("private".equalsIgnoreCase(directive)) {
+          isPrivate = true;
+        } else if ("public".equalsIgnoreCase(directive)) {
+          isPublic = true;
+        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+          mustRevalidate = true;
+        } else if ("max-stale".equalsIgnoreCase(directive)) {
+          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
+        } else if ("min-fresh".equalsIgnoreCase(directive)) {
+          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+          onlyIfCached = true;
+        } else if ("no-transform".equalsIgnoreCase(directive)) {
+          noTransform = true;
+        }
+      }
+    }
+
+    if (!canUseHeaderValue) {
+      headerValue = null;
+    }
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
+  }
+
+  @Override public String toString() {
+    String result = headerValue;
+    return result != null ? result : (headerValue = headerValue());
+  }
+
+  private String headerValue() {
+    StringBuilder result = new StringBuilder();
+    if (noCache) result.append("no-cache, ");
+    if (noStore) result.append("no-store, ");
+    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
+    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
+    if (isPrivate) result.append("private, ");
+    if (isPublic) result.append("public, ");
+    if (mustRevalidate) result.append("must-revalidate, ");
+    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
+    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
+    if (onlyIfCached) result.append("only-if-cached, ");
+    if (noTransform) result.append("no-transform, ");
+    if (result.length() == 0) return "";
+    result.delete(result.length() - 2, result.length());
+    return result.toString();
+  }
+
+  /** Builds a {@code Cache-Control} request header. */
+  public static final class Builder {
+    boolean noCache;
+    boolean noStore;
+    int maxAgeSeconds = -1;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached;
+    boolean noTransform;
+
+    /** Don't accept an unvalidated cached response. */
+    public Builder noCache() {
+      this.noCache = true;
+      return this;
+    }
+
+    /** Don't store the server's response in any cache. */
+    public Builder noStore() {
+      this.noStore = true;
+      return this;
+    }
+
+    /**
+     * Sets the maximum age of a cached response. If the cache response's age
+     * exceeds {@code maxAge}, it will not be used and a network request will
+     * be made.
+     *
+     * @param maxAge a non-negative integer. This is stored and transmitted with
+     *     {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+     */
+    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
+      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
+      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
+      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) maxAgeSecondsLong;
+      return this;
+    }
+
+    /**
+     * Accept cached responses that have exceeded their freshness lifetime by
+     * up to {@code maxStale}. If unspecified, stale cache responses will not be
+     * used.
+     *
+     * @param maxStale a non-negative integer. This is stored and transmitted
+     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
+     *     lost.
+     */
+    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
+      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
+      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
+      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) maxStaleSecondsLong;
+      return this;
+    }
+
+    /**
+     * Sets the minimum number of seconds that a response will continue to be
+     * fresh for. If the response will be stale when {@code minFresh} have
+     * elapsed, the cached response will not be used and a network request will
+     * be made.
+     *
+     * @param minFresh a non-negative integer. This is stored and transmitted
+     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
+     *     lost.
+     */
+    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
+      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
+      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
+      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) minFreshSecondsLong;
+      return this;
+    }
+
+    /**
+     * Only accept the response if it is in the cache. If the response isn't
+     * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+     */
+    public Builder onlyIfCached() {
+      this.onlyIfCached = true;
+      return this;
+    }
+
+    /** Don't accept a transformed response. */
+    public Builder noTransform() {
+      this.noTransform = true;
+      return this;
+    }
+
+    public CacheControl build() {
+      return new CacheControl(this);
+    }
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/HeaderParser.java b/retrofit/src/main/java/retrofit/sharehttp/HeaderParser.java
new file mode 100644
index 000000000..202a73e63
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/HeaderParser.java
@@ -0,0 +1,54 @@
+package retrofit.sharehttp;
+
+public final class HeaderParser {
+  /**
+   * Returns the next index in {@code input} at or after {@code pos} that
+   * contains a character from {@code characters}. Returns the input length if
+   * none of the requested characters can be found.
+   */
+  public static int skipUntil(String input, int pos, String characters) {
+    for (; pos < input.length(); pos++) {
+      if (characters.indexOf(input.charAt(pos)) != -1) {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns the next non-whitespace character in {@code input} that is white
+   * space. Result is undefined if input contains newline characters.
+   */
+  public static int skipWhitespace(String input, int pos) {
+    for (; pos < input.length(); pos++) {
+      char c = input.charAt(pos);
+      if (c != ' ' && c != '\t') {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /**
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or
+   * {@code defaultValue} if it cannot be parsed.
+   */
+  public static int parseSeconds(String value, int defaultValue) {
+    try {
+      long seconds = Long.parseLong(value);
+      if (seconds > Integer.MAX_VALUE) {
+        return Integer.MAX_VALUE;
+      } else if (seconds < 0) {
+        return 0;
+      } else {
+        return (int) seconds;
+      }
+    } catch (NumberFormatException e) {
+      return defaultValue;
+    }
+  }
+
+  private HeaderParser() {
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/Headers.java b/retrofit/src/main/java/retrofit/sharehttp/Headers.java
new file mode 100644
index 000000000..2961eca66
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/Headers.java
@@ -0,0 +1,269 @@
+package retrofit.sharehttp;
+
+/**
+ * Created by dementrock on 3/20/15.
+ */
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+/**
+ * The header fields of a single HTTP message. Values are uninterpreted strings;
+ * use {@code Request} and {@code Response} for interpreted headers. This class
+ * maintains the order of the header fields within the HTTP message.
+ *
+ * <p>This class tracks header values line-by-line. A field with multiple comma-
+ * separated values on the same line will be treated as a field with a single
+ * value by this class. It is the caller's responsibility to detect and split
+ * on commas if their field permits multiple values. This simplifies use of
+ * single-valued fields whose values routinely contain commas, such as cookies
+ * or dates.
+ *
+ * <p>This class trims whitespace from values. It never returns values with
+ * leading or trailing whitespace.
+ *
+ * <p>Instances of this class are immutable. Use {@link Builder} to create
+ * instances.
+ */
+public final class Headers {
+  private final String[] namesAndValues;
+
+  private Headers(Builder builder) {
+    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
+  }
+
+  private Headers(String[] namesAndValues) {
+    this.namesAndValues = namesAndValues;
+  }
+
+  /** Returns the last value corresponding to the specified field, or null. */
+  public String get(String name) {
+    return get(namesAndValues, name);
+  }
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an
+   * HTTP date, or null if either the field is absent or cannot be parsed as a
+   * date.
+   */
+//  public Date getDate(String name) {
+//    String value = get(name);
+//    return value != null ? HttpDate.parse(value) : null;
+//  }
+
+  /** Returns the number of field values. */
+  public int size() {
+    return namesAndValues.length / 2;
+  }
+
+  /** Returns the field at {@code position} or null if that is out of range. */
+  public String name(int index) {
+    int nameIndex = index * 2;
+    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
+      return null;
+    }
+    return namesAndValues[nameIndex];
+  }
+
+  /** Returns the value at {@code index} or null if that is out of range. */
+  public String value(int index) {
+    int valueIndex = index * 2 + 1;
+    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
+      return null;
+    }
+    return namesAndValues[valueIndex];
+  }
+
+  /** Returns an immutable case-insensitive set of header names. */
+  public Set<String> names() {
+    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0, size = size(); i < size; i++) {
+      result.add(name(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  /** Returns an immutable list of the header values for {@code name}. */
+  public List<String> values(String name) {
+    List<String> result = null;
+    for (int i = 0, size = size(); i < size; i++) {
+      if (name.equalsIgnoreCase(name(i))) {
+        if (result == null) result = new ArrayList<>(2);
+        result.add(value(i));
+      }
+    }
+    return result != null
+        ? Collections.unmodifiableList(result)
+        : Collections.<String>emptyList();
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    Collections.addAll(result.namesAndValues, namesAndValues);
+    return result;
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0, size = size(); i < size; i++) {
+      result.append(name(i)).append(": ").append(value(i)).append("\n");
+    }
+    return result.toString();
+  }
+
+  private static String get(String[] namesAndValues, String name) {
+    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+      if (name.equalsIgnoreCase(namesAndValues[i])) {
+        return namesAndValues[i + 1];
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns headers for the alternating header names and values. There must be
+   * an even number of arguments, and they must alternate between header names
+   * and values.
+   */
+  public static Headers of(String... namesAndValues) {
+    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+      throw new IllegalArgumentException("Expected alternating header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    namesAndValues = namesAndValues.clone();
+    for (int i = 0; i < namesAndValues.length; i++) {
+      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
+      namesAndValues[i] = namesAndValues[i].trim();
+    }
+
+    // Check for malformed headers.
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String name = namesAndValues[i];
+      String value = namesAndValues[i + 1];
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+    }
+
+    return new Headers(namesAndValues);
+  }
+
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  public static Headers of(Map<String, String> headers) {
+    if (headers == null) {
+      throw new IllegalArgumentException("Expected map with header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    String[] namesAndValues = new String[headers.size() * 2];
+    int i = 0;
+    for (Map.Entry<String, String> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        throw new IllegalArgumentException("Headers cannot be null");
+      }
+      String name = header.getKey().trim();
+      String value = header.getValue().trim();
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+      namesAndValues[i] = name;
+      namesAndValues[i + 1] = value;
+      i += 2;
+    }
+
+    return new Headers(namesAndValues);
+  }
+
+  public static final class Builder {
+    private final List<String> namesAndValues = new ArrayList<>(20);
+
+    /**
+     * Add a header line without any validation. Only appropriate for headers from the remote peer
+     * or cache.
+     */
+    Builder addLenient(String line) {
+      int index = line.indexOf(":", 1);
+      if (index != -1) {
+        return addLenient(line.substring(0, index), line.substring(index + 1));
+      } else if (line.startsWith(":")) {
+        // Work around empty header names and header names that start with a
+        // colon (created by old broken SPDY versions of the response cache).
+        return addLenient("", line.substring(1)); // Empty header name.
+      } else {
+        return addLenient("", line); // No header name.
+      }
+    }
+
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    public Builder add(String line) {
+      int index = line.indexOf(":");
+      if (index == -1) {
+        throw new IllegalArgumentException("Unexpected header: " + line);
+      }
+      return add(line.substring(0, index).trim(), line.substring(index + 1));
+    }
+
+    /** Add a field with the specified value. */
+    public Builder add(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (value == null) throw new IllegalArgumentException("value == null");
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+      return addLenient(name, value);
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only
+     * appropriate for headers from the remote peer.
+     */
+    private Builder addLenient(String name, String value) {
+      namesAndValues.add(name);
+      namesAndValues.add(value.trim());
+      return this;
+    }
+
+    public Builder removeAll(String name) {
+      for (int i = 0; i < namesAndValues.size(); i += 2) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // name
+          namesAndValues.remove(i); // value
+          i -= 2;
+        }
+      }
+      return this;
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is
+     * added. If the field is found, the existing values are replaced.
+     */
+    public Builder set(String name, String value) {
+      removeAll(name);
+      add(name, value);
+      return this;
+    }
+
+    /** Equivalent to {@code build().get(name)}, but potentially faster. */
+    public String get(String name) {
+      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          return namesAndValues.get(i + 1);
+        }
+      }
+      return null;
+    }
+
+    public Headers build() {
+      return new Headers(this);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/HttpMethod.java b/retrofit/src/main/java/retrofit/sharehttp/HttpMethod.java
new file mode 100644
index 000000000..b8b538668
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/HttpMethod.java
@@ -0,0 +1,24 @@
+package retrofit.sharehttp;
+
+public final class HttpMethod {
+  public static boolean invalidatesCache(String method) {
+    return method.equals("POST")
+        || method.equals("PATCH")
+        || method.equals("PUT")
+        || method.equals("DELETE");
+  }
+
+  public static boolean requiresRequestBody(String method) {
+    return method.equals("POST")
+        || method.equals("PUT")
+        || method.equals("PATCH");
+  }
+
+  public static boolean permitsRequestBody(String method) {
+    return requiresRequestBody(method)
+        || method.equals("DELETE"); // Permitted as spec is ambiguous.
+  }
+
+  private HttpMethod() {
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/MediaType.java b/retrofit/src/main/java/retrofit/sharehttp/MediaType.java
new file mode 100644
index 000000000..8d1b9932b
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/MediaType.java
@@ -0,0 +1,109 @@
+package retrofit.sharehttp;
+
+import java.nio.charset.Charset;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type,
+ * appropriate to describe the content type of an HTTP request or response body.
+ */
+public final class MediaType {
+  private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
+  private static final String QUOTED = "\"([^\"]*)\"";
+  private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
+  private static final Pattern PARAMETER = Pattern.compile(
+      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
+
+  private final String mediaType;
+  private final String type;
+  private final String subtype;
+  private final String charset;
+
+  private MediaType(String mediaType, String type, String subtype, String charset) {
+    this.mediaType = mediaType;
+    this.type = type;
+    this.subtype = subtype;
+    this.charset = charset;
+  }
+
+  /**
+   * Returns a media type for {@code string}, or null if {@code string} is not a
+   * well-formed media type.
+   */
+  public static MediaType parse(String string) {
+    Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
+    if (!typeSubtype.lookingAt()) return null;
+    String type = typeSubtype.group(1).toLowerCase(Locale.US);
+    String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
+
+    String charset = null;
+    Matcher parameter = PARAMETER.matcher(string);
+    for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
+      parameter.region(s, string.length());
+      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
+
+      String name = parameter.group(1);
+      if (name == null || !name.equalsIgnoreCase("charset")) continue;
+      String charsetParameter = parameter.group(2) != null
+          ? parameter.group(2)  // Value is a token.
+          : parameter.group(3); // Value is a quoted string.
+      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
+        throw new IllegalArgumentException("Multiple different charsets: " + string);
+      }
+      charset = charsetParameter;
+    }
+
+    return new MediaType(string, type, subtype, charset);
+  }
+
+  /**
+   * Returns the high-level media type, such as "text", "image", "audio",
+   * "video", or "application".
+   */
+  public String type() {
+    return type;
+  }
+
+  /**
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg",
+   * "mp4" or "xml".
+   */
+  public String subtype() {
+    return subtype;
+  }
+
+  /**
+   * Returns the charset of this media type, or null if this media type doesn't
+   * specify a charset.
+   */
+  public Charset charset() {
+    return charset != null ? Charset.forName(charset) : null;
+  }
+
+  /**
+   * Returns the charset of this media type, or {@code defaultValue} if this
+   * media type doesn't specify a charset.
+   */
+  public Charset charset(Charset defaultValue) {
+    return charset != null ? Charset.forName(charset) : defaultValue;
+  }
+
+  /**
+   * Returns the encoded media type, like "text/plain; charset=utf-8",
+   * appropriate for use in a Content-Type header.
+   */
+  @Override public String toString() {
+    return mediaType;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof MediaType && ((MediaType) o).mediaType.equals(mediaType);
+  }
+
+  @Override public int hashCode() {
+    return mediaType.hashCode();
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/Protocol.java b/retrofit/src/main/java/retrofit/sharehttp/Protocol.java
new file mode 100644
index 000000000..ff8264df2
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/Protocol.java
@@ -0,0 +1,83 @@
+package retrofit.sharehttp;
+
+import java.io.IOException;
+
+/**
+ * Protocols that OkHttp implements for <a
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+ * selection.
+ *
+ * <h3>Protocol vs Scheme</h3>
+ * Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
+ * the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i>
+ * to identify how HTTP messages are framed.
+ */
+public enum Protocol {
+  /**
+   * An obsolete plaintext framing that does not use persistent sockets by
+   * default.
+   */
+  HTTP_1_0("http/1.0"),
+
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * <p>This version of OkHttp implements <a
+   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
+   * revisions to that spec.
+   */
+  HTTP_1_1("http/1.1"),
+
+  /**
+   * Chromium's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * <p>This version of OkHttp implements SPDY 3 <a
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
+   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of the SPDY spec.
+   */
+  SPDY_3("spdy/3.1"),
+
+  /**
+   * The IETF's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
+   * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
+   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
+   * exception message including the string {@code INADEQUATE_SECURITY}.
+   */
+  HTTP_2("h2");
+
+  private final String protocol;
+
+  Protocol(String protocol) {
+    this.protocol = protocol;
+  }
+
+  /**
+   * Returns the protocol identified by {@code protocol}.
+   * @throws IOException if {@code protocol} is unknown.
+   */
+  public static Protocol get(String protocol) throws IOException {
+    // Unroll the loop over values() to save an allocation.
+    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
+    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
+    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    throw new IOException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Returns the string used to identify this protocol for ALPN, like
+   * "http/1.1", "spdy/3.1" or "h2".
+   */
+  @Override public String toString() {
+    return protocol;
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/Request.java b/retrofit/src/main/java/retrofit/sharehttp/Request.java
new file mode 100644
index 000000000..7ad74bc97
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/Request.java
@@ -0,0 +1,245 @@
+package retrofit.sharehttp;
+
+//import com.squareup.okhttp.internal.Platform;
+//import com.squareup.okhttp.internal.Util;
+//import com.squareup.okhttp.internal.http.HttpMethod;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.List;
+
+/**
+ * An HTTP request. Instances of this class are immutable if their {@link #body}
+ * is null or itself immutable.
+ */
+public final class Request {
+  private final String urlString;
+  private final String method;
+  private final Headers headers;
+  private final RequestBody body;
+  private final Object tag;
+
+  private volatile URL url; // Lazily initialized.
+  private volatile URI uri; // Lazily initialized.
+//  private volatile CacheControl cacheControl; // Lazily initialized.
+
+  private Request(Builder builder) {
+    this.urlString = builder.urlString;
+    this.method = builder.method;
+    this.headers = builder.headers.build();
+    this.body = builder.body;
+    this.tag = builder.tag != null ? builder.tag : this;
+    this.url = builder.url;
+  }
+
+  public URL url() {
+    try {
+      URL result = url;
+      return result != null ? result : (url = new URL(urlString));
+    } catch (MalformedURLException e) {
+      throw new RuntimeException("Malformed URL: " + urlString, e);
+    }
+  }
+
+//  public URI uri() throws IOException {
+//    try {
+//      URI result = uri;
+//      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
+//    } catch (URISyntaxException e) {
+//      throw new IOException(e.getMessage());
+//    }
+//  }
+
+  public String urlString() {
+    return urlString;
+  }
+
+  public String method() {
+    return method;
+  }
+
+  public Headers headers() {
+    return headers;
+  }
+
+  public String header(String name) {
+    return headers.get(name);
+  }
+
+  public List<String> headers(String name) {
+    return headers.values(name);
+  }
+
+  public RequestBody body() {
+    return body;
+  }
+
+  public Object tag() {
+    return tag;
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+//  public CacheControl cacheControl() {
+//    CacheControl result = cacheControl;
+//    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+//  }
+
+  public boolean isHttps() {
+    return url().getProtocol().equals("https");
+  }
+
+  @Override public String toString() {
+    return "Request{method="
+        + method
+        + ", url="
+        + urlString
+        + ", tag="
+        + (tag != this ? tag : null)
+        + '}';
+  }
+
+  public static class Builder {
+    private String urlString;
+    private URL url;
+    private String method;
+    private Headers.Builder headers;
+    private RequestBody body;
+    private Object tag;
+
+    public Builder() {
+      this.method = "GET";
+      this.headers = new Headers.Builder();
+    }
+
+    private Builder(Request request) {
+      this.urlString = request.urlString;
+      this.url = request.url;
+      this.method = request.method;
+      this.body = request.body;
+      this.tag = request.tag;
+      this.headers = request.headers.newBuilder();
+    }
+
+    public Builder url(String url) {
+      if (url == null) throw new IllegalArgumentException("url == null");
+      this.urlString = url;
+      this.url = null;
+      return this;
+    }
+
+    public Builder url(URL url) {
+      if (url == null) throw new IllegalArgumentException("url == null");
+      this.url = url;
+      this.urlString = url.toString();
+      return this;
+    }
+
+    /**
+     * Sets the header named {@code name} to {@code value}. If this request
+     * already has any headers with that name, they are all replaced.
+     */
+    public Builder header(String name, String value) {
+      headers.set(name, value);
+      return this;
+    }
+
+    /**
+     * Adds a header with {@code name} and {@code value}. Prefer this method for
+     * multiply-valued headers like "Cookie".
+     */
+    public Builder addHeader(String name, String value) {
+      headers.add(name, value);
+      return this;
+    }
+
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    /**
+     * Sets this request's {@code Cache-Control} header, replacing any cache
+     * control headers already present. If {@code cacheControl} doesn't define
+     * any directives, this clears this request's cache-control headers.
+     */
+//    public Builder cacheControl(CacheControl cacheControl) {
+//      String value = cacheControl.toString();
+//      if (value.isEmpty()) return removeHeader("Cache-Control");
+//      return header("Cache-Control", value);
+//    }
+
+    public Builder get() {
+      return method("GET", null);
+    }
+
+    public Builder head() {
+      return method("HEAD", null);
+    }
+
+    public Builder post(RequestBody body) {
+      return method("POST", body);
+    }
+
+    public Builder delete(RequestBody body) {
+      return method("DELETE", body);
+    }
+
+    public Builder delete() {
+      return method("DELETE", null);
+    }
+
+    public Builder put(RequestBody body) {
+      return method("PUT", body);
+    }
+
+    public Builder patch(RequestBody body) {
+      return method("PATCH", body);
+    }
+
+    public Builder method(String method, RequestBody body) {
+      if (method == null || method.length() == 0) {
+        throw new IllegalArgumentException("method == null || method.length() == 0");
+      }
+      if (body != null && !HttpMethod.permitsRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
+      if (body == null && HttpMethod.permitsRequestBody(method)) {
+        body = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
+      }
+      this.method = method;
+      this.body = body;
+      return this;
+    }
+
+    /**
+     * Attaches {@code tag} to the request. It can be used later to cancel the
+     * request. If the tag is unspecified or null, the request is canceled by
+     * using the request itself as the tag.
+     */
+    public Builder tag(Object tag) {
+      this.tag = tag;
+      return this;
+    }
+
+    public Request build() {
+      if (urlString == null) throw new IllegalStateException("url == null");
+      return new Request(this);
+    }
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/RequestBody.java b/retrofit/src/main/java/retrofit/sharehttp/RequestBody.java
new file mode 100644
index 000000000..9011f38c1
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/RequestBody.java
@@ -0,0 +1,94 @@
+package retrofit.sharehttp;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+
+public abstract class RequestBody {
+  /** Returns the Content-Type header for this body. */
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes that will be written to {@code out} in a call
+   * to {@link #writeTo}, or -1 if that count is unknown.
+   */
+  public long contentLength() throws IOException {
+    return -1;
+  }
+
+  /** Writes the content of this request to {@code out}. */
+  public abstract void writeTo(BufferedSink sink) throws IOException;
+
+  /**
+   * Returns a new request body that transmits {@code content}. If {@code
+   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   */
+  public static RequestBody create(MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    byte[] bytes = content.getBytes(charset);
+    return create(contentType, bytes);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content) {
+    return create(contentType, content, 0, content.length);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content,
+      final int offset, final int byteCount) {
+    if (content == null) throw new NullPointerException("content == null");
+    Util.checkOffsetAndCount(content.length, offset, byteCount);
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return byteCount;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content, offset, byteCount);
+      }
+    };
+  }
+
+  /** Returns a new request body that transmits the content of {@code file}. */
+  public static RequestBody create(final MediaType contentType, final File file) {
+    if (file == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return file.length();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Source source = null;
+        try {
+          source = Okio.source(file);
+          sink.writeAll(source);
+        } finally {
+          Util.closeQuietly(source);
+        }
+      }
+    };
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/Response.java b/retrofit/src/main/java/retrofit/sharehttp/Response.java
new file mode 100644
index 000000000..08f56c9ba
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/Response.java
@@ -0,0 +1,336 @@
+package retrofit.sharehttp;
+
+import java.util.List;
+
+import static retrofit.sharehttp.StatusLine.HTTP_PERM_REDIRECT;
+import static retrofit.sharehttp.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+
+/**
+ * An HTTP response. Instances of this class are not immutable: the response
+ * body is a one-shot value that may be consumed only once. All other properties
+ * are immutable.
+ */
+public final class Response {
+  private final Request request;
+  private final Protocol protocol;
+  private final int code;
+  private final String message;
+//  private final Handshake handshake;
+  private final Headers headers;
+  private final ResponseBody body;
+  private Response networkResponse;
+  private Response cacheResponse;
+  private final Response priorResponse;
+
+  private volatile CacheControl cacheControl; // Lazily initialized.
+
+  private Response(Builder builder) {
+    this.request = builder.request;
+    this.protocol = builder.protocol;
+    this.code = builder.code;
+    this.message = builder.message;
+//    this.handshake = builder.handshake;
+    this.headers = builder.headers.build();
+    this.body = builder.body;
+    this.networkResponse = builder.networkResponse;
+    this.cacheResponse = builder.cacheResponse;
+    this.priorResponse = builder.priorResponse;
+  }
+
+  /**
+   * The wire-level request that initiated this HTTP response. This is not
+   * necessarily the same request issued by the application:
+   * <ul>
+   *     <li>It may be transformed by the HTTP client. For example, the client
+   *         may copy headers like {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or
+   *         authentication challenge. In this case the request URL may be
+   *         different than the initial request URL.
+   * </ul>
+   */
+  public Request request() {
+    return request;
+  }
+
+  /**
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
+   * Protocol#HTTP_1_0}.
+   */
+  public Protocol protocol() {
+    return protocol;
+  }
+
+  /** Returns the HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /**
+   * Returns true if the code is in [200..300), which means the request was
+   * successfully received, understood, and accepted.
+   */
+  public boolean isSuccessful() {
+    return code >= 200 && code < 300;
+  }
+
+  /** Returns the HTTP status message or null if it is unknown. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or
+   * null if the response was received without TLS.
+   */
+//  public Handshake handshake() {
+//    return handshake;
+//  }
+
+  public List<String> headers(String name) {
+    return headers.values(name);
+  }
+
+  public String header(String name) {
+    return header(name, null);
+  }
+
+  public String header(String name, String defaultValue) {
+    String result = headers.get(name);
+    return result != null ? result : defaultValue;
+  }
+
+  public Headers headers() {
+    return headers;
+  }
+
+  public ResponseBody body() {
+    return body;
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  /** Returns true if this response redirects to another resource. */
+  public boolean isRedirect() {
+    switch (code) {
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  /**
+   * Returns the raw response received from the network. Will be null if this
+   * response didn't use the network, such as when the response is fully cached.
+   * The body of the returned response should not be read.
+   */
+  public Response networkResponse() {
+    return networkResponse;
+  }
+
+  /**
+   * Returns the raw response received from the cache. Will be null if this
+   * response didn't use the cache. For conditional get requests the cache
+   * response and network response may both be non-null. The body of the
+   * returned response should not be read.
+   */
+  public Response cacheResponse() {
+    return cacheResponse;
+  }
+
+  /**
+   * Returns the response for the HTTP redirect or authorization challenge that
+   * triggered this response, or null if this response wasn't triggered by an
+   * automatic retry. The body of the returned response should not be read
+   * because it has already been consumed by the redirecting client.
+   */
+  public Response priorResponse() {
+    return priorResponse;
+  }
+
+  /**
+   * Returns the authorization challenges appropriate for this response's code.
+   * If the response code is 401 unauthorized, this returns the
+   * "WWW-Authenticate" challenges. If the response code is 407 proxy
+   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
+   * this returns an empty list of challenges.
+   */
+//  public List<Challenge> challenges() {
+//    String responseField;
+//    if (code == HTTP_UNAUTHORIZED) {
+//      responseField = "WWW-Authenticate";
+//    } else if (code == HTTP_PROXY_AUTH) {
+//      responseField = "Proxy-Authenticate";
+//    } else {
+//      return Collections.emptyList();
+//    }
+//    return OkHeaders.parseChallenges(headers(), responseField);
+//  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
+  @Override public String toString() {
+    return "Response{protocol="
+        + protocol
+        + ", code="
+        + code
+        + ", message="
+        + message
+        + ", url="
+        + request.urlString()
+        + '}';
+  }
+
+  public static class Builder {
+    private Request request;
+    private Protocol protocol;
+    private int code = -1;
+    private String message;
+//    private Handshake handshake;
+    private Headers.Builder headers;
+    private ResponseBody body;
+    private Response networkResponse;
+    private Response cacheResponse;
+    private Response priorResponse;
+
+    public Builder() {
+      headers = new Headers.Builder();
+    }
+
+    private Builder(Response response) {
+      this.request = response.request;
+      this.protocol = response.protocol;
+      this.code = response.code;
+      this.message = response.message;
+//      this.handshake = response.handshake;
+      this.headers = response.headers.newBuilder();
+      this.body = response.body;
+      this.networkResponse = response.networkResponse;
+      this.cacheResponse = response.cacheResponse;
+      this.priorResponse = response.priorResponse;
+    }
+
+    public Builder request(Request request) {
+      this.request = request;
+      return this;
+    }
+
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
+      return this;
+    }
+
+    public Builder code(int code) {
+      this.code = code;
+      return this;
+    }
+
+    public Builder message(String message) {
+      this.message = message;
+      return this;
+    }
+
+//    public Builder handshake(Handshake handshake) {
+//      this.handshake = handshake;
+//      return this;
+//    }
+
+    /**
+     * Sets the header named {@code name} to {@code value}. If this request
+     * already has any headers with that name, they are all replaced.
+     */
+    public Builder header(String name, String value) {
+      headers.set(name, value);
+      return this;
+    }
+
+    /**
+     * Adds a header with {@code name} and {@code value}. Prefer this method for
+     * multiply-valued headers like "Set-Cookie".
+     */
+    public Builder addHeader(String name, String value) {
+      headers.add(name, value);
+      return this;
+    }
+
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    public Builder body(ResponseBody body) {
+      this.body = body;
+      return this;
+    }
+
+    public Builder networkResponse(Response networkResponse) {
+      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
+      this.networkResponse = networkResponse;
+      return this;
+    }
+
+    public Builder cacheResponse(Response cacheResponse) {
+      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
+      this.cacheResponse = cacheResponse;
+      return this;
+    }
+
+    private void checkSupportResponse(String name, Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException(name + ".body != null");
+      } else if (response.networkResponse != null) {
+        throw new IllegalArgumentException(name + ".networkResponse != null");
+      } else if (response.cacheResponse != null) {
+        throw new IllegalArgumentException(name + ".cacheResponse != null");
+      } else if (response.priorResponse != null) {
+        throw new IllegalArgumentException(name + ".priorResponse != null");
+      }
+    }
+
+    public Builder priorResponse(Response priorResponse) {
+      if (priorResponse != null) checkPriorResponse(priorResponse);
+      this.priorResponse = priorResponse;
+      return this;
+    }
+
+    private void checkPriorResponse(Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException("priorResponse.body != null");
+      }
+    }
+
+    public Response build() {
+      if (request == null) throw new IllegalStateException("request == null");
+      if (protocol == null) throw new IllegalStateException("protocol == null");
+      if (code < 0) throw new IllegalStateException("code < 0: " + code);
+      return new Response(this);
+    }
+  }
+}
+
diff --git a/retrofit/src/main/java/retrofit/sharehttp/ResponseBody.java b/retrofit/src/main/java/retrofit/sharehttp/ResponseBody.java
new file mode 100644
index 000000000..35d4ba3d2
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/ResponseBody.java
@@ -0,0 +1,17 @@
+package retrofit.sharehttp;
+
+import okio.Source;
+
+/**
+ * Created by dementrock on 3/20/15.
+ */
+public abstract class ResponseBody {
+
+    public abstract MediaType contentType();
+
+    public abstract Source source();
+
+    public abstract long contentLength();
+
+
+}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/ResponseCallback.java b/retrofit/src/main/java/retrofit/sharehttp/ResponseCallback.java
new file mode 100644
index 000000000..7c0b28d19
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/ResponseCallback.java
@@ -0,0 +1,14 @@
+package retrofit.sharehttp;
+
+import java.io.IOException;
+
+/**
+ * Created by dementrock on 3/20/15.
+ */
+public interface ResponseCallback {
+
+    void onFailure(Request request, IOException e);
+
+    void onResponse(Response response);
+
+}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/ShareHttpClient.java b/retrofit/src/main/java/retrofit/sharehttp/ShareHttpClient.java
new file mode 100644
index 000000000..4338c814a
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/ShareHttpClient.java
@@ -0,0 +1,38 @@
+package retrofit.sharehttp;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Created by dementrock on 3/20/15.
+ */
+public abstract class ShareHttpClient {
+
+    private static ShareHttpClientFactory sFactory;
+
+    public static ShareHttpClientFactory getFactory() {
+        return sFactory;
+    }
+
+    public static void setFactory(ShareHttpClientFactory factory) {
+        sFactory = factory;
+    }
+
+    public static ShareHttpClient newInstance() {
+        if (sFactory != null) {
+            return sFactory.newInstance();
+        }
+        throw new RuntimeException("Need to set Factory before instantiating ShareHttpClient " +
+                "instance!");
+    }
+
+    public abstract void setConnectTimeout(long timeout, TimeUnit unit);
+
+    public abstract void setReadTimeout(long timeout, TimeUnit unit);
+
+    public abstract void setWriteTimeout(long timeout, TimeUnit unit);
+
+    public abstract Response executeSync(Request request) throws IOException;
+
+    public abstract void executeAsync(Request request, ResponseCallback callback);
+}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/ShareHttpClientFactory.java b/retrofit/src/main/java/retrofit/sharehttp/ShareHttpClientFactory.java
new file mode 100644
index 000000000..5fe72405a
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/ShareHttpClientFactory.java
@@ -0,0 +1,10 @@
+package retrofit.sharehttp;
+
+/**
+ * Created by dementrock on 3/20/15.
+ */
+public interface ShareHttpClientFactory {
+
+    ShareHttpClient newInstance();
+
+}
diff --git a/retrofit/src/main/java/retrofit/sharehttp/StatusLine.java b/retrofit/src/main/java/retrofit/sharehttp/StatusLine.java
new file mode 100644
index 000000000..8760b5d9d
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/StatusLine.java
@@ -0,0 +1,88 @@
+package retrofit.sharehttp;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+
+/** An HTTP response status line like "HTTP/1.1 200 OK". */
+public final class StatusLine {
+  /** Numeric status code, 307: Temporary Redirect. */
+  public static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_PERM_REDIRECT = 308;
+  public static final int HTTP_CONTINUE = 100;
+
+  public final Protocol protocol;
+  public final int code;
+  public final String message;
+
+  public StatusLine(Protocol protocol, int code, String message) {
+    this.protocol = protocol;
+    this.code = code;
+    this.message = message;
+  }
+
+  public static StatusLine get(Response response) {
+    return new StatusLine(response.protocol(), response.code(), response.message());
+  }
+
+  public static StatusLine parse(String statusLine) throws IOException {
+    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+
+    // Parse protocol like "HTTP/1.1" followed by a space.
+    int codeStart;
+    Protocol protocol;
+    if (statusLine.startsWith("HTTP/1.")) {
+      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      int httpMinorVersion = statusLine.charAt(7) - '0';
+      codeStart = 9;
+      if (httpMinorVersion == 0) {
+        protocol = Protocol.HTTP_1_0;
+      } else if (httpMinorVersion == 1) {
+        protocol = Protocol.HTTP_1_1;
+      } else {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+    } else if (statusLine.startsWith("ICY ")) {
+      // Shoutcast uses ICY instead of "HTTP/1.0".
+      protocol = Protocol.HTTP_1_0;
+      codeStart = 4;
+    } else {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse response code like "200". Always 3 digits.
+    if (statusLine.length() < codeStart + 3) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    int code;
+    try {
+      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+    } catch (NumberFormatException e) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse an optional response message like "OK" or "Not Modified". If it
+    // exists, it is separated from the response code by a space.
+    String message = "";
+    if (statusLine.length() > codeStart + 3) {
+      if (statusLine.charAt(codeStart + 3) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      message = statusLine.substring(codeStart + 4);
+    }
+
+    return new StatusLine(protocol, code, message);
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
+    result.append(' ').append(code);
+    if (message != null) {
+      result.append(' ').append(message);
+    }
+    return result.toString();
+  }
+}
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/sharehttp/Util.java b/retrofit/src/main/java/retrofit/sharehttp/Util.java
new file mode 100644
index 000000000..b7408aa8f
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/sharehttp/Util.java
@@ -0,0 +1,31 @@
+package retrofit.sharehttp;
+
+import java.io.Closeable;
+import java.nio.charset.Charset;
+
+/**
+ * Created by dementrock on 3/20/15.
+ */
+public class Util {
+
+  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
+    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+      throw new ArrayIndexOutOfBoundsException();
+    }
+  }
+
+  public static void closeQuietly(Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+}
