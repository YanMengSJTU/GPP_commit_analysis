diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index df0f1073d..960aae6d9 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -19,99 +19,115 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import javax.annotation.Nullable;
+
 import kotlin.Unit;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
+/**
+ * 内置的转换器
+ */
 final class BuiltInConverters extends Converter.Factory {
-  /** Not volatile because we don't mind multiple threads discovering this. */
-  private boolean checkForKotlinUnit = true;
-
-  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
-      Type type, Annotation[] annotations, Retrofit retrofit) {
-    if (type == ResponseBody.class) {
-      return Utils.isAnnotationPresent(annotations, Streaming.class)
-          ? StreamingResponseBodyConverter.INSTANCE
-          : BufferingResponseBodyConverter.INSTANCE;
-    }
-    if (type == Void.class) {
-      return VoidResponseBodyConverter.INSTANCE;
-    }
-    if (checkForKotlinUnit) {
-      try {
-        if (type == Unit.class) {
-          return UnitResponseBodyConverter.INSTANCE;
+    /**
+     * Not volatile because we don't mind multiple threads discovering this.
+     */
+    private boolean checkForKotlinUnit = true;
+
+    @Override
+    public @Nullable
+    Converter<ResponseBody, ?> responseBodyConverter(
+            Type type, Annotation[] annotations, Retrofit retrofit) {
+        if (type == ResponseBody.class) {
+            return Utils.isAnnotationPresent(annotations, Streaming.class)
+                    ? StreamingResponseBodyConverter.INSTANCE
+                    : BufferingResponseBodyConverter.INSTANCE;
         }
-      } catch (NoClassDefFoundError ignored) {
-        checkForKotlinUnit = false;
-      }
+        if (type == Void.class) {
+            return VoidResponseBodyConverter.INSTANCE;
+        }
+        if (checkForKotlinUnit) {
+            try {
+                if (type == Unit.class) {
+                    return UnitResponseBodyConverter.INSTANCE;
+                }
+            } catch (NoClassDefFoundError ignored) {
+                checkForKotlinUnit = false;
+            }
+        }
+        return null;
     }
-    return null;
-  }
 
-  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
-      return RequestBodyConverter.INSTANCE;
+    @Override
+    public @Nullable
+    Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                   Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+            return RequestBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
-    static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
+    static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
+        static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
-    @Override public Void convert(ResponseBody value) {
-      value.close();
-      return null;
+        @Override
+        public Void convert(ResponseBody value) {
+            value.close();
+            return null;
+        }
     }
-  }
 
-  static final class UnitResponseBodyConverter implements Converter<ResponseBody, Unit> {
-    static final UnitResponseBodyConverter INSTANCE = new UnitResponseBodyConverter();
+    static final class UnitResponseBodyConverter implements Converter<ResponseBody, Unit> {
+        static final UnitResponseBodyConverter INSTANCE = new UnitResponseBodyConverter();
 
-    @Override public Unit convert(ResponseBody value) {
-      value.close();
-      return Unit.INSTANCE;
+        @Override
+        public Unit convert(ResponseBody value) {
+            value.close();
+            return Unit.INSTANCE;
+        }
     }
-  }
 
-  static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
-    static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
+    static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
+        static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
-    @Override public RequestBody convert(RequestBody value) {
-      return value;
+        @Override
+        public RequestBody convert(RequestBody value) {
+            return value;
+        }
     }
-  }
 
-  static final class StreamingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
+    static final class StreamingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) {
-      return value;
+        @Override
+        public ResponseBody convert(ResponseBody value) {
+            return value;
+        }
     }
-  }
-
-  static final class BufferingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
-
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        return Utils.buffer(value);
-      } finally {
-        value.close();
-      }
+
+    static final class BufferingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
+
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                return Utils.buffer(value);
+            } finally {
+                value.close();
+            }
+        }
     }
-  }
 
-  static final class ToStringConverter implements Converter<Object, String> {
-    static final ToStringConverter INSTANCE = new ToStringConverter();
+    static final class ToStringConverter implements Converter<Object, String> {
+        static final ToStringConverter INSTANCE = new ToStringConverter();
 
-    @Override public String convert(Object value) {
-      return value.toString();
+        @Override
+        public String convert(Object value) {
+            return value.toString();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index dedfb0e74..b4e3c091d 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -20,93 +20,114 @@
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
+
 import okhttp3.Request;
 
 import static retrofit2.Utils.checkNotNull;
 
+/**
+ * 默认的回调处理器
+ */
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override public @Nullable CallAdapter<?, ?> get(
-      Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object, Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public Call<Object> adapt(Call<Object> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
     final Executor callbackExecutor;
-    final Call<T> delegate;
 
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
+    ExecutorCallAdapterFactory(Executor callbackExecutor) {
+        this.callbackExecutor = callbackExecutor;
     }
 
-    @Override public void enqueue(final Callback<T> callback) {
-      checkNotNull(callback, "callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
+    @Override
+    public @Nullable
+    CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
         }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Object, Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
+            @Override
+            public Call<Object> adapt(Call<Object> call) {
+                return new ExecutorCallbackCall<>(callbackExecutor, call);
             }
-          });
-        }
-      });
+        };
     }
 
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
+    static final class ExecutorCallbackCall<T> implements Call<T> {
+        final Executor callbackExecutor;
+        final Call<T> delegate;
 
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
+        ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+            this.callbackExecutor = callbackExecutor;
+            this.delegate = delegate;
+        }
 
-    @Override public void cancel() {
-      delegate.cancel();
-    }
+        @Override
+        public void enqueue(final Callback<T> callback) {
+            checkNotNull(callback, "callback == null");
+
+            // 加入到请求队列中进行请求
+            delegate.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, final Response<T> response) {
+                    // 得到了请求结果了
+                    // 通过请求回调回调到UI线程
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (delegate.isCanceled()) {
+                                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+                            } else {
+                                callback.onResponse(ExecutorCallbackCall.this, response);
+                            }
+                        }
+                    });
+                }
+
+                @Override
+                public void onFailure(Call<T> call, final Throwable t) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onFailure(ExecutorCallbackCall.this, t);
+                        }
+                    });
+                }
+            });
+        }
 
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
+        @Override
+        public boolean isExecuted() {
+            return delegate.isExecuted();
+        }
 
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
+        @Override
+        public Response<T> execute() throws IOException {
+            return delegate.execute();
+        }
+
+        @Override
+        public void cancel() {
+            delegate.cancel();
+        }
+
+        @Override
+        public boolean isCanceled() {
+            return delegate.isCanceled();
+        }
 
-    @Override public Request request() {
-      return delegate.request();
+        @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+        @Override
+        public Call<T> clone() {
+            return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+        }
+
+        @Override
+        public Request request() {
+            return delegate.request();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index d149df56a..6e9d9d7b2 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -18,75 +18,115 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+
 import okhttp3.ResponseBody;
 
 import static retrofit2.Utils.methodError;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
+/**
+ * Adapts an invocation of an interface method into an HTTP call.
+ */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method that
-   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
-   * method only once and reuse it.
-   */
-  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
-      Retrofit retrofit, Method method, RequestFactory requestFactory) {
-    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
-    Type responseType = callAdapter.responseType();
-    if (responseType == Response.class || responseType == okhttp3.Response.class) {
-      throw methodError(method, "'"
-          + Utils.getRawType(responseType).getName()
-          + "' is not a valid response body type. Did you mean ResponseBody?");
-    }
-    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
-      throw methodError(method, "HEAD method must use Void as response type.");
-    }
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method that
+     * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+     * method only once and reuse it.
+     * 检查接口方法上的注解，以构建可以说HTTP的可重用服务方法。
+     * 这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。
+     */
+    static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+            Retrofit retrofit, Method method, RequestFactory requestFactory) {
+        // 获取一个 适配器，如果是RxJava的话，返回的就是RxJava适配器了
+        CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
+        // 数据返回类型
+        Type responseType = callAdapter.responseType();
+        if (responseType == Response.class || responseType == okhttp3.Response.class) {
+            throw methodError(method, "'"
+                    + Utils.getRawType(responseType).getName()
+                    + "' is not a valid response body type. Did you mean ResponseBody?");
+        }
+        // HEAD没有响应体
+        if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+            throw methodError(method, "HEAD method must use Void as response type.");
+        }
 
-    Converter<ResponseBody, ResponseT> responseConverter =
-        createResponseConverter(retrofit, method, responseType);
+        //获取将返回数据序列化的转换器
+        // 序列化和反序列化的转换器
+        Converter<ResponseBody, ResponseT> responseConverter =
+                createResponseConverter(retrofit, method, responseType);
 
-    okhttp3.Call.Factory callFactory = retrofit.callFactory;
-    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
-  }
+        // 其实这个就是OkHttpClient
+        okhttp3.Call.Factory callFactory = retrofit.callFactory;
 
-  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
-      Retrofit retrofit, Method method) {
-    Type returnType = method.getGenericReturnType();
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      //noinspection unchecked
-      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+        // 每一个请求方法就是一个对象
+        return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
     }
-  }
 
-  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
-      Retrofit retrofit, Method method, Type responseType) {
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.responseBodyConverter(responseType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw methodError(method, e, "Unable to create converter for %s", responseType);
+    private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+            Retrofit retrofit, Method method) {
+        // 方法的返回类型
+        Type returnType = method.getGenericReturnType();
+        // 方法上面的注解
+        Annotation[] annotations = method.getAnnotations();
+        try {
+            //noinspection unchecked
+            // 获取相应的适配器，转换成不同的数据格式
+            return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+            throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+        }
     }
-  }
 
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
+    /**
+     * 创建返回值序列化的转换器
+     *
+     * @param retrofit
+     * @param method
+     * @param responseType
+     * @param <ResponseT>
+     * @return
+     */
+    private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+            Retrofit retrofit, Method method, Type responseType) {
+        // 获取方法上面的注解
+        Annotation[] annotations = method.getAnnotations();
+        try {
+            return retrofit.responseBodyConverter(responseType, annotations);
+        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+            throw methodError(method, e, "Unable to create converter for %s", responseType);
+        }
+    }
+
+    /**
+     * 请求工程类，所有请求相关的配置都在这里
+     * 比如请求方式啊，参数啊，请求头啊，请求体啊之类的
+     */
+    private final RequestFactory requestFactory;
+    /**
+     * 发起请求的工厂
+     */
+    private final okhttp3.Call.Factory callFactory;
+    /**
+     * 类型转换适配器
+     */
+    private final CallAdapter<ResponseT, ReturnT> callAdapter;
+    /**
+     * 序列化与反序列化的转换器
+     */
+    private final Converter<ResponseBody, ResponseT> responseConverter;
 
-  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
-      CallAdapter<ResponseT, ReturnT> callAdapter,
-      Converter<ResponseBody, ResponseT> responseConverter) {
-    this.requestFactory = requestFactory;
-    this.callFactory = callFactory;
-    this.callAdapter = callAdapter;
-    this.responseConverter = responseConverter;
-  }
+    private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+                              CallAdapter<ResponseT, ReturnT> callAdapter,
+                              Converter<ResponseBody, ResponseT> responseConverter) {
+        this.requestFactory = requestFactory;
+        this.callFactory = callFactory;
+        this.callAdapter = callAdapter;
+        this.responseConverter = responseConverter;
+    }
 
-  @Override ReturnT invoke(Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
+    @Override
+    ReturnT invoke(Object[] args) {
+        return callAdapter.adapt(
+                new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index baec970ac..eb23cb781 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -165,14 +165,21 @@ public Executor defaultCallbackExecutor() {
         List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
                 @Nullable Executor callbackExecutor) {
             if (callbackExecutor == null) throw new AssertionError();
+
+            // 返回一个只有默认转换器的list集合
             return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
         }
 
+        /**
+         * 安卓平台下，主线程回调使用的是Handler
+         */
         static class MainThreadExecutor implements Executor {
+            // 获取主线程的handler
             private final Handler handler = new Handler(Looper.getMainLooper());
 
             @Override
             public void execute(Runnable r) {
+                // 请求结果从这里回调回来了
                 handler.post(r);
             }
         }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 78a4c0af4..b3a9d8efd 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -197,6 +197,8 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
         RequestFactory build() {
             // 遍历方法数组  e.g.. array[]
             for (Annotation annotation : methodAnnotations) {
+                // 解析标记在方法注解
+                // e.g.. @GET/@POST
                 parseMethodAnnotation(annotation);
             }
 
@@ -219,7 +221,7 @@ RequestFactory build() {
                 }
             }
 
-            // 处理参数
+            // 处理参数注解
             int parameterCount = parameterAnnotationsArray.length;
             // 每一个参数对应一个参数处理者数组
             parameterHandlers = new ParameterHandler<?>[parameterCount];
@@ -369,9 +371,10 @@ private Headers parseHeaders(String[] headers) {
 
         /**
          * 解析参数
+         *
          * @param position
          * @param parameterType
-         * @param annotations
+         * @param annotations   参数注解数组
          * @return
          */
         private ParameterHandler<?> parseParameter(int position,
@@ -407,34 +410,35 @@ private Headers parseHeaders(String[] headers) {
 
         /**
          * 解析参数注解  @Query @Field
-         * @param p
+         *
+         * @param position
          * @param type
-         * @param annotations
-         * @param annotation
+         * @param annotations 参数注解数组
+         * @param annotation  当前的参数注解
          * @return
          */
         private ParameterHandler<?> parseParameterAnnotation(
-                int p, Type type, Annotation[] annotations, Annotation annotation) {
+                int position, Type type, Annotation[] annotations, Annotation annotation) {
             if (annotation instanceof Url) {
                 //参数类型不得包含类型变量或通配符
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 if (gotUrl) {
-                    throw parameterError(method, p, "Multiple @Url method annotations found.");
+                    throw parameterError(method, position, "Multiple @Url method annotations found.");
                 }
                 if (gotPath) {
-                    throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+                    throw parameterError(method, position, "@Path parameters may not be used with @Url.");
                 }
                 if (gotQuery) {
-                    throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+                    throw parameterError(method, position, "A @Url parameter must not come after a @Query.");
                 }
                 if (gotQueryName) {
-                    throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+                    throw parameterError(method, position, "A @Url parameter must not come after a @QueryName.");
                 }
                 if (gotQueryMap) {
-                    throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
+                    throw parameterError(method, position, "A @Url parameter must not come after a @QueryMap.");
                 }
                 if (relativeUrl != null) {
-                    throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
+                    throw parameterError(method, position, "@Url cannot be used with @%s URL", httpMethod);
                 }
 
                 gotUrl = true;
@@ -445,39 +449,42 @@ private Headers parseHeaders(String[] headers) {
                         || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
                     return new ParameterHandler.RelativeUrl();
                 } else {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
                 }
 
             } else if (annotation instanceof Path) {
-                validateResolvableType(p, type);
+                // Path注解必须是第一个，不能放在第二个
+                validateResolvableType(position, type);
                 if (gotQuery) {
-                    throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
+                    throw parameterError(method, position, "A @Path parameter must not come after a @Query.");
                 }
                 if (gotQueryName) {
-                    throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+                    throw parameterError(method, position, "A @Path parameter must not come after a @QueryName.");
                 }
                 if (gotQueryMap) {
-                    throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
+                    throw parameterError(method, position, "A @Path parameter must not come after a @QueryMap.");
                 }
                 if (gotUrl) {
-                    throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+                    throw parameterError(method, position, "@Path parameters may not be used with @Url.");
                 }
                 if (relativeUrl == null) {
-                    throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+                    throw parameterError(method, position, "@Path can only be used with relative url on @%s",
                             httpMethod);
                 }
                 gotPath = true;
 
                 Path path = (Path) annotation;
                 String name = path.value();
-                validatePathName(p, name);
+                validatePathName(position, name);
 
+                // 这里是填充到字符串中的
+                // 字符串转换器
                 Converter<?, String> converter = retrofit.stringConverter(type, annotations);
                 return new ParameterHandler.Path<>(name, converter, path.encoded());
 
             } else if (annotation instanceof Query) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 Query query = (Query) annotation;
                 String name = query.value();
                 boolean encoded = query.encoded();
@@ -486,7 +493,7 @@ private Headers parseHeaders(String[] headers) {
                 gotQuery = true;
                 if (Iterable.class.isAssignableFrom(rawParameterType)) {
                     if (!(type instanceof ParameterizedType)) {
-                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                        throw parameterError(method, position, rawParameterType.getSimpleName()
                                 + " must include generic type (e.g., "
                                 + rawParameterType.getSimpleName()
                                 + "<String>)");
@@ -508,7 +515,7 @@ private Headers parseHeaders(String[] headers) {
                 }
 
             } else if (annotation instanceof QueryName) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 QueryName query = (QueryName) annotation;
                 boolean encoded = query.encoded();
 
@@ -516,7 +523,7 @@ private Headers parseHeaders(String[] headers) {
                 gotQueryName = true;
                 if (Iterable.class.isAssignableFrom(rawParameterType)) {
                     if (!(type instanceof ParameterizedType)) {
-                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                        throw parameterError(method, position, rawParameterType.getSimpleName()
                                 + " must include generic type (e.g., "
                                 + rawParameterType.getSimpleName()
                                 + "<String>)");
@@ -538,21 +545,21 @@ private Headers parseHeaders(String[] headers) {
                 }
 
             } else if (annotation instanceof QueryMap) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 Class<?> rawParameterType = Utils.getRawType(type);
                 gotQueryMap = true;
                 if (!Map.class.isAssignableFrom(rawParameterType)) {
-                    throw parameterError(method, p, "@QueryMap parameter type must be Map.");
+                    throw parameterError(method, position, "@QueryMap parameter type must be Map.");
                 }
                 Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
                 if (!(mapType instanceof ParameterizedType)) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "Map must include generic types (e.g., Map<String, String>)");
                 }
                 ParameterizedType parameterizedType = (ParameterizedType) mapType;
                 Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
                 if (String.class != keyType) {
-                    throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
+                    throw parameterError(method, position, "@QueryMap keys must be of type String: " + keyType);
                 }
                 Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
                 Converter<?, String> valueConverter =
@@ -561,14 +568,14 @@ private Headers parseHeaders(String[] headers) {
                 return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
             } else if (annotation instanceof Header) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 Header header = (Header) annotation;
                 String name = header.value();
 
                 Class<?> rawParameterType = Utils.getRawType(type);
                 if (Iterable.class.isAssignableFrom(rawParameterType)) {
                     if (!(type instanceof ParameterizedType)) {
-                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                        throw parameterError(method, position, rawParameterType.getSimpleName()
                                 + " must include generic type (e.g., "
                                 + rawParameterType.getSimpleName()
                                 + "<String>)");
@@ -590,20 +597,20 @@ private Headers parseHeaders(String[] headers) {
                 }
 
             } else if (annotation instanceof HeaderMap) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 Class<?> rawParameterType = Utils.getRawType(type);
                 if (!Map.class.isAssignableFrom(rawParameterType)) {
-                    throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
+                    throw parameterError(method, position, "@HeaderMap parameter type must be Map.");
                 }
                 Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
                 if (!(mapType instanceof ParameterizedType)) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "Map must include generic types (e.g., Map<String, String>)");
                 }
                 ParameterizedType parameterizedType = (ParameterizedType) mapType;
                 Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
                 if (String.class != keyType) {
-                    throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
+                    throw parameterError(method, position, "@HeaderMap keys must be of type String: " + keyType);
                 }
                 Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
                 Converter<?, String> valueConverter =
@@ -612,9 +619,9 @@ private Headers parseHeaders(String[] headers) {
                 return new ParameterHandler.HeaderMap<>(valueConverter);
 
             } else if (annotation instanceof Field) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 if (!isFormEncoded) {
-                    throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
+                    throw parameterError(method, position, "@Field parameters can only be used with form encoding.");
                 }
                 Field field = (Field) annotation;
                 String name = field.value();
@@ -625,7 +632,7 @@ private Headers parseHeaders(String[] headers) {
                 Class<?> rawParameterType = Utils.getRawType(type);
                 if (Iterable.class.isAssignableFrom(rawParameterType)) {
                     if (!(type instanceof ParameterizedType)) {
-                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                        throw parameterError(method, position, rawParameterType.getSimpleName()
                                 + " must include generic type (e.g., "
                                 + rawParameterType.getSimpleName()
                                 + "<String>)");
@@ -647,24 +654,24 @@ private Headers parseHeaders(String[] headers) {
                 }
 
             } else if (annotation instanceof FieldMap) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 if (!isFormEncoded) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "@FieldMap parameters can only be used with form encoding.");
                 }
                 Class<?> rawParameterType = Utils.getRawType(type);
                 if (!Map.class.isAssignableFrom(rawParameterType)) {
-                    throw parameterError(method, p, "@FieldMap parameter type must be Map.");
+                    throw parameterError(method, position, "@FieldMap parameter type must be Map.");
                 }
                 Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
                 if (!(mapType instanceof ParameterizedType)) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "Map must include generic types (e.g., Map<String, String>)");
                 }
                 ParameterizedType parameterizedType = (ParameterizedType) mapType;
                 Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
                 if (String.class != keyType) {
-                    throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
+                    throw parameterError(method, position, "@FieldMap keys must be of type String: " + keyType);
                 }
                 Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
                 Converter<?, String> valueConverter =
@@ -674,9 +681,9 @@ private Headers parseHeaders(String[] headers) {
                 return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
             } else if (annotation instanceof Part) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 if (!isMultipart) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "@Part parameters can only be used with multipart encoding.");
                 }
                 Part part = (Part) annotation;
@@ -687,7 +694,7 @@ private Headers parseHeaders(String[] headers) {
                 if (partName.isEmpty()) {
                     if (Iterable.class.isAssignableFrom(rawParameterType)) {
                         if (!(type instanceof ParameterizedType)) {
-                            throw parameterError(method, p, rawParameterType.getSimpleName()
+                            throw parameterError(method, position, rawParameterType.getSimpleName()
                                     + " must include generic type (e.g., "
                                     + rawParameterType.getSimpleName()
                                     + "<String>)");
@@ -695,21 +702,21 @@ private Headers parseHeaders(String[] headers) {
                         ParameterizedType parameterizedType = (ParameterizedType) type;
                         Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
                         if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-                            throw parameterError(method, p,
+                            throw parameterError(method, position,
                                     "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
                         }
                         return ParameterHandler.RawPart.INSTANCE.iterable();
                     } else if (rawParameterType.isArray()) {
                         Class<?> arrayComponentType = rawParameterType.getComponentType();
                         if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-                            throw parameterError(method, p,
+                            throw parameterError(method, position,
                                     "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
                         }
                         return ParameterHandler.RawPart.INSTANCE.array();
                     } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
                         return ParameterHandler.RawPart.INSTANCE;
                     } else {
-                        throw parameterError(method, p,
+                        throw parameterError(method, position,
                                 "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
                     }
                 } else {
@@ -719,7 +726,7 @@ private Headers parseHeaders(String[] headers) {
 
                     if (Iterable.class.isAssignableFrom(rawParameterType)) {
                         if (!(type instanceof ParameterizedType)) {
-                            throw parameterError(method, p, rawParameterType.getSimpleName()
+                            throw parameterError(method, position, rawParameterType.getSimpleName()
                                     + " must include generic type (e.g., "
                                     + rawParameterType.getSimpleName()
                                     + "<String>)");
@@ -727,7 +734,7 @@ private Headers parseHeaders(String[] headers) {
                         ParameterizedType parameterizedType = (ParameterizedType) type;
                         Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
                         if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-                            throw parameterError(method, p,
+                            throw parameterError(method, position,
                                     "@Part parameters using the MultipartBody.Part must not "
                                             + "include a part name in the annotation.");
                         }
@@ -737,7 +744,7 @@ private Headers parseHeaders(String[] headers) {
                     } else if (rawParameterType.isArray()) {
                         Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
                         if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-                            throw parameterError(method, p,
+                            throw parameterError(method, position,
                                     "@Part parameters using the MultipartBody.Part must not "
                                             + "include a part name in the annotation.");
                         }
@@ -745,7 +752,7 @@ private Headers parseHeaders(String[] headers) {
                                 retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
                         return new ParameterHandler.Part<>(headers, converter).array();
                     } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-                        throw parameterError(method, p,
+                        throw parameterError(method, position,
                                 "@Part parameters using the MultipartBody.Part must not "
                                         + "include a part name in the annotation.");
                     } else {
@@ -756,31 +763,31 @@ private Headers parseHeaders(String[] headers) {
                 }
 
             } else if (annotation instanceof PartMap) {
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 if (!isMultipart) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "@PartMap parameters can only be used with multipart encoding.");
                 }
                 gotPart = true;
                 Class<?> rawParameterType = Utils.getRawType(type);
                 if (!Map.class.isAssignableFrom(rawParameterType)) {
-                    throw parameterError(method, p, "@PartMap parameter type must be Map.");
+                    throw parameterError(method, position, "@PartMap parameter type must be Map.");
                 }
                 Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
                 if (!(mapType instanceof ParameterizedType)) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "Map must include generic types (e.g., Map<String, String>)");
                 }
                 ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
                 Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
                 if (String.class != keyType) {
-                    throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+                    throw parameterError(method, position, "@PartMap keys must be of type String: " + keyType);
                 }
 
                 Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
                 if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-                    throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
+                    throw parameterError(method, position, "@PartMap values cannot be MultipartBody.Part. "
                             + "Use @Part List<Part> or a different value type instead.");
                 }
 
@@ -792,13 +799,13 @@ private Headers parseHeaders(String[] headers) {
 
             } else if (annotation instanceof Body) {
 
-                validateResolvableType(p, type);
+                validateResolvableType(position, type);
                 if (isFormEncoded || isMultipart) {
-                    throw parameterError(method, p,
+                    throw parameterError(method, position,
                             "@Body parameters cannot be used with form or multi-part encoding.");
                 }
                 if (gotBody) {
-                    throw parameterError(method, p, "Multiple @Body method annotations found.");
+                    throw parameterError(method, position, "Multiple @Body method annotations found.");
                 }
 
                 Converter<?, RequestBody> converter;
@@ -806,7 +813,7 @@ private Headers parseHeaders(String[] headers) {
                     converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
                 } catch (RuntimeException e) {
                     // Wide exception range because factories are user code.
-                    throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
+                    throw parameterError(method, e, position, "Unable to create @Body converter for %s", type);
                 }
                 gotBody = true;
                 return new ParameterHandler.Body<>(converter);
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index ac575a074..d31adafe2 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -59,19 +59,31 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
+    /**
+     * 所有已经创建成功了的请求
+     * <p>也就是我们在服务中创建了的方法，避免重复创建</p>
+     */
     private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
-
+    /**
+     * 就是传递的OkHttpClient
+     */
     final okhttp3.Call.Factory callFactory;
     final HttpUrl baseUrl;
+    /**
+     * 转换器工厂集合
+     */
     final List<Converter.Factory> converterFactories;
     final List<CallAdapter.Factory> callAdapterFactories;
     final @Nullable
     Executor callbackExecutor;
     final boolean validateEagerly;
 
-    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-             List<Converter.Factory> converterFactories, List<CallAdapter.Factory> callAdapterFactories,
-             @Nullable Executor callbackExecutor, boolean validateEagerly) {
+    Retrofit(okhttp3.Call.Factory callFactory,
+             HttpUrl baseUrl,
+             List<Converter.Factory> converterFactories,
+             List<CallAdapter.Factory> callAdapterFactories,
+             @Nullable Executor callbackExecutor,
+             boolean validateEagerly) {
         this.callFactory = callFactory;
         this.baseUrl = baseUrl;
         this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
@@ -137,6 +149,7 @@
         Utils.validateServiceInterface(service);
         // 是否立即检测所有的方法配置
         if (validateEagerly) {
+            // 理解检测和配置所有的方法
             eagerlyValidateMethods(service);
         }
         // 动态代理
@@ -155,6 +168,7 @@ public Object invoke(Object proxy, Method method, @Nullable Object[] args)
                         if (platform.isDefaultMethod(method)) {
                             return platform.invokeDefaultMethod(method, service, proxy, args);
                         }
+                        // 这一步就是开始请求了
                         return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
                     }
                 });
@@ -246,12 +260,15 @@ public HttpUrl baseUrl() {
 
         int start = callAdapterFactories.indexOf(skipPast) + 1;
         for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+            // 根据方法的返回值类型，获取相应的适配器
+            // 如果是RxJava的话，他是继承至retrofit2.CallAdapter.Factory，多态的一种
             CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
             if (adapter != null) {
                 return adapter;
             }
         }
 
+        ///-------------------------------------end
         StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
                 .append(returnType)
                 .append(".\n");
@@ -352,8 +369,12 @@ public HttpUrl baseUrl() {
         checkNotNull(type, "type == null");
         checkNotNull(annotations, "annotations == null");
 
+        // 这里永远是0，从0开始的
         int start = converterFactories.indexOf(skipPast) + 1;
         for (int i = start, count = converterFactories.size(); i < count; i++) {
+            // 第0个是内置默认的转换器 {@link BuiltInConverters} 继承至 Converter.Factory
+            // BuiltInConverters在除去普通的类型为，其它都是返回的null
+            // 主要是根据 responseBodyConverter 方法的返回
             Converter<ResponseBody, ?> converter =
                     converterFactories.get(i).responseBodyConverter(type, annotations, this);
             if (converter != null) {
@@ -421,14 +442,33 @@ public Builder newBuilder() {
      * are optional.
      */
     public static final class Builder {
+        /**
+         * 运行在上面平台
+         */
         private final Platform platform;
         private @Nullable
         okhttp3.Call.Factory callFactory;
+        /**
+         * 请求API地址
+         */
         private HttpUrl baseUrl;
+        /**
+         * 序列化和反序列化的工具
+         */
         private final List<Converter.Factory> converterFactories = new ArrayList<>();
+        /**
+         * 返回类型适配器，加入RxJava2CallAdapterFactory，就能直接将Call转换为RxJava2所需要的
+         */
         private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>();
+        /**
+         * 线程池
+         */
         private @Nullable
         Executor callbackExecutor;
+        /**
+         * 是否立即对相关数据做校验
+         * 如果为如果为true的话，直接在create的时候进行校验和生成相关
+         */
         private boolean validateEagerly;
 
         Builder(Platform platform) {
@@ -436,6 +476,7 @@ public Builder newBuilder() {
         }
 
         public Builder() {
+            // 判断当前的平台
             this(Platform.get());
         }
 
@@ -466,6 +507,7 @@ public Builder() {
          * The HTTP client used for requests.
          * <p>
          * This is a convenience method for calling {@link #callFactory}.
+         * OkHttpClient 是 okhttp3.Call.Factory的子类
          */
         public Builder client(OkHttpClient client) {
             return callFactory(checkNotNull(client, "client == null"));
@@ -483,6 +525,7 @@ public Builder callFactory(okhttp3.Call.Factory factory) {
 
         /**
          * Set the API base URL.
+         * 请求API地址，字符串类型的
          *
          * @see #baseUrl(HttpUrl)
          */
@@ -499,6 +542,7 @@ public Builder baseUrl(String baseUrl) {
          * {@code <a href="">} link on a website resolving on the current URL.
          * <p>
          * <b>Base URLs should always end in {@code /}.</b>
+         * <b>Base URLs 必须以 / 结束</b>
          * <p>
          * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
          * append themselves to a base which has path components.
@@ -610,21 +654,26 @@ public Builder validateEagerly(boolean validateEagerly) {
          * OkHttpClient} will be created and used.
          */
         public Retrofit build() {
+            // BaseUrl 不能为空
             if (baseUrl == null) {
                 throw new IllegalStateException("Base URL required.");
             }
 
             okhttp3.Call.Factory callFactory = this.callFactory;
+            // 不传OkHttpClient的话，这里会默认创建一个
             if (callFactory == null) {
                 callFactory = new OkHttpClient();
             }
 
+            // 回调执行者，不指定的话，使用默认的回调
             Executor callbackExecutor = this.callbackExecutor;
             if (callbackExecutor == null) {
+                // 如果是Android平台，使用的是handler
                 callbackExecutor = platform.defaultCallbackExecutor();
             }
 
             // Make a defensive copy of the adapters and add the default Call adapter.
+            // 复制了一份，其实是空的
             List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
             callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
 
@@ -634,12 +683,17 @@ public Retrofit build() {
 
             // Add the built-in converter factory first. This prevents overriding its behavior but also
             // ensures correct behavior when using converters that consume all types.
+            // 只是做一份保险，防止覆盖操作而已？？？
             converterFactories.add(new BuiltInConverters());
             converterFactories.addAll(this.converterFactories);
             converterFactories.addAll(platform.defaultConverterFactories());
 
-            return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
-                    unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
+            return new Retrofit(callFactory,
+                    baseUrl,
+                    unmodifiableList(converterFactories),
+                    unmodifiableList(callAdapterFactories),
+                    callbackExecutor,
+                    validateEagerly);
         }
     }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 54cddb539..4ea9d9165 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -25,7 +25,7 @@
 abstract class ServiceMethod<T> {
 
     static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
-        // 请求工厂
+        // 请求工厂 解析注解
         RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
         // 获取方法的返回类型
         Type returnType = method.getGenericReturnType();
@@ -39,6 +39,7 @@
         if (returnType == void.class) {
             throw methodError(method, "Service methods cannot return void.");
         }
+        // 对请求服务的接口中的注解进行解析
         return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
     }
 
