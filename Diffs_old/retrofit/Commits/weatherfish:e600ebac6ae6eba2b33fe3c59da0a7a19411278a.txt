diff --git a/README.md b/README.md
index 026930a7b..c7a7cdd9e 100644
--- a/README.md
+++ b/README.md
@@ -47,5 +47,5 @@ License
 
 
  [1]: http://square.github.io/retrofit/
- [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/checkstyle.xml b/checkstyle.xml
index a729c26a7..73b55406d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -102,7 +102,6 @@
         <!--module name="InnerAssignment"/-->
         <!--module name="MagicNumber"/-->
         <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
         <module name="SimplifyBooleanExpression"/>
         <module name="SimplifyBooleanReturn"/>
 
@@ -123,6 +122,7 @@
         <module name="UpperEll"/>
         <module name="Indentation">
           <property name="basicOffset" value="2"/>
+          <property name="caseIndent" value="2"/>
         </module>
     </module>
 </module>
diff --git a/pom.xml b/pom.xml
index 96b732dbf..3b9062c9b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -49,11 +49,13 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.4.1</okhttp.version>
+    <okhttp.version>3.5.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
     <rxjava.version>1.2.0</rxjava.version>
+    <rxjava2.version>2.0.0</rxjava2.version>
+    <guava.version>19.0</guava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.7</gson.version>
@@ -61,7 +63,7 @@
     <jackson.version>2.7.2</jackson.version>
     <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.2.0</moshi.version>
+    <moshi.version>1.3.0</moshi.version>
 
     <!-- Sample Dependencies -->
     <jsoup.version>1.7.3</jsoup.version>
@@ -70,7 +72,6 @@
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>19.0</guava.version>
     <robolectric.version>3.0</robolectric.version>
   </properties>
 
@@ -125,7 +126,11 @@
         <artifactId>rxjava</artifactId>
         <version>${rxjava.version}</version>
       </dependency>
-
+      <dependency>
+        <groupId>io.reactivex.rxjava2</groupId>
+        <artifactId>rxjava</artifactId>
+        <version>${rxjava2.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.google.protobuf</groupId>
         <artifactId>protobuf-java</artifactId>
@@ -213,7 +218,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.15</version>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.3</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
new file mode 100644
index 000000000..c4749e28e
--- /dev/null
+++ b/retrofit-adapters/guava/README.md
@@ -0,0 +1,30 @@
+Guava Adapter
+==============
+
+An `Adapter` for adapting [Guava][1] types.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-guava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-guava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/google/guava
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-guava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-guava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
new file mode 100644
index 000000000..84e151b9f
--- /dev/null
+++ b/retrofit-adapters/java8/README.md
@@ -0,0 +1,30 @@
+Java8 Adapter
+==============
+
+An `Adapter` for adapting [Java8][1] types.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-java8</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-java8:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-java8&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-java8%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index c66902ccc..fc5e8d505 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -18,5 +18,6 @@
     <module>guava</module>
     <module>java8</module>
     <module>rxjava</module>
+    <module>rxjava2</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
new file mode 100644
index 000000000..daaea6786
--- /dev/null
+++ b/retrofit-adapters/rxjava/README.md
@@ -0,0 +1,30 @@
+RxJava Adapter
+==============
+
+An `Adapter` for adapting [RxJava 1.x][1] types.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-rxjava</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-rxjava:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/ReactiveX/RxJava/tree/1.x
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-rxjava&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-rxjava%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
new file mode 100644
index 000000000..1ae1499eb
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class BodyOnSubscribe<T> implements OnSubscribe<T> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  BodyOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super T> subscriber) {
+    upstream.call(new BodySubscriber<>(subscriber));
+  }
+
+  private static class BodySubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super R> subscriber;
+    /** Indicates whether a terminal event has been sent to {@link #subscriber}. */
+    private boolean subscriberTerminated;
+
+    BodySubscriber(Subscriber<? super R> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        subscriber.onNext(response.body());
+      } else {
+        subscriberTerminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!subscriberTerminated) {
+        subscriber.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a Retrofit bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(broken);
+      }
+    }
+
+    @Override public void onCompleted() {
+      if (!subscriberTerminated) {
+        subscriber.onCompleted();
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
new file mode 100644
index 000000000..7e0f53969
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Producer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class CallOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    Response<T> response;
+    try {
+      response = call.execute();
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      arbiter.emitError(t);
+      return;
+    }
+    arbiter.emitResponse(response);
+  }
+
+  static final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
+    private static final int STATE_WAITING = 0;
+    private static final int STATE_REQUESTED = 1;
+    private static final int STATE_HAS_RESPONSE = 2;
+    private static final int STATE_TERMINATED = 3;
+
+    private final Call<T> call;
+    private final Subscriber<? super Response<T>> subscriber;
+
+    private volatile Response<T> response;
+
+    CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
+      super(STATE_WAITING);
+
+      this.call = call;
+      this.subscriber = subscriber;
+    }
+
+    @Override public void unsubscribe() {
+      call.cancel();
+    }
+
+    @Override public boolean isUnsubscribed() {
+      return call.isCanceled();
+    }
+
+    @Override public void request(long amount) {
+      if (amount == 0) {
+        return;
+      }
+      while (true) {
+        int state = get();
+        switch (state) {
+          case STATE_WAITING:
+            if (compareAndSet(STATE_WAITING, STATE_REQUESTED)) {
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_HAS_RESPONSE:
+            if (compareAndSet(STATE_HAS_RESPONSE, STATE_TERMINATED)) {
+              deliverResponse(response);
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_REQUESTED:
+          case STATE_TERMINATED:
+            return; // Nothing to do.
+
+          default:
+            throw new IllegalStateException("Unknown state: " + state);
+        }
+      }
+    }
+
+    void emitResponse(Response<T> response) {
+      while (true) {
+        int state = get();
+        switch (state) {
+          case STATE_WAITING:
+            this.response = response;
+            if (compareAndSet(STATE_WAITING, STATE_HAS_RESPONSE)) {
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_REQUESTED:
+            if (compareAndSet(STATE_REQUESTED, STATE_TERMINATED)) {
+              deliverResponse(response);
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_HAS_RESPONSE:
+          case STATE_TERMINATED:
+            throw new AssertionError();
+
+          default:
+            throw new IllegalStateException("Unknown state: " + state);
+        }
+      }
+    }
+
+    private void deliverResponse(Response<T> response) {
+      try {
+        if (!isUnsubscribed()) {
+          subscriber.onNext(response);
+        }
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+        return;
+      }
+      try {
+        subscriber.onCompleted();
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+      }
+    }
+
+    void emitError(Throwable t) {
+      set(STATE_TERMINATED);
+
+      if (!isUnsubscribed()) {
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
deleted file mode 100644
index 7d075e71b..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import retrofit2.Call;
-import retrofit2.Response;
-
-final class ResponseCallable<T> implements Callable<Response<T>> {
-  private final Call<T> call;
-
-  ResponseCallable(Call<T> call) {
-    this.call = call;
-  }
-
-  @Override public Response<T> call() throws IOException {
-    // Since Call is a one-shot type, clone it for each new caller.
-    return call.clone().execute();
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
deleted file mode 100644
index ea9e37c25..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.util.concurrent.Callable;
-import retrofit2.Response;
-
-final class ResultCallable<R> implements Callable<Result<R>> {
-  private final Callable<Response<R>> responseCallable;
-
-  ResultCallable(Callable<Response<R>> responseCallable) {
-    this.responseCallable = responseCallable;
-  }
-
-  @Override public Result<R> call() {
-    try {
-      return Result.response(responseCallable.call());
-    } catch (Throwable t) {
-      return Result.error(t);
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
new file mode 100644
index 000000000..798df5af8
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  ResultOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super Result<T>> subscriber) {
+    upstream.call(new ResultSubscriber<T>(subscriber));
+  }
+
+  private static class ResultSubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super Result<R>> subscriber;
+
+    ResultSubscriber(Subscriber<? super Result<R>> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      subscriber.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        subscriber.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+        return;
+      }
+      subscriber.onCompleted();
+    }
+
+    @Override public void onCompleted() {
+      subscriber.onCompleted();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index 19cf184ad..8d8f3776a 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -18,7 +18,9 @@
 import java.lang.reflect.Type;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
+import retrofit2.Response;
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.Scheduler;
 
 final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
@@ -44,16 +46,17 @@
   }
 
   @Override public Object adapt(Call<R> call) {
-    ResponseCallable<R> resultCallable = new ResponseCallable<>(call);
+    OnSubscribe<Response<R>> callFunc = new CallOnSubscribe<>(call);
 
-    Observable<?> observable;
+    OnSubscribe<?> func;
     if (isResult) {
-      observable = Observable.fromCallable(new ResultCallable<>(resultCallable));
+      func = new ResultOnSubscribe<>(callFunc);
     } else if (isBody) {
-      observable = Observable.fromCallable(new BodyCallable<>(resultCallable));
+      func = new BodyOnSubscribe<>(callFunc);
     } else {
-      observable = Observable.fromCallable(resultCallable);
+      func = callFunc;
     }
+    Observable<?> observable = Observable.create(func);
 
     if (scheduler != null) {
       observable = observable.subscribeOn(scheduler);
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
new file mode 100644
index 000000000..1c5ca742d
--- /dev/null
+++ b/retrofit-adapters/rxjava2/README.md
@@ -0,0 +1,30 @@
+RxJava2 Adapter
+==============
+
+An `Adapter` for adapting [RxJava 2.x][1] types.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>adapter-rxjava2</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:adapter-rxjava2:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://github.com/ReactiveX/RxJava/tree/2.x
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=adapter-rxjava2&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22adapter-rxjava2%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
new file mode 100644
index 000000000..354834586
--- /dev/null
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.1.1-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava2</artifactId>
+  <name>Adapter: RxJava 2</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex.rxjava2</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
new file mode 100644
index 000000000..2f1a234d7
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+final class BodyObservable<T> extends Observable<T> {
+  private final Observable<Response<T>> upstream;
+
+  BodyObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super T> observer) {
+    upstream.subscribe(new BodyObserver<>(observer));
+  }
+
+  private static class BodyObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super R> observer;
+    private boolean terminated;
+
+    BodyObserver(Observer<? super R> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        observer.onNext(response.body());
+      } else {
+        terminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+
+    @Override public void onComplete() {
+      if (!terminated) {
+        observer.onComplete();
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!terminated) {
+        observer.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.onError(broken);
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
new file mode 100644
index 000000000..d7a4f7197
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Response;
+
+final class CallObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    observer.onSubscribe(new CallDisposable(call));
+
+    boolean terminated = false;
+    try {
+      Response<T> response = call.execute();
+      if (!call.isCanceled()) {
+        observer.onNext(response);
+      }
+      if (!call.isCanceled()) {
+        terminated = true;
+        observer.onComplete();
+      }
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      if (terminated) {
+        RxJavaPlugins.onError(t);
+      } else if (!call.isCanceled()) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+  }
+
+  private static final class CallDisposable implements Disposable {
+    private final Call<?> call;
+
+    CallDisposable(Call<?> call) {
+      this.call = call;
+    }
+
+    @Override public void dispose() {
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return call.isCanceled();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
new file mode 100644
index 000000000..d612b9d5a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import retrofit2.Response;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private static String getMessage(Response<?> response) {
+    if (response == null) throw new NullPointerException("response == null");
+    return "HTTP " + response.code() + " " + response.message();
+  }
+
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super(getMessage(response));
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
new file mode 100644
index 000000000..dac56cdbb
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import retrofit2.Response;
+
+/** The result of executing an HTTP request. */
+public final class Result<T> {
+  public static <T> Result<T> error(Throwable error) {
+    if (error == null) throw new NullPointerException("error == null");
+    return new Result<>(null, error);
+  }
+
+  public static <T> Result<T> response(Response<T> response) {
+    if (response == null) throw new NullPointerException("response == null");
+    return new Result<>(response, null);
+  }
+
+  private final Response<T> response;
+  private final Throwable error;
+
+  private Result(Response<T> response, Throwable error) {
+    this.response = response;
+    this.error = error;
+  }
+
+  /**
+   * The response received from executing an HTTP request. Only present when {@link #isError()} is
+   * false, null otherwise.
+   */
+  public Response<T> response() {
+    return response;
+  }
+
+  /**
+   * The error experienced while attempting to execute an HTTP request. Only present when {@link
+   * #isError()} is true, null otherwise.
+   * <p>
+   * If the error is an {@link IOException} then there was a problem with the transport to the
+   * remote server. Any other exception type indicates an unexpected failure and should be
+   * considered fatal (configuration error, programming error, etc.).
+   */
+  public Throwable error() {
+    return error;
+  }
+
+  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+  public boolean isError() {
+    return error != null;
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
new file mode 100644
index 000000000..4fb08fbd0
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+final class ResultObservable<T> extends Observable<Result<T>> {
+  private final Observable<Response<T>> upstream;
+
+  ResultObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Result<T>> observer) {
+    upstream.subscribe(new ResultObserver<T>(observer));
+  }
+
+  private static class ResultObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super Result<R>> observer;
+
+    ResultObserver(Observer<? super Result<R>> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      observer.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        observer.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+        return;
+      }
+      observer.onComplete();
+    }
+
+    @Override public void onComplete() {
+      observer.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
new file mode 100644
index 000000000..e6b7861cb
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+
+final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
+  private final Type responseType;
+  private final Scheduler scheduler;
+  private final boolean isResult;
+  private final boolean isBody;
+  private final boolean isFlowable;
+  private final boolean isSingle;
+  private final boolean isMaybe;
+  private final boolean isCompletable;
+
+  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
+      boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) {
+    this.responseType = responseType;
+    this.scheduler = scheduler;
+    this.isResult = isResult;
+    this.isBody = isBody;
+    this.isFlowable = isFlowable;
+    this.isSingle = isSingle;
+    this.isMaybe = isMaybe;
+    this.isCompletable = isCompletable;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public Object adapt(Call<R> call) {
+    Observable<Response<R>> responseObservable = new CallObservable<>(call);
+
+    Observable<?> observable;
+    if (isResult) {
+      observable = new ResultObservable<>(responseObservable);
+    } else if (isBody) {
+      observable = new BodyObservable<>(responseObservable);
+    } else {
+      observable = responseObservable;
+    }
+
+    if (scheduler != null) {
+      observable = observable.subscribeOn(scheduler);
+    }
+
+    if (isFlowable) {
+      return observable.toFlowable(BackpressureStrategy.LATEST);
+    }
+    if (isSingle) {
+      return observable.singleOrError();
+    }
+    if (isMaybe) {
+      return observable.singleElement();
+    }
+    if (isCompletable) {
+      return observable.ignoreElements();
+    }
+    return observable;
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
new file mode 100644
index 000000000..d11af328b
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler;
+import io.reactivex.Single;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava 2 for creating observables.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return an {@link Observable},
+ * {@link Flowable}, {@link Single}, {@link Completable} or {@link Maybe} from service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   Observable&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are three configurations supported for the {@code Observable}, {@code Flowable},
+ * {@code Single}, and {@code Maybe} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code Observable<User>}) calls {@code onNext} with the deserialized body
+ * for 2XX responses and calls {@code onError} with {@link HttpException} for non-2XX responses and
+ * {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code Observable<Response<User>>}) calls {@code onNext}
+ * with a {@link Response} object for all HTTP responses and calls {@code onError} with
+ * {@link IOException} for network errors</li>
+ * <li>Result wrapped body (e.g., {@code Observable<Result<User>>}) calls {@code onNext} with a
+ * {@link Result} object for all HTTP responses and errors.</li>
+ * </ul>
+ */
+public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
+  /**
+   * Returns an instance which creates synchronous observables that do not operate on any scheduler
+   * by default.
+   */
+  public static RxJava2CallAdapterFactory create() {
+    return new RxJava2CallAdapterFactory(null);
+  }
+
+  /**
+   * Returns an instance which creates synchronous observables that
+   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+   */
+  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
+    if (scheduler == null) throw new NullPointerException("scheduler == null");
+    return new RxJava2CallAdapterFactory(scheduler);
+  }
+
+  private final Scheduler scheduler;
+
+  private RxJava2CallAdapterFactory(Scheduler scheduler) {
+    this.scheduler = scheduler;
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = getRawType(returnType);
+
+    if (rawType == Completable.class) {
+      // Completable is not parameterized (which is what the rest of this method deals with) so it
+      // can only be created with a single configuration.
+      return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true);
+    }
+
+    boolean isFlowable = rawType == Flowable.class;
+    boolean isSingle = rawType == Single.class;
+    boolean isMaybe = rawType == Maybe.class;
+    if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
+      return null;
+    }
+
+    boolean isResult = false;
+    boolean isBody = false;
+    Type responseType;
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+    } else if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+      isResult = true;
+    } else {
+      responseType = observableType;
+      isBody = true;
+    }
+
+    return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,
+        isSingle, isMaybe, false);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
new file mode 100644
index 000000000..64fb3870a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+
+public final class CompletableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertComplete();
+  }
+
+  @Test public void completableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void completableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
new file mode 100644
index 000000000..535fdeeed
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.CompletableObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class CompletableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingCompletableObserver observer = observerRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+      }
+    });
+
+    RecordingCompletableObserver observer = observerRule.create();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  private static abstract class ForwardingCompletableObserver implements CompletableObserver {
+    private final CompletableObserver delegate;
+
+    ForwardingCompletableObserver(CompletableObserver delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
new file mode 100644
index 000000000..b4a4bc9a2
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class CompletableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingCompletableObserver.Rule observerRule =
+      new RecordingCompletableObserver.Rule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void completableUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingCompletableObserver observer = observerRule.create();
+    service.completable().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
new file mode 100644
index 000000000..042b8028d
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FlowableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertValue("Hi").assertComplete();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void bodyRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<String> o = service.body();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    assertThat(subscriber.takeValue().isSuccessful()).isTrue();
+    subscriber.assertComplete();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    assertThat(subscriber.takeValue().isSuccessful()).isFalse();
+    subscriber.assertComplete();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void responseRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<Response<String>> o = service.response();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    Result<String> result = subscriber.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+    subscriber.assertComplete();
+  }
+
+  @Test public void resultRespectsBackpressure() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+    Flowable<Result<String>> o = service.result();
+
+    o.subscribe(subscriber);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    subscriber.assertNoEvents();
+
+    subscriber.request(1);
+    subscriber.assertAnyValue().assertComplete();
+
+    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
new file mode 100644
index 000000000..34afbbeef
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FlowableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().safeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<String> subscriber = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().safeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    subscriber.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    subscriber.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingSubscriber<T> implements Subscriber<T> {
+    private final Subscriber<T> delegate;
+
+    ForwardingSubscriber(Subscriber<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Subscription subscription) {
+      delegate.onSubscribe(subscription);
+    }
+
+    @Override public void onNext(T value) {
+      delegate.onNext(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
new file mode 100644
index 000000000..946ff51f1
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Flowable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class FlowableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+  interface Service {
+    @GET("/") Flowable<String> body();
+    @GET("/") Flowable<Response<String>> response();
+    @GET("/") Flowable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.body().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.response().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSubscriber<Object> subscriber = subscriberRule.create();
+    service.result().subscribe(subscriber);
+    subscriber.assertNoEvents();
+
+    scheduler.triggerActions();
+    subscriber.assertAnyValue().assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
new file mode 100644
index 000000000..da781ffd0
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import org.junit.Test;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class HttpExceptionTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    HttpException exception = new HttpException(response);
+    assertThat(exception.code()).isEqualTo(200);
+    assertThat(exception.message()).isEqualTo("OK");
+    assertThat(exception.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      new HttpException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
new file mode 100644
index 000000000..d5eda7d9e
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import java.io.IOException;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MaybeTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    Response<String> response = observer.takeValue();
+    assertThat(response.isSuccessful()).isTrue();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
new file mode 100644
index 000000000..d5f83e1bd
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import io.reactivex.MaybeObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MaybeThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingMaybeObserver.Rule subscriberRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements MaybeObserver<T> {
+    private final MaybeObserver<T> delegate;
+
+    ForwardingObserver(MaybeObserver<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onSuccess(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
new file mode 100644
index 000000000..53fe60d94
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Maybe;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class MaybeWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+  interface Service {
+    @GET("/") Maybe<String> body();
+    @GET("/") Maybe<Response<String>> response();
+    @GET("/") Maybe<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingMaybeObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
new file mode 100644
index 000000000..be8f5c31a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi").assertComplete();
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+    observer.assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
new file mode 100644
index 000000000..05c1d4f8f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ObservableThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingObserver.Rule subscriberRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onNext(String value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onNext(Response<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnNextDeliveredToError() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        throw e;
+      }
+    });
+
+    observer.assertError(e);
+  }
+
+  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    observer.assertAnyValue();
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onNext(Result<String> value) {
+        // The only way to trigger onError for a result is if onNext throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements Observer<T> {
+    private final Observer<T> delegate;
+
+    ForwardingObserver(Observer<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(T value) {
+      delegate.onNext(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+
+    @Override public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
new file mode 100644
index 000000000..2379f2835
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class ObservableWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue().assertComplete();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
new file mode 100644
index 000000000..de7c93055
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.CompletableObserver;
+import io.reactivex.Notification;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link CompletableObserver} and JUnit rule which guarantees all events are asserted. */
+final class RecordingCompletableObserver implements CompletableObserver {
+  private final Deque<Notification<?>> events = new ArrayDeque<>();
+
+  private RecordingCompletableObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.createOnError(e));
+  }
+
+  private Notification<?> takeNotification() {
+    Notification<?> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public Throwable takeError() {
+    Notification<?> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public void assertComplete() {
+    Notification<?> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingCompletableObserver> subscribers = new ArrayList<>();
+
+    public <T> RecordingCompletableObserver create() {
+      RecordingCompletableObserver subscriber = new RecordingCompletableObserver();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingCompletableObserver subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
new file mode 100644
index 000000000..63d34499f
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.MaybeObserver;
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingMaybeObserver<T> implements MaybeObserver<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingMaybeObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onSuccess(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingMaybeObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingMaybeObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingMaybeObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingMaybeObserver<T> create() {
+      RecordingMaybeObserver<T> subscriber = new RecordingMaybeObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingMaybeObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
new file mode 100644
index 000000000..033111ff4
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingObserver<T> implements Observer<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertComplete() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingObserver<T> create() {
+      RecordingObserver<T> subscriber = new RecordingObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
new file mode 100644
index 000000000..6c7b61f77
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.disposables.Disposable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSingleObserver<T> implements SingleObserver<T> {
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private RecordingSingleObserver() {
+  }
+
+  @Override public void onSubscribe(Disposable disposable) {
+  }
+
+  @Override public void onSuccess(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingSingleObserver<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSingleObserver<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSingleObserver<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSingleObserver<T> create() {
+      RecordingSingleObserver<T> subscriber = new RecordingSingleObserver<>();
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSingleObserver<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
new file mode 100644
index 000000000..f81bfd97a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Notification;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
+final class RecordingSubscriber<T> implements Subscriber<T> {
+  private final long initialRequest;
+  private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+  private Subscription subscription;
+
+  private RecordingSubscriber(long initialRequest) {
+    this.initialRequest = initialRequest;
+  }
+
+  @Override public void onSubscribe(Subscription subscription) {
+    this.subscription = subscription;
+
+    subscription.request(initialRequest);
+  }
+
+  @Override public void onNext(T value) {
+    events.add(Notification.createOnNext(value));
+  }
+
+  @Override public void onComplete() {
+    events.add(Notification.<T>createOnComplete());
+  }
+
+  @Override public void onError(Throwable e) {
+    events.add(Notification.<T>createOnError(e));
+  }
+
+  private Notification<T> takeNotification() {
+    Notification<T> notification = events.pollFirst();
+    if (notification == null) {
+      throw new AssertionError("No event found!");
+    }
+    return notification;
+  }
+
+  public T takeValue() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnNext())
+        .as("Expected onNext event but was " + notification)
+        .isTrue();
+    return notification.getValue();
+  }
+
+  public Throwable takeError() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnError())
+        .as("Expected onError event but was " + notification)
+        .isTrue();
+    return notification.getError();
+  }
+
+  public RecordingSubscriber<T> assertAnyValue() {
+    takeValue();
+    return this;
+  }
+
+  public RecordingSubscriber<T> assertValue(T value) {
+    assertThat(takeValue()).isEqualTo(value);
+    return this;
+  }
+
+  public void assertComplete() {
+    Notification<T> notification = takeNotification();
+    assertThat(notification.isOnComplete())
+        .as("Expected onCompleted event but was " + notification)
+        .isTrue();
+    assertNoEvents();
+  }
+
+  public void assertError(Throwable throwable) {
+    assertThat(takeError()).isEqualTo(throwable);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass) {
+    assertError(errorClass, null);
+  }
+
+  public void assertError(Class<? extends Throwable> errorClass, String message) {
+    Throwable throwable = takeError();
+    assertThat(throwable).isInstanceOf(errorClass);
+    if (message != null) {
+      assertThat(throwable).hasMessage(message);
+    }
+    assertNoEvents();
+  }
+
+  public void assertNoEvents() {
+    assertThat(events).as("Unconsumed events found!").isEmpty();
+  }
+
+  public void request(long amount) {
+    if (subscription == null) {
+      throw new IllegalStateException("onSubscribe has not been called yet. Did you subscribe()?");
+    }
+    subscription.request(amount);
+  }
+
+  public static final class Rule implements TestRule {
+    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+    public <T> RecordingSubscriber<T> create() {
+      return createWithInitialRequest(Long.MAX_VALUE);
+    }
+
+    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+      subscribers.add(subscriber);
+      return subscriber;
+    }
+
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          for (RecordingSubscriber<?> subscriber : subscribers) {
+            subscriber.assertNoEvents();
+          }
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
new file mode 100644
index 000000000..a26043296
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import org.junit.Test;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResultTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    Result<String> result = Result.response(response);
+    assertThat(result.isError()).isFalse();
+    assertThat(result.error()).isNull();
+    assertThat(result.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      Result.response(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+
+  @Test public void error() {
+    Throwable error = new IOException();
+    Result<Object> result = Result.error(error);
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isSameAs(error);
+    assertThat(result.response()).isNull();
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Result.error(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("error == null");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
similarity index 51%
rename from retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
rename to retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
index 88e5c5e4e..2e97cc6f4 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
@@ -13,23 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2.adapter.rxjava;
+package retrofit2.adapter.rxjava2;
 
-import java.util.concurrent.Callable;
-import retrofit2.Response;
+import io.reactivex.plugins.RxJavaPlugins;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
 
-final class BodyCallable<R> implements Callable<R> {
-  private final Callable<Response<R>> responseCallable;
-
-  BodyCallable(Callable<Response<R>> responseCallable) {
-    this.responseCallable = responseCallable;
-  }
-
-  @Override public R call() throws Exception {
-    Response<R> response = responseCallable.call();
-    if (response.isSuccessful()) {
-      return response.body();
-    }
-    throw new HttpException(response);
+final class RxJavaPluginsResetRule implements TestRule {
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        RxJavaPlugins.reset();
+        try {
+          base.evaluate();
+        } finally {
+          RxJavaPlugins.reset();
+        }
+      }
+    };
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
new file mode 100644
index 000000000..9ebe67e94
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertValue("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(HttpException.class, "HTTP 404 Client Error");
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<String> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    Response<String> response = observer.takeValue();
+    assertThat(response.isSuccessful()).isTrue();
+  }
+
+  @Test public void responseSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<Response<String>> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isTrue();
+  }
+
+  @Test public void resultSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isFalse();
+    assertThat(result.response().isSuccessful()).isFalse();
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingSingleObserver<Result<String>> observer = observerRule.create();
+    service.result().subscribe(observer);
+    Result<String> result = observer.takeValue();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
new file mode 100644
index 000000000..294722783
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import io.reactivex.SingleObserver;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class SingleThrowingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
+  @Rule public final RecordingSingleObserver.Rule subscriberRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<String> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onSuccess(String value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<String> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.body().subscribe(new ForwardingObserver<String>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onSuccess(Response<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    final RuntimeException e = new RuntimeException();
+    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+      @Override public void onError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+        throw e;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+
+  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException e = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        throw e;
+      }
+    });
+
+    assertThat(throwableRef.get()).isSameAs(e);
+  }
+
+  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
+    server.enqueue(new MockResponse());
+
+    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!throwableRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable);
+        }
+      }
+    });
+
+    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+    final RuntimeException first = new RuntimeException();
+    final RuntimeException second = new RuntimeException();
+    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+      @Override public void onSuccess(Result<String> value) {
+        // The only way to trigger onError for Result is if onSuccess throws.
+        throw first;
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw second;
+      }
+    });
+
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) throwableRef.get();
+    assertThat(composite.getExceptions()).containsExactly(first, second);
+  }
+
+  private static abstract class ForwardingObserver<T> implements SingleObserver<T> {
+    private final SingleObserver<T> delegate;
+
+    ForwardingObserver(SingleObserver<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      delegate.onSubscribe(disposable);
+    }
+
+    @Override public void onSuccess(T value) {
+      delegate.onSuccess(value);
+    }
+
+    @Override public void onError(Throwable throwable) {
+      delegate.onError(throwable);
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
new file mode 100644
index 000000000..5198d7bf3
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Single;
+import io.reactivex.schedulers.TestScheduler;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+public final class SingleWithSchedulerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+  interface Service {
+    @GET("/") Single<String> body();
+    @GET("/") Single<Response<String>> response();
+    @GET("/") Single<Result<String>> result();
+  }
+
+  private final TestScheduler scheduler = new TestScheduler();
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.body().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void responseUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.response().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+
+  @Test public void resultUsesScheduler() {
+    server.enqueue(new MockResponse());
+
+    RecordingSingleObserver<Object> observer = observerRule.create();
+    service.result().subscribe(observer);
+    observer.assertNoEvents();
+
+    scheduler.triggerActions();
+    observer.assertAnyValue();
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
new file mode 100644
index 000000000..5a6841840
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+final class StringConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    return new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    };
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    return new Converter<String, RequestBody>() {
+      @Override public RequestBody convert(String value) throws IOException {
+        return RequestBody.create(MediaType.parse("text/plain"), value);
+      }
+    };
+  }
+}
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
index 1568926f2..980d1d1f0 100644
--- a/retrofit-converters/gson/README.md
+++ b/retrofit-converters/gson/README.md
@@ -4,7 +4,30 @@ Gson Converter
 A `Converter` which uses [Gson][1] for serialization to and from JSON.
 
 A default `Gson` instance will be created or one can be configured and passed to the
-`GsonConverter` construction to further control the serialization.
+`GsonConverterFactory` to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-gson</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-gson:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
  [1]: https://github.com/google/gson
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-gson&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-gson%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
index d07b0afa6..2335d2903 100644
--- a/retrofit-converters/jackson/README.md
+++ b/retrofit-converters/jackson/README.md
@@ -4,7 +4,30 @@ Jackson Converter
 A `Converter` which uses [Jackson][1] for serialization to and from JSON.
 
 A default `ObjectMapper` instance will be created or one can be configured and passed to the
-`JacksonConverter` construction to further control the serialization.
+`JacksonConverterFactory` construction to further control the serialization.
+
+
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-jackson</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-jackson:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
  [1]: http://wiki.fasterxml.com/JacksonHome
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-jackson&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-jackson%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index 9968ccd38..c5668f9ab 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -7,4 +7,27 @@ A default `Moshi` instance will be created or one can be configured and passed t
 `MoshiConverterFactory.create()` to further control the serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-moshi</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-moshi:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://github.com/square/moshi
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-moshi&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-moshi%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
index ca4334147..7575a3d6c 100644
--- a/retrofit-converters/protobuf/README.md
+++ b/retrofit-converters/protobuf/README.md
@@ -4,4 +4,27 @@ Google Protocol Buffer Converter
 A `Converter` which uses [Protocol Buffer][1] binary serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-protobuf</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-protobuf:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://developers.google.com/protocol-buffers/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-protobuf&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-protobuf%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
index e3edef925..5231b6129 100644
--- a/retrofit-converters/scalars/README.md
+++ b/retrofit-converters/scalars/README.md
@@ -3,3 +3,28 @@ Java Scalars Converter
 
 A `Converter` which supports converting strings and both primitives and their boxed types to
 `text/plain` bodies.
+
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-scalars</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][2]:
+```groovy
+compile 'com.squareup.retrofit2:converter-scalars:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-scalars&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-scalars%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
index 8d5b8e369..b791e8122 100644
--- a/retrofit-converters/simplexml/README.md
+++ b/retrofit-converters/simplexml/README.md
@@ -15,5 +15,27 @@ a Maven or Gradle dependency, exclude the following transitive dependencies: `st
 `stax:stax`, and `xpp3:xpp3`.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-simplexml</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-simplexml:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
 
  [1]: http://simple.sourceforge.net/
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-simplexml&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-simplexml%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 9c82b143e..6289cc8a7 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -4,4 +4,27 @@ Wire Converter
 A `Converter` which uses [Wire][1] for protocol buffer-compatible serialization.
 
 
+Download
+--------
+
+Download [the latest JAR][2] or grab via [Maven][3]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>converter-wire</artifactId>
+  <version>latest.version</version>
+</dependency>
+```
+or [Gradle][3]:
+```groovy
+compile 'com.squareup.retrofit2:converter-wire:latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
  [1]: https://github.com/square/wire
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=converter-wire&v=LATEST
+ [3]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.retrofit2%22%20a%3A%22converter-wire%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit-mock/README.md b/retrofit-mock/README.md
new file mode 100644
index 000000000..4474e5af3
--- /dev/null
+++ b/retrofit-mock/README.md
@@ -0,0 +1,26 @@
+Mock Web Server
+==============
+
+An mock web server for mocking HTTP responses from a server, and simulating network behaviour.
+
+Download
+--------
+
+Download [the latest JAR][1] or grab via [Maven][2]:
+```xml
+<dependency>
+  <groupId>com.squareup.retrofit2</groupId>
+  <artifactId>retrofit-mock</artifactId>
+  <version>see.latest.version</version>
+</dependency>
+```
+or [Gradle][1]:
+```groovy
+compile 'com.squareup.retrofit2:retrofit-mock:see.latest.version'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+ [1]: https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit-mock&v=LATEST
+ [2]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22retrofit-mock%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5b9a196ff..ccbfe1ab2 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -232,7 +232,12 @@ public void cancel() {
   }
 
   @Override public boolean isCanceled() {
-    return canceled;
+    if (canceled) {
+      return true;
+    }
+    synchronized (this) {
+      return rawCall != null && rawCall.isCanceled();
+    }
   }
 
   static final class NoContentResponseBody extends ResponseBody {
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index e67159bff..ad9cf533c 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -20,7 +20,6 @@
 import android.os.Looper;
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
@@ -45,11 +44,6 @@ private static Platform findPlatform() {
       return new Java8();
     } catch (ClassNotFoundException ignored) {
     }
-    try {
-      Class.forName("org.robovm.apple.foundation.NSObject");
-      return new IOS();
-    } catch (ClassNotFoundException ignored) {
-    }
     return new Platform();
   }
 
@@ -109,47 +103,4 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
       }
     }
   }
-
-  static class IOS extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
-
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
-    }
-
-    static class MainThreadExecutor implements Executor {
-      private static Object queue;
-      private static Method addOperation;
-
-      static {
-        try {
-          // queue = NSOperationQueue.getMainQueue();
-          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
-          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
-          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
-        } catch (Exception e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      @Override public void execute(Runnable r) {
-        try {
-          // queue.addOperation(r);
-          addOperation.invoke(queue, r);
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-          throw new AssertionError(e);
-        } catch (InvocationTargetException e) {
-          Throwable cause = e.getCause();
-          if (cause instanceof RuntimeException) {
-            throw (RuntimeException) cause;
-          } else if (cause instanceof Error) {
-            throw (Error) cause;
-          }
-          throw new RuntimeException(cause);
-        }
-      }
-    }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index e7659c5cd..8633de4af 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -59,12 +59,12 @@
 public final class Retrofit {
   private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
 
-  private final okhttp3.Call.Factory callFactory;
-  private final HttpUrl baseUrl;
-  private final List<Converter.Factory> converterFactories;
-  private final List<CallAdapter.Factory> adapterFactories;
-  private final Executor callbackExecutor;
-  private final boolean validateEagerly;
+  final okhttp3.Call.Factory callFactory;
+  final HttpUrl baseUrl;
+  final List<Converter.Factory> converterFactories;
+  final List<CallAdapter.Factory> adapterFactories;
+  final Executor callbackExecutor;
+  final boolean validateEagerly;
 
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
       List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
@@ -379,6 +379,10 @@ public Executor callbackExecutor() {
     return callbackExecutor;
   }
 
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
   /**
    * Build a new {@link Retrofit}.
    * <p>
@@ -386,11 +390,11 @@ public Executor callbackExecutor() {
    * are optional.
    */
   public static final class Builder {
-    private Platform platform;
+    private final Platform platform;
     private okhttp3.Call.Factory callFactory;
     private HttpUrl baseUrl;
-    private List<Converter.Factory> converterFactories = new ArrayList<>();
-    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+    private final List<Converter.Factory> converterFactories = new ArrayList<>();
+    private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
     private Executor callbackExecutor;
     private boolean validateEagerly;
 
@@ -405,14 +409,22 @@ public Builder() {
       this(Platform.get());
     }
 
+    Builder(Retrofit retrofit) {
+      platform = Platform.get();
+      callFactory = retrofit.callFactory;
+      baseUrl = retrofit.baseUrl;
+      converterFactories.addAll(retrofit.converterFactories);
+      adapterFactories.addAll(retrofit.adapterFactories);
+      // Remove the default, platform-aware call adapter added by build().
+      adapterFactories.remove(adapterFactories.size() - 1);
+      callbackExecutor = retrofit.callbackExecutor;
+      validateEagerly = retrofit.validateEagerly;
+    }
+
     /**
      * The HTTP client used for requests.
      * <p>
      * This is a convenience method for calling {@link #callFactory}.
-     * <p>
-     * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
-     * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
-     * instance to prevent this if desired.
      */
     public Builder client(OkHttpClient client) {
       return callFactory(checkNotNull(client, "client == null"));
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 3a4325a7e..7765aba03 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -148,7 +148,7 @@ R toResponse(ResponseBody body) throws IOException {
     Converter<ResponseBody, T> responseConverter;
     CallAdapter<T, R> callAdapter;
 
-    public Builder(Retrofit retrofit, Method method) {
+    Builder(Retrofit retrofit, Method method) {
       this.retrofit = retrofit;
       this.method = method;
       this.methodAnnotations = method.getAnnotations();
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 09ab09064..cae93701e 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -369,7 +369,7 @@ static Type getCallResponseType(Type returnType) {
     private final Type rawType;
     private final Type[] typeArguments;
 
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+    ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
       // Require an owner type if the raw type needs it.
       if (rawType instanceof Class<?>
           && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
@@ -421,7 +421,7 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
   private static final class GenericArrayTypeImpl implements GenericArrayType {
     private final Type componentType;
 
-    public GenericArrayTypeImpl(Type componentType) {
+    GenericArrayTypeImpl(Type componentType) {
       this.componentType = componentType;
     }
 
@@ -452,7 +452,7 @@ public GenericArrayTypeImpl(Type componentType) {
     private final Type upperBound;
     private final Type lowerBound;
 
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
       if (lowerBounds.length > 1) throw new IllegalArgumentException();
       if (upperBounds.length != 1) throw new IllegalArgumentException();
 
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index 18dd035af..fffd43c1f 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -674,6 +674,40 @@
     assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
   }
 
+  @Test public void cancelOkHttpRequest() throws InterruptedException {
+    OkHttpClient client = new OkHttpClient();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .client(client)
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    Call<String> call = service.getString();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // Cancel the underlying HTTP Call. Should be reflected accurately back in the Retrofit Call.
+    client.dispatcher().cancelAll();
+    assertThat(call.isCanceled()).isTrue();
+
+    assertTrue(latch.await(10, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+  }
+
   @Test public void requestBeforeExecuteCreates() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 885394bfc..92dfb74ca 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -54,6 +54,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
@@ -140,6 +141,36 @@
     }
   }
 
+  @Test public void cloneSharesStatefulInstances() {
+    CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
+    Converter.Factory converter = mock(Converter.Factory.class);
+    HttpUrl baseUrl = server.url("/");
+    Executor executor = mock(Executor.class);
+    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+
+    Retrofit one = new Retrofit.Builder()
+        .addCallAdapterFactory(callAdapter)
+        .addConverterFactory(converter)
+        .baseUrl(baseUrl)
+        .callbackExecutor(executor)
+        .callFactory(callFactory)
+        .build();
+
+    CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
+    Converter.Factory converter2 = mock(Converter.Factory.class);
+    Retrofit two = one.newBuilder()
+        .addCallAdapterFactory(callAdapter2)
+        .addConverterFactory(converter2)
+        .build();
+    assertEquals(one.callAdapterFactories().size() + 1, two.callAdapterFactories().size());
+    assertThat(two.callAdapterFactories()).contains(callAdapter, callAdapter2);
+    assertEquals(one.converterFactories().size() + 1, two.converterFactories().size());
+    assertThat(two.converterFactories()).contains(converter, converter2);
+    assertSame(baseUrl, two.baseUrl());
+    assertSame(executor, two.callbackExecutor());
+    assertSame(callFactory, two.callFactory());
+  }
+
   @Test public void responseTypeCannotBeRetrofitResponse() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
diff --git a/samples/pom.xml b/samples/pom.xml
index 07483d1cf..63123e082 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -34,6 +34,11 @@
       <artifactId>converter-simplexml</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 97c739e39..b8e20a1b1 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -116,10 +116,10 @@ public static void main(String... args) throws Exception {
   }
 
   static class Page {
-    public final String title;
-    public final List<String> links;
+    final String title;
+    final List<String> links;
 
-    public Page(String title, List<String> links) {
+    Page(String title, List<String> links) {
       this.title = title;
       this.links = links;
     }
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index bc29f8355..724c75fb2 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -78,9 +78,9 @@
   }
 
   static class Filter {
-    public final String userId;
+    final String userId;
 
-    public Filter(String userId) {
+    Filter(String userId) {
       this.userId = userId;
     }
   }
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
new file mode 100644
index 000000000..6c4fec40d
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
+import rx.Observable;
+import rx.Scheduler;
+import rx.schedulers.Schedulers;
+
+import static rx.schedulers.Schedulers.io;
+
+public final class RxJavaObserveOnMainThread {
+  public static void main(String... args) {
+    Scheduler observeOn = Schedulers.computation(); // Or use mainThread() for Android.
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .addCallAdapterFactory(new ObserveOnMainCallAdapterFactory(observeOn))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(io()))
+        .build();
+
+    // Services created with this instance that use Observable will execute on the 'io' scheduler
+    // and notify their observer on the 'computation' scheduler.
+  }
+
+  static final class ObserveOnMainCallAdapterFactory extends CallAdapter.Factory {
+    final Scheduler scheduler;
+
+    ObserveOnMainCallAdapterFactory(Scheduler scheduler) {
+      this.scheduler = scheduler;
+    }
+
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+      if (getRawType(returnType) != Observable.class) {
+        return null; // Ignore non-Observable types.
+      }
+
+      // Look up the next call adapter which would otherwise be used if this one was not present.
+      //noinspection unchecked returnType checked above to be Observable.
+      final CallAdapter<Object, Observable<?>> delegate =
+          (CallAdapter<Object, Observable<?>>) retrofit.nextCallAdapter(this, returnType,
+              annotations);
+
+      return new CallAdapter<Object, Object>() {
+        @Override public Object adapt(Call<Object> call) {
+          // Delegate to get the normal Observable...
+          Observable<?> o = delegate.adapt(call);
+          // ...and change it to send notifications to the observer on the specified scheduler.
+          return o.observeOn(scheduler);
+        }
+
+        @Override public Type responseType() {
+          return delegate.responseType();
+        }
+      };
+    }
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..7c8a98e37 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -26,7 +26,7 @@
     private final BehaviorDelegate<GitHub> delegate;
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+    MockGitHub(BehaviorDelegate<GitHub> delegate) {
       this.delegate = delegate;
       ownerRepoContributors = new LinkedHashMap<>();
 
@@ -50,7 +50,7 @@ public MockGitHub(BehaviorDelegate<GitHub> delegate) {
       return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
+    void addContributor(String owner, String repo, String name, int contributions) {
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
       if (repoContributors == null) {
         repoContributors = new LinkedHashMap<>();
diff --git a/website/index.html b/website/index.html
index 21483f474..fa15e43f0 100644
--- a/website/index.html
+++ b/website/index.html
@@ -171,12 +171,10 @@ <h4>Gradle</h4>
               <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
               <h4>ProGuard</h4>
-              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+              <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
               <pre class="prettyprint">
 # Platform calls Class.forName on types which do not exist on Android to determine platform.
 -dontnote retrofit2.Platform
-# Platform used when running on RoboVM on iOS. Will not be used at runtime.
--dontnote retrofit2.Platform$IOS$MainThreadExecutor
 # Platform used when running on Java 8 VMs. Will not be used at runtime.
 -dontwarn retrofit2.Platform$Java8
 # Retain generic type information for use by reflection by converters and adapters.
@@ -184,6 +182,7 @@ <h4>ProGuard</h4>
 # Retain declared checked exceptions for use by a Proxy instance.
 -keepattributes Exceptions
 </pre>
+            <p>Retrofit uses <a href="https://github.com/square/okio">Okio</a> under the hood, so you may want to look at its <a href="https://github.com/square/okio#proguard">ProGuard rules</a> as well.</p>
             </section>
 
             <section id="contributing">
