diff --git a/CHANGELOG.md b/CHANGELOG.md
index fd0f32be5..595a153eb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,14 @@
 Change Log
 ==========
 
+Version 1.5.1 *(2014-05-08)*
+----------------------------
+
+ * New: `@PartMap` annotation accepts a `Map` of key/value pairs for multi-part.
+ * Fix: `MockRestAdpater` uses the `ErrorHandler` from its parent `RestAdapter`.
+ * Experimental RxJava support updated for v0.18 and is now lazily initialized.
+
+
 Version 1.5.0 *(2014-03-20)*
 ----------------------------
 
diff --git a/README.md b/README.md
index dbc8e6e69..7d8e63002 100644
--- a/README.md
+++ b/README.md
@@ -14,12 +14,12 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>retrofit</artifactId>
-  <version>1.5.0</version>
+  <version>1.5.1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:1.5.0'
+compile 'com.squareup.retrofit:retrofit:1.5.1'
 ```
 
 
diff --git a/pom.xml b/pom.xml
index e71473b18..3eed3f54c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>parent</artifactId>
-  <version>1.5.1-SNAPSHOT</version>
+  <version>1.5.2-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -51,7 +51,7 @@
     <android.platform>16</android.platform>
     <gson.version>2.2.4</gson.version>
     <okhttp.version>1.3.0</okhttp.version>
-    <rxjava.version>0.17.1</rxjava.version>
+    <rxjava.version>0.18.3</rxjava.version>
     <appengine.version>1.8.9</appengine.version>
 
     <!-- Converter Dependencies -->
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 56b7970b0..f2f7fc59a 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index c8e928fed..e80927cd6 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 4826e0b63..b4263b12e 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index b0e01c688..a68238418 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index bf77d0a26..d1ad3e0c8 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index d43acffec..522846238 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
index 7b1c1ff91..a27a9455b 100644
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
@@ -8,13 +8,12 @@
 import java.lang.reflect.Proxy;
 import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import retrofit.client.Request;
 import retrofit.client.Response;
 import rx.Observable;
-import rx.Scheduler;
 import rx.Subscriber;
-import rx.schedulers.Schedulers;
 
 import static retrofit.RestAdapter.LogLevel;
 import static retrofit.RetrofitError.unexpectedError;
@@ -85,7 +84,7 @@ public static MockRestAdapter from(RestAdapter restAdapter) {
   }
 
   private final RestAdapter restAdapter;
-  private final MockRxSupport mockRxSupport;
+  private MockRxSupport mockRxSupport;
   final Random random = new Random();
 
   private ValueChangeListener listener = ValueChangeListener.EMPTY;
@@ -95,12 +94,6 @@ public static MockRestAdapter from(RestAdapter restAdapter) {
 
   private MockRestAdapter(RestAdapter restAdapter) {
     this.restAdapter = restAdapter;
-
-    if (Platform.HAS_RX_JAVA) {
-      mockRxSupport = new MockRxSupport(restAdapter);
-    } else {
-      mockRxSupport = null;
-    }
   }
 
   /** Set a listener to be notified when any mock value changes. */
@@ -261,6 +254,13 @@ public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCac
       restAdapter.requestInterceptor.intercept(interceptorTape);
 
       if (methodInfo.isObservable) {
+        if (mockRxSupport == null) {
+          if (Platform.HAS_RX_JAVA) {
+            mockRxSupport = new MockRxSupport(restAdapter);
+          } else {
+            throw new IllegalStateException("Observable method found but no RxJava on classpath");
+          }
+        }
         return mockRxSupport.createMockObservable(this, methodInfo, interceptorTape, args);
       }
 
@@ -525,30 +525,36 @@ private static long uptimeMillis() {
 
   /** Indirection to avoid VerifyError if RxJava isn't present. */
   private static class MockRxSupport {
-    private final Scheduler scheduler;
+    private final Executor httpExecutor;
     private final ErrorHandler errorHandler;
 
     MockRxSupport(RestAdapter restAdapter) {
-      scheduler = Schedulers.executor(restAdapter.httpExecutor);
+      httpExecutor = restAdapter.httpExecutor;
       errorHandler = restAdapter.errorHandler;
     }
 
     Observable createMockObservable(final MockHandler mockHandler, final RestMethodInfo methodInfo,
         final RequestInterceptor interceptor, final Object[] args) {
       return Observable.create(new Observable.OnSubscribe<Object>() {
-        @Override public void call(Subscriber<? super Object> subscriber) {
-          try {
-            Observable observable =
-                (Observable) mockHandler.invokeSync(methodInfo, interceptor, args);
-            //noinspection unchecked
-            observable.subscribe(subscriber);
-          } catch (RetrofitError e) {
-            subscriber.onError(errorHandler.handleError(e));
-          } catch (Throwable e) {
-            subscriber.onError(e);
-          }
+        @Override public void call(final Subscriber<? super Object> subscriber) {
+          if (subscriber.isUnsubscribed()) return;
+          httpExecutor.execute(new Runnable() {
+            @Override public void run() {
+              try {
+                if (subscriber.isUnsubscribed()) return;
+                Observable observable =
+                        (Observable) mockHandler.invokeSync(methodInfo, interceptor, args);
+                //noinspection unchecked
+                observable.subscribe(subscriber);
+              } catch (RetrofitError e) {
+                subscriber.onError(errorHandler.handleError(e));
+              } catch (Throwable e) {
+                subscriber.onError(e);
+              }
+            }
+          });
         }
-      }).subscribeOn(scheduler);
+      });
     }
   }
 }
diff --git a/retrofit-samples/github-client/pom.xml b/retrofit-samples/github-client/pom.xml
index 0bf172add..7bf4f5e21 100644
--- a/retrofit-samples/github-client/pom.xml
+++ b/retrofit-samples/github-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit.samples</groupId>
     <artifactId>parent</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-samples/mock-github-client/pom.xml b/retrofit-samples/mock-github-client/pom.xml
index 7880928e6..55147a499 100644
--- a/retrofit-samples/mock-github-client/pom.xml
+++ b/retrofit-samples/mock-github-client/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit.samples</groupId>
     <artifactId>parent</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-samples/pom.xml b/retrofit-samples/pom.xml
index 54fb317c8..6ac4899de 100644
--- a/retrofit-samples/pom.xml
+++ b/retrofit-samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index d2375ba50..bcde49f03 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.5.1-SNAPSHOT</version>
+    <version>1.5.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index dbee94a2f..e3d1aed08 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -280,6 +280,23 @@ void setArguments(Object[] args) {
             }
           }
           break;
+        case PART_MAP:
+          if (value != null) { // Skip null values.
+            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+              String entryName = entry.getKey().toString();
+              Object entryValue = entry.getValue();
+              if (entryValue != null) { // Skip null values.
+                if (entryValue instanceof TypedOutput) {
+                  multipartBody.addPart(entryName, (TypedOutput) entryValue);
+                } else if (entryValue instanceof String) {
+                  multipartBody.addPart(entryName, new TypedString((String) entryValue));
+                } else {
+                  multipartBody.addPart(entryName, converter.toBody(entryValue));
+                }
+              }
+            }
+          }
+          break;
         case BODY:
           if (value == null) {
             throw new IllegalArgumentException("Body parameter value must not be null.");
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 18174734f..d1a9940d1 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -38,10 +38,6 @@
 import retrofit.mime.TypedByteArray;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
-import rx.Observable;
-import rx.Scheduler;
-import rx.Subscriber;
-import rx.schedulers.Schedulers;
 
 /**
  * Adapts a Java interface to a REST API.
@@ -160,7 +156,7 @@ public boolean log() {
 
   private final Client.Provider clientProvider;
   private final Profiler profiler;
-  private final RxSupport rxSupport;
+  private RxSupport rxSupport;
 
   volatile LogLevel logLevel;
 
@@ -177,11 +173,6 @@ private RestAdapter(Endpoint server, Client.Provider clientProvider, Executor ht
     this.errorHandler = errorHandler;
     this.log = log;
     this.logLevel = logLevel;
-    if (Platform.HAS_RX_JAVA && httpExecutor != null) {
-      this.rxSupport = new RxSupport(httpExecutor, errorHandler);
-    } else {
-      this.rxSupport = null;
-    }
   }
 
   /** Change the level of logging. */
@@ -227,40 +218,6 @@ static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method me
     }
   }
 
-  /** Indirection to avoid VerifyError if RxJava isn't present. */
-  private static final class RxSupport {
-    private final Scheduler scheduler;
-    private final ErrorHandler errorHandler;
-
-    RxSupport(Executor executor, ErrorHandler errorHandler) {
-      this.scheduler = Schedulers.executor(executor);
-      this.errorHandler = errorHandler;
-    }
-
-    Observable createRequestObservable(final Callable<ResponseWrapper> request) {
-      return Observable.create(new Observable.OnSubscribe<Object>() {
-        @Override public void call(Subscriber<? super Object> subscriber) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
-          try {
-            ResponseWrapper wrapper = request.call();
-            if (subscriber.isUnsubscribed()) {
-              return;
-            }
-            subscriber.onNext(wrapper.responseBody);
-            subscriber.onCompleted();
-          } catch (RetrofitError e) {
-            subscriber.onError(errorHandler.handleError(e));
-          } catch (Exception e) {
-            // This is from the Callable.  It shouldn't actually throw.
-            throw new RuntimeException(e);
-          }
-        }
-      }).subscribeOn(scheduler);
-    }
-  }
-
   private class RestHandler implements InvocationHandler {
     private final Map<Method, RestMethodInfo> methodDetailsCache;
 
@@ -302,6 +259,13 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
       requestInterceptor.intercept(interceptorTape);
 
       if (methodInfo.isObservable) {
+        if (rxSupport == null) {
+          if (Platform.HAS_RX_JAVA) {
+            rxSupport = new RxSupport(httpExecutor, errorHandler);
+          } else {
+            throw new IllegalStateException("Observable method found but no RxJava on classpath");
+          }
+        }
         return rxSupport.createRequestObservable(new Callable<ResponseWrapper>() {
           @Override public ResponseWrapper call() throws Exception {
             return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
@@ -324,8 +288,8 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
      * @return HTTP response object of specified {@code type} or {@code null}.
      * @throws RetrofitError if any error occurs during the HTTP request.
      */
-    private Object invokeRequest(RequestInterceptor requestInterceptor,
-        RestMethodInfo methodInfo, Object[] args) {
+    private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo,
+        Object[] args) {
       methodInfo.init(); // Ensure all relevant method information has been loaded.
 
       String serverUrl = server.getUrl();
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index ebd28ebfd..e61c34c45 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -38,6 +38,7 @@
 import retrofit.http.Headers;
 import retrofit.http.Multipart;
 import retrofit.http.Part;
+import retrofit.http.PartMap;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
@@ -68,6 +69,7 @@
     FIELD,
     FIELD_MAP,
     PART,
+    PART_MAP,
     BODY,
     HEADER
   }
@@ -411,6 +413,17 @@ private void parseParameters() {
             gotPart = true;
             paramNames[i] = name;
             paramUsage[i] = ParamUsage.PART;
+          } else if (annotationType == PartMap.class) {
+            if (requestType != RequestType.MULTIPART) {
+              throw parameterError(i,
+                  "@PartMap parameters can only be used with multipart encoding.");
+            }
+            if (!Map.class.isAssignableFrom(parameterType)) {
+              throw parameterError(i, "@PartMap parameter type must be Map.");
+            }
+
+            gotPart = true;
+            paramUsage[i] = ParamUsage.PART_MAP;
           } else if (annotationType == Body.class) {
             if (requestType != RequestType.SIMPLE) {
               throw parameterError(i,
diff --git a/retrofit/src/main/java/retrofit/RxSupport.java b/retrofit/src/main/java/retrofit/RxSupport.java
new file mode 100644
index 000000000..cc8e90abf
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RxSupport.java
@@ -0,0 +1,58 @@
+package retrofit;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
+import java.util.concurrent.FutureTask;
+import rx.Observable;
+import rx.Subscriber;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * Utilities for supporting RxJava Observables.
+ * <p>
+ * RxJava might not be on the available to use. Check {@link Platform#HAS_RX_JAVA} before calling.
+ */
+final class RxSupport {
+  private final Executor executor;
+  private final ErrorHandler errorHandler;
+
+  RxSupport(Executor executor, ErrorHandler errorHandler) {
+    this.executor = executor;
+    this.errorHandler = errorHandler;
+  }
+
+  Observable createRequestObservable(final Callable<ResponseWrapper> request) {
+    return Observable.create(new Observable.OnSubscribe<Object>() {
+      @Override public void call(Subscriber<? super Object> subscriber) {
+        if (subscriber.isUnsubscribed()) {
+          return;
+        }
+        FutureTask<Void> task = new FutureTask<Void>(getRunnable(subscriber, request), null);
+        // Subscribe to the future task of the network call allowing unsubscription.
+        subscriber.add(Subscriptions.from(task));
+        executor.execute(task);
+      }
+    });
+  }
+
+  private Runnable getRunnable(final Subscriber<? super Object> subscriber,
+      final Callable<ResponseWrapper> request) {
+    return new Runnable() {
+      @Override public void run() {
+        try {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          ResponseWrapper wrapper = request.call();
+          subscriber.onNext(wrapper.responseBody);
+          subscriber.onCompleted();
+        } catch (RetrofitError e) {
+          subscriber.onError(errorHandler.handleError(e));
+        } catch (Exception e) {
+          // This is from the Callable.  It shouldn't actually throw.
+          throw new RuntimeException(e);
+        }
+      }
+    };
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
new file mode 100644
index 000000000..40da835b6
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes name and value parts of a multi-part request
+ * <p>
+ * Values of the map on which this annotation exists will be processed in one of three ways:
+ * <ul>
+ * <li>If the type implements {@link retrofit.mime.TypedOutput TypedOutput} the headers and
+ * body will be used directly.</li>
+ * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
+ * content type.</li>
+ * <li>Other object types will be converted to an appropriate representation by calling {@link
+ * retrofit.converter.Converter#toBody(Object)}.</li>
+ * </ul>
+ * <p>
+ * <pre>
+ * &#64;Multipart
+ * &#64;POST("/upload")
+ * void upload(&#64;Part("file") TypedFile file, &#64;PartMap Map&lt;String, String&gt; params);
+ * </pre>
+ * <p>
+ *
+ * @see Multipart
+ * @see Part
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface PartMap {
+}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 81dfcc5f6..2263eabfd 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -33,6 +33,7 @@
 import static retrofit.RestMethodInfo.ParamUsage.FIELD_MAP;
 import static retrofit.RestMethodInfo.ParamUsage.HEADER;
 import static retrofit.RestMethodInfo.ParamUsage.PART;
+import static retrofit.RestMethodInfo.ParamUsage.PART_MAP;
 import static retrofit.RestMethodInfo.ParamUsage.PATH;
 import static retrofit.RestMethodInfo.ParamUsage.QUERY;
 import static retrofit.RestMethodInfo.ParamUsage.QUERY_MAP;
@@ -490,6 +491,38 @@
     assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
   }
 
+  @Test public void multipartPartMap() throws Exception {
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put("ping", "pong");
+    params.put("kit", new TypedString("kat"));
+
+    Request request = new Helper() //
+        .setMethod("POST") //
+        .setHasBody() //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .setMultipart() //
+        .addPartMap("params", params) //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("POST");
+    assertThat(request.getHeaders()).hasSize(2);
+    assertThat(request.getHeaders().get(0).getName()).isEqualTo("Content-Type");
+    assertThat(request.getHeaders().get(1)).isEqualTo(new Header("Content-Length", "414"));
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+
+    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
+    List<byte[]> bodyParts = MimeHelper.getParts(body);
+    assertThat(bodyParts).hasSize(2);
+
+    Iterator<byte[]> iterator = bodyParts.iterator();
+
+    String one = new String(iterator.next(), "UTF-8");
+    assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
+
+    String two = new String(iterator.next(), "UTF-8");
+    assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
+  }
+
   @Test public void multipartNullRemovesPart() throws Exception {
     Request request = new Helper() //
         .setMethod("POST") //
@@ -858,6 +891,13 @@ Helper addPart(String name, Object value) {
       return this;
     }
 
+    Helper addPartMap(String name, Map<String, Object> values) {
+      paramNames.add(name);
+      paramUsages.add(PART_MAP);
+      args.add(values);
+      return this;
+    }
+
     Helper setBody(Object value) {
       paramNames.add(null);
       paramUsages.add(BODY);
diff --git a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
index 41e250c9a..ece88dd5c 100644
--- a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
@@ -28,6 +28,7 @@
 import retrofit.http.POST;
 import retrofit.http.PUT;
 import retrofit.http.Part;
+import retrofit.http.PartMap;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
@@ -908,6 +909,21 @@ Response a(@Part("a") TypedOutput a, @Part("b") int b) {
     assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
   }
 
+  @Test public void partMapMultipart() {
+    class Example {
+      @Multipart @PUT("/")
+      Response a(@Part("a") TypedOutput a, @PartMap Map<String, String> b) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    methodInfo.init();
+
+    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
+  }
+
   @Test public void implicitMultipartForbidden() {
     class Example {
       @POST("/") Response a(@Part("a") int a) {
@@ -926,6 +942,24 @@ Response a(@Part("a") TypedOutput a, @Part("b") int b) {
     }
   }
 
+  @Test public void implicitMultipartWithPartMapForbidden() {
+    class Example {
+      @POST("/") Response a(@PartMap Map<String, String> params) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    try {
+      methodInfo.init();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.a: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
+    }
+  }
+
   @Test public void multipartFailsOnNonBodyMethod() {
     class Example {
       @Multipart @GET("/") Response a() {
diff --git a/retrofit/src/test/java/retrofit/RxSupportTest.java b/retrofit/src/test/java/retrofit/RxSupportTest.java
new file mode 100644
index 000000000..8868faec9
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/RxSupportTest.java
@@ -0,0 +1,174 @@
+package retrofit;
+
+import java.util.ArrayDeque;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import retrofit.client.Header;
+import retrofit.client.Response;
+import retrofit.mime.TypedInput;
+import rx.Observer;
+import rx.Subscription;
+import rx.schedulers.Schedulers;
+import rx.schedulers.TestScheduler;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+public class RxSupportTest {
+
+  private Object response;
+  private ResponseWrapper responseWrapper;
+  private Callable<ResponseWrapper> callable = spy(new Callable<ResponseWrapper>() {
+    @Override public ResponseWrapper call() throws Exception {
+      return responseWrapper;
+    }
+  });
+
+  private QueuedSynchronousExecutor executor;
+  private RxSupport rxSupport;
+
+  @Mock Observer<Object> subscriber;
+
+  @Before public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    response = new Object();
+    responseWrapper = new ResponseWrapper(
+            new Response(
+                    "http://example.com", 200, "Success",
+                    Collections.<Header>emptyList(), mock(TypedInput.class)
+            ), response
+    );
+    executor = spy(new QueuedSynchronousExecutor());
+    rxSupport = new RxSupport(executor, ErrorHandler.DEFAULT);
+  }
+
+  @Test public void testObservableCallsOnNextOnHttpExecutor() {
+    rxSupport.createRequestObservable(callable).subscribe(subscriber);
+    executor.executeNextInQueue();
+    verify(subscriber, times(1)).onNext(response);
+  }
+
+  @Test public void testObservableCallsOnNextOnHttpExecutorWithSubscriber() {
+    TestScheduler test = Schedulers.test();
+    rxSupport.createRequestObservable(callable).subscribeOn(test).subscribe(subscriber);
+    // Subscription is handled via the Scheduler.
+    test.triggerActions();
+    // This will only execute up to the executor in OnSubscribe.
+    verify(subscriber, never()).onNext(any());
+    // Upon continuing the executor we then run the retrofit request.
+    executor.executeNextInQueue();
+    verify(subscriber, times(1)).onNext(response);
+  }
+
+  @Test public void testObservableUnSubscribesDoesNotExecuteCallable() throws Exception {
+    Subscription subscription = rxSupport.createRequestObservable(callable).subscribe(subscriber);
+    verify(subscriber, never()).onNext(any());
+
+    // UnSubscribe here should cancel the queued runnable.
+    subscription.unsubscribe();
+
+    executor.executeNextInQueue();
+    verify(callable, never()).call();
+    verify(subscriber, never()).onNext(response);
+  }
+
+  @Test public void testObservableCallsOperatorsOffHttpExecutor() {
+    TestScheduler test = Schedulers.test();
+    rxSupport.createRequestObservable(callable)
+            .delaySubscription(1000, TimeUnit.MILLISECONDS, test)
+            .subscribe(subscriber);
+
+    verify(subscriber, never()).onNext(any());
+    test.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
+    // Upon continuing the executor we then run the retrofit request.
+    executor.executeNextInQueue();
+    verify(subscriber, times(1)).onNext(response);
+  }
+
+  @Test public void testObservableDoesNotLockExecutor() {
+    TestScheduler test = Schedulers.test();
+    rxSupport.createRequestObservable(callable)
+            .delay(1000, TimeUnit.MILLISECONDS, test)
+            .subscribe(subscriber);
+
+    rxSupport.createRequestObservable(callable)
+            .delay(2000, TimeUnit.MILLISECONDS, test)
+            .subscribe(subscriber);
+
+    // Nothing fired yet
+    verify(subscriber, never()).onNext(any());
+    // Subscriptions should of been queued up and executed even tho we delayed on the Subscriber.
+    executor.executeNextInQueue();
+    executor.executeNextInQueue();
+
+    verify(subscriber, never()).onNext(response);
+
+    test.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
+    verify(subscriber, times(1)).onNext(response);
+
+    test.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
+    verify(subscriber, times(2)).onNext(response);
+  }
+
+  @Test public void testObservableRespectsObserveOn() throws Exception {
+    TestScheduler observe = Schedulers.test();
+    rxSupport.createRequestObservable(callable)
+            .observeOn(observe)
+            .subscribe(subscriber);
+
+    verify(subscriber, never()).onNext(any());
+    executor.executeNextInQueue();
+
+    // Should have no response yet, but callback should of been executed.
+    verify(subscriber, never()).onNext(any());
+    verify(callable, times(1)).call();
+
+    // Forward the Observable Scheduler
+    observe.triggerActions();
+    verify(subscriber, times(1)).onNext(response);
+  }
+
+  /**
+   * Test Executor to iterate through Executions to aid in checking
+   * that the Observable implementation is correct.
+   */
+  static class QueuedSynchronousExecutor implements Executor {
+    Deque<Runnable> runnableQueue = new ArrayDeque<Runnable>();
+
+    @Override public void execute(Runnable runnable) {
+      runnableQueue.add(runnable);
+    }
+
+    /**
+     * Will throw exception if you are expecting something to be added to the Executor
+     * and it hasn't.
+     */
+    void executeNextInQueue() {
+      runnableQueue.removeFirst().run();
+    }
+
+    /**
+     * Executes any queued executions on the executor.
+     */
+    void executeAll() {
+      Iterator<Runnable> iterator = runnableQueue.iterator();
+      while (iterator.hasNext()) {
+        Runnable next = iterator.next();
+        next.run();
+        iterator.remove();
+      }
+    }
+  }
+}
