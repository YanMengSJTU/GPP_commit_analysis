diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f7..45e2d44a8 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -27,118 +28,138 @@
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
+/**
+ * 模拟的回调
+ *
+ * @param <T>
+ */
 final class BehaviorCall<T> implements Call<T> {
-  final NetworkBehavior behavior;
-  final ExecutorService backgroundExecutor;
-  final Call<T> delegate;
-
-  private volatile Future<?> task;
-  volatile boolean canceled;
-  private volatile boolean executed;
-
-  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
-    this.behavior = behavior;
-    this.backgroundExecutor = backgroundExecutor;
-    this.delegate = delegate;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public Call<T> clone() {
-    return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
-  }
-
-  @Override public Request request() {
-    return delegate.request();
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+    final NetworkBehavior behavior;
+    final ExecutorService backgroundExecutor;
+    final Call<T> delegate;
+
+    private volatile Future<?> task;
+    volatile boolean canceled;
+    private volatile boolean executed;
+
+    BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
+        this.behavior = behavior;
+        this.backgroundExecutor = backgroundExecutor;
+        this.delegate = delegate;
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public Call<T> clone() {
+        return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
     }
-    task = backgroundExecutor.submit(new Runnable() {
-      boolean delaySleep() {
-        long sleepMs = behavior.calculateDelay(MILLISECONDS);
-        if (sleepMs > 0) {
-          try {
-            Thread.sleep(sleepMs);
-          } catch (InterruptedException e) {
-            callback.onFailure(BehaviorCall.this, new IOException("canceled"));
-            return false;
-          }
+
+    @Override
+    public Request request() {
+        return delegate.request();
+    }
+
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed");
+            executed = true;
         }
-        return true;
-      }
-
-      @Override public void run() {
-        if (canceled) {
-          callback.onFailure(BehaviorCall.this, new IOException("canceled"));
-        } else if (behavior.calculateIsFailure()) {
-          if (delaySleep()) {
-            callback.onFailure(BehaviorCall.this, behavior.failureException());
-          }
-        } else {
-          delegate.enqueue(new Callback<T>() {
-            @Override public void onResponse(Call<T> call, Response<T> response) {
-              if (delaySleep()) {
-                callback.onResponse(call, response);
-              }
+        task = backgroundExecutor.submit(new Runnable() {
+            boolean delaySleep() {
+                long sleepMs = behavior.calculateDelay(MILLISECONDS);
+                if (sleepMs > 0) {
+                    try {
+                        // 延迟
+                        Thread.sleep(sleepMs);
+                    } catch (InterruptedException e) {
+                        callback.onFailure(BehaviorCall.this, new IOException("canceled"));
+                        return false;
+                    }
+                }
+                return true;
             }
 
-            @Override public void onFailure(Call<T> call, Throwable t) {
-              if (delaySleep()) {
-                callback.onFailure(call, t);
-              }
+            @Override
+            public void run() {
+                if (canceled) {
+                    callback.onFailure(BehaviorCall.this, new IOException("canceled"));
+                } else if (behavior.calculateIsFailure()) {
+                    // 模拟失败
+                    if (delaySleep()) {
+                        callback.onFailure(BehaviorCall.this, behavior.failureException());
+                    }
+                } else {
+                    // 成功
+                    delegate.enqueue(new Callback<T>() {
+                        @Override
+                        public void onResponse(Call<T> call, Response<T> response) {
+                            if (delaySleep()) {
+                                callback.onResponse(call, response);
+                            }
+                        }
+
+                        @Override
+                        public void onFailure(Call<T> call, Throwable t) {
+                            if (delaySleep()) {
+                                callback.onFailure(call, t);
+                            }
+                        }
+                    });
+                }
             }
-          });
+        });
+    }
+
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
+    }
+
+    @Override
+    public Response<T> execute() throws IOException {
+        final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        enqueue(new Callback<T>() {
+            @Override
+            public void onResponse(Call<T> call, Response<T> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<T> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new IOException("canceled");
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    enqueue(new Callback<T>() {
-      @Override public void onResponse(Call<T> call, Response<T> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<T> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    try {
-      latch.await();
-    } catch (InterruptedException e) {
-      throw new IOException("canceled");
+        Response<T> response = responseRef.get();
+        if (response != null) return response;
+        Throwable failure = failureRef.get();
+        if (failure instanceof RuntimeException) throw (RuntimeException) failure;
+        if (failure instanceof IOException) throw (IOException) failure;
+        throw new RuntimeException(failure);
     }
-    Response<T> response = responseRef.get();
-    if (response != null) return response;
-    Throwable failure = failureRef.get();
-    if (failure instanceof RuntimeException) throw (RuntimeException) failure;
-    if (failure instanceof IOException) throw (IOException) failure;
-    throw new RuntimeException(failure);
-  }
-
-  @Override public void cancel() {
-    canceled = true;
-    Future<?> task = this.task;
-    if (task != null) {
-      task.cancel(true);
+
+    @Override
+    public void cancel() {
+        canceled = true;
+        Future<?> task = this.task;
+        if (task != null) {
+            task.cancel(true);
+        }
     }
-  }
 
-  @Override public boolean isCanceled() {
-    return canceled;
-  }
+    @Override
+    public boolean isCanceled() {
+        return canceled;
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 7c9361f65..28ba6a500 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -31,6 +31,8 @@
  * {@link Retrofit}.
  *
  * @see MockRetrofit#create(Class)
+ *
+ *
  */
 public final class BehaviorDelegate<T> {
   final Retrofit retrofit;
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490aee..1472033e0 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,82 +16,99 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
 
-/** Factory methods for creating {@link Call} instances which immediately respond or fail. */
+/**
+ * Factory methods for creating {@link Call} instances which immediately respond or fail.
+ */
 public final class Calls {
-  public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
-  }
-
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        return response;
-      }
-
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onResponse(this, response);
-      }
-
-      @Override public boolean isExecuted() {
-        return false;
-      }
-
-      @Override public void cancel() {
-      }
-
-      @Override public boolean isCanceled() {
-        return false;
-      }
-
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-
-      @Override public Request request() {
-        return response.raw().request();
-      }
-    };
-  }
-
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
-      }
-
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(this, failure);
-      }
-
-      @Override public boolean isExecuted() {
-        return false;
-      }
-
-      @Override public void cancel() {
-      }
-
-      @Override public boolean isCanceled() {
-        return false;
-      }
-
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-
-      @Override public Request request() {
-        return new Request.Builder().url("http://localhost").build();
-      }
-    };
-  }
-
-  private Calls() {
-    throw new AssertionError("No instances.");
-  }
+    public static <T> Call<T> response(T successValue) {
+        return response(Response.success(successValue));
+    }
+
+    public static <T> Call<T> response(final Response<T> response) {
+        return new Call<T>() {
+            @Override
+            public Response<T> execute() throws IOException {
+                return response;
+            }
+
+            @Override
+            public void enqueue(Callback<T> callback) {
+                callback.onResponse(this, response);
+            }
+
+            @Override
+            public boolean isExecuted() {
+                return false;
+            }
+
+            @Override
+            public void cancel() {
+            }
+
+            @Override
+            public boolean isCanceled() {
+                return false;
+            }
+
+            @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+            @Override
+            public Call<T> clone() {
+                return this;
+            }
+
+            @Override
+            public Request request() {
+                return response.raw().request();
+            }
+        };
+    }
+
+    public static <T> Call<T> failure(final IOException failure) {
+        return new Call<T>() {
+            @Override
+            public Response<T> execute() throws IOException {
+                throw failure;
+            }
+
+            @Override
+            public void enqueue(Callback<T> callback) {
+                callback.onFailure(this, failure);
+            }
+
+            @Override
+            public boolean isExecuted() {
+                return false;
+            }
+
+            @Override
+            public void cancel() {
+            }
+
+            @Override
+            public boolean isCanceled() {
+                return false;
+            }
+
+            @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+            @Override
+            public Call<T> clone() {
+                return this;
+            }
+
+            @Override
+            public Request request() {
+                return new Request.Builder().url("http://localhost").build();
+            }
+        };
+    }
+
+    private Calls() {
+        throw new AssertionError("No instances.");
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..e20737342 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -20,6 +20,10 @@
 import java.util.concurrent.Executors;
 import retrofit2.Retrofit;
 
+/**
+ * Mock  虚拟的意思
+ * 这个是一个 包装的 retrofit
+ */
 public final class MockRetrofit {
   private final Retrofit retrofit;
   private final NetworkBehavior behavior;
@@ -44,6 +48,7 @@ public Executor backgroundExecutor() {
   }
 
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  // 模拟 Retrofit 的 creat
   public <T> BehaviorDelegate<T> create(Class<T> service) {
     return new BehaviorDelegate<>(retrofit, behavior, executor, service);
   }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index d182862cb..6dc4d0d4a 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -35,118 +35,155 @@
  * <p>
  * By default, instances of this class will use a 2 second delay with 40% variance and failures
  * will occur 3% of the time.
+ *
+ * 网络 行为 模拟不同的网络环境
  */
 public final class NetworkBehavior {
-  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
-  private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
-  private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+    // 默认延迟 2s
+    private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+    // 40% 上下的变化
+    private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
+
+    // 3% 的请求会失败
+    private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+
+    /**
+     * Applies {@link NetworkBehavior} to instances of {@code T}.
+     */
+    public interface Adapter<T> {
+        /**
+         * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+         * traits when interacted with.
+         */
+        T applyBehavior(NetworkBehavior behavior, T value);
+    }
+
+    /**
+     * Create an instance with default behavior.
+     */
+    public static NetworkBehavior create() {
+        return new NetworkBehavior(new Random());
+    }
+
+    /**
+     * Create an instance with default behavior which uses {@code random} to control variance and
+     * failure calculation.
+     */
+    public static NetworkBehavior create(Random random) {
+        if (random == null) throw new NullPointerException("random == null");
+        return new NetworkBehavior(random);
+    }
+
+    // 随机种子 参数随机数 的对象
+    private final Random random;
+
+    private volatile long delayMs = DEFAULT_DELAY_MS;
+    private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
+    private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
+    private volatile Throwable failureException = new IOException("Mock failure!");
+
+    private NetworkBehavior(Random random) {
+        this.random = random;
+    }
 
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
     /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
+     * Set the network round trip delay.
+     * 设置延迟时间
      */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
-
-  /** Create an instance with default behavior. */
-  public static NetworkBehavior create() {
-    return new NetworkBehavior(new Random());
-  }
-
-  /**
-   * Create an instance with default behavior which uses {@code random} to control variance and
-   * failure calculation.
-   */
-  public static NetworkBehavior create(Random random) {
-    if (random == null) throw new NullPointerException("random == null");
-    return new NetworkBehavior(random);
-  }
-
-  private final Random random;
-
-  private volatile long delayMs = DEFAULT_DELAY_MS;
-  private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
-  private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile Throwable failureException = new IOException("Mock failure!");
-
-  private NetworkBehavior(Random random) {
-    this.random = random;
-  }
-
-  /** Set the network round trip delay. */
-  public void setDelay(long amount, TimeUnit unit) {
-    if (amount < 0) {
-      throw new IllegalArgumentException("Amount must be positive value.");
+    public void setDelay(long amount, TimeUnit unit) {
+        if (amount < 0) {
+            throw new IllegalArgumentException("Amount must be positive value.");
+        }
+        this.delayMs = unit.toMillis(amount);
     }
-    this.delayMs = unit.toMillis(amount);
-  }
-
-  /** The network round trip delay. */
-  public long delay(TimeUnit unit) {
-    return MILLISECONDS.convert(delayMs, unit);
-  }
-
-  /** Set the plus-or-minus variance percentage of the network round trip delay. */
-  public void setVariancePercent(int variancePercent) {
-    if (variancePercent < 0 || variancePercent > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+
+    /**
+     * The network round trip delay.
+     * 设置延迟的 时间类型  秒 毫秒 分 这些
+     */
+    public long delay(TimeUnit unit) {
+        return MILLISECONDS.convert(delayMs, unit);
     }
-    this.variancePercent = variancePercent;
-  }
-
-  /** The plus-or-minus variance percentage of the network round trip delay. */
-  public int variancePercent() {
-    return variancePercent;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public void setFailurePercent(int failurePercent) {
-    if (failurePercent < 0 || failurePercent > 100) {
-      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+
+    /**
+     * Set the plus-or-minus variance percentage of the network round trip delay.
+     * 这种不稳地的比例
+     */
+    public void setVariancePercent(int variancePercent) {
+        if (variancePercent < 0 || variancePercent > 100) {
+            throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+        }
+        this.variancePercent = variancePercent;
     }
-    this.failurePercent = failurePercent;
-  }
-
-  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public int failurePercent() {
-    return failurePercent;
-  }
-
-  /** Set the exception to be used when a failure is triggered. */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+
+    /**
+     * The plus-or-minus variance percentage of the network round trip delay.
+     */
+    public int variancePercent() {
+        return variancePercent;
+    }
+
+    /**
+     * Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}.
+     *
+     * 设置失败的比例
+     */
+    public void setFailurePercent(int failurePercent) {
+        if (failurePercent < 0 || failurePercent > 100) {
+            throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+        }
+        this.failurePercent = failurePercent;
+    }
+
+    /**
+     * The percentage of calls to {@link #calculateIsFailure()} that return {@code true}.
+     */
+    public int failurePercent() {
+        return failurePercent;
+    }
+
+    /**
+     * Set the exception to be used when a failure is triggered.
+     * 设置失败时 的异常
+     */
+    public void setFailureException(Throwable t) {
+        if (t == null) {
+            throw new NullPointerException("t == null");
+        }
+        this.failureException = t;
+    }
+
+    /**
+     * The exception to be used when a failure is triggered.
+     */
+    public Throwable failureException() {
+        return failureException;
+    }
+
+    /**
+     * Randomly determine whether this call should result in a network failure in accordance with
+     * configured behavior. When true, {@link #failureException()} should be thrown.
+     *
+     * 计算是否 失败
+     */
+    public boolean calculateIsFailure() {
+        int randomValue = random.nextInt(100);
+        return randomValue < failurePercent;
+    }
+
+    /**
+     * Get the delay that should be used for delaying a response in accordance with configured
+     * behavior.
+     *
+     * 计算延迟时间  计入了不稳定的 比例
+     */
+    public long calculateDelay(TimeUnit unit) {
+        float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
+        float lowerBound = 1f - delta; // 0.2f --> 0.8f
+        float upperBound = 1f + delta; // 0.2f --> 1.2f
+        float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+        float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
+        long callDelayMs = (long) (delayMs * delayPercent);
+        return MILLISECONDS.convert(callDelayMs, unit);
     }
-    this.failureException = t;
-  }
-
-  /** The exception to be used when a failure is triggered. */
-  public Throwable failureException() {
-    return failureException;
-  }
-
-  /**
-   * Randomly determine whether this call should result in a network failure in accordance with
-   * configured behavior. When true, {@link #failureException()} should be thrown.
-   */
-  public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
-  }
-
-  /**
-   * Get the delay that should be used for delaying a response in accordance with configured
-   * behavior.
-   */
-  public long calculateDelay(TimeUnit unit) {
-    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
-    float lowerBound = 1f - delta; // 0.2f --> 0.8f
-    float upperBound = 1f + delta; // 0.2f --> 1.2f
-    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
-    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
-    long callDelayMs = (long) (delayMs * delayPercent);
-    return MILLISECONDS.convert(callDelayMs, unit);
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..5207a1c34 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -3,6 +3,7 @@
 
 import com.example.retrofit.SimpleService.Contributor;
 import com.example.retrofit.SimpleService.GitHub;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+
 import retrofit2.Call;
 import retrofit2.Retrofit;
 import retrofit2.mock.BehaviorDelegate;
@@ -19,91 +21,98 @@
 /**
  * An example of using {@link MockRetrofit} to create a mock service implementation with
  * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
+ * <p>
+ * 一个 模拟网络 的 例子
  */
 public final class SimpleMockService {
-  /** A mock implementation of the {@link GitHub} API interface. */
-  static final class MockGitHub implements GitHub {
-    private final BehaviorDelegate<GitHub> delegate;
-    private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
-
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
-      this.delegate = delegate;
-      ownerRepoContributors = new LinkedHashMap<>();
-
-      // Seed some mock data.
-      addContributor("square", "retrofit", "John Doe", 12);
-      addContributor("square", "retrofit", "Bob Smith", 2);
-      addContributor("square", "retrofit", "Big Bird", 40);
-      addContributor("square", "picasso", "Proposition Joe", 39);
-      addContributor("square", "picasso", "Keiser Soze", 152);
-    }
+    /**
+     * A mock implementation of the {@link GitHub} API interface.
+     */
+    static final class MockGitHub implements GitHub {
+        private final BehaviorDelegate<GitHub> delegate;
+        private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
+
+        public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+            this.delegate = delegate;
+            ownerRepoContributors = new LinkedHashMap<>();
+
+            // Seed some mock data.
+            addContributor("square", "retrofit", "John Doe", 12);
+            addContributor("square", "retrofit", "Bob Smith", 2);
+            addContributor("square", "retrofit", "Big Bird", 40);
+            addContributor("square", "picasso", "Proposition Joe", 39);
+            addContributor("square", "picasso", "Keiser Soze", 152);
+        }
+
+        @Override
+        public Call<List<Contributor>> contributors(String owner, String repo) {
+            List<Contributor> response = Collections.emptyList();
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors != null) {
+                List<Contributor> contributors = repoContributors.get(repo);
+                if (contributors != null) {
+                    response = contributors;
+                }
+            }
+            return delegate.returningResponse(response).contributors(owner, repo);
+        }
 
-    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
-      List<Contributor> response = Collections.emptyList();
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors != null) {
-        List<Contributor> contributors = repoContributors.get(repo);
-        if (contributors != null) {
-          response = contributors;
+        public void addContributor(String owner, String repo, String name, int contributions) {
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors == null) {
+                repoContributors = new LinkedHashMap<>();
+                ownerRepoContributors.put(owner, repoContributors);
+            }
+            List<Contributor> contributors = repoContributors.get(repo);
+            if (contributors == null) {
+                contributors = new ArrayList<>();
+                repoContributors.put(repo, contributors);
+            }
+            contributors.add(new Contributor(name, contributions));
         }
-      }
-      return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<>();
-        ownerRepoContributors.put(owner, repoContributors);
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        contributors = new ArrayList<>();
-        repoContributors.put(repo, contributors);
-      }
-      contributors.add(new Contributor(name, contributions));
+    public static void main(String... args) throws IOException {
+        // Create a very simple Retrofit adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(SimpleService.API_URL)
+                .build();
+
+        // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
+        // 构建模拟的 MockRetrofit
+        NetworkBehavior behavior = NetworkBehavior.create();
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+
+        // 这里 create 接口
+        BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
+        MockGitHub gitHub = new MockGitHub(delegate);
+
+        // Query for some contributors for a few repositories.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
+
+        // Using the mock-only methods, add some additional data.
+        System.out.println("Adding more mock data...\n");
+        gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+        gitHub.addContributor("square", "picasso", "Kit Kat", 53);
+
+        // Reduce the delay to make the next calls complete faster.
+        behavior.setDelay(500, TimeUnit.MILLISECONDS);
+
+        // Query for the contributors again so we can see the mock data that was added.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
     }
-  }
-
-  public static void main(String... args) throws IOException {
-    // Create a very simple Retrofit adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(SimpleService.API_URL)
-        .build();
-
-    // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
-    NetworkBehavior behavior = NetworkBehavior.create();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-
-    BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
-    MockGitHub gitHub = new MockGitHub(delegate);
-
-    // Query for some contributors for a few repositories.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-
-    // Using the mock-only methods, add some additional data.
-    System.out.println("Adding more mock data...\n");
-    gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
-    gitHub.addContributor("square", "picasso", "Kit Kat", 53);
-
-    // Reduce the delay to make the next calls complete faster.
-    behavior.setDelay(500, TimeUnit.MILLISECONDS);
-
-    // Query for the contributors again so we can see the mock data that was added.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-  }
-
-  private static void printContributors(GitHub gitHub, String owner, String repo)
-      throws IOException {
-    System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors.execute().body()) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+
+    private static void printContributors(GitHub gitHub, String owner, String repo)
+            throws IOException {
+        System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
+        Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+        for (Contributor contributor : contributors.execute().body()) {
+            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        }
+        System.out.println();
     }
-    System.out.println();
-  }
 }
