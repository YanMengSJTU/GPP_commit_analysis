diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 40ebe1ff5..fb7434994 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -19,6 +19,7 @@
 import java.net.URLEncoder;
 import java.util.ArrayList;
 import java.util.List;
+
 import retrofit.client.Header;
 import retrofit.client.Request;
 import retrofit.converter.Converter;
@@ -28,232 +29,254 @@
 import retrofit.mime.TypedString;
 
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
-  private final Converter converter;
-  private final List<Header> headers;
-  private final StringBuilder queryParams;
-  private final String[] paramNames;
-  private final RestMethodInfo.ParamUsage[] paramUsages;
-  private final String requestMethod;
-  private final boolean isSynchronous;
-  private final boolean isObservable;
+    private final Converter converter;
+    private final List<Header> headers;
+    private final StringBuilder queryParams;
+    private final String[] paramNames;
+    private final RestMethodInfo.ParamUsage[] paramUsages;
+    private final String requestMethod;
+    private final boolean isSynchronous;
+    private final boolean isObservable;
 
-  private final FormUrlEncodedTypedOutput formBody;
-  private final MultipartTypedOutput multipartBody;
-  private TypedOutput body;
+    private final FormUrlEncodedTypedOutput formBody;
+    private final MultipartTypedOutput multipartBody;
+    private TypedOutput body;
 
-  private String relativeUrl;
-  private String apiUrl;
+    private String overrideAbsoluteUrl = null;
 
-  RequestBuilder(Converter converter, RestMethodInfo methodInfo) {
-    this.converter = converter;
+    private String relativeUrl;
+    private String apiUrl;
 
-    paramNames = methodInfo.requestParamNames;
-    paramUsages = methodInfo.requestParamUsage;
-    requestMethod = methodInfo.requestMethod;
-    isSynchronous = methodInfo.isSynchronous;
-    isObservable = methodInfo.isObservable;
+    RequestBuilder(Converter converter, RestMethodInfo methodInfo) {
+        this.converter = converter;
 
-    headers = new ArrayList<Header>();
-    if (methodInfo.headers != null) {
-      headers.addAll(methodInfo.headers);
-    }
+        paramNames = methodInfo.requestParamNames;
+        paramUsages = methodInfo.requestParamUsage;
+        requestMethod = methodInfo.requestMethod;
+        isSynchronous = methodInfo.isSynchronous;
+        isObservable = methodInfo.isObservable;
+
+        headers = new ArrayList<Header>();
+        if (methodInfo.headers != null) {
+            headers.addAll(methodInfo.headers);
+        }
+
+        queryParams = new StringBuilder();
 
-    queryParams = new StringBuilder();
+        relativeUrl = methodInfo.requestUrl;
 
-    relativeUrl = methodInfo.requestUrl;
+        String requestQuery = methodInfo.requestQuery;
+        if (requestQuery != null) {
+            queryParams.append('?').append(requestQuery);
+        }
 
-    String requestQuery = methodInfo.requestQuery;
-    if (requestQuery != null) {
-      queryParams.append('?').append(requestQuery);
+        switch (methodInfo.requestType) {
+            case FORM_URL_ENCODED:
+                formBody = new FormUrlEncodedTypedOutput();
+                multipartBody = null;
+                body = formBody;
+                break;
+            case MULTIPART:
+                formBody = null;
+                multipartBody = new MultipartTypedOutput();
+                body = multipartBody;
+                break;
+            case SIMPLE:
+                formBody = null;
+                multipartBody = null;
+                // If present, 'body' will be set in 'setArguments' call.
+                break;
+            default:
+                throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
+        }
     }
 
-    switch (methodInfo.requestType) {
-      case FORM_URL_ENCODED:
-        formBody = new FormUrlEncodedTypedOutput();
-        multipartBody = null;
-        body = formBody;
-        break;
-      case MULTIPART:
-        formBody = null;
-        multipartBody = new MultipartTypedOutput();
-        body = multipartBody;
-        break;
-      case SIMPLE:
-        formBody = null;
-        multipartBody = null;
-        // If present, 'body' will be set in 'setArguments' call.
-        break;
-      default:
-        throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
+    void setApiUrl(String apiUrl) {
+        this.apiUrl = apiUrl;
     }
-  }
 
-  void setApiUrl(String apiUrl) {
-    this.apiUrl = apiUrl;
-  }
+    @Override
+    public void addHeader(String name, String value) {
+        if (name == null) {
+            throw new IllegalArgumentException("Header name must not be null.");
+        }
+        headers.add(new Header(name, value));
+    }
 
-  @Override public void addHeader(String name, String value) {
-    if (name == null) {
-      throw new IllegalArgumentException("Header name must not be null.");
+    @Override
+    public void addPathParam(String name, String value) {
+        addPathParam(name, value, true);
     }
-    headers.add(new Header(name, value));
-  }
 
-  @Override public void addPathParam(String name, String value) {
-    addPathParam(name, value, true);
-  }
+    @Override
+    public void addEncodedPathParam(String name, String value) {
+        addPathParam(name, value, false);
+    }
 
-  @Override public void addEncodedPathParam(String name, String value) {
-    addPathParam(name, value, false);
-  }
+    void addPathParam(String name, String value, boolean urlEncodeValue) {
+        if (name == null) {
+            throw new IllegalArgumentException("Path replacement name must not be null.");
+        }
+        if (value == null) {
+            throw new IllegalArgumentException(
+                    "Path replacement \"" + name + "\" value must not be null.");
+        }
+        try {
+            if (urlEncodeValue) {
+                String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
+                // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
+                // encode spaces rather than +. Query encoding difference specified in HTML spec.
+                // Any remaining plus signs represent spaces as already URLEncoded.
+                encodedValue = encodedValue.replace("+", "%20");
+                relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
+            } else {
+                relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
+            }
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(
+                    "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
+        }
+    }
 
-  void addPathParam(String name, String value, boolean urlEncodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Path replacement name must not be null.");
+    @Override
+    public void addQueryParam(String name, String value) {
+        addQueryParam(name, value, true);
     }
-    if (value == null) {
-      throw new IllegalArgumentException(
-          "Path replacement \"" + name + "\" value must not be null.");
+
+    @Override
+    public void addEncodedQueryParam(String name, String value) {
+        addQueryParam(name, value, false);
     }
-    try {
-      if (urlEncodeValue) {
-        String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
-        // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
-        // encode spaces rather than +. Query encoding difference specified in HTML spec.
-        // Any remaining plus signs represent spaces as already URLEncoded.
-        encodedValue = encodedValue.replace("+", "%20");
-        relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
-      } else {
-        relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
-      }
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
+
+    void addQueryParam(String name, String value, boolean urlEncodeValue) {
+        if (name == null) {
+            throw new IllegalArgumentException("Query param name must not be null.");
+        }
+        if (value == null) {
+            throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
+        }
+        try {
+            if (urlEncodeValue) {
+                value = URLEncoder.encode(String.valueOf(value), "UTF-8");
+            }
+            StringBuilder queryParams = this.queryParams;
+            queryParams.append(queryParams.length() > 0 ? '&' : '?');
+            queryParams.append(name).append('=').append(value);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(
+                    "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
+        }
     }
-  }
 
-  @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, true);
-  }
+    void setArguments(Object[] args) {
+        if (args == null) {
+            return;
+        }
+        int count = args.length;
+        if (!isSynchronous && !isObservable) {
+            count -= 1;
+        }
+        for (int i = 0; i < count; i++) {
+            String name = paramNames[i];
+            Object value = args[i];
+            RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
+            switch (paramUsage) {
+                case PATH:
+                    if (value == null) {
+                        throw new IllegalArgumentException(
+                                "Path parameter \"" + name + "\" value must not be null.");
+                    }
+                    addPathParam(name, value.toString());
+                    break;
+                case ENCODED_PATH:
+                    if (value == null) {
+                        throw new IllegalArgumentException(
+                                "Path parameter \"" + name + "\" value must not be null.");
+                    }
+                    addEncodedPathParam(name, value.toString());
+                    break;
+                case QUERY:
+                    if (value != null) { // Skip null values.
+                        addQueryParam(name, value.toString());
+                    }
+                    break;
+                case ENCODED_QUERY:
+                    if (value != null) { // Skip null values.
+                        addEncodedQueryParam(name, value.toString());
+                    }
+                    break;
+                case HEADER:
+                    if (value != null) { // Skip null values.
+                        addHeader(name, value.toString());
+                    }
+                    break;
+                case FIELD:
+                    if (value != null) { // Skip null values.
+                        formBody.addField(name, value.toString());
+                    }
+                    break;
+                case PART:
+                    if (value != null) { // Skip null values.
+                        if (value instanceof TypedOutput) {
+                            multipartBody.addPart(name, (TypedOutput) value);
+                        } else if (value instanceof String) {
+                            multipartBody.addPart(name, new TypedString((String) value));
+                        } else {
+                            multipartBody.addPart(name, converter.toBody(value));
+                        }
+                    }
+                    break;
+                case BODY:
+                    if (value == null) {
+                        throw new IllegalArgumentException("Body parameter value must not be null.");
+                    }
+                    if (value instanceof TypedOutput) {
+                        body = (TypedOutput) value;
+                    } else {
+                        body = converter.toBody(value);
+                    }
+                    break;
+                case URL:
+                    //No there is no uri support, just a simple string
+                    this.overrideAbsoluteUrl = (String) value;
+                    this.relativeUrl = overrideAbsoluteUrl;
+                    break;
+                default:
+                    throw new IllegalArgumentException("Unknown parameter usage: " + paramUsage);
+            }
+        }
+    }
 
-  @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false);
-  }
+    Request build() throws UnsupportedEncodingException {
 
-  void addQueryParam(String name, String value, boolean urlEncodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Query param name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
-    }
-    try {
-      if (urlEncodeValue) {
-        value = URLEncoder.encode(String.valueOf(value), "UTF-8");
-      }
-      StringBuilder queryParams = this.queryParams;
-      queryParams.append(queryParams.length() > 0 ? '&' : '?');
-      queryParams.append(name).append('=').append(value);
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
-    }
-  }
+        if (multipartBody != null && multipartBody.getPartCount() == 0) {
+            throw new IllegalStateException("Multipart requests must contain at least one part.");
+        }
 
-  void setArguments(Object[] args) {
-    if (args == null) {
-      return;
-    }
-    int count = args.length;
-    if (!isSynchronous && !isObservable) {
-      count -= 1;
-    }
-    for (int i = 0; i < count; i++) {
-      String name = paramNames[i];
-      Object value = args[i];
-      RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
-      switch (paramUsage) {
-        case PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                "Path parameter \"" + name + "\" value must not be null.");
-          }
-          addPathParam(name, value.toString());
-          break;
-        case ENCODED_PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                "Path parameter \"" + name + "\" value must not be null.");
-          }
-          addEncodedPathParam(name, value.toString());
-          break;
-        case QUERY:
-          if (value != null) { // Skip null values.
-            addQueryParam(name, value.toString());
-          }
-          break;
-        case ENCODED_QUERY:
-          if (value != null) { // Skip null values.
-            addEncodedQueryParam(name, value.toString());
-          }
-          break;
-        case HEADER:
-          if (value != null) { // Skip null values.
-            addHeader(name, value.toString());
-          }
-          break;
-        case FIELD:
-          if (value != null) { // Skip null values.
-            formBody.addField(name, value.toString());
-          }
-          break;
-        case PART:
-          if (value != null) { // Skip null values.
-            if (value instanceof TypedOutput) {
-              multipartBody.addPart(name, (TypedOutput) value);
-            } else if (value instanceof String) {
-              multipartBody.addPart(name, new TypedString((String) value));
-            } else {
-              multipartBody.addPart(name, converter.toBody(value));
+        if (overrideAbsoluteUrl != null) {
+            //Override it
+            StringBuilder url = new StringBuilder(overrideAbsoluteUrl);
+            if (queryParams.length() > 0) {
+                url.append(queryParams);
             }
-          }
-          break;
-        case BODY:
-          if (value == null) {
-            throw new IllegalArgumentException("Body parameter value must not be null.");
-          }
-          if (value instanceof TypedOutput) {
-            body = (TypedOutput) value;
-          } else {
-            body = converter.toBody(value);
-          }
-          break;
-        default:
-          throw new IllegalArgumentException("Unknown parameter usage: " + paramUsage);
-      }
-    }
-  }
+            return new Request(requestMethod, url.toString(), headers, body);
+        }
 
-  Request build() throws UnsupportedEncodingException {
-    String apiUrl = this.apiUrl;
+        String apiUrl = this.apiUrl;
 
-    StringBuilder url = new StringBuilder(apiUrl);
-    if (apiUrl.endsWith("/")) {
-      // We require relative paths to start with '/'. Prevent a double-slash.
-      url.deleteCharAt(url.length() - 1);
-    }
+        StringBuilder url = new StringBuilder(apiUrl);
+        if (apiUrl.endsWith("/")) {
+            // We require relative paths to start with '/'. Prevent a double-slash.
+            url.deleteCharAt(url.length() - 1);
+        }
 
-    url.append(relativeUrl);
+        url.append(relativeUrl);
 
-    StringBuilder queryParams = this.queryParams;
-    if (queryParams.length() > 0) {
-      url.append(queryParams);
-    }
+        StringBuilder queryParams = this.queryParams;
+        if (queryParams.length() > 0) {
+            url.append(queryParams);
+        }
 
-    if (multipartBody != null && multipartBody.getPartCount() == 0) {
-      throw new IllegalStateException("Multipart requests must contain at least one part.");
+        return new Request(requestMethod, url.toString(), headers, body);
     }
-
-    return new Request(requestMethod, url.toString(), headers, body);
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index 7ba93689c..a1f471ba8 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import retrofit.http.Body;
 import retrofit.http.EncodedPath;
 import retrofit.http.EncodedQuery;
@@ -38,423 +39,444 @@
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.RestMethod;
+import retrofit.http.Url;
 import rx.Observable;
 
-/** Request metadata about a service interface declaration. */
+/**
+ * Request metadata about a service interface declaration.
+ */
 final class RestMethodInfo {
 
-  private enum ResponseType {
-    VOID,
-    OBSERVABLE,
-    OBJECT
-  }
-
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-  enum ParamUsage {
-    PATH, ENCODED_PATH, QUERY, ENCODED_QUERY, FIELD, PART, BODY, HEADER
-  }
-
-  enum RequestType {
-    /** No content-specific logic required. */
-    SIMPLE,
-    /** Multi-part request body. */
-    MULTIPART,
-    /** Form URL-encoded request body. */
-    FORM_URL_ENCODED
-  }
-
-  final Method method;
-
-  boolean loaded = false;
-
-  // Method-level details
-  final ResponseType responseType;
-  final boolean isSynchronous;
-  final boolean isObservable;
-  Type responseObjectType;
-  RequestType requestType = RequestType.SIMPLE;
-  String requestMethod;
-  boolean requestHasBody;
-  String requestUrl;
-  Set<String> requestUrlParamNames;
-  String requestQuery;
-  List<retrofit.client.Header> headers;
-
-  // Parameter-level details
-  String[] requestParamNames;
-  ParamUsage[] requestParamUsage;
-
-  RestMethodInfo(Method method) {
-    this.method = method;
-    responseType = parseResponseType();
-    isSynchronous = (responseType == ResponseType.OBJECT);
-    isObservable = (responseType == ResponseType.OBSERVABLE);
-  }
-
-  synchronized void init() {
-    if (loaded) return;
-
-    parseMethodAnnotations();
-    parseParameters();
-
-    loaded = true;
-  }
-
-  /** Loads {@link #requestMethod} and {@link #requestType}. */
-  private void parseMethodAnnotations() {
-    for (Annotation methodAnnotation : method.getAnnotations()) {
-      Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
-      RestMethod methodInfo = null;
-
-      // Look for a @RestMethod annotation on the parameter annotation indicating request method.
-      for (Annotation innerAnnotation : annotationType.getAnnotations()) {
-        if (RestMethod.class == innerAnnotation.annotationType()) {
-          methodInfo = (RestMethod) innerAnnotation;
-          break;
-        }
-      }
-
-      if (methodInfo != null) {
-        if (requestMethod != null) {
-          throw new IllegalArgumentException("Method "
-              + method.getName()
-              + " contains multiple HTTP methods. Found: "
-              + requestMethod
-              + " and "
-              + methodInfo.value());
-        }
-        String path;
-        try {
-          path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
-        } catch (Exception e) {
-          throw new RuntimeException("Failed to extract path from "
-              + annotationType.getSimpleName()
-              + " annotation on "
-              + method.getName()
-              + ".", e);
-        }
-        parsePath(path);
-        requestMethod = methodInfo.value();
-        requestHasBody = methodInfo.hasBody();
-      } else if (annotationType == Headers.class) {
-        String[] headersToParse = ((Headers) methodAnnotation).value();
-        if (headersToParse.length == 0) {
-          throw new IllegalStateException("Headers annotation was empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotationType == Multipart.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw new IllegalStateException(
-              "Only one encoding annotation per method is allowed: " + method.getName());
-        }
-        requestType = RequestType.MULTIPART;
-      } else if (annotationType == FormUrlEncoded.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw new IllegalStateException(
-              "Only one encoding annotation per method is allowed: " + method.getName());
-        }
-        requestType = RequestType.FORM_URL_ENCODED;
-      }
+    private enum ResponseType {
+        VOID,
+        OBSERVABLE,
+        OBJECT
     }
 
-    if (requestMethod == null) {
-      throw new IllegalStateException(
-          "Method " + method.getName() + " not annotated with request type (e.g., GET, POST).");
-    }
-    if (!requestHasBody) {
-      if (requestType == RequestType.MULTIPART) {
-        throw new IllegalStateException(
-            "Multipart can only be specified on HTTP methods with request body (e.g., POST). ("
-                + method.getName()
-                + ")");
-      }
-      if (requestType == RequestType.FORM_URL_ENCODED) {
-        throw new IllegalStateException(
-            "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., POST). ("
-                + method.getName()
-                + ")");
-      }
-    }
-  }
-
-  /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
-  private void parsePath(String path) {
-    if (path == null || path.length() == 0 || path.charAt(0) != '/') {
-      throw new IllegalArgumentException("URL path \""
-          + path
-          + "\" on method "
-          + method.getName()
-          + " must start with '/'. ("
-          + method.getName()
-          + ")");
-    }
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-    // Get the relative URL path and existing query string, if present.
-    String url = path;
-    String query = null;
-    int question = path.indexOf('?');
-    if (question != -1 && question < path.length() - 1) {
-      url = path.substring(0, question);
-      query = path.substring(question + 1);
-
-      // Ensure the query string does not have any named parameters.
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
-      if (queryParamMatcher.find()) {
-        throw new IllegalStateException("URL query string \""
-            + query
-            + "\" on method "
-            + method.getName()
-            + " may not have replace block.");
-      }
+    enum ParamUsage {
+        PATH, ENCODED_PATH, QUERY, ENCODED_QUERY, FIELD, PART, BODY, HEADER, URL
     }
 
-    Set<String> urlParams = parsePathParameters(path);
-
-    requestUrl = url;
-    requestUrlParamNames = urlParams;
-    requestQuery = query;
-  }
-
-  private List<retrofit.client.Header> parseHeaders(String[] headers) {
-    List<retrofit.client.Header> headerList = new ArrayList<retrofit.client.Header>();
-    for (String header : headers) {
-      int colon = header.indexOf(':');
-      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw new IllegalStateException(
-            "Header must be in the form \"Name: Value\": \"" + header + "\"");
-      }
-      headerList.add(new retrofit.client.Header(header.substring(0, colon),
-          header.substring(colon + 1).trim()));
+    enum RequestType {
+        /**
+         * No content-specific logic required.
+         */
+        SIMPLE,
+        /**
+         * Multi-part request body.
+         */
+        MULTIPART,
+        /**
+         * Form URL-encoded request body.
+         */
+        FORM_URL_ENCODED
     }
-    return headerList;
-  }
-
-  /** Loads {@link #responseObjectType}. Returns {@code true} if method is synchronous. */
-  private ResponseType parseResponseType() {
-    // Synchronous methods have a non-void return type.
-    // Observable methods have a return type of Observable.
-    Type returnType = method.getGenericReturnType();
-
-    // Asynchronous methods should have a Callback type as the last argument.
-    Type lastArgType = null;
-    Class<?> lastArgClass = null;
-    Type[] parameterTypes = method.getGenericParameterTypes();
-    if (parameterTypes.length > 0) {
-      Type typeToCheck = parameterTypes[parameterTypes.length - 1];
-      lastArgType = typeToCheck;
-      if (typeToCheck instanceof ParameterizedType) {
-        typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
-      }
-      if (typeToCheck instanceof Class) {
-        lastArgClass = (Class<?>) typeToCheck;
-      }
+
+    final Method method;
+
+    boolean loaded = false;
+
+    // Method-level details
+    final ResponseType responseType;
+    final boolean isSynchronous;
+    final boolean isObservable;
+    Type responseObjectType;
+    RequestType requestType = RequestType.SIMPLE;
+    String requestMethod;
+    boolean requestHasBody;
+    String requestUrl;
+    Set<String> requestUrlParamNames;
+    String requestQuery;
+    List<retrofit.client.Header> headers;
+
+    // Parameter-level details
+    String[] requestParamNames;
+    ParamUsage[] requestParamUsage;
+
+    RestMethodInfo(Method method) {
+        this.method = method;
+        responseType = parseResponseType();
+        isSynchronous = (responseType == ResponseType.OBJECT);
+        isObservable = (responseType == ResponseType.OBSERVABLE);
     }
 
-    boolean hasReturnType = returnType != void.class;
-    boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
+    synchronized void init() {
+        if (loaded) return;
 
-    // Check for invalid configurations.
-    if (hasReturnType && hasCallback) {
-      throw new IllegalArgumentException("Method "
-          + method.getName()
-          + " may only have return type or Callback as last argument, not both.");
-    }
-    if (!hasReturnType && !hasCallback) {
-      throw new IllegalArgumentException("Method "
-          + method.getName()
-          + " must have either a return type or Callback as last argument.");
+        parseMethodAnnotations();
+        parseParameters();
+
+        loaded = true;
     }
 
-    if (hasReturnType) {
-      if (Platform.HAS_RX_JAVA) {
-        Class rawReturnType = Types.getRawType(returnType);
-        if (RxSupport.isObservable(rawReturnType)) {
-          returnType = RxSupport.getObservableType(returnType, rawReturnType);
-          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
-          return ResponseType.OBSERVABLE;
+    /**
+     * Loads {@link #requestMethod} and {@link #requestType}.
+     */
+    private void parseMethodAnnotations() {
+        for (Annotation methodAnnotation : method.getAnnotations()) {
+            Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
+            RestMethod methodInfo = null;
+
+            // Look for a @RestMethod annotation on the parameter annotation indicating request method.
+            for (Annotation innerAnnotation : annotationType.getAnnotations()) {
+                if (RestMethod.class == innerAnnotation.annotationType()) {
+                    methodInfo = (RestMethod) innerAnnotation;
+                    break;
+                }
+            }
+
+            if (methodInfo != null) {
+                if (requestMethod != null) {
+                    throw new IllegalArgumentException("Method "
+                            + method.getName()
+                            + " contains multiple HTTP methods. Found: "
+                            + requestMethod
+                            + " and "
+                            + methodInfo.value());
+                }
+                String path;
+                try {
+                    path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
+                } catch (Exception e) {
+                    throw new RuntimeException("Failed to extract path from "
+                            + annotationType.getSimpleName()
+                            + " annotation on "
+                            + method.getName()
+                            + ".", e);
+                }
+                parsePath(path);
+                requestMethod = methodInfo.value();
+                requestHasBody = methodInfo.hasBody();
+            } else if (annotationType == Headers.class) {
+                String[] headersToParse = ((Headers) methodAnnotation).value();
+                if (headersToParse.length == 0) {
+                    throw new IllegalStateException("Headers annotation was empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotationType == Multipart.class) {
+                if (requestType != RequestType.SIMPLE) {
+                    throw new IllegalStateException(
+                            "Only one encoding annotation per method is allowed: " + method.getName());
+                }
+                requestType = RequestType.MULTIPART;
+            } else if (annotationType == FormUrlEncoded.class) {
+                if (requestType != RequestType.SIMPLE) {
+                    throw new IllegalStateException(
+                            "Only one encoding annotation per method is allowed: " + method.getName());
+                }
+                requestType = RequestType.FORM_URL_ENCODED;
+            }
         }
-      }
-      responseObjectType = returnType;
-      return ResponseType.OBJECT;
-    }
 
-    lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
-    if (lastArgType instanceof ParameterizedType) {
-      responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
-      return ResponseType.VOID;
+        if (requestMethod == null) {
+            throw new IllegalStateException(
+                    "Method " + method.getName() + " not annotated with request type (e.g., GET, POST).");
+        }
+        if (!requestHasBody) {
+            if (requestType == RequestType.MULTIPART) {
+                throw new IllegalStateException(
+                        "Multipart can only be specified on HTTP methods with request body (e.g., POST). ("
+                                + method.getName()
+                                + ")");
+            }
+            if (requestType == RequestType.FORM_URL_ENCODED) {
+                throw new IllegalStateException(
+                        "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., POST). ("
+                                + method.getName()
+                                + ")");
+            }
+        }
     }
 
-    throw new IllegalArgumentException("Last parameter of "
-        + method.getName()
-        + " must be of type Callback<X> or Callback<? super X>. Found: "
-        + lastArgType);
-  }
+    /**
+     * Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}.
+     */
+    private void parsePath(String path) {
+        if (path == null || path.length() == 0 || path.charAt(0) != '/') {
+            throw new IllegalArgumentException("URL path \""
+                    + path
+                    + "\" on method "
+                    + method.getName()
+                    + " must start with '/'. ("
+                    + method.getName()
+                    + ")");
+        }
 
+        // Get the relative URL path and existing query string, if present.
+        String url = path;
+        String query = null;
+        int question = path.indexOf('?');
+        if (question != -1 && question < path.length() - 1) {
+            url = path.substring(0, question);
+            query = path.substring(question + 1);
+
+            // Ensure the query string does not have any named parameters.
+            Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
+            if (queryParamMatcher.find()) {
+                throw new IllegalStateException("URL query string \""
+                        + query
+                        + "\" on method "
+                        + method.getName()
+                        + " may not have replace block.");
+            }
+        }
 
-  private static Type getParameterUpperBound(ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    for (int i = 0; i < types.length; i++) {
-      Type paramType = types[i];
-      if (paramType instanceof WildcardType) {
-        types[i] = ((WildcardType) paramType).getUpperBounds()[0];
-      }
-    }
-    return types[0];
-  }
-
-  /**
-   * Loads {@link #requestParamNames} and {@link #requestParamUsage}. Must be called after
-   * {@link #parseMethodAnnotations()}.
-   */
-  private void parseParameters() {
-    Class<?>[] parameterTypes = method.getParameterTypes();
-
-    Annotation[][] parameterAnnotationArrays = method.getParameterAnnotations();
-    int count = parameterAnnotationArrays.length;
-    if (!isSynchronous && !isObservable) {
-      count -= 1; // Callback is last argument when not a synchronous method.
+        Set<String> urlParams = parsePathParameters(path);
+
+        requestUrl = url;
+        requestUrlParamNames = urlParams;
+        requestQuery = query;
     }
 
-    String[] paramNames = new String[count];
-    requestParamNames = paramNames;
-    ParamUsage[] paramUsage = new ParamUsage[count];
-    requestParamUsage = paramUsage;
-
-    boolean gotField = false;
-    boolean gotPart = false;
-    boolean gotBody = false;
-
-    for (int i = 0; i < count; i++) {
-      Class<?> parameterType = parameterTypes[i];
-      Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
-      if (parameterAnnotations != null) {
-        for (Annotation parameterAnnotation : parameterAnnotations) {
-          Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
-
-          if (annotationType == Path.class) {
-            String name = ((Path) parameterAnnotation).value();
-            validatePathName(name);
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.PATH;
-          } else if (annotationType == EncodedPath.class) {
-            String name = ((EncodedPath) parameterAnnotation).value();
-            validatePathName(name);
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.ENCODED_PATH;
-          } else if (annotationType == Query.class) {
-            String name = ((Query) parameterAnnotation).value();
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.QUERY;
-          } else if (annotationType == EncodedQuery.class) {
-            String name = ((EncodedQuery) parameterAnnotation).value();
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.ENCODED_QUERY;
-          } else if (annotationType == Header.class) {
-            String name = ((Header) parameterAnnotation).value();
-            if (parameterType != String.class) {
-              throw new IllegalStateException("@Header parameter type must be String: " + name);
+    private List<retrofit.client.Header> parseHeaders(String[] headers) {
+        List<retrofit.client.Header> headerList = new ArrayList<retrofit.client.Header>();
+        for (String header : headers) {
+            int colon = header.indexOf(':');
+            if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                throw new IllegalStateException(
+                        "Header must be in the form \"Name: Value\": \"" + header + "\"");
             }
+            headerList.add(new retrofit.client.Header(header.substring(0, colon),
+                    header.substring(colon + 1).trim()));
+        }
+        return headerList;
+    }
 
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.HEADER;
-          } else if (annotationType == Field.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw new IllegalStateException(
-                  "@Field parameters can only be used with form encoding.");
+    /**
+     * Loads {@link #responseObjectType}. Returns {@code true} if method is synchronous.
+     */
+    private ResponseType parseResponseType() {
+        // Synchronous methods have a non-void return type.
+        // Observable methods have a return type of Observable.
+        Type returnType = method.getGenericReturnType();
+
+        // Asynchronous methods should have a Callback type as the last argument.
+        Type lastArgType = null;
+        Class<?> lastArgClass = null;
+        Type[] parameterTypes = method.getGenericParameterTypes();
+        if (parameterTypes.length > 0) {
+            Type typeToCheck = parameterTypes[parameterTypes.length - 1];
+            lastArgType = typeToCheck;
+            if (typeToCheck instanceof ParameterizedType) {
+                typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
             }
+            if (typeToCheck instanceof Class) {
+                lastArgClass = (Class<?>) typeToCheck;
+            }
+        }
 
-            String name = ((Field) parameterAnnotation).value();
+        boolean hasReturnType = returnType != void.class;
+        boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
+
+        // Check for invalid configurations.
+        if (hasReturnType && hasCallback) {
+            throw new IllegalArgumentException("Method "
+                    + method.getName()
+                    + " may only have return type or Callback as last argument, not both.");
+        }
+        if (!hasReturnType && !hasCallback) {
+            throw new IllegalArgumentException("Method "
+                    + method.getName()
+                    + " must have either a return type or Callback as last argument.");
+        }
 
-            gotField = true;
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.FIELD;
-          } else if (annotationType == Part.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw new IllegalStateException(
-                  "@Part parameters can only be used with multipart encoding.");
+        if (hasReturnType) {
+            if (Platform.HAS_RX_JAVA) {
+                Class rawReturnType = Types.getRawType(returnType);
+                if (RxSupport.isObservable(rawReturnType)) {
+                    returnType = RxSupport.getObservableType(returnType, rawReturnType);
+                    responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
+                    return ResponseType.OBSERVABLE;
+                }
             }
+            responseObjectType = returnType;
+            return ResponseType.OBJECT;
+        }
+
+        lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
+        if (lastArgType instanceof ParameterizedType) {
+            responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
+            return ResponseType.VOID;
+        }
 
-            String name = ((Part) parameterAnnotation).value();
+        throw new IllegalArgumentException("Last parameter of "
+                + method.getName()
+                + " must be of type Callback<X> or Callback<? super X>. Found: "
+                + lastArgType);
+    }
 
-            gotPart = true;
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.PART;
-          } else if (annotationType == Body.class) {
-            if (requestType != RequestType.SIMPLE) {
-              throw new IllegalStateException(
-                  "@Body parameters cannot be used with form or multi-part encoding.");
+
+    private static Type getParameterUpperBound(ParameterizedType type) {
+        Type[] types = type.getActualTypeArguments();
+        for (int i = 0; i < types.length; i++) {
+            Type paramType = types[i];
+            if (paramType instanceof WildcardType) {
+                types[i] = ((WildcardType) paramType).getUpperBounds()[0];
             }
-            if (gotBody) {
-              throw new IllegalStateException(
-                  "Method annotated with multiple Body method annotations: " + method);
+        }
+        return types[0];
+    }
+
+    /**
+     * Loads {@link #requestParamNames} and {@link #requestParamUsage}. Must be called after
+     * {@link #parseMethodAnnotations()}.
+     */
+    private void parseParameters() {
+        Class<?>[] parameterTypes = method.getParameterTypes();
+
+        Annotation[][] parameterAnnotationArrays = method.getParameterAnnotations();
+        int count = parameterAnnotationArrays.length;
+        if (!isSynchronous && !isObservable) {
+            count -= 1; // Callback is last argument when not a synchronous method.
+        }
+
+        String[] paramNames = new String[count];
+        requestParamNames = paramNames;
+        ParamUsage[] paramUsage = new ParamUsage[count];
+        requestParamUsage = paramUsage;
+
+        boolean gotField = false;
+        boolean gotPart = false;
+        boolean gotBody = false;
+
+        for (int i = 0; i < count; i++) {
+            Class<?> parameterType = parameterTypes[i];
+            Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
+            if (parameterAnnotations != null) {
+                for (Annotation parameterAnnotation : parameterAnnotations) {
+                    Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
+
+                    if (annotationType == Url.class) {
+                        paramNames[i] = "";
+                        paramUsage[i] = ParamUsage.URL;
+                    }
+                    if (annotationType == Path.class) {
+                        String name = ((Path) parameterAnnotation).value();
+                        validatePathName(name);
+
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.PATH;
+                    } else if (annotationType == EncodedPath.class) {
+                        String name = ((EncodedPath) parameterAnnotation).value();
+                        validatePathName(name);
+
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.ENCODED_PATH;
+                    } else if (annotationType == Query.class) {
+                        String name = ((Query) parameterAnnotation).value();
+
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.QUERY;
+                    } else if (annotationType == EncodedQuery.class) {
+                        String name = ((EncodedQuery) parameterAnnotation).value();
+
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.ENCODED_QUERY;
+                    } else if (annotationType == Header.class) {
+                        String name = ((Header) parameterAnnotation).value();
+                        if (parameterType != String.class) {
+                            throw new IllegalStateException("@Header parameter type must be String: " + name);
+                        }
+
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.HEADER;
+                    } else if (annotationType == Field.class) {
+                        if (requestType != RequestType.FORM_URL_ENCODED) {
+                            throw new IllegalStateException(
+                                    "@Field parameters can only be used with form encoding.");
+                        }
+
+                        String name = ((Field) parameterAnnotation).value();
+
+                        gotField = true;
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.FIELD;
+                    } else if (annotationType == Part.class) {
+                        if (requestType != RequestType.MULTIPART) {
+                            throw new IllegalStateException(
+                                    "@Part parameters can only be used with multipart encoding.");
+                        }
+
+                        String name = ((Part) parameterAnnotation).value();
+
+                        gotPart = true;
+                        paramNames[i] = name;
+                        paramUsage[i] = ParamUsage.PART;
+                    } else if (annotationType == Body.class) {
+                        if (requestType != RequestType.SIMPLE) {
+                            throw new IllegalStateException(
+                                    "@Body parameters cannot be used with form or multi-part encoding.");
+                        }
+                        if (gotBody) {
+                            throw new IllegalStateException(
+                                    "Method annotated with multiple Body method annotations: " + method);
+                        }
+
+                        gotBody = true;
+                        paramUsage[i] = ParamUsage.BODY;
+                    }
+                }
             }
 
-            gotBody = true;
-            paramUsage[i] = ParamUsage.BODY;
-          }
+            if (paramUsage[i] == null) {
+                throw new IllegalStateException(
+                        "No Retrofit annotation found on parameter " + (i + 1) + " of " + method.getName());
+            }
         }
-      }
 
-      if (paramUsage[i] == null) {
-        throw new IllegalStateException(
-            "No Retrofit annotation found on parameter " + (i + 1) + " of " + method.getName());
-      }
+        if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
+            throw new IllegalStateException("Non-body HTTP method cannot contain @Body or @TypedOutput.");
+        }
+        if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
+            throw new IllegalStateException("Form-encoded method must contain at least one @Field.");
+        }
+        if (requestType == RequestType.MULTIPART && !gotPart) {
+            throw new IllegalStateException("Multipart method must contain at least one @Part.");
+        }
     }
 
-    if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
-      throw new IllegalStateException("Non-body HTTP method cannot contain @Body or @TypedOutput.");
-    }
-    if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
-      throw new IllegalStateException("Form-encoded method must contain at least one @Field.");
-    }
-    if (requestType == RequestType.MULTIPART && !gotPart) {
-      throw new IllegalStateException("Multipart method must contain at least one @Part.");
-    }
-  }
-
-  private void validatePathName(String name) {
-    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw new IllegalStateException("Path parameter name is not valid: "
-          + name
-          + ". Must match "
-          + PARAM_URL_REGEX.pattern());
-    }
-    // Verify URL replacement name is actually present in the URL path.
-    if (!requestUrlParamNames.contains(name)) {
-      throw new IllegalStateException(
-          "Method URL \"" + requestUrl + "\" does not contain {" + name + "}.");
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<String>();
-    while (m.find()) {
-      patterns.add(m.group(1));
+    private void validatePathName(String name) {
+        if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+            throw new IllegalStateException("Path parameter name is not valid: "
+                    + name
+                    + ". Must match "
+                    + PARAM_URL_REGEX.pattern());
+        }
+        // Verify URL replacement name is actually present in the URL path.
+        if (!requestUrlParamNames.contains(name)) {
+            throw new IllegalStateException(
+                    "Method URL \"" + requestUrl + "\" does not contain {" + name + "}.");
+        }
     }
-    return patterns;
-  }
 
-  /** Indirection to avoid log complaints if RxJava isn't present. */
-  private static final class RxSupport {
-    public static boolean isObservable(Class rawType) {
-      return rawType == Observable.class;
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+        Matcher m = PARAM_URL_REGEX.matcher(path);
+        Set<String> patterns = new LinkedHashSet<String>();
+        while (m.find()) {
+            patterns.add(m.group(1));
+        }
+        return patterns;
     }
 
-    public static Type getObservableType(Type contextType, Class contextRawType) {
-      return Types.getSupertype(contextType, contextRawType, Observable.class);
+    /**
+     * Indirection to avoid log complaints if RxJava isn't present.
+     */
+    private static final class RxSupport {
+        public static boolean isObservable(Class rawType) {
+            return rawType == Observable.class;
+        }
+
+        public static Type getObservableType(Type contextType, Class contextRawType) {
+            return Types.getSupertype(contextType, contextRawType, Observable.class);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Url.java b/retrofit/src/main/java/retrofit/http/Url.java
new file mode 100644
index 000000000..c6179955f
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Url.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * This will override the endpoint with the absolute url given as this param
+ * so magicMethod(@Url "http://...")
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(PARAMETER)
+public @interface Url {
+}
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 67fa3cf1f..95cd03877 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -1,6 +1,12 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -9,11 +15,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Executor;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
+
 import retrofit.client.Client;
 import retrofit.client.Header;
 import retrofit.client.Request;
@@ -24,6 +26,7 @@
 import retrofit.http.Headers;
 import retrofit.http.POST;
 import retrofit.http.Path;
+import retrofit.http.Url;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
 import retrofit.mime.TypedString;
@@ -52,518 +55,582 @@
 import static retrofit.Utils.SynchronousExecutor;
 
 public class RestAdapterTest {
-  private static final List<Header> NO_HEADERS = Collections.emptyList();
-  private static final List<Header> TWO_HEADERS =
-      Arrays.asList(new Header("Content-Type", "application/json"),
-          new Header("Content-Length", "42"));
-
-  /** Not all servers play nice and add content-type headers to responses. */
-  private static final TypedInput NO_MIME_BODY = new TypedInput() {
-    @Override public String mimeType() {
-      return null;
+    private static final List<Header> NO_HEADERS = Collections.emptyList();
+    private static final List<Header> TWO_HEADERS =
+            Arrays.asList(new Header("Content-Type", "application/json"),
+                    new Header("Content-Length", "42"));
+
+    /**
+     * Not all servers play nice and add content-type headers to responses.
+     */
+    private static final TypedInput NO_MIME_BODY = new TypedInput() {
+        @Override
+        public String mimeType() {
+            return null;
+        }
+
+        @Override
+        public long length() {
+            return 2;
+        }
+
+        @Override
+        public InputStream in() throws IOException {
+            return new ByteArrayInputStream("{}".getBytes("UTF-8"));
+        }
+    };
+
+    private interface Example {
+        @Headers("Foo: Bar")
+        @GET("/")
+        Object something();
+
+        @Headers("Foo: Bar")
+        @POST("/")
+        Object something(@Body TypedOutput body);
+
+        @GET("/")
+        void something(Callback<Object> callback);
+
+        @GET("/")
+        Response direct();
+
+        @GET("/")
+        void direct(Callback<Response> callback);
+
+        @POST("/")
+        Observable<String> observable(@Body String body);
+
+        @POST("/{x}/{y}")
+        Observable<Response> observable(@Path("x") String x, @Path("y") String y);
+
+        @GET("/")
+        Observable<Response> observableAbsolute(@Url String absoluteUrl);
     }
 
-    @Override public long length() {
-      return 2;
+    private interface InvalidExample extends Example {
     }
 
-    @Override public InputStream in() throws IOException {
-      return new ByteArrayInputStream("{}".getBytes("UTF-8"));
+    private Client mockClient;
+    private Executor mockRequestExecutor;
+    private Executor mockCallbackExecutor;
+    private Profiler<Object> mockProfiler;
+    private Example example;
+
+    @SuppressWarnings("unchecked") // Mock profiler type erasure.
+    @Before
+    public void setUp() throws Exception {
+        mockClient = mock(Client.class);
+        mockRequestExecutor = spy(new SynchronousExecutor());
+        mockCallbackExecutor = spy(new SynchronousExecutor());
+        mockProfiler = mock(Profiler.class);
+
+        example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .build()
+                .create(Example.class);
     }
-  };
-
-  private interface Example {
-    @Headers("Foo: Bar")
-    @GET("/") Object something();
-    @Headers("Foo: Bar")
-    @POST("/") Object something(@Body TypedOutput body);
-    @GET("/") void something(Callback<Object> callback);
-    @GET("/") Response direct();
-    @GET("/") void direct(Callback<Response> callback);
-    @POST("/") Observable<String> observable(@Body String body);
-    @POST("/{x}/{y}") Observable<Response> observable(@Path("x") String x, @Path("y") String y);
-  }
-  private interface InvalidExample extends Example {
-  }
-
-  private Client mockClient;
-  private Executor mockRequestExecutor;
-  private Executor mockCallbackExecutor;
-  private Profiler<Object> mockProfiler;
-  private Example example;
-
-  @SuppressWarnings("unchecked") // Mock profiler type erasure.
-  @Before public void setUp() throws Exception{
-    mockClient = mock(Client.class);
-    mockRequestExecutor = spy(new SynchronousExecutor());
-    mockCallbackExecutor = spy(new SynchronousExecutor());
-    mockProfiler = mock(Profiler.class);
-
-    example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .build()
-        .create(Example.class);
-  }
-
-  @Test public void objectMethodsStillWork() {
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    try {
-      new RestAdapter.Builder().setServer("http://foo/").build().create(InvalidExample.class);
-      fail("Interface inheritance should not be supported.");
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+
+    @Test
+    public void objectMethodsStillWork() {
+        assertThat(example.hashCode()).isNotZero();
+        assertThat(example.equals(this)).isFalse();
+        assertThat(example.toString()).isNotEmpty();
     }
-  }
-
-  @Test public void profilerObjectPassThrough() throws Exception {
-    Object data = new Object();
-    when(mockProfiler.beforeCall()).thenReturn(data);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, null));
-
-    example.something();
-
-    verify(mockProfiler).beforeCall();
-    verify(mockClient).execute(any(Request.class));
-    verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
-  }
-
-  @Test public void logRequestResponseBasic() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(BASIC)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something();
-    assertThat(logMessages).hasSize(2);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-  }
-
-  @Test public void logRequestResponseHeaders() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void interfaceWithExtendIsNotSupported() {
+        try {
+            new RestAdapter.Builder().setServer("http://foo/").build().create(InvalidExample.class);
+            fail("Interface inheritance should not be supported.");
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+        }
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(HEADERS)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something();
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenResponseBodyPresent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void profilerObjectPassThrough() throws Exception {
+        Object data = new Object();
+        when(mockProfiler.beforeCall()).thenReturn(data);
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, null));
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something(new TypedString("Hi"));
-    assertThat(logMessages).hasSize(13);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP POST http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("Content-Type: text/plain; charset=UTF-8");
-    assertThat(logMessages.get(3)).isEqualTo("Content-Length: 2");
-    assertThat(logMessages.get(4)).isEqualTo("");
-    assertThat(logMessages.get(5)).isEqualTo("Hi");
-    assertThat(logMessages.get(6)).isEqualTo("---> END HTTP (2-byte body)");
-    assertThat(logMessages.get(7)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(8)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(9)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(10)).isEqualTo("");
-    assertThat(logMessages.get(11)).isEqualTo("{}");
-    assertThat(logMessages.get(12)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+        example.something();
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", TWO_HEADERS, null));
-
-    example.something();
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenMimeTypeMissing() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+        verify(mockProfiler).beforeCall();
+        verify(mockClient).execute(any(Request.class));
+        verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", TWO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-    assertThat(logMessages).hasSize(9);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("");
-    assertThat(logMessages.get(7)).isEqualTo("{}");
-    assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void synchronousDoesNotUseExecutors() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, null));
-
-    example.something();
-
-    verifyZeroInteractions(mockRequestExecutor);
-    verifyZeroInteractions(mockCallbackExecutor);
-  }
-
-  @Test public void asynchronousUsesExecutors() throws Exception {
-    Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
-    when(mockClient.execute(any(Request.class))).thenReturn(response);
-    Callback<Object> callback = mock(Callback.class);
-
-    example.something(callback);
-
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(anyString(), same(response));
-  }
-
-  @Test public void malformedResponseThrowsConversionException() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("{")));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on malformed response body.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(200);
-      assertThat(e.getCause()).isInstanceOf(ConversionException.class);
-      assertThat(e.getResponse().getBody()).isNull();
+    @Test
+    public void logRequestResponseBasic() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(BASIC)
+                .build()
+                .create(Example.class);
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
+
+        example.something();
+        assertThat(logMessages).hasSize(2);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
     }
-  }
 
-  @Test public void errorResponseThrowsHttpError() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(500, "Internal Server Error", NO_HEADERS, null));
+    @Test
+    public void logRequestResponseHeaders() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(HEADERS)
+                .build()
+                .create(Example.class);
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
+
+        example.something();
+        assertThat(logMessages).hasSize(7);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (2-byte body)");
+    }
 
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+    @Test
+    public void logSuccessfulRequestResponseFullWhenResponseBodyPresent() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(FULL)
+                .build()
+                .create(Example.class);
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
+
+        example.something(new TypedString("Hi"));
+        assertThat(logMessages).hasSize(13);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP POST http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("Content-Type: text/plain; charset=UTF-8");
+        assertThat(logMessages.get(3)).isEqualTo("Content-Length: 2");
+        assertThat(logMessages.get(4)).isEqualTo("");
+        assertThat(logMessages.get(5)).isEqualTo("Hi");
+        assertThat(logMessages.get(6)).isEqualTo("---> END HTTP (2-byte body)");
+        assertThat(logMessages.get(7)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(8)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(9)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(10)).isEqualTo("");
+        assertThat(logMessages.get(11)).isEqualTo("{}");
+        assertThat(logMessages.get(12)).isEqualTo("<--- END HTTP (2-byte body)");
     }
-  }
-
-  @Test public void logErrorRequestResponseFullWhenMimeTypeMissing() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    Response responseMissingMimeType = //
-        new Response(403, "Forbidden", TWO_HEADERS, NO_MIME_BODY);
-
-    when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
-
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(403);
+    @Test
+    public void logSuccessfulRequestResponseFullWhenResponseBodyAbsent() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(FULL)
+                .build()
+                .create(Example.class);
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", TWO_HEADERS, null));
+
+        example.something();
+        assertThat(logMessages).hasSize(7);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
     }
 
-    assertThat(logMessages).hasSize(9);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("");
-    assertThat(logMessages.get(7)).isEqualTo("{}");
-    assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logErrorRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, NO_MIME_BODY));
+
+        example.something();
+    }
+
+    @Test
+    public void logSuccessfulRequestResponseFullWhenMimeTypeMissing() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(FULL)
+                .build()
+                .create(Example.class);
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", TWO_HEADERS, NO_MIME_BODY));
+
+        example.something();
+        assertThat(logMessages).hasSize(9);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("");
+        assertThat(logMessages.get(7)).isEqualTo("{}");
+        assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
+    }
+
+    @Test
+    public void synchronousDoesNotUseExecutors() throws Exception {
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, null));
+
+        example.something();
+
+        verifyZeroInteractions(mockRequestExecutor);
+        verifyZeroInteractions(mockCallbackExecutor);
+    }
+
+    @Test
+    public void asynchronousUsesExecutors() throws Exception {
+        Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        Callback<Object> callback = mock(Callback.class);
+
+        example.something(callback);
+
+        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+        verify(mockCallbackExecutor).execute(any(Runnable.class));
+        verify(callback).success(anyString(), same(response));
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(500, "Internal Server Error", TWO_HEADERS, null));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+    @Test
+    public void malformedResponseThrowsConversionException() throws Exception {
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("{")));
+
+        try {
+            example.something();
+            fail("RetrofitError expected on malformed response body.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(200);
+            assertThat(e.getCause()).isInstanceOf(ConversionException.class);
+            assertThat(e.getResponse().getBody()).isNull();
+        }
     }
 
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-  }
-
-  @Test public void clientExceptionThrowsNetworkError() throws Exception {
-    IOException exception = new IOException("I'm broken!");
-    when(mockClient.execute(any(Request.class))).thenThrow(exception);
-
-    try {
-      example.something();
-      fail("RetrofitError expected when client throws exception.");
-    } catch (RetrofitError e) {
-      assertThat(e.getCause()).isSameAs(exception);
+    @Test
+    public void errorResponseThrowsHttpError() throws Exception {
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(500, "Internal Server Error", NO_HEADERS, null));
+
+        try {
+            example.something();
+            fail("RetrofitError expected on non-2XX response code.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(500);
+        }
     }
-  }
-
-  @Test public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
-    TypedInput body = spy(new TypedString("{}"));
-    InputStream bodyStream = mock(InputStream.class, new Answer() {
-      @Override public Object answer(InvocationOnMock invocation) throws Throwable {
-        throw new IOException("I'm broken!");
-      }
-    });
-    doReturn(bodyStream).when(body).in();
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, body));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on malformed response body.");
-    } catch (RetrofitError e) {
-      assertThat(e.isNetworkError());
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-      assertThat(e.getCause()).hasMessage("I'm broken!");
+
+    @Test
+    public void logErrorRequestResponseFullWhenMimeTypeMissing() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(FULL)
+                .build()
+                .create(Example.class);
+
+        Response responseMissingMimeType = //
+                new Response(403, "Forbidden", TWO_HEADERS, NO_MIME_BODY);
+
+        when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
+
+        try {
+            example.something();
+            fail("RetrofitError expected on non-2XX response code.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(403);
+        }
+
+        assertThat(logMessages).hasSize(9);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("");
+        assertThat(logMessages.get(7)).isEqualTo("{}");
+        assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
+    }
+
+    @Test
+    public void logErrorRequestResponseFullWhenResponseBodyAbsent() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(log)
+                .setLogLevel(FULL)
+                .build()
+                .create(Example.class);
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(500, "Internal Server Error", TWO_HEADERS, null));
+
+        try {
+            example.something();
+            fail("RetrofitError expected on non-2XX response code.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(500);
+        }
+
+        assertThat(logMessages).hasSize(7);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
+    }
+
+    @Test
+    public void clientExceptionThrowsNetworkError() throws Exception {
+        IOException exception = new IOException("I'm broken!");
+        when(mockClient.execute(any(Request.class))).thenThrow(exception);
+
+        try {
+            example.something();
+            fail("RetrofitError expected when client throws exception.");
+        } catch (RetrofitError e) {
+            assertThat(e.getCause()).isSameAs(exception);
+        }
+    }
+
+    @Test
+    public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
+        TypedInput body = spy(new TypedString("{}"));
+        InputStream bodyStream = mock(InputStream.class, new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                throw new IOException("I'm broken!");
+            }
+        });
+        doReturn(bodyStream).when(body).in();
+
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, body));
+
+        try {
+            example.something();
+            fail("RetrofitError expected on malformed response body.");
+        } catch (RetrofitError e) {
+            assertThat(e.isNetworkError());
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+            assertThat(e.getCause()).hasMessage("I'm broken!");
+        }
+    }
+
+    @Test
+    public void unexpectedExceptionThrows() {
+        RuntimeException exception = new RuntimeException("More breakage.");
+        when(mockProfiler.beforeCall()).thenThrow(exception);
+
+        try {
+            example.something();
+            fail("RetrofitError expected when unexpected exception thrown.");
+        } catch (RetrofitError e) {
+            assertThat(e.getCause()).isSameAs(exception);
+        }
     }
-  }
 
-  @Test public void unexpectedExceptionThrows() {
-    RuntimeException exception = new RuntimeException("More breakage.");
-    when(mockProfiler.beforeCall()).thenThrow(exception);
+    @Test
+    public void getResponseDirectly() throws Exception {
+        Response response = new Response(200, "OK", NO_HEADERS, null);
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(response);
+        assertThat(example.direct()).isSameAs(response);
+    }
+
+    @Test
+    public void closeInputStream() throws IOException {
+        // Set logger and profiler on example to make sure we exercise all the code paths.
+        Example example = new RestAdapter.Builder() //
+                .setClient(mockClient)
+                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+                .setServer("http://example.com")
+                .setProfiler(mockProfiler)
+                .setLog(RestAdapter.Log.NONE)
+                .setLogLevel(FULL)
+                .build()
+                .create(Example.class);
+
+        ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
+        TypedInput typedInput = mock(TypedInput.class);
+        when(typedInput.in()).thenReturn(is);
+        Response response = new Response(200, "OK", NO_HEADERS, typedInput);
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(response);
+        example.something();
+        verify(is).close();
+    }
+
+    @Test
+    public void getResponseDirectlyAsync() throws Exception {
+        Response response = new Response(200, "OK", NO_HEADERS, null);
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(response);
+        Callback<Response> callback = mock(Callback.class);
+
+        example.direct(callback);
+
+        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+        verify(mockCallbackExecutor).execute(any(Runnable.class));
+        verify(callback).success(eq(response), same(response));
+    }
+
+    @Test
+    public void observableCallsOnNext() throws Exception {
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
+        Action1<String> action = mock(Action1.class);
+        example.observable("Howdy").subscribe(action);
+        verify(action).call(eq("hello"));
+    }
+
+    @Test
+    public void observableCallsOnError() throws Exception {
+        when(mockClient.execute(any(Request.class))) //
+                .thenReturn(new Response(300, "FAIL", NO_HEADERS, new TypedString("bummer")));
+        Action1<String> onSuccess = mock(Action1.class);
+        Action1<Throwable> onError = mock(Action1.class);
+        example.observable("Howdy").subscribe(onSuccess, onError);
+        verifyZeroInteractions(onSuccess);
+        verify(onError).call(isA(RetrofitError.class));
+    }
+
+    @Test
+    public void observableHandlesParams() throws Exception {
+        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
+        when(mockClient.execute(requestCaptor.capture())) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
+        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
+        Action1<Response> action = mock(Action1.class);
+        example.observable("X", "Y").subscribe(action);
+
+        Request request = requestCaptor.getValue();
+        assertThat(request.getUrl()).contains("/X/Y");
+
+        verify(action).call(responseCaptor.capture());
+        Response response = responseCaptor.getValue();
+        assertThat(response.getStatus()).isEqualTo(200);
+    }
+
+    @Test
+    public void testAbsoluteUrl() throws Exception {
+        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
+        when(mockClient.execute(requestCaptor.capture())) //
+                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
+        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
+        Action1<Response> action = mock(Action1.class);
+        example.observableAbsolute("http://appstrakt.com/").subscribe(action);
+
+        Request request = requestCaptor.getValue();
+        verify(action).call(responseCaptor.capture());
+        Response response = responseCaptor.getValue();
+        assertThat(response.getStatus()).isEqualTo(200);
+    }
+
+    @Test
+    public void observableUsesHttpExecutor() throws IOException {
+        Response response = new Response(200, "OK", NO_HEADERS, new TypedString("hello"));
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+
+        example.observable("Howdy").subscribe(mock(Action1.class));
 
-    try {
-      example.something();
-      fail("RetrofitError expected when unexpected exception thrown.");
-    } catch (RetrofitError e) {
-      assertThat(e.getCause()).isSameAs(exception);
+        verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
+        verifyZeroInteractions(mockCallbackExecutor);
     }
-  }
-
-  @Test public void getResponseDirectly() throws Exception {
-    Response response = new Response(200, "OK", NO_HEADERS, null);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    assertThat(example.direct()).isSameAs(response);
-  }
-
-  @Test public void closeInputStream() throws IOException {
-    // Set logger and profiler on example to make sure we exercise all the code paths.
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setServer("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(RestAdapter.Log.NONE)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
-    TypedInput typedInput = mock(TypedInput.class);
-    when(typedInput.in()).thenReturn(is);
-    Response response = new Response(200, "OK", NO_HEADERS, typedInput);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    example.something();
-    verify(is).close();
-  }
-
-  @Test public void getResponseDirectlyAsync() throws Exception {
-    Response response = new Response(200, "OK", NO_HEADERS, null);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    Callback<Response> callback = mock(Callback.class);
-
-    example.direct(callback);
-
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(response), same(response));
-  }
-
-  @Test public void observableCallsOnNext() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
-    Action1<String> action = mock(Action1.class);
-    example.observable("Howdy").subscribe(action);
-    verify(action).call(eq("hello"));
-  }
-
-  @Test public void observableCallsOnError() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response(300, "FAIL", NO_HEADERS, new TypedString("bummer")));
-    Action1<String> onSuccess = mock(Action1.class);
-    Action1<Throwable> onError = mock(Action1.class);
-    example.observable("Howdy").subscribe(onSuccess, onError);
-    verifyZeroInteractions(onSuccess);
-    verify(onError).call(isA(RetrofitError.class));
-  }
-
-  @Test public void observableHandlesParams() throws Exception {
-    ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
-    when(mockClient.execute(requestCaptor.capture())) //
-        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
-    ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
-    Action1<Response> action = mock(Action1.class);
-    example.observable("X", "Y").subscribe(action);
-
-    Request request = requestCaptor.getValue();
-    assertThat(request.getUrl()).contains("/X/Y");
-
-    verify(action).call(responseCaptor.capture());
-    Response response = responseCaptor.getValue();
-    assertThat(response.getStatus()).isEqualTo(200);
-  }
-
-  @Test public void observableUsesHttpExecutor() throws IOException {
-    Response response = new Response(200, "OK", NO_HEADERS, new TypedString("hello"));
-    when(mockClient.execute(any(Request.class))).thenReturn(response);
-
-    example.observable("Howdy").subscribe(mock(Action1.class));
-
-    verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
-    verifyZeroInteractions(mockCallbackExecutor);
-  }
 
 }
