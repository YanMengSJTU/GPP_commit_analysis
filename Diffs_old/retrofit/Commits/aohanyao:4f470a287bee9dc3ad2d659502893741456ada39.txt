diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..f83157d71 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 
 /**
@@ -30,44 +31,57 @@
  * working as designed.
  *
  * @param <T> Successful response body type.
+ *            <p>
+ *            返回结果回调结构
  */
 public interface Call<T> extends Cloneable {
-  /**
-   * Synchronously send the request and return its response.
-   *
-   * @throws IOException if a problem occurred talking to the server.
-   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
-   * or decoding the response.
-   */
-  Response<T> execute() throws IOException;
+    /**
+     * Synchronously send the request and return its response.
+     * 发送同步请求
+     *
+     * @throws IOException      if a problem occurred talking to the server.
+     * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+     *                          or decoding the response.
+     */
+    Response<T> execute() throws IOException;
 
-  /**
-   * Asynchronously send the request and notify {@code callback} of its response or if an error
-   * occurred talking to the server, creating the request, or processing the response.
-   */
-  void enqueue(Callback<T> callback);
+    /**
+     * 发送异步请求，并且回调结果是在UI线程的
+     * Asynchronously send the request and notify {@code callback} of its response or if an error
+     * occurred talking to the server, creating the request, or processing the response.
+     */
+    void enqueue(Callback<T> callback);
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * 是否在执行中
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+     */
+    boolean isExecuted();
 
-  /**
-   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
-   * yet been executed it never will be.
-   */
-  void cancel();
+    /**
+     * 取消请求
+     * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+     * yet been executed it never will be.
+     */
+    void cancel();
 
-  /** True if {@link #cancel()} was called. */
-  boolean isCanceled();
+    /**
+     * 是否已经取消了
+     * True if {@link #cancel()} was called.
+     */
+    boolean isCanceled();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call<T> clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     * 复制一个完全相同的请求
+     */
+    Call<T> clone();
 
-  /** The original HTTP request. */
-  Request request();
+    /**
+     * 原始HTTP请求
+     * The original HTTP request.
+     */
+    Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 050def5da..4106a77ca 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -29,287 +30,324 @@
 import static retrofit2.Utils.checkNotNull;
 import static retrofit2.Utils.throwIfFatal;
 
+/**
+ * Retrofit实现的一个请求回调
+ *
+ * @param <T>
+ */
 final class OkHttpCall<T> implements Call<T> {
-  private final RequestFactory requestFactory;
-  private final Object[] args;
-  private final okhttp3.Call.Factory callFactory;
-  private final Converter<ResponseBody, T> responseConverter;
-
-  private volatile boolean canceled;
-
-  @GuardedBy("this")
-  private @Nullable okhttp3.Call rawCall;
-  @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
-  private @Nullable Throwable creationFailure;
-  @GuardedBy("this")
-  private boolean executed;
-
-  OkHttpCall(RequestFactory requestFactory, Object[] args,
-      okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
-    this.requestFactory = requestFactory;
-    this.args = args;
-    this.callFactory = callFactory;
-    this.responseConverter = responseConverter;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else if (creationFailure instanceof RuntimeException) {
-        throw (RuntimeException) creationFailure;
-      } else {
-        throw (Error) creationFailure;
-      }
+    private final RequestFactory requestFactory;
+    private final Object[] args;
+    private final okhttp3.Call.Factory callFactory;
+    private final Converter<ResponseBody, T> responseConverter;
+
+    private volatile boolean canceled;
+
+    @GuardedBy("this")/*TODO 这个注解的意思不是很明白*/
+    private @Nullable
+    okhttp3.Call rawCall;
+    @GuardedBy("this") // Either a RuntimeException, non-fatal Error, or IOException.
+    private @Nullable
+    Throwable creationFailure;
+    @GuardedBy("this")
+    private boolean executed;
+
+    OkHttpCall(RequestFactory requestFactory, Object[] args,
+               okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
+        this.requestFactory = requestFactory;
+        this.args = args;
+        this.callFactory = callFactory;
+        this.responseConverter = responseConverter;
     }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException | Error e) {
-      throwIfFatal(e); // Do not assign a fatal error to creationFailure.
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    checkNotNull(callback, "callback == null");
 
-    okhttp3.Call call;
-    Throwable failure;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        // 直接 new 一个对象返回回去
+        return new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
+    }
 
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            // 已经创建好了，直接返回请求
+            return call.request();
+        }
+        // 做 失败处理
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            } else if (creationFailure instanceof RuntimeException) {
+                throw (RuntimeException) creationFailure;
+            } else {
+                throw (Error) creationFailure;
+            }
+        }
         try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          throwIfFatal(t);
-          failure = creationFailure = t;
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException | Error e) {
+            throwIfFatal(e); // Do not assign a fatal error to creationFailure.
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
-    }
-
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
-    }
-
-    if (canceled) {
-      call.cancel();
     }
 
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          throwIfFatal(e);
-          callFailure(e);
-          return;
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        checkNotNull(callback, "callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    throwIfFatal(t);
+                    failure = creationFailure = t;
+                }
+            }
         }
 
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
         }
-      }
 
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        callFailure(e);
-      }
-
-      private void callFailure(Throwable e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (canceled) {
+            call.cancel();
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else if (creationFailure instanceof RuntimeException) {
-          throw (RuntimeException) creationFailure;
-        } else {
-          throw (Error) creationFailure;
-        }
-      }
 
-      call = rawCall;
-      if (call == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException | Error e) {
-          throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
-          creationFailure = e;
-          throw e;
-        }
-      }
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    throwIfFatal(e);
+                    callFailure(e);
+                    return;
+                }
+
+                try {
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                callFailure(e);
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    return parseResponse(call.execute());
-  }
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                } else if (creationFailure instanceof RuntimeException) {
+                    throw (RuntimeException) creationFailure;
+                } else {
+                    throw (Error) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException | Error e) {
+                    throwIfFatal(e); //  Do not assign a fatal error to creationFailure.
+                    creationFailure = e;
+                    throw e;
+                }
+            }
+        }
 
-  private okhttp3.Call createRawCall() throws IOException {
-    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
-    }
+        if (canceled) {
+            call.cancel();
+        }
 
-    if (code == 204 || code == 205) {
-      rawBody.close();
-      return Response.success(null, rawResponse);
+        return parseResponse(call.execute());
     }
 
-    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
-    try {
-      T body = responseConverter.convert(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+    private okhttp3.Call createRawCall() throws IOException {
+        // 这里就是使用okhttp3发起请求了
+        okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
+        }
+        return call;
     }
-  }
 
-  public void cancel() {
-    canceled = true;
+    /**
+     * 解析返回结果
+     *
+     * @param rawResponse 返回结果
+     * @return
+     * @throws IOException
+     */
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        // 获取body中的内容
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        // TODO 删除正文的源（唯一的有状态对象），以便我们可以传递响应。
+        rawResponse = rawResponse.newBuilder()
+                .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        // 没有body的情况
+        if (code == 204 || code == 205) {
+            rawBody.close();
+            return Response.success(null, rawResponse);
+        }
 
-  @Override public boolean isCanceled() {
-    if (canceled) {
-      return true;
-    }
-    synchronized (this) {
-      return rawCall != null && rawCall.isCanceled();
+        ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
+        try {
+            T body = responseConverter.convert(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
     }
-  }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
-    private final long contentLength;
+    public void cancel() {
+        canceled = true;
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    @Override
+    public boolean isCanceled() {
+        if (canceled) {
+            return true;
+        }
+        synchronized (this) {
+            return rawCall != null && rawCall.isCanceled();
+        }
     }
 
-    @Override public long contentLength() {
-      return contentLength;
-    }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final MediaType contentType;
+        private final long contentLength;
 
-    @Override public BufferedSource source() {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+        NoContentResponseBody(MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-  static final class ExceptionCatchingResponseBody extends ResponseBody {
-    private final ResponseBody delegate;
-    IOException thrownException;
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    ExceptionCatchingResponseBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public long contentLength() {
+            return contentLength;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
+        @Override
+        public BufferedSource source() {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public long contentLength() {
-      return delegate.contentLength();
-    }
+    static final class ExceptionCatchingResponseBody extends ResponseBody {
+        private final ResponseBody delegate;
+        IOException thrownException;
 
-    @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+        ExceptionCatchingResponseBody(ResponseBody delegate) {
+            this.delegate = delegate;
         }
-      });
-    }
 
-    @Override public void close() {
-      delegate.close();
-    }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index b3a9d8efd..d10e58c28 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -133,6 +133,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
                     + ") doesn't match expected count (" + handlers.length + ")");
         }
 
+        // 这里创建整个请求所需的东西
         RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
                 headers, contentType, hasBody, isFormEncoded, isMultipart);
 
