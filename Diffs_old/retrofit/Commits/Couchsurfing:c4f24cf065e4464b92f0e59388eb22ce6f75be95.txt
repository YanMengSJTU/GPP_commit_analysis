diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3d514f29a..837b4ffa3 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,31 @@
 Change Log
 ==========
 
+Version 1.1.0 *(2013-06-20)*
+----------------------------
+
+ * Introduce `RequestInterceptor` to replace `RequestHeaders`. An interceptor provided to the
+   `RestAdapter.Builder` will be called for every request and allow setting both headers and
+   additional path parameter replacements.
+ * Add `ErrorHandler` for customizing the exceptions which are thrown when synchronous methods
+   return non-200 error codes.
+ * Properly parse responses which erroneously omit the "Content-Type" header.
+
+
+Version 1.0.2 *(2013-05-23)*
+----------------------------
+
+ * Allow uppercase letters in path replacement identifiers.
+ * Fix: Static query parameters in the URL are now correctly appended with a separating '?'.
+ * Fix: Explicitly allow or forbid `null` as a value for method parameters.
+   * `@Path` - Forbidden
+   * `@Query` - Allowed
+   * `@Field` - Allowed
+   * `@Part` - Forbidden
+   * `@Body` - Forbidden
+   * `@Header` - Allowed
+
+
 Version 1.0.1 *(2013-05-13)*
 ----------------------------
 
diff --git a/pom.xml b/pom.xml
index 8235f2617..e7058199b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>parent</artifactId>
-  <version>1.0.1</version>
+  <version>1.1.0</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -34,7 +34,7 @@
 
   <modules>
     <module>retrofit</module>
-    <module>samples</module>
+    <module>retrofit-samples</module>
   </modules>
 
   <properties>
@@ -42,21 +42,20 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <android-maven.version>3.5.1</android-maven.version>
     <java.version>1.6</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.3</gson.version>
+    <gson.version>2.2.4</gson.version>
     <javax.inject.version>1</javax.inject.version>
-    <okhttp.version>1.0.1</okhttp.version>
+    <okhttp.version>1.0.2</okhttp.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
     <fest.version>2.0M10</fest.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>14.0</guava.version>
+    <guava.version>14.0.1</guava.version>
   </properties>
 
   <scm>
diff --git a/samples/github-client/pom.xml b/retrofit-samples/github-client/pom.xml
similarity index 78%
rename from samples/github-client/pom.xml
rename to retrofit-samples/github-client/pom.xml
index 4f23c9caf..0179673ee 100644
--- a/samples/github-client/pom.xml
+++ b/retrofit-samples/github-client/pom.xml
@@ -4,13 +4,13 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.retrofit</groupId>
-    <artifactId>samples</artifactId>
-    <version>1.0.1</version>
+    <groupId>com.squareup.retrofit.samples</groupId>
+    <artifactId>parent</artifactId>
+    <version>1.1.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>sample-github-client</artifactId>
+  <artifactId>github-client</artifactId>
   <name>Sample: GitHub Client</name>
 
   <dependencies>
diff --git a/samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java b/retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
similarity index 100%
rename from samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
diff --git a/samples/pom.xml b/retrofit-samples/pom.xml
similarity index 82%
rename from samples/pom.xml
rename to retrofit-samples/pom.xml
index e599fea08..b0b88f01e 100644
--- a/samples/pom.xml
+++ b/retrofit-samples/pom.xml
@@ -6,11 +6,12 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.1.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>samples</artifactId>
+  <groupId>com.squareup.retrofit.samples</groupId>
+  <artifactId>parent</artifactId>
   <name>Samples</name>
   <packaging>pom</packaging>
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 6005683ac..a642bfdfe 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.1.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit/src/main/java/retrofit/ErrorHandler.java b/retrofit/src/main/java/retrofit/ErrorHandler.java
new file mode 100644
index 000000000..46dcfdbb0
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ErrorHandler.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+/**
+ * A hook allowing clients to customize error exceptions for synchronous requests.
+ *
+ * @author Sam Beran sberan@gmail.com
+ */
+public interface ErrorHandler {
+  /**
+   * Return a custom exception to be thrown for a {@link RetrofitError}. It is recommended that you
+   * pass the supplied error as the cause to any new exceptions.
+   * <p>
+   * If the return exception is checked it must be declared to be thrown on the interface method.
+   * <p>
+   * Example usage:
+   * <pre>
+   * class MyErrorHandler implements ErrorHandler {
+   *   &#64;Override public Throwable handleError(RetrofitError cause) {
+   *     Response r = cause.getResponse();
+   *     if (r != null && r.getStatus() == 401) {
+   *       return new UnauthorizedException(cause);
+   *     }
+   *     return cause;
+   *   }
+   * }
+   * </pre>
+   *
+   * @param cause the original {@link RetrofitError} exception
+   * @return Throwable an exception which will be thrown from the client interface method. Must not
+   *         be {@code null}.
+   */
+  Throwable handleError(RetrofitError cause);
+
+  /** An {@link ErrorHandler} which returns the original error. */
+  ErrorHandler DEFAULT = new ErrorHandler() {
+    @Override public Throwable handleError(RetrofitError cause) {
+      return cause;
+    }
+  };
+}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 1cb800c7d..884742237 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -26,164 +26,185 @@
 import retrofit.mime.MultipartTypedOutput;
 import retrofit.mime.TypedOutput;
 
-/** Builds HTTP requests from Java method invocations. */
-final class RequestBuilder {
+final class RequestBuilder implements RequestInterceptor.RequestFacade {
   private final Converter converter;
-
-  private RestMethodInfo methodInfo;
-  private Object[] args;
+  private final List<Header> headers;
+  private final StringBuilder queryParams;
+  private final String[] paramNames;
+  private final RestMethodInfo.ParamUsage[] paramUsages;
+  private final String requestMethod;
+  private final boolean isSynchronous;
+
+  private final FormUrlEncodedTypedOutput formBody;
+  private final MultipartTypedOutput multipartBody;
+  private TypedOutput body;
+
+  private String relativeUrl;
   private String apiUrl;
-  private List<retrofit.client.Header> headers;
 
-  RequestBuilder(Converter converter) {
+  RequestBuilder(Converter converter, RestMethodInfo methodInfo) {
     this.converter = converter;
-  }
 
-  /** Supply cached method metadata info. */
-  RequestBuilder methodInfo(RestMethodInfo methodDetails) {
-    this.methodInfo = methodDetails;
-    return this;
-  }
+    paramNames = methodInfo.requestParamNames;
+    paramUsages = methodInfo.requestParamUsage;
+    requestMethod = methodInfo.requestMethod;
+    isSynchronous = methodInfo.isSynchronous;
 
-  /** Base API url. */
-  RequestBuilder apiUrl(String apiUrl) {
-    this.apiUrl = apiUrl;
-    return this;
-  }
-
-  /** Arguments from method invocation. */
-  RequestBuilder args(Object[] args) {
-    this.args = args;
-    return this;
-  }
+    headers = new ArrayList<Header>();
+    queryParams = new StringBuilder();
 
-  /** A list of custom headers. */
-  RequestBuilder headers(List<retrofit.client.Header> headers) {
-    this.headers = headers;
-    return this;
-  }
+    relativeUrl = methodInfo.requestUrl;
 
-  /**
-   * Construct a {@link Request} from the supplied information. You <strong>must</strong> call
-   * {@link #methodInfo}, {@link #apiUrl}, {@link #args}, and {@link #headers} before invoking this
-   * method.
-   */
-  Request build() throws UnsupportedEncodingException {
-    String apiUrl = this.apiUrl;
+    String requestQuery = methodInfo.requestQuery;
+    if (requestQuery != null) {
+      queryParams.append('?').append(requestQuery);
+    }
 
-    StringBuilder url = new StringBuilder(apiUrl);
-    if (apiUrl.endsWith("/")) {
-      // We require relative paths to start with '/'. Prevent a double-slash.
-      url.deleteCharAt(url.length() - 1);
+    switch (methodInfo.requestType) {
+      case FORM_URL_ENCODED:
+        formBody = new FormUrlEncodedTypedOutput();
+        multipartBody = null;
+        body = formBody;
+        break;
+      case MULTIPART:
+        formBody = null;
+        multipartBody = new MultipartTypedOutput();
+        body = multipartBody;
+        break;
+      case SIMPLE:
+        formBody = null;
+        multipartBody = null;
+        // If present, 'body' will be set in 'setArguments' call.
+        break;
+      default:
+        throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
     }
+  }
 
-    // Append the method relative URL.
-    url.append(buildRelativeUrl());
+  void setApiUrl(String apiUrl) {
+    this.apiUrl = apiUrl;
+  }
 
-    // Append query parameters, if needed.
-    if (methodInfo.hasQueryParams) {
-      boolean first = true;
-      String requestQuery = methodInfo.requestQuery;
-      if (requestQuery != null) {
-        url.append(requestQuery);
-        first = false;
-      }
-      String[] requestQueryName = methodInfo.requestQueryName;
-      for (int i = 0; i < requestQueryName.length; i++) {
-        String query = requestQueryName[i];
-        if (query != null) {
-          String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");
-          url.append(first ? '?' : '&').append(query).append('=').append(value);
-          first = false;
-        }
-      }
+  @Override public void addHeader(String name, String value) {
+    if (name == null) {
+      throw new IllegalArgumentException("Header name must not be null.");
     }
+    headers.add(new Header(name, value));
+  }
 
-    List<retrofit.client.Header> headers = new ArrayList<retrofit.client.Header>();
-    if (this.headers != null) {
-      headers.addAll(this.headers);
+  @Override public void addPathParam(String name, String value) {
+    if (name == null) {
+      throw new IllegalArgumentException("Path replacement name must not be null.");
     }
-    List<Header> methodHeaders = methodInfo.headers;
-    if (methodHeaders != null) {
-      headers.addAll(methodHeaders);
+    if (value == null) {
+      throw new IllegalArgumentException(
+          "Path replacement \"" + name + "\" value must not be null.");
     }
-    // RFC 2616: Header names are case-insensitive.
-    String[] requestParamHeader = methodInfo.requestParamHeader;
-    if (requestParamHeader != null) {
-      for (int i = 0; i < requestParamHeader.length; i++) {
-        String name = requestParamHeader[i];
-        if (name == null) continue;
-        Object arg = args[i];
-        if (arg != null) {
-          headers.add(new retrofit.client.Header(name, String.valueOf(arg)));
-        }
-      }
+    try {
+      String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
+      relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
+    } catch (UnsupportedEncodingException e) {
+      throw new RuntimeException(
+          "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
     }
+  }
 
-    return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());
+  private void addQueryParam(String name, String value) {
+    if (name == null) {
+      throw new IllegalArgumentException("Query param name must not be null.");
+    }
+    if (value == null) {
+      throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
+    }
+    try {
+      value = URLEncoder.encode(String.valueOf(value), "UTF-8");
+      StringBuilder queryParams = this.queryParams;
+      queryParams.append(queryParams.length() > 0 ? '&' : '?');
+      queryParams.append(name).append('=').append(value);
+    } catch (UnsupportedEncodingException e) {
+      throw new RuntimeException(
+          "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
+    }
   }
 
-  /** Create the final relative URL by performing parameter replacement. */
-  private String buildRelativeUrl() throws UnsupportedEncodingException {
-    String replacedPath = methodInfo.requestUrl;
-    String[] requestUrlParam = methodInfo.requestUrlParam;
-    for (int i = 0; i < requestUrlParam.length; i++) {
-      String param = requestUrlParam[i];
-      if (param != null) {
-        String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");
-        replacedPath = replacedPath.replace("{" + param + "}", value);
+  void setArguments(Object[] args) {
+    if (args == null) {
+      return;
+    }
+    int count = args.length;
+    if (!isSynchronous) {
+      count -= 1;
+    }
+    for (int i = 0; i < count; i++) {
+      String name = paramNames[i];
+      Object value = args[i];
+      RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
+      switch (paramUsage) {
+        case PATH:
+          if (value == null) {
+            throw new IllegalArgumentException(
+                "Path parameter \"" + name + "\" value must not be null.");
+          }
+          addPathParam(name, value.toString());
+          break;
+        case QUERY:
+          if (value != null) { // Skip null values.
+            addQueryParam(name, value.toString());
+          }
+          break;
+        case HEADER:
+          if (value != null) { // Skip null values.
+            addHeader(name, value.toString());
+          }
+          break;
+        case FIELD:
+          if (value != null) { // Skip null values.
+            formBody.addField(name, value.toString());
+          }
+          break;
+        case PART:
+          if (value == null) {
+            throw new IllegalArgumentException(
+                "Multipart part \"" + name + "\" value must not be null.");
+          }
+          if (value instanceof TypedOutput) {
+            multipartBody.addPart(name, (TypedOutput) value);
+          } else {
+            multipartBody.addPart(name, converter.toBody(value));
+          }
+          break;
+        case BODY:
+          if (value == null) {
+            throw new IllegalArgumentException("Body parameter value must not be null.");
+          }
+          if (value instanceof TypedOutput) {
+            body = (TypedOutput) value;
+          } else {
+            body = converter.toBody(value);
+          }
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown parameter usage: " + paramUsage);
       }
     }
-    return replacedPath;
   }
 
-  /** Create the request body using the method info and invocation arguments. */
-  private TypedOutput buildBody() {
-    switch (methodInfo.requestType) {
-      case SIMPLE: {
-        int bodyIndex = methodInfo.bodyIndex;
-        if (bodyIndex == RestMethodInfo.NO_BODY) {
-          return null;
-        }
-        Object body = args[bodyIndex];
-        if (body instanceof TypedOutput) {
-          return (TypedOutput) body;
-        } else {
-          return converter.toBody(body);
-        }
-      }
+  Request build() throws UnsupportedEncodingException {
+    String apiUrl = this.apiUrl;
 
-      case FORM_URL_ENCODED: {
-        FormUrlEncodedTypedOutput body = new FormUrlEncodedTypedOutput();
-        String[] requestFormFields = methodInfo.requestFormFields;
-        for (int i = 0; i < requestFormFields.length; i++) {
-          String name = requestFormFields[i];
-          if (name != null) {
-            body.addField(name, String.valueOf(args[i]));
-          }
-        }
-        return body;
-      }
+    StringBuilder url = new StringBuilder(apiUrl);
+    if (apiUrl.endsWith("/")) {
+      // We require relative paths to start with '/'. Prevent a double-slash.
+      url.deleteCharAt(url.length() - 1);
+    }
 
-      case MULTIPART: {
-        MultipartTypedOutput body = new MultipartTypedOutput();
-        String[] requestMultipartPart = methodInfo.requestMultipartPart;
-        for (int i = 0; i < requestMultipartPart.length; i++) {
-          String name = requestMultipartPart[i];
-          if (name != null) {
-            Object value = args[i];
-            if (value instanceof TypedOutput) {
-              body.addPart(name, (TypedOutput) value);
-            } else {
-              body.addPart(name, converter.toBody(value));
-            }
-          }
-        }
-        return body;
-      }
+    url.append(relativeUrl);
 
-      default:
-        throw new IllegalArgumentException("Unknown request type " + methodInfo.requestType);
+    StringBuilder queryParams = this.queryParams;
+    if (queryParams.length() > 0) {
+      url.append(queryParams);
     }
+
+    return new Request(requestMethod, url.toString(), headers, body);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestHeaders.java b/retrofit/src/main/java/retrofit/RequestHeaders.java
deleted file mode 100644
index c1bef05d5..000000000
--- a/retrofit/src/main/java/retrofit/RequestHeaders.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.util.Collections;
-import java.util.List;
-import retrofit.client.Header;
-
-/** Manages headers for each request. */
-public interface RequestHeaders {
-  /**
-   * Get a list of headers for a request. This method will be called once for each request allowing
-   * you to change the list as the state of your application changes.
-   */
-  List<Header> get();
-
-  /** Empty header list. */
-  RequestHeaders NONE = new RequestHeaders() {
-    @Override public List<Header> get() {
-      return Collections.emptyList();
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptor.java b/retrofit/src/main/java/retrofit/RequestInterceptor.java
new file mode 100644
index 000000000..d5b1d0953
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestInterceptor.java
@@ -0,0 +1,25 @@
+package retrofit;
+
+/** Intercept every request before it is executed in order to add additional data. */
+public interface RequestInterceptor {
+  /** Called for every request. Add data using methods on the supplied {@link RequestFacade}. */
+  void intercept(RequestFacade request);
+
+  interface RequestFacade {
+    /** Add a header to the request. This will not replace any existing headers. */
+    void addHeader(String name, String value);
+
+    /**
+     * Add a path parameter replacement. This works exactly like a {@link retrofit.http.Part
+     * &#64;Part}-annotated method argument.
+     */
+    void addPathParam(String name, String value);
+  }
+
+  /** A {@link RequestInterceptor} which does no modification of requests. */
+  RequestInterceptor NONE = new RequestInterceptor() {
+    @Override public void intercept(RequestFacade request) {
+      // Do nothing.
+    }
+  };
+}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 95199c37c..a447a0fc2 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -18,7 +18,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
@@ -118,22 +117,24 @@
   private final Client.Provider clientProvider;
   private final Executor httpExecutor;
   private final Executor callbackExecutor;
-  private final RequestHeaders requestHeaders;
+  private final RequestInterceptor requestInterceptor;
   private final Converter converter;
   private final Profiler profiler;
+  private final ErrorHandler errorHandler;
   private final Log log;
   private volatile boolean debug;
 
   private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, RequestHeaders requestHeaders, Converter converter,
-      Profiler profiler, Log log, boolean debug) {
+      Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
+      Profiler profiler, ErrorHandler errorHandler, Log log, boolean debug) {
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
     this.callbackExecutor = callbackExecutor;
-    this.requestHeaders = requestHeaders;
+    this.requestInterceptor = requestInterceptor;
     this.converter = converter;
     this.profiler = profiler;
+    this.errorHandler = errorHandler;
     this.log = log;
     this.debug = debug;
   }
@@ -159,7 +160,7 @@ public void setDebug(boolean debug) {
 
     @SuppressWarnings("unchecked") //
     @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws InvocationTargetException, IllegalAccessException {
+        throws Throwable {
       // If the method is a method from Object then defer to normal invocation.
       if (method.getDeclaringClass() == Object.class) {
         return method.invoke(this, args);
@@ -177,7 +178,16 @@ public void setDebug(boolean debug) {
       }
 
       if (methodDetails.isSynchronous) {
-        return invokeRequest(methodDetails, args);
+        try {
+          return invokeRequest(methodDetails, args);
+        } catch (RetrofitError error) {
+          Throwable newError = errorHandler.handleError(error);
+          if (newError == null) {
+            throw new IllegalStateException("Error handler returned null for wrapped exception.",
+                error);
+          }
+          throw newError;
+        }
       }
 
       if (httpExecutor == null || callbackExecutor == null) {
@@ -204,12 +214,13 @@ private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
       String serverUrl = server.getUrl();
       String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
       try {
-        Request request = new RequestBuilder(converter) //
-            .apiUrl(serverUrl) //
-            .args(args) //
-            .headers(requestHeaders.get()) //
-            .methodInfo(methodDetails) //
-            .build();
+        RequestBuilder requestBuilder = new RequestBuilder(converter, methodDetails);
+        requestBuilder.setApiUrl(serverUrl);
+        requestBuilder.setArguments(args);
+
+        requestInterceptor.intercept(requestBuilder);
+
+        Request request = requestBuilder.build();
         url = request.getUrl();
 
         if (!methodDetails.isSynchronous) {
@@ -398,28 +409,35 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
     private Client.Provider clientProvider;
     private Executor httpExecutor;
     private Executor callbackExecutor;
-    private RequestHeaders requestHeaders;
+    private RequestInterceptor requestInterceptor;
     private Converter converter;
     private Profiler profiler;
+    private ErrorHandler errorHandler;
     private Log log;
     private boolean debug;
 
     /** API server base URL. */
     public Builder setServer(String endpoint) {
-      if (endpoint == null) throw new NullPointerException("endpoint");
+      if (endpoint == null || endpoint.trim().length() == 0) {
+        throw new NullPointerException("Server may not be blank.");
+      }
       return setServer(new Server(endpoint));
     }
 
     /** API server. */
     public Builder setServer(Server server) {
-      if (server == null) throw new NullPointerException("server");
+      if (server == null) {
+        throw new NullPointerException("Server may not be null.");
+      }
       this.server = server;
       return this;
     }
 
     /** The HTTP client used for requests. */
     public Builder setClient(final Client client) {
-      if (client == null) throw new NullPointerException("client");
+      if (client == null) {
+        throw new NullPointerException("Client may not be null.");
+      }
       return setClient(new Client.Provider() {
         @Override public Client get() {
           return client;
@@ -429,7 +447,9 @@ public Builder setClient(final Client client) {
 
     /** The HTTP client used for requests. */
     public Builder setClient(Client.Provider clientProvider) {
-      if (clientProvider == null) throw new NullPointerException("clientProvider");
+      if (clientProvider == null) {
+        throw new NullPointerException("Client provider may not be null.");
+      }
       this.clientProvider = clientProvider;
       return this;
     }
@@ -443,37 +463,61 @@ public Builder setClient(Client.Provider clientProvider) {
      * HTTP client.
      */
     public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
-      if (httpExecutor == null) throw new NullPointerException("httpExecutor");
-      if (callbackExecutor == null) callbackExecutor = new Utils.SynchronousExecutor();
+      if (httpExecutor == null) {
+        throw new NullPointerException("HTTP executor may not be null.");
+      }
+      if (callbackExecutor == null) {
+        callbackExecutor = new Utils.SynchronousExecutor();
+      }
       this.httpExecutor = httpExecutor;
       this.callbackExecutor = callbackExecutor;
       return this;
     }
 
-    /**  */
-    public Builder setRequestHeaders(RequestHeaders requestHeaders) {
-      if (requestHeaders == null) throw new NullPointerException("requestHeaders");
-      this.requestHeaders = requestHeaders;
+    /** A request interceptor for adding data to every request. */
+    public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
+      if (requestInterceptor == null) {
+        throw new NullPointerException("Request interceptor may not be null.");
+      }
+      this.requestInterceptor = requestInterceptor;
       return this;
     }
 
     /** The converter used for serialization and deserialization of objects. */
     public Builder setConverter(Converter converter) {
-      if (converter == null) throw new NullPointerException("converter");
+      if (converter == null) {
+        throw new NullPointerException("Converter may not be null.");
+      }
       this.converter = converter;
       return this;
     }
 
     /** Set the profiler used to measure requests. */
     public Builder setProfiler(Profiler profiler) {
-      if (profiler == null) throw new NullPointerException("profiler");
+      if (profiler == null) {
+        throw new NullPointerException("Profiler may not be null.");
+      }
       this.profiler = profiler;
       return this;
     }
 
+    /**
+     * The error handler allows you to customize the type of exception thrown for errors on
+     * synchronous requests.
+     */
+    public Builder setErrorHandler(ErrorHandler errorHandler) {
+      if (errorHandler == null) {
+        throw new NullPointerException("Error handler may not be null.");
+      }
+      this.errorHandler = errorHandler;
+      return this;
+    }
+
     /** Configure debug logging mechanism. */
     public Builder setLog(Log log) {
-      if (log == null) throw new NullPointerException("log");
+      if (log == null) {
+        throw new NullPointerException("Log may not be null.");
+      }
       this.log = log;
       return this;
     }
@@ -490,8 +534,8 @@ public RestAdapter build() {
         throw new IllegalArgumentException("Server may not be null.");
       }
       ensureSaneDefaults();
-      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor, requestHeaders,
-          converter, profiler, log, debug);
+      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor,
+          requestInterceptor, converter, profiler, errorHandler, log, debug);
     }
 
     private void ensureSaneDefaults() {
@@ -507,11 +551,14 @@ private void ensureSaneDefaults() {
       if (callbackExecutor == null) {
         callbackExecutor = Platform.get().defaultCallbackExecutor();
       }
+      if (errorHandler == null) {
+        errorHandler = ErrorHandler.DEFAULT;
+      }
       if (log == null) {
         log = Platform.get().defaultLog();
       }
-      if (requestHeaders == null) {
-        requestHeaders = RequestHeaders.NONE;
+      if (requestInterceptor == null) {
+        requestInterceptor = RequestInterceptor.NONE;
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index 0eafca32c..809f6aac4 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -39,11 +39,14 @@
 
 /** Request metadata about a service interface declaration. */
 final class RestMethodInfo {
-  static final int NO_BODY = -1;
+  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-  // Matches strings containing lowercase characters, digits, underscores, or hyphens that start
-  // with a lowercase character in between '{' and '}'.
-  private static final Pattern URL_PARAMETERS = Pattern.compile("\\{([a-z][a-z0-9_-]*)\\}");
+  enum ParamUsage {
+    PATH, QUERY, FIELD, PART, BODY, HEADER
+  }
 
   enum RequestType {
     /** No content-specific logic required. */
@@ -70,13 +73,8 @@
   List<retrofit.client.Header> headers;
 
   // Parameter-level details
-  String[] requestUrlParam;
-  String[] requestQueryName;
-  boolean hasQueryParams = false;
-  String[] requestFormFields;
-  String[] requestMultipartPart;
-  String[] requestParamHeader;
-  int bodyIndex = NO_BODY;
+  String[] requestParamNames;
+  ParamUsage[] requestParamUsage;
 
   RestMethodInfo(Method method) {
     this.method = method;
@@ -188,10 +186,9 @@ private void parsePath(String path) {
     if (question != -1 && question < path.length() - 1) {
       url = path.substring(0, question);
       query = path.substring(question + 1);
-      hasQueryParams = true;
 
       // Ensure the query string does not have any named parameters.
-      Matcher queryParamMatcher = URL_PARAMETERS.matcher(query);
+      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
       if (queryParamMatcher.find()) {
         throw new IllegalStateException("URL query string \""
             + query
@@ -281,8 +278,7 @@ private boolean parseResponseType() {
   }
 
   /**
-   * Loads {@link #requestUrlParam}, {@link #requestQueryName}, {@link #requestFormFields},
-   * {@link #requestMultipartPart}, and {@link #requestParamHeader}. Must be called after
+   * Loads {@link #requestParamNames} and {@link #requestParamUsage}. Must be called after
    * {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
@@ -294,17 +290,16 @@ private void parseParameters() {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
-    String[] urlParam = new String[count];
-    String[] queryName = new String[count];
-    String[] formValue = new String[count];
-    String[] multipartPart = new String[count];
-    String[] paramHeader = new String[count];
+    String[] paramNames = new String[count];
+    requestParamNames = paramNames;
+    ParamUsage[] paramUsage = new ParamUsage[count];
+    requestParamUsage = paramUsage;
+
     boolean gotField = false;
     boolean gotPart = false;
+    boolean gotBody = false;
 
     for (int i = 0; i < count; i++) {
-      boolean hasRetrofitAnnotation = false;
-
       Class<?> parameterType = parameterTypes[i];
       Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
       if (parameterAnnotations != null) {
@@ -312,30 +307,35 @@ private void parseParameters() {
           Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
 
           if (annotationType == Path.class) {
-            hasRetrofitAnnotation = true;
             String name = ((Path) parameterAnnotation).value();
 
+            if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+              throw new IllegalStateException("Path parameter name is not valid: "
+                  + name
+                  + ". Must match "
+                  + PARAM_URL_REGEX.pattern());
+            }
             // Verify URL replacement name is actually present in the URL path.
             if (!requestUrlParamNames.contains(name)) {
               throw new IllegalStateException(
-                  "Method path \"" + requestUrl + "\" does not contain {" + name + "}.");
+                  "Method URL \"" + requestUrl + "\" does not contain {" + name + "}.");
             }
 
-            urlParam[i] = name;
+            paramNames[i] = name;
+            paramUsage[i] = ParamUsage.PATH;
           } else if (annotationType == Query.class) {
-            hasRetrofitAnnotation = true;
-            hasQueryParams = true;
             String name = ((Query) parameterAnnotation).value();
 
-            queryName[i] = name;
+            paramNames[i] = name;
+            paramUsage[i] = ParamUsage.QUERY;
           } else if (annotationType == Header.class) {
             String name = ((Header) parameterAnnotation).value();
             if (parameterType != String.class) {
               throw new IllegalStateException("@Header parameter type must be String: " + name);
             }
 
-            hasRetrofitAnnotation = true;
-            paramHeader[i] = name;
+            paramNames[i] = name;
+            paramUsage[i] = ParamUsage.HEADER;
           } else if (annotationType == Field.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw new IllegalStateException(
@@ -345,8 +345,8 @@ private void parseParameters() {
             String name = ((Field) parameterAnnotation).value();
 
             gotField = true;
-            hasRetrofitAnnotation = true;
-            formValue[i] = name;
+            paramNames[i] = name;
+            paramUsage[i] = ParamUsage.FIELD;
           } else if (annotationType == Part.class) {
             if (requestType != RequestType.MULTIPART) {
               throw new IllegalStateException(
@@ -356,31 +356,31 @@ private void parseParameters() {
             String name = ((Part) parameterAnnotation).value();
 
             gotPart = true;
-            hasRetrofitAnnotation = true;
-            multipartPart[i] = name;
+            paramNames[i] = name;
+            paramUsage[i] = ParamUsage.PART;
           } else if (annotationType == Body.class) {
             if (requestType != RequestType.SIMPLE) {
               throw new IllegalStateException(
                   "@Body parameters cannot be used with form or multi-part encoding.");
             }
-            if (bodyIndex != NO_BODY) {
+            if (gotBody) {
               throw new IllegalStateException(
                   "Method annotated with multiple Body method annotations: " + method);
             }
 
-            hasRetrofitAnnotation = true;
-            bodyIndex = i;
+            gotBody = true;
+            paramUsage[i] = ParamUsage.BODY;
           }
         }
       }
 
-      if (!hasRetrofitAnnotation) {
+      if (paramUsage[i] == null) {
         throw new IllegalStateException(
-            "No annotations found on parameter " + (i + 1) + " of " + method.getName());
+            "No Retrofit annotation found on parameter " + (i + 1) + " of " + method.getName());
       }
     }
 
-    if (requestType == RequestType.SIMPLE && !requestHasBody && bodyIndex != NO_BODY) {
+    if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
       throw new IllegalStateException("Non-body HTTP method cannot contain @Body or @TypedOutput.");
     }
     if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
@@ -389,12 +389,6 @@ private void parseParameters() {
     if (requestType == RequestType.MULTIPART && !gotPart) {
       throw new IllegalStateException("Multipart method must contain at least one @Part.");
     }
-
-    requestUrlParam = urlParam;
-    requestQueryName = queryName;
-    requestFormFields = formValue;
-    requestMultipartPart = multipartPart;
-    requestParamHeader = paramHeader;
   }
 
   /**
@@ -402,7 +396,7 @@ private void parseParameters() {
    * in the URI, it will only show up once in the set.
    */
   static Set<String> parsePathParameters(String path) {
-    Matcher m = URL_PARAMETERS.matcher(path);
+    Matcher m = PARAM_URL_REGEX.matcher(path);
     Set<String> patterns = new LinkedHashSet<String>();
     while (m.find()) {
       patterns.add(m.group(1));
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
index 9e5df33cd..4cea8653d 100644
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
@@ -39,7 +39,10 @@ public GsonConverter(Gson gson) {
   }
 
   @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
-    String charset = MimeUtil.parseCharset(body.mimeType());
+    String charset = "UTF-8";
+    if (body.mimeType() != null) {
+      charset = MimeUtil.parseCharset(body.mimeType());
+    }
     InputStreamReader isr = null;
     try {
       isr = new InputStreamReader(body.in(), charset);
diff --git a/retrofit/src/main/java/retrofit/http/Body.java b/retrofit/src/main/java/retrofit/http/Body.java
index 2b560989a..091425e4d 100644
--- a/retrofit/src/main/java/retrofit/http/Body.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -24,9 +24,14 @@
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body).  If the value of the parameter implements TypedOutput, the request body will be written
- * exactly as specified by the TypedOutput.writeTo object.  If it doesn't implement TypedOutput, the
- * object will be serialized into JSON and the result will be set directly as the request body.
+ * body). If the value of the parameter implements {@link retrofit.mime.TypedOutput TypedOutput},
+ * the request body will be written exactly as specified by
+ * {@link retrofit.mime.TypedOutput#writeTo(java.io.OutputStream)}. If the value does not implement
+ * TypedOutput, the object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
+ * {@link retrofit.converter.Converter Converter} and the result will be set directly as the
+ * request body.
+ * <p>
+ * Body parameters may not be {@code null}.
  *
  * @author Eric Denman (edenman@squareup.com)
  */
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
index 4e9bdb126..47e82349d 100644
--- a/retrofit/src/main/java/retrofit/http/Field.java
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -30,6 +30,8 @@
  * void example(@Field("name") String name, @Field("occupation") String occupation, ..);
  * }
  * </pre>
+ * <p>
+ * Field parameters may be {@code null} which will omit them from the request body.
  */
 @Target(PARAMETER) @Retention(RUNTIME)
 public @interface Field {
diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
index 05979fd5f..9069432dd 100644
--- a/retrofit/src/main/java/retrofit/http/Header.java
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -22,14 +22,15 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Replaces the header with the the value of its target. If the target is null,
- * the header is removed.
+ * Replaces the header with the the value of its target.
  * <p>
  * <pre>
  * &#64;GET("/")
  * void foo(@Header("Accept-Language") String lang, Callback&lt;Response> cb);
  * </pre>
  * <p>
+ * Header parameters may be {@code null} which will omit them from the request.
+ * <p>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index be78a14ee..fb25de68e 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -40,6 +40,8 @@
  *              ...
  * );
  * </pre>
+ * <p>
+ * Part parameters may not be {@code null}.
  */
 @Target(PARAMETER) @Retention(RUNTIME)
 public @interface Part {
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
index 479279e88..d46ebba67 100644
--- a/retrofit/src/main/java/retrofit/http/Path.java
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -29,6 +29,8 @@
  * &#64;GET("/image/{id}")
  * void example(@Path("id") int id, ..);
  * </pre>
+ * <p>
+ * Path parameters may not be {@code null}.
  */
 @Retention(RUNTIME) @Target(PARAMETER)
 public @interface Path {
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
index 3ae1a3918..22149794d 100644
--- a/retrofit/src/main/java/retrofit/http/Query.java
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -29,6 +29,8 @@
  * &#64;GET("/list")
  * void example(@Query("page") int page, ..);
  * </pre>
+ * <p>
+ * Query parameters may be {@code null} which will omit them from the URL.
  */
 @Target(PARAMETER) @Retention(RUNTIME)
 public @interface Query {
diff --git a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java b/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
index 5f05def04..a167ae9c9 100644
--- a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
+++ b/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
@@ -31,13 +31,13 @@
   private final byte[] bytes;
 
   /**
-   * Constructs a new typed byte array.
+   * Constructs a new typed byte array.  Sets mimeType to {@code application/unknown} if absent.
    *
-   * @throws NullPointerException if bytes or mimeType is null
+   * @throws NullPointerException if bytes are null
    */
   public TypedByteArray(String mimeType, byte[] bytes) {
     if (mimeType == null) {
-      throw new NullPointerException("mimeType");
+      mimeType = "application/unknown";
     }
     if (bytes == null) {
       throw new NullPointerException("bytes");
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
new file mode 100644
index 000000000..981b3b05b
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
@@ -0,0 +1,74 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.io.IOException;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit.client.Client;
+import retrofit.client.Header;
+import retrofit.client.Request;
+import retrofit.client.Response;
+import retrofit.http.GET;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+
+public class ErrorHandlerTest {
+
+  interface ExampleClient {
+    @GET("/")
+    Response throwsCustomException() throws TestException;
+  }
+
+  static class TestException extends Exception {
+  }
+
+  /* An HTTP client which always returns a 400 response */
+  static class MockInvalidResponseClient implements Client {
+    @Override public Response execute(Request request) throws IOException {
+      return new Response(400, "invalid request", Collections.<Header>emptyList(), null);
+    }
+  }
+
+  ExampleClient client;
+  ErrorHandler errorHandler;
+
+  @Before public void setup() {
+    errorHandler = mock(ErrorHandler.class);
+
+    client = new RestAdapter.Builder() //
+        .setServer("http://example.com")
+        .setClient(new MockInvalidResponseClient())
+        .setErrorHandler(errorHandler)
+        .setExecutors(new Utils.SynchronousExecutor(), new Utils.SynchronousExecutor())
+        .build()
+        .create(ExampleClient.class);
+  }
+
+  @Test public void customizedExceptionUsed() throws Throwable {
+    TestException exception = new TestException();
+    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
+
+    try {
+      client.throwsCustomException();
+      fail();
+    } catch (TestException e) {
+      assertThat(e).isSameAs(exception);
+    }
+  }
+
+  @Test public void returningNullThrowsException() throws Exception {
+    doReturn(null).when(errorHandler).handleError(any(RetrofitError.class));
+
+    try {
+      client.throwsCustomException();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Error handler returned null for wrapped exception.");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 7ed4ede5e..11fe09615 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -20,7 +20,14 @@
 import retrofit.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.RestMethodInfo.NO_BODY;
+import static org.fest.assertions.api.Assertions.fail;
+import static retrofit.RestMethodInfo.ParamUsage;
+import static retrofit.RestMethodInfo.ParamUsage.BODY;
+import static retrofit.RestMethodInfo.ParamUsage.FIELD;
+import static retrofit.RestMethodInfo.ParamUsage.HEADER;
+import static retrofit.RestMethodInfo.ParamUsage.PART;
+import static retrofit.RestMethodInfo.ParamUsage.PATH;
+import static retrofit.RestMethodInfo.ParamUsage.QUERY;
 import static retrofit.RestMethodInfo.RequestType;
 
 public class RequestBuilderTest {
@@ -49,6 +56,20 @@
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void pathParamRequired() throws Exception {
+    try {
+      new Helper() //
+          .setMethod("GET") //
+          .setUrl("http://example.com") //
+          .setPath("/foo/bar/{ping}/") //
+          .addPathParam("ping", null) //
+          .build();
+      fail("Null path parameters not allowed.");
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+    }
+  }
+
   @Test public void getWithQueryParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -62,12 +83,32 @@
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void queryParamOptional() throws Exception {
+    Request request1 = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addQueryParam("ping", null) //
+        .build();
+    assertThat(request1.getUrl()).isEqualTo("http://example.com/foo/bar/");
+
+    Request request2 = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addQueryParam("foo", "bar") //
+        .addQueryParam("ping", null) //
+        .addQueryParam("kit", "kat") //
+        .build();
+    assertThat(request2.getUrl()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+  }
+
   @Test public void getWithQueryUrlAndParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
         .setUrl("http://example.com") //
         .setPath("/foo/bar/") //
-        .setQuery("?hi=mom") //
+        .setQuery("hi=mom") //
         .addQueryParam("ping", "pong") //
         .build();
     assertThat(request.getMethod()).isEqualTo("GET");
@@ -76,6 +117,19 @@
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void getWithQuery() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .setQuery("hi=mom") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.getBody()).isNull();
+  }
+
   @Test public void getWithPathAndQueryParam() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -160,7 +214,7 @@
     assertThat(request.getBody()).isNull();
   }
 
-  @Test public void singleEntity() throws Exception {
+  @Test public void body() throws Exception {
     Request request = new Helper() //
         .setMethod("POST") //
         .setHasBody() //
@@ -174,7 +228,22 @@
     assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
   }
 
-  @Test public void singleEntityWithPathParams() throws Exception {
+  @Test public void bodyRequired() throws Exception {
+    try {
+      new Helper() //
+          .setMethod("POST") //
+          .setHasBody() //
+          .setUrl("http://example.com") //
+          .setPath("/foo/bar/") //
+          .setBody(null) //
+          .build();
+      fail("Null body not allowed.");
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+    }
+  }
+
+  @Test public void bodyWithPathParams() throws Exception {
     Request request = new Helper() //
         .setMethod("POST") //
         .setHasBody() //
@@ -217,6 +286,22 @@
     assertThat(two).contains("kit").contains("kat");
   }
 
+  @Test public void multipartPartOptional() throws Exception {
+    try {
+      new Helper() //
+          .setMethod("POST") //
+          .setHasBody() //
+          .setUrl("http://example.com") //
+          .setPath("/foo/bar/") //
+          .setMultipart() //
+          .addPart("ping", null) //
+          .build();
+      fail("Null multipart part is not allowed.");
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Multipart part \"ping\" value must not be null.");
+    }
+  }
+
   @Test public void simpleFormEncoded() throws Exception {
     Request request = new Helper() //
         .setMethod("POST") //
@@ -230,6 +315,20 @@
     assertTypedBytes(request.getBody(), "foo=bar&ping=pong");
   }
 
+  @Test public void formEncodedFieldOptional() throws Exception {
+    Request request = new Helper() //
+        .setMethod("POST") //
+        .setHasBody() //
+        .setUrl("http://example.com") //
+        .setPath("/foo") //
+        .setFormEncoded() //
+        .addField("foo", "bar") //
+        .addField("ping", null) //
+        .addField("kit", "kat") //
+        .build();
+    assertTypedBytes(request.getBody(), "foo=bar&kit=kat");
+  }
+
   @Test public void simpleHeaders() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -297,17 +396,12 @@ private static void assertTypedBytes(TypedOutput bytes, String expected) throws
     private RequestType requestType = RequestType.SIMPLE;
     private String method;
     private boolean hasBody = false;
-    private boolean hasQueryParams = false;
     private String path;
     private String query;
-    private final List<String> pathParams = new ArrayList<String>();
-    private final List<String> queryParams = new ArrayList<String>();
-    private final List<String> fieldParams = new ArrayList<String>();
-    private final List<String> partParams = new ArrayList<String>();
-    private final List<String> headerParams = new ArrayList<String>();
+    private final List<String> paramNames = new ArrayList<String>();
+    private final List<ParamUsage> paramUsages = new ArrayList<ParamUsage>();
     private final List<Object> args = new ArrayList<Object>();
     private final List<Header> headers = new ArrayList<Header>();
-    private int bodyIndex = NO_BODY;
     private String url;
 
     Helper setMethod(String method) {
@@ -332,49 +426,48 @@ Helper setPath(String path) {
 
     Helper setQuery(String query) {
       this.query = query;
-      hasQueryParams = true;
       return this;
     }
 
-    private void addParam(String path, String query, String field, String part, String header,
-        Object value) {
-      pathParams.add(path);
-      queryParams.add(query);
-      fieldParams.add(field);
-      partParams.add(part);
-      headerParams.add(header);
-      args.add(value);
-    }
-
     Helper addPathParam(String name, Object value) {
-      addParam(name, null, null, null, null, value);
+      paramNames.add(name);
+      paramUsages.add(PATH);
+      args.add(value);
       return this;
     }
 
     Helper addQueryParam(String name, String value) {
-      addParam(null, name, null, null, null, value);
-      hasQueryParams = true;
+      paramNames.add(name);
+      paramUsages.add(QUERY);
+      args.add(value);
       return this;
     }
 
     Helper addField(String name, String value) {
-      addParam(null, null, name, null, null, value);
+      paramNames.add(name);
+      paramUsages.add(FIELD);
+      args.add(value);
       return this;
     }
 
     Helper addPart(String name, Object value) {
-      addParam(null, null, null, name, null, value);
+      paramNames.add(name);
+      paramUsages.add(PART);
+      args.add(value);
       return this;
     }
 
     Helper setBody(Object value) {
-      addParam(null, null, null, null, null, value);
-      bodyIndex = args.size() - 1;
+      paramNames.add(null);
+      paramUsages.add(BODY);
+      args.add(value);
       return this;
     }
 
     Helper addHeaderParam(String name, Object value) {
-      addParam(null, null, null, null, name, value);
+      paramNames.add(name);
+      paramUsages.add(HEADER);
+      args.add(value);
       return this;
     }
 
@@ -410,21 +503,20 @@ Request build() throws Exception {
       methodInfo.requestUrl = path;
       methodInfo.requestUrlParamNames = RestMethodInfo.parsePathParameters(path);
       methodInfo.requestQuery = query;
-      methodInfo.hasQueryParams = hasQueryParams;
-      methodInfo.requestUrlParam = pathParams.toArray(new String[pathParams.size()]);
-      methodInfo.requestQueryName = queryParams.toArray(new String[queryParams.size()]);
-      methodInfo.requestFormFields = fieldParams.toArray(new String[fieldParams.size()]);
-      methodInfo.requestMultipartPart = partParams.toArray(new String[partParams.size()]);
-      methodInfo.requestParamHeader = headerParams.toArray(new String[headerParams.size()]);
-      methodInfo.bodyIndex = bodyIndex;
+      methodInfo.requestParamNames = paramNames.toArray(new String[paramNames.size()]);
+      methodInfo.requestParamUsage = paramUsages.toArray(new ParamUsage[paramUsages.size()]);
       methodInfo.loaded = true;
 
-      return new RequestBuilder(GSON) //
-          .apiUrl(url)
-          .headers(headers)
-          .args(args.toArray(new Object[args.size()]))
-          .methodInfo(methodInfo)
-          .build();
+      RequestBuilder requestBuilder = new RequestBuilder(GSON, methodInfo);
+
+      for (Header header : headers) {
+        requestBuilder.addHeader(header.getName(), header.getValue());
+      }
+
+      requestBuilder.setApiUrl(url);
+      requestBuilder.setArguments(args.toArray(new Object[args.size()]));
+
+      return requestBuilder.build();
     }
 
     @SuppressWarnings("UnusedDeclaration") // Accessed via reflection.
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 282fff5ea..bf6d603f0 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -1,7 +1,10 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Executor;
@@ -13,6 +16,7 @@
 import retrofit.client.Header;
 import retrofit.client.Request;
 import retrofit.client.Response;
+import retrofit.mime.TypedInput;
 import retrofit.mime.TypedString;
 
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -81,6 +85,118 @@
     verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
   }
 
+  @Test public void logSuccessfulRequestResponseOnDebugWhenResponseBodyPresent() throws Exception {
+    final List<String> logMessages = new ArrayList<String>();
+    RestAdapter.Log log = new RestAdapter.Log() {
+      public void log(String message) {
+        logMessages.add(message);
+      }
+    };
+
+    Example example = new RestAdapter.Builder() //
+        .setClient(mockClient)
+        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+        .setServer("http://example.com")
+        .setProfiler(mockProfiler)
+        .setLog(log)
+        .setDebug(true)
+        .build()
+        .create(Example.class);
+
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("{}")));
+
+    example.something();
+    assertThat(logMessages).hasSize(5);
+    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+    assertThat(logMessages.get(1)).isEqualTo("---> END HTTP (0-byte body)");
+    assertThat(logMessages.get(2)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+    assertThat(logMessages.get(3)).isEqualTo("{}");
+    assertThat(logMessages.get(4)).isEqualTo("<--- END HTTP (2-byte body)");
+  }
+
+  @Test public void logSuccessfulRequestResponseOnDebugWhenResponseBodyAbsent() throws Exception {
+    final List<String> logMessages = new ArrayList<String>();
+    RestAdapter.Log log = new RestAdapter.Log() {
+      public void log(String message) {
+        logMessages.add(message);
+      }
+    };
+
+    Example example = new RestAdapter.Builder() //
+        .setClient(mockClient)
+        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+        .setServer("http://example.com")
+        .setProfiler(mockProfiler)
+        .setLog(log)
+        .setDebug(true)
+        .build()
+        .create(Example.class);
+
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(200, "OK", NO_HEADERS, null));
+
+    example.something();
+    assertThat(logMessages).hasSize(4);
+    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+    assertThat(logMessages.get(1)).isEqualTo("---> END HTTP (0-byte body)");
+    assertThat(logMessages.get(2)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+    assertThat(logMessages.get(3)).isEqualTo("<--- END HTTP (0-byte body)");
+  }
+
+  /** Not all servers play nice and add content-type headers to responses. */
+  TypedInput inputMissingMimeType = new TypedInput() {
+
+    @Override public String mimeType() {
+      return null;
+    }
+
+    @Override public long length() {
+      return 2;
+    }
+
+    @Override public InputStream in() throws IOException {
+      return new ByteArrayInputStream("{}".getBytes());
+    }
+  };
+
+  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(200, "OK", NO_HEADERS, inputMissingMimeType));
+
+    example.something();
+  }
+
+  @Test public void logSuccessfulRequestResponseOnDebugWhenMimeTypeMissing() throws Exception {
+    final List<String> logMessages = new ArrayList<String>();
+    RestAdapter.Log log = new RestAdapter.Log() {
+      public void log(String message) {
+        logMessages.add(message);
+      }
+    };
+
+    Example example = new RestAdapter.Builder() //
+        .setClient(mockClient)
+        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+        .setServer("http://example.com")
+        .setProfiler(mockProfiler)
+        .setLog(log)
+        .setDebug(true)
+        .build()
+        .create(Example.class);
+
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(200, "OK", NO_HEADERS, inputMissingMimeType));
+
+    example.something();
+    assertThat(logMessages).hasSize(5);
+    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+    assertThat(logMessages.get(1)).isEqualTo("---> END HTTP (0-byte body)");
+    assertThat(logMessages.get(2)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+    assertThat(logMessages.get(3)).isEqualTo("{}");
+    assertThat(logMessages.get(4)).isEqualTo("<--- END HTTP (2-byte body)");
+  }
+
   @Test public void synchronousDoesNotUseExecutors() throws Exception {
     when(mockClient.execute(any(Request.class))) //
         .thenReturn(new Response(200, "OK", NO_HEADERS, null));
@@ -93,8 +209,7 @@
 
   @Test public void asynchronousUsesExecutors() throws Exception {
     Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
+    when(mockClient.execute(any(Request.class))).thenReturn(response);
     Callback<Object> callback = mock(Callback.class);
 
     example.something(callback);
@@ -130,6 +245,79 @@
     }
   }
 
+  @Test public void logErrorRequestResponseOnDebugWhenMimeTypeMissing() throws Exception {
+    final List<String> logMessages = new ArrayList<String>();
+    RestAdapter.Log log = new RestAdapter.Log() {
+      public void log(String message) {
+        logMessages.add(message);
+      }
+    };
+
+    Example example = new RestAdapter.Builder() //
+        .setClient(mockClient)
+        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+        .setServer("http://example.com")
+        .setProfiler(mockProfiler)
+        .setLog(log)
+        .setDebug(true)
+        .build()
+        .create(Example.class);
+
+    Response responseMissingMimeType = //
+        new Response(403, "Forbidden", NO_HEADERS, inputMissingMimeType);
+
+    when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
+
+    try {
+      example.something();
+      fail("RetrofitError expected on non-2XX response code.");
+    } catch (RetrofitError e) {
+      assertThat(e.getResponse().getStatus()).isEqualTo(403);
+    }
+
+    assertThat(logMessages.size()).isEqualTo(5);
+    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+    assertThat(logMessages.get(1)).isEqualTo("---> END HTTP (0-byte body)");
+    assertThat(logMessages.get(2)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
+    assertThat(logMessages.get(3)).isEqualTo("{}");
+    assertThat(logMessages.get(4)).isEqualTo("<--- END HTTP (2-byte body)");
+  }
+
+  @Test public void logErrorRequestResponseOnDebugWhenResponseBodyAbsent() throws Exception {
+    final List<String> logMessages = new ArrayList<String>();
+    RestAdapter.Log log = new RestAdapter.Log() {
+      public void log(String message) {
+        logMessages.add(message);
+      }
+    };
+
+    Example example = new RestAdapter.Builder() //
+        .setClient(mockClient)
+        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
+        .setServer("http://example.com")
+        .setProfiler(mockProfiler)
+        .setLog(log)
+        .setDebug(true)
+        .build()
+        .create(Example.class);
+
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(500, "Internal Server Error", NO_HEADERS, null));
+
+    try {
+      example.something();
+      fail("RetrofitError expected on non-2XX response code.");
+    } catch (RetrofitError e) {
+      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+    }
+
+    assertThat(logMessages.size()).isEqualTo(4);
+    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+    assertThat(logMessages.get(1)).isEqualTo("---> END HTTP (0-byte body)");
+    assertThat(logMessages.get(2)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
+    assertThat(logMessages.get(3)).isEqualTo("<--- END HTTP (0-byte body)");
+  }
+
   @Test public void clientExceptionThrowsNetworkError() throws Exception{
     IOException exception = new IOException("I'm broken.");
     when(mockClient.execute(any(Request.class))).thenThrow(exception);
diff --git a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
index 624684062..064c450d9 100644
--- a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
@@ -31,7 +31,11 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.RestMethodInfo.NO_BODY;
+import static org.junit.Assert.fail;
+import static retrofit.RestMethodInfo.ParamUsage.BODY;
+import static retrofit.RestMethodInfo.ParamUsage.HEADER;
+import static retrofit.RestMethodInfo.ParamUsage.PATH;
+import static retrofit.RestMethodInfo.ParamUsage.QUERY;
 import static retrofit.RestMethodInfo.RequestType.MULTIPART;
 import static retrofit.RestMethodInfo.RequestType.SIMPLE;
 
@@ -39,18 +43,20 @@
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
-    expectParams("foo/bar");
-    expectParams("foo/bar/{}");
-    expectParams("foo/bar/{taco}", "taco");
-    expectParams("foo/bar/{t}", "t");
-    expectParams("foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("foo/bar/{}/{taco}", "taco");
-    expectParams("foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("foo/bar/{taco-shell}", "taco-shell");
-    expectParams("foo/bar/{taco_shell}", "taco_shell");
-    expectParams("foo/bar/{sha256}", "sha256");
-    expectParams("foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+    expectParams("/foo/bar");
+    expectParams("/foo/bar/{}");
+    expectParams("/foo/bar/{taco}", "taco");
+    expectParams("/foo/bar/{t}", "t");
+    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+    expectParams("/foo/bar/{}/{taco}", "taco");
+    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("/foo/bar/{taco-shell}", "taco-shell");
+    expectParams("/foo/bar/{taco_shell}", "taco_shell");
+    expectParams("/foo/bar/{sha256}", "sha256");
+    expectParams("/foo/bar/{TACO}", "TACO");
+    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
   }
 
   private static void expectParams(String path, String... expected) {
@@ -353,7 +359,7 @@ Response a() {
     assertThat(methodInfo.requestUrl).isEqualTo("/foo");
   }
 
-  @Test public void singleQueryParam() {
+  @Test public void singlePathQueryParam() {
     class Example {
       @GET("/foo?a=b")
       Response a() {
@@ -380,15 +386,12 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.requestUrlParam).isEmpty();
-    assertThat(methodInfo.requestQueryName).isEmpty();
-    assertThat(methodInfo.requestFormFields).isEmpty();
-    assertThat(methodInfo.requestMultipartPart).isEmpty();
-    assertThat(methodInfo.bodyIndex).isEqualTo(NO_BODY);
+    assertThat(methodInfo.requestParamNames).isEmpty();
+    assertThat(methodInfo.requestParamUsage).isEmpty();
     assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test public void singleParam() {
+  @Test public void singleQueryParam() {
     class Example {
       @GET("/") Response a(@Query("a") String a) {
         return null;
@@ -399,12 +402,12 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.requestQueryName).hasSize(1).containsSequence("a");
-    assertThat(methodInfo.bodyIndex).isEqualTo(NO_BODY);
+    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
+    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(QUERY);
     assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
-  @Test public void multipleParams() {
+  @Test public void multipleQueryParams() {
     class Example {
       @GET("/") Response a(@Query("a") String a, @Query("b") String b, @Query("c") String c) {
         return null;
@@ -415,8 +418,8 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.requestQueryName).hasSize(3).containsSequence("a", "b", "c");
-    assertThat(methodInfo.bodyIndex).isEqualTo(NO_BODY);
+    assertThat(methodInfo.requestParamNames).hasSize(3).containsExactly("a", "b", "c");
+    assertThat(methodInfo.requestParamUsage).hasSize(3).containsExactly(QUERY, QUERY, QUERY);
     assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
@@ -431,11 +434,8 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.requestUrlParam).containsOnly(new String[] { null });
-    assertThat(methodInfo.requestQueryName).containsOnly(new String[] { null });
-    assertThat(methodInfo.requestFormFields).containsOnly(new String[] { null });
-    assertThat(methodInfo.requestMultipartPart).containsOnly(new String[] { null });
-    assertThat(methodInfo.bodyIndex).isEqualTo(0);
+    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly(new String[] { null });
+    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(BODY);
     assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
@@ -450,11 +450,8 @@ Response a() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.requestUrlParam).containsOnly(new String[] { null });
-    assertThat(methodInfo.requestQueryName).containsOnly(new String[] { null });
-    assertThat(methodInfo.requestFormFields).containsOnly(new String[] { null });
-    assertThat(methodInfo.requestMultipartPart).containsOnly(new String[] { null });
-    assertThat(methodInfo.bodyIndex).isEqualTo(0);
+    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly(new String[] { null });
+    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(BODY);
     assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
@@ -481,11 +478,8 @@ public void twoBodies() {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(methodInfo.requestUrlParam).containsExactly("a", null, "c");
-    assertThat(methodInfo.requestQueryName).containsExactly(null, null, null);
-    assertThat(methodInfo.requestFormFields).containsExactly(null, null, null);
-    assertThat(methodInfo.requestMultipartPart).containsExactly(null, null, null);
-    assertThat(methodInfo.bodyIndex).isEqualTo(1);
+    assertThat(methodInfo.requestParamNames).containsExactly("a", null, "c");
+    assertThat(methodInfo.requestParamUsage).containsExactly(PATH, BODY, PATH);
     assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
   }
 
@@ -709,8 +703,8 @@ Response a(@Header("a") String a, @Header("b") String b) {
     RestMethodInfo methodInfo = new RestMethodInfo(method);
     methodInfo.init();
 
-    assertThat(Arrays.asList(methodInfo.requestParamHeader))
-      .isEqualTo(Arrays.asList("a", "b"));
+    assertThat(methodInfo.requestParamNames).containsExactly("a", "b");
+    assertThat(methodInfo.requestParamUsage).containsExactly(HEADER, HEADER);
   }
 
   @Test(expected = IllegalStateException.class)
@@ -743,6 +737,23 @@ Response a() {
     methodInfo.init();
   }
 
+  @Test public void invalidPathParam() throws Exception {
+    class Example {
+      @GET("/") Response a(@Path("hey!") String thing) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    try {
+      methodInfo.init();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).startsWith("Path parameter name is not valid: hey!.");
+    }
+  }
+
   private static class Response {
   }
 
