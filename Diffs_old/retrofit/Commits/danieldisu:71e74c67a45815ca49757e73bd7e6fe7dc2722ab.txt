diff --git a/retrofit/src/main/java/retrofit/ResponseInterceptor.java b/retrofit/src/main/java/retrofit/ResponseInterceptor.java
new file mode 100644
index 000000000..d135baf4b
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ResponseInterceptor.java
@@ -0,0 +1,92 @@
+package retrofit;
+
+import org.apache.commons.io.IOUtils;
+import retrofit.client.Header;
+import retrofit.client.Response;
+import retrofit.http.Body;
+import retrofit.mime.TypedByteArray;
+import retrofit.mime.TypedInput;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.List;
+
+/**
+ * Created by ddiaz on 25/04/14.
+ */
+public interface ResponseInterceptor {
+  ResponseFacade intercept(ResponseFacade responseFacade);
+
+  boolean shouldRepeatRequestAfterIntercept();
+
+  public class ResponseFacade {
+
+    private final Response originalResponse;
+    private Response newResponse;
+    private TypedByteArray originalResponseBody = null;
+
+    ResponseFacade(Response originalResponse) {
+      this.originalResponse = originalResponse;
+      this.newResponse = new Response(originalResponse.getUrl(), originalResponse.getStatus(), originalResponse.getReason(), originalResponse.getHeaders(), getOriginalResponseBody());
+    }
+
+    private void changeResponseBody(String newBody) {
+      // TODO
+    }
+
+    public void changeStatus(int newStatus) {
+      this.newResponse = new Response(newResponse.getUrl(), newStatus, newResponse.getReason(), newResponse.getHeaders(), newResponse.getBody());
+    }
+
+    public void changeHeaders(List<Header> headers) {
+      this.newResponse = new Response(newResponse.getUrl(), newResponse.getStatus(), newResponse.getReason(), headers, newResponse.getBody());
+    }
+
+    public void addHeader(Header header) {
+      originalResponse.getHeaders().add(header);
+      this.newResponse = new Response(newResponse.getUrl(), newResponse.getStatus(), newResponse.getReason(), newResponse.getHeaders(), newResponse.getBody());
+    }
+
+    public TypedByteArray getOriginalResponseBody() {
+      if(originalResponseBody != null){
+        return originalResponseBody;
+      }
+
+      TypedByteArray newBody = null;
+      InputStream is = null;
+      try {
+        is = originalResponse.getBody().in();
+        byte[] bytes = IOUtils.toByteArray(is);
+        originalResponseBody = new TypedByteArray(originalResponse.getBody().mimeType(), bytes);
+        return originalResponseBody;
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+      return originalResponseBody;
+    }
+
+    public int getOriginalResponseStatus() {
+      return originalResponse.getStatus();
+    }
+
+    protected Response getNewResponse() {
+      return this.newResponse;
+    }
+  }
+
+  /**
+   * A {@link ResponseInterceptor} which does no modification of requests.
+   */
+  ResponseInterceptor NONE = new ResponseInterceptor() {
+    @Override
+    public ResponseFacade intercept(ResponseFacade responseFacade) {
+      return responseFacade;
+    }
+
+    @Override public boolean shouldRepeatRequestAfterIntercept() {
+      return false;
+    }
+  };
+}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 18174734f..bfc4b251c 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
+
 import retrofit.Profiler.RequestInformation;
 import retrofit.client.Client;
 import retrofit.client.Header;
@@ -45,24 +46,24 @@
 
 /**
  * Adapts a Java interface to a REST API.
- * <p>
+ * <p/>
  * API endpoints are defined as methods on an interface with annotations providing metadata about
  * the form in which the HTTP call should be made.
- * <p>
+ * <p/>
  * The relative path for a given method is obtained from an annotation on the method describing
  * the request type. The built-in methods are {@link retrofit.http.GET GET},
  * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.HEAD HEAD},
  * and {@link retrofit.http.DELETE DELETE}. You can define your own HTTP method by creating an
  * annotation that takes a {code String} value and itself is annotated with
  * {@link retrofit.http.RestMethod @RestMethod}.
- * <p>
+ * <p/>
  * Method parameters can be used to replace parts of the URL by annotating them with
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
  * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
  * {@link retrofit.http.Query @Query}. If the path or query element has already been URI encoded
  * use {@link retrofit.http.EncodedPath @EncodedPath} or
  * {@link retrofit.http.EncodedQuery @EncodedQuery} to prevent repeated encoding.
- * <p>
+ * <p/>
  * HTTP requests happen in one of two ways:
  * <ul>
  * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
@@ -74,13 +75,13 @@
  * response will be converted to the method's return type using the specified
  * {@link retrofit.converter.Converter Converter}.
  * </ul>
- * <p>
+ * <p/>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
  * will be converted to request representation by a call to
  * {@link retrofit.converter.Converter#toBody(Object) toBody} on the supplied
  * {@link retrofit.converter.Converter Converter} for this instance. The body can also be a
  * {@link TypedOutput} where it will be used directly.
- * <p>
+ * <p/>
  * Alternative request body formats are supported by method annotations and corresponding parameter
  * annotations:
  * <ul>
@@ -89,11 +90,11 @@
  * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
  * specified by the {@link retrofit.http.Part @Part} parameter annotation.
  * </ul>
- * <p>
+ * <p/>
  * Additional static headers can be added for an endpoint using the
  * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
  * annotate a parameter with {@link Header @Header}.
- * <p>
+ * <p/>
  * For example:
  * <pre>
  * public interface MyApi {
@@ -104,7 +105,7 @@
  *   List&lt;Item&gt; categoryList(@Path("cat") String a, @Query("page") int b);
  * }
  * </pre>
- * <p>
+ * <p/>
  * Calling {@link #create(Class)} with {@code MyApi.class} will validate and create a new
  * implementation of the API.
  *
@@ -115,29 +116,43 @@
   static final String THREAD_PREFIX = "Retrofit-";
   static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
 
-  /** Simple logging abstraction for debug messages. */
+  /**
+   * Simple logging abstraction for debug messages.
+   */
   public interface Log {
-    /** Log a debug message to the appropriate console. */
+    /**
+     * Log a debug message to the appropriate console.
+     */
     void log(String message);
 
-    /** A {@link Log} implementation which does not log anything. */
+    /**
+     * A {@link Log} implementation which does not log anything.
+     */
     Log NONE = new Log() {
       @Override public void log(String message) {
       }
     };
   }
 
-  /** Controls the level of logging. */
+  /**
+   * Controls the level of logging.
+   */
   public enum LogLevel {
-    /** No logging. */
+    /**
+     * No logging.
+     */
     NONE,
-    /** Log only the request method and URL and the response status code and execution time. */
+    /**
+     * Log only the request method and URL and the response status code and execution time.
+     */
     BASIC,
-    /** Log the basic information along with request and response headers. */
+    /**
+     * Log the basic information along with request and response headers.
+     */
     HEADERS,
     /**
      * Log the headers, body, and metadata for both requests and responses.
-     * <p>
+     * <p/>
      * Note: This requires that the entire request and response body be buffered in memory!
      */
     FULL;
@@ -148,12 +163,13 @@ public boolean log() {
   }
 
   private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
+    new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
 
   final Endpoint server;
   final Executor httpExecutor;
   final Executor callbackExecutor;
   final RequestInterceptor requestInterceptor;
+  final ResponseInterceptor responseInterceptor;
   final Converter converter;
   final Log log;
   final ErrorHandler errorHandler;
@@ -165,13 +181,14 @@ public boolean log() {
   volatile LogLevel logLevel;
 
   private RestAdapter(Endpoint server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
-      Profiler profiler, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
+                      Executor callbackExecutor, RequestInterceptor requestInterceptor, ResponseInterceptor responseInterceptor, Converter converter,
+                      Profiler profiler, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
     this.callbackExecutor = callbackExecutor;
     this.requestInterceptor = requestInterceptor;
+    this.responseInterceptor = responseInterceptor;
     this.converter = converter;
     this.profiler = profiler;
     this.errorHandler = errorHandler;
@@ -184,7 +201,9 @@ private RestAdapter(Endpoint server, Client.Provider clientProvider, Executor ht
     }
   }
 
-  /** Change the level of logging. */
+  /**
+   * Change the level of logging.
+   */
   public void setLogLevel(LogLevel loglevel) {
     if (logLevel == null) {
       throw new NullPointerException("Log level may not be null.");
@@ -192,17 +211,21 @@ public void setLogLevel(LogLevel loglevel) {
     this.logLevel = loglevel;
   }
 
-  /** The current logging level. */
+  /**
+   * The current logging level.
+   */
   public LogLevel getLogLevel() {
     return logLevel;
   }
 
-  /** Create an implementation of the API defined by the specified {@code service} interface. */
+  /**
+   * Create an implementation of the API defined by the specified {@code service} interface.
+   */
   @SuppressWarnings("unchecked")
   public <T> T create(Class<T> service) {
     Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler(getMethodInfoCache(service)));
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
+      new RestHandler(getMethodInfoCache(service)));
   }
 
   Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
@@ -227,7 +250,9 @@ static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method me
     }
   }
 
-  /** Indirection to avoid VerifyError if RxJava isn't present. */
+  /**
+   * Indirection to avoid VerifyError if RxJava isn't present.
+   */
   private static final class RxSupport {
     private final Scheduler scheduler;
     private final ErrorHandler errorHandler;
@@ -270,7 +295,7 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
 
     @SuppressWarnings("unchecked") //
     @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
+      throws Throwable {
       // If the method is a method from Object then defer to normal invocation.
       if (method.getDeclaringClass() == Object.class) {
         return method.invoke(this, args);
@@ -281,12 +306,12 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
 
       if (methodInfo.isSynchronous) {
         try {
-          return invokeRequest(requestInterceptor, methodInfo, args);
+          return invokeRequest(requestInterceptor, responseInterceptor, methodInfo, args);
         } catch (RetrofitError error) {
           Throwable newError = errorHandler.handleError(error);
           if (newError == null) {
             throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
+              error);
           }
           throw newError;
         }
@@ -304,7 +329,7 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
       if (methodInfo.isObservable) {
         return rxSupport.createRequestObservable(new Callable<ResponseWrapper>() {
           @Override public ResponseWrapper call() throws Exception {
-            return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
+            return (ResponseWrapper) invokeRequest(interceptorTape, responseInterceptor, methodInfo, args);
           }
         });
       }
@@ -312,7 +337,7 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
       Callback<?> callback = (Callback<?>) args[args.length - 1];
       httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor, errorHandler) {
         @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
+          return (ResponseWrapper) invokeRequest(interceptorTape, responseInterceptor, methodInfo, args);
         }
       });
       return null; // Asynchronous methods should have return type of void.
@@ -324,8 +349,8 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
      * @return HTTP response object of specified {@code type} or {@code null}.
      * @throws RetrofitError if any error occurs during the HTTP request.
      */
-    private Object invokeRequest(RequestInterceptor requestInterceptor,
-        RestMethodInfo methodInfo, Object[] args) {
+    private Object invokeRequest(RequestInterceptor requestInterceptor, ResponseInterceptor responseInterceptor,
+                                 RestMethodInfo methodInfo, Object[] args) {
       methodInfo.init(); // Ensure all relevant method information has been loaded.
 
       String serverUrl = server.getUrl();
@@ -370,6 +395,16 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
           response = logAndReplaceResponse(url, response, elapsedTime);
         }
 
+        if (responseInterceptor != null) {
+          final ResponseInterceptor.ResponseFacade responseFacade = new ResponseInterceptor.ResponseFacade(response);
+          response = responseInterceptor.intercept(responseFacade).getNewResponse();
+          if (response.getStatus() == 401) {
+            requestInterceptor.intercept(requestBuilder);
+            Request newRequest = requestBuilder.build();
+            response = clientProvider.get().execute(newRequest);
+          }
+        }
+
         Type type = methodInfo.responseObjectType;
 
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
@@ -388,7 +423,6 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
           if (body == null) {
             return new ResponseWrapper(response, null);
           }
-
           ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
           try {
             Object convert = converter.fromBody(wrapped, type);
@@ -432,7 +466,9 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
     }
   }
 
-  /** Log request headers and body. Consumes request body and returns identical replacement. */
+  /**
+   * Log request headers and body. Consumes request body and returns identical replacement.
+   */
   Request logAndReplaceRequest(String name, Request request) throws IOException {
     log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
 
@@ -469,9 +505,11 @@ Request logAndReplaceRequest(String name, Request request) throws IOException {
     return request;
   }
 
-  /** Log response headers and body. Consumes response body and returns identical replacement. */
+  /**
+   * Log response headers and body. Consumes response body and returns identical replacement.
+   */
   private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
-      throws IOException {
+    throws IOException {
     log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
 
     if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
@@ -509,7 +547,9 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
     return response;
   }
 
-  /** Log an exception that occurred during the processing of a request or response. */
+  /**
+   * Log an exception that occurred during the processing of a request or response.
+   */
   void logException(Throwable t, String url) {
     log.log(String.format("---- ERROR %s", url));
     StringWriter sw = new StringWriter();
@@ -519,7 +559,7 @@ void logException(Throwable t, String url) {
   }
 
   private static Profiler.RequestInformation getRequestInfo(String serverUrl,
-      RestMethodInfo methodDetails, Request request) {
+                                                            RestMethodInfo methodDetails, Request request) {
     long contentLength = 0;
     String contentType = null;
 
@@ -530,19 +570,19 @@ void logException(Throwable t, String url) {
     }
 
     return new Profiler.RequestInformation(methodDetails.requestMethod, serverUrl,
-        methodDetails.requestUrl, contentLength, contentType);
+      methodDetails.requestUrl, contentLength, contentType);
   }
 
   /**
    * Build a new {@link RestAdapter}.
-   * <p>
+   * <p/>
    * Calling the following methods is required before calling {@link #build()}:
    * <ul>
    * <li>{@link #setEndpoint(Endpoint)}</li>
    * <li>{@link #setClient(Client.Provider)}</li>
    * <li>{@link #setConverter(Converter)}</li>
    * </ul>
-   * <p>
+   * <p/>
    * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
    * is also required:
    * <ul>
@@ -560,6 +600,7 @@ void logException(Throwable t, String url) {
     private ErrorHandler errorHandler;
     private Log log;
     private LogLevel logLevel = LogLevel.NONE;
+    private ResponseInterceptor responseInterceptor = ResponseInterceptor.NONE;
 
     /**
      * API server base URL.
@@ -583,7 +624,9 @@ public Builder setServer(Server server) {
       return setEndpoint(server);
     }
 
-    /** API endpoint URL. */
+    /**
+     * API endpoint URL.
+     */
     public Builder setEndpoint(String endpoint) {
       if (endpoint == null || endpoint.trim().length() == 0) {
         throw new NullPointerException("Endpoint may not be blank.");
@@ -592,7 +635,9 @@ public Builder setEndpoint(String endpoint) {
       return this;
     }
 
-    /** API endpoint. */
+    /**
+     * API endpoint.
+     */
     public Builder setEndpoint(Endpoint endpoint) {
       if (endpoint == null) {
         throw new NullPointerException("Endpoint may not be null.");
@@ -601,7 +646,9 @@ public Builder setEndpoint(Endpoint endpoint) {
       return this;
     }
 
-    /** The HTTP client used for requests. */
+    /**
+     * The HTTP client used for requests.
+     */
     public Builder setClient(final Client client) {
       if (client == null) {
         throw new NullPointerException("Client may not be null.");
@@ -613,7 +660,9 @@ public Builder setClient(final Client client) {
       });
     }
 
-    /** The HTTP client used for requests. */
+    /**
+     * The HTTP client used for requests.
+     */
     public Builder setClient(Client.Provider clientProvider) {
       if (clientProvider == null) {
         throw new NullPointerException("Client provider may not be null.");
@@ -625,10 +674,10 @@ public Builder setClient(Client.Provider clientProvider) {
     /**
      * Executors used for asynchronous HTTP client downloads and callbacks.
      *
-     * @param httpExecutor Executor on which HTTP client calls will be made.
+     * @param httpExecutor     Executor on which HTTP client calls will be made.
      * @param callbackExecutor Executor on which any {@link Callback} methods will be invoked. If
-     * this argument is {@code null} then callback methods will be run on the same thread as the
-     * HTTP client.
+     *                         this argument is {@code null} then callback methods will be run on the same thread as the
+     *                         HTTP client.
      */
     public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
       if (httpExecutor == null) {
@@ -642,7 +691,9 @@ public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
       return this;
     }
 
-    /** A request interceptor for adding data to every request. */
+    /**
+     * A request interceptor for adding data to every request.
+     */
     public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
       if (requestInterceptor == null) {
         throw new NullPointerException("Request interceptor may not be null.");
@@ -651,7 +702,17 @@ public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
       return this;
     }
 
-    /** The converter used for serialization and deserialization of objects. */
+    public Builder setResponseInterceptor(ResponseInterceptor responseInterceptor) {
+      if (responseInterceptor == null) {
+        throw new NullPointerException("Response interceptor may not be null.");
+      }
+      this.responseInterceptor = responseInterceptor;
+      return this;
+    }
+
+    /**
+     * The converter used for serialization and deserialization of objects.
+     */
     public Builder setConverter(Converter converter) {
       if (converter == null) {
         throw new NullPointerException("Converter may not be null.");
@@ -660,7 +721,9 @@ public Builder setConverter(Converter converter) {
       return this;
     }
 
-    /** Set the profiler used to measure requests. */
+    /**
+     * Set the profiler used to measure requests.
+     */
     public Builder setProfiler(Profiler profiler) {
       if (profiler == null) {
         throw new NullPointerException("Profiler may not be null.");
@@ -681,7 +744,9 @@ public Builder setErrorHandler(ErrorHandler errorHandler) {
       return this;
     }
 
-    /** Configure debug logging mechanism. */
+    /**
+     * Configure debug logging mechanism.
+     */
     public Builder setLog(Log log) {
       if (log == null) {
         throw new NullPointerException("Log may not be null.");
@@ -690,7 +755,9 @@ public Builder setLog(Log log) {
       return this;
     }
 
-    /** Change the level of logging. */
+    /**
+     * Change the level of logging.
+     */
     public Builder setLogLevel(LogLevel logLevel) {
       if (logLevel == null) {
         throw new NullPointerException("Log level may not be null.");
@@ -699,14 +766,16 @@ public Builder setLogLevel(LogLevel logLevel) {
       return this;
     }
 
-    /** Create the {@link RestAdapter} instances. */
+    /**
+     * Create the {@link RestAdapter} instances.
+     */
     public RestAdapter build() {
       if (endpoint == null) {
         throw new IllegalArgumentException("Endpoint may not be null.");
       }
       ensureSaneDefaults();
       return new RestAdapter(endpoint, clientProvider, httpExecutor, callbackExecutor,
-          requestInterceptor, converter, profiler, errorHandler, log, logLevel);
+        requestInterceptor, responseInterceptor, converter, profiler, errorHandler, log, logLevel);
     }
 
     private void ensureSaneDefaults() {
