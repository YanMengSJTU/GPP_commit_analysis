diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 86228d5c3..c221b21c9 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,10 +18,14 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
+// 말 그대로 빌트인으로 제공하는 Converters.
+// "기본" Converter 로써 사용된다.
+// Retrofit.Builder#build를 보면 다른 converter들보다 먼저 list에 넣는 것을 볼 수 있음.
 final class BuiltInConverters extends Converter.Factory {
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
@@ -86,6 +90,7 @@
     }
   }
 
+  // Object를 String으로 바꾸는 Converter.
   static final class ToStringConverter implements Converter<Object, String> {
     static final ToStringConverter INSTANCE = new ToStringConverter();
 
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..005f27160 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,9 +16,15 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 
 /**
+ * Call. Request를 감싸는 녀석인 것 같은데..
+ * execute - synchronous request
+ * enqueue - asynchronous request
+ * cancel - cancel invoked request.
+ *
  * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 97d34585d..28671892a 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+
 import javax.annotation.Nullable;
 
 /**
@@ -38,6 +39,11 @@
   Type responseType();
 
   /**
+   * Call을 위임하는 것 같다.
+   * 가령.. 우리가 반환형을 Call이 아니라 Observable로 선언했다면
+   * {@code Call<R>}를 {@code Observable<R>}로 바꿔줘야 하는데
+   * 이럴 때 사용하는 것 같다.
+   *
    * Returns an instance of {@code T} which delegates to {@code call}.
    * <p>
    * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 62c93a621..10c824725 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -15,6 +15,8 @@
  */
 package retrofit2;
 
+// 그냥 Callback임. enqueue했을 때.
+
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 37a64f8d1..e7c40d526 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -19,7 +19,9 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+
 import javax.annotation.Nullable;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
@@ -33,6 +35,15 @@
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
 
+/**
+ *
+ * 이녀석은 선언한걸로만 보면 그냥 F라는 클래스를 T로 변환시키는 컨버터인데,
+ * 실제 구현들을 보면 주로 ResponseBody -> 다른 무언가로 바꾸는 경우가 많아 보임.
+ *
+ * 예시로.. {@link retrofit2.BuiltInConverters.ToStringConverter}
+ * -> 이건 그냥 단순히 Object.toString()을 호출하는 컨버터.
+ */
+
 /**
  * Convert objects to and from their representation in HTTP. Instances are created by {@linkplain
  * Factory a factory} which is {@linkplain Retrofit.Builder#addConverterFactory(Factory) installed}
@@ -44,6 +55,9 @@
   /** Creates {@link Converter} instances based on a type and target usage. */
   abstract class Factory {
     /**
+     * 받은 ResponseBody를 원하는 type으로 바꿀 때 쓰는 converter.
+     * 아무래도 Response를 받았을 떄 호출되겠지?
+     *
      * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
      * {@code type} cannot be handled by this factory. This is used to create converters for
      * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
@@ -55,6 +69,9 @@
     }
 
     /**
+     * 이건.. 원하는 타입을 RequestBody로 바꿀 때 쓰는 converter.
+     * 그럼 Request를 날리기 전에 이녀석을 통과하겠구만..
+     *
      * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
      * {@code type} cannot be handled by this factory. This is used to create converters for types
      * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..acd77a5f7 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -17,8 +17,15 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
 
 /**
+ * 그냥 우리가 일반적으로 {@code Call<String>} 이런 식으로 쓰는거.
+ * {@link Platform#defaultCallAdapterFactory(Executor)}
+ * 여기를 보면 default로 사용하고 있는 것을 알 수 있다.
+ * 아래 설명을 보면 CallAdapter가 IO 작업과 application-level 작업에 같은 쓰레드를 사용한다고 나옴.
+ * (Android에서 application-level 작업이라면 당연히 UI 작업이겠지?)
+ *
  * Creates call adapters for that uses the same thread for both I/O and application-level
  * callbacks. For synchronous calls this is the application thread making the request; for
  * asynchronous calls this is a thread provided by OkHttp's dispatcher.
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index f819c7863..b534ed6f5 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,10 +19,18 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 
 import static retrofit2.Utils.checkNotNull;
 
+/**
+ * DefaultCallAdapterFactory와는 다르게 이 녀석은 asynchronous call을 했을 때
+ * I/O 작업과 UI 작업의 쓰레드가 서로 다름.
+ *
+ * 그렇다면 우리가 안드로이드쪽에서 enqueue()를 호출할 떄 그 콜백은
+ * 메인쓰레드에서 실행하는게 보장이 되어있다는 거네요. 와우
+ */
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index b6d13cedf..eaa42da2e 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -18,11 +18,23 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+
 import javax.annotation.Nullable;
+
 import okhttp3.ResponseBody;
 
 import static retrofit2.Utils.methodError;
 
+/**
+ * ServiceMethod의 구현체.
+ * 마찬가지로 Builder 패턴을 사용했음.
+ *
+ * 이걸 잘 보면 RequestFactory, CallFactory를 가지고 있는 것을 볼 수 있음.
+ * 왜 Factory일까? - Retrofit을 보면 ServiceMethod에 대한 cache를 가지고 있음.
+ * 즉 이 HttpServiceMethod는 여러 번 request를 날릴 때 재사용 된다는거고..
+ * 그래서 Request"Factory"이고 Call"Factory"인 것임.
+ */
+
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
   private final RequestFactory requestFactory;
@@ -64,6 +76,7 @@
     HttpServiceMethod<ResponseT, ReturnT> build() {
       requestFactory = RequestFactory.parseAnnotations(retrofit, method);
 
+      // call adapter retrofit에서 가져오고
       callAdapter = createCallAdapter();
       responseType = callAdapter.responseType();
       if (responseType == Response.class || responseType == okhttp3.Response.class) {
@@ -71,12 +84,15 @@
             + Utils.getRawType(responseType).getName()
             + "' is not a valid response body type. Did you mean ResponseBody?");
       }
+      
+      // response converter retrofit에서 가져오고
       responseConverter = createResponseConverter();
 
       if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
         throw methodError(method, "HEAD method must use Void as response type.");
       }
 
+      // 생성!
       return new HttpServiceMethod<>(this);
     }
 
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 3a4d0562d..634a4fd8e 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,8 +16,10 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -29,6 +31,8 @@
 import static retrofit2.Utils.checkNotNull;
 import static retrofit2.Utils.throwIfFatal;
 
+// OkHttpCall.. Call의 구현체임.
+
 final class OkHttpCall<T> implements Call<T> {
   private final RequestFactory requestFactory;
   private final @Nullable Object[] args;
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 929413418..70455f84c 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -18,20 +18,35 @@
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+
 import javax.annotation.Nullable;
+
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
 
 import static retrofit2.Utils.checkNotNull;
 
+/**
+ * Parameter Handler.
+ * 파라미터 어노테이션에 따라서 여러 가지가 정의되어 있음.
+ * (RelativeUrl, Header, Path 등등)
+ */
 abstract class ParameterHandler<T> {
   abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;
 
+  // 정말 영리한 방식으로 메소드를 만들었음.
+  // 일단 apply에서는 어떤 Type에 대한 처리를 기술함.
+  // iterable()과 array()에서는 자신의 apply()를 이용해서 새로운 ParameterHandler를 만듦.
+  // 이런 방식으로 따로 클래스를 만들지 않고 dynamic하게 만들 수 있을 뿐더러
+  // 호출하는 쪽에서도 iterable인지, array인지를 손쉽게 바꿀 수 있게 됨.
+  
   final ParameterHandler<Iterable<T>> iterable() {
     return new ParameterHandler<Iterable<T>>() {
       @Override void apply(RequestBuilder builder, @Nullable Iterable<T> values)
           throws IOException {
+        // return을 하는게 아니라 들어온 builde에 apply를 하는 개념이라
+        // null에 대해서 skip하는게 가능해짐..
         if (values == null) return; // Skip null values.
 
         for (T value : values) {
@@ -53,14 +68,21 @@
       }
     };
   }
-
+  
+  /**
+   * RequestBuilder의 relativeUrl 재지정
+   * @see retrofit2.http.Url
+   */
   static final class RelativeUrl extends ParameterHandler<Object> {
     @Override void apply(RequestBuilder builder, @Nullable Object value) {
       checkNotNull(value, "@Url parameter is null.");
       builder.setRelativeUrl(value);
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.Header
+   */
   static final class Header<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -79,7 +101,10 @@
       builder.addHeader(name, headerValue);
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.Path
+   */
   static final class Path<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -99,7 +124,10 @@
       builder.addPathParam(name, valueConverter.convert(value), encoded);
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.Query
+   */
   static final class Query<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -120,7 +148,10 @@
       builder.addQueryParam(name, queryValue, encoded);
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.QueryName
+   */
   static final class QueryName<T> extends ParameterHandler<T> {
     private final Converter<T, String> nameConverter;
     private final boolean encoded;
@@ -135,7 +166,10 @@
       builder.addQueryParam(nameConverter.convert(value), null, encoded);
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.QueryMap
+   */
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
@@ -162,6 +196,7 @@
               "Query map contained null value for key '" + entryKey + "'.");
         }
 
+        // converter가 null을 반환할 경우를 상정한 error handling.
         String convertedEntryValue = valueConverter.convert(entryValue);
         if (convertedEntryValue == null) {
           throw new IllegalArgumentException("Query map value '"
@@ -177,7 +212,10 @@
       }
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.HeaderMap
+   */
   static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
 
@@ -191,6 +229,7 @@
         throw new IllegalArgumentException("Header map was null.");
       }
 
+      // Map#entrySet()을 이용한 foreach.
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String headerName = entry.getKey();
         if (headerName == null) {
@@ -205,7 +244,10 @@
       }
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.Field
+   */
   static final class Field<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -226,7 +268,10 @@
       builder.addFormField(name, fieldValue, encoded);
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.FieldMap
+   */
   static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
@@ -268,7 +313,10 @@
       }
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.Part
+   */
   static final class Part<T> extends ParameterHandler<T> {
     private final Headers headers;
     private final Converter<T, RequestBody> converter;
@@ -291,6 +339,9 @@
     }
   }
 
+  // 왜 이것만 싱글턴일까? 조금 생각을 해봤더니..
+  // 이건 field가 필요하지 않음! 그러니까 서로 다른 버전의 RawPart가 필요하지 않다는거.
+  // 이것만 싱글턴으로 한게 아니라 이것밖에 싱글턴으로 할 수 없었던 것..
   static final class RawPart extends ParameterHandler<MultipartBody.Part> {
     static final RawPart INSTANCE = new RawPart();
 
@@ -303,7 +354,10 @@ private RawPart() {
       }
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.PartMap
+   */
   static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, RequestBody> valueConverter;
     private final String transferEncoding;
@@ -338,7 +392,10 @@ private RawPart() {
       }
     }
   }
-
+  
+  /**
+   * @see retrofit2.http.Body
+   */
   static final class Body<T> extends ParameterHandler<T> {
     private final Converter<T, RequestBody> converter;
 
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 092c95f8f..233b2d36e 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,23 +18,38 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+
 import javax.annotation.Nullable;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+/**
+ * Platform - 말 그대로 Retrofit이 실행될 플랫폼을 가리키는 것 같음.
+ *
+ * {@link Retrofit#create(Class)} 실행할 때 Proxy를 만드는데,
+ * 이 때 InvocationHandler에서 default 메소드 여부를 가지고 그냥 default 메소드를 실행할지,
+ * 아니면 어노테이션을 가지고 바인딩을 할지 결정함.
+ *
+ * 이 클래스의 목적
+ * 1. inteface에서 default method 여부를 판별하기 위한 것.
+ */
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
   static Platform get() {
     return PLATFORM;
   }
-
+  
+  // 안드로이드, 자바에서만 있는 클래스를 찾아서 ClassNotFoundException이 일어나는지를 가지고 플랫폼을 판단함. 신박하다!
   private static Platform findPlatform() {
     try {
       Class.forName("android.os.Build");
+      // SDK_INT가 0일 수 있을까? 아무튼 Android임
       if (Build.VERSION.SDK_INT != 0) {
         return new Android();
       }
@@ -48,10 +63,12 @@ private static Platform findPlatform() {
     return new Platform();
   }
 
+  // Platform에 따라서 달라질 수 있는, callback이 실행되어야 할 default executor를 정의함
   @Nullable Executor defaultCallbackExecutor() {
     return null;
   }
-
+  
+  // Platform에 따라서 달라질 수 있는, callback이 실행되어야 할 default call adapter를 정의함
   CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
     if (callbackExecutor != null) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
@@ -59,10 +76,12 @@ private static Platform findPlatform() {
     return DefaultCallAdapterFactory.INSTANCE;
   }
 
+  // Default 메소드 지원하는지 체크
   boolean isDefaultMethod(Method method) {
     return false;
   }
-
+  
+  //Default 메소드 지원할 경우 실행. 아니면 exception 던짐
   @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
       @Nullable Object... args) throws Throwable {
     throw new UnsupportedOperationException();
@@ -105,6 +124,7 @@ boolean isDefaultMethod(Method method) {
       return new ExecutorCallAdapterFactory(callbackExecutor);
     }
 
+    // 동작을 메인 쓰레드에서 수행하는 Executor.
     static class MainThreadExecutor implements Executor {
       private final Handler handler = new Handler(Looper.getMainLooper());
 
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 436240cc4..7b2223e89 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,7 +16,9 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import javax.annotation.Nullable;
+
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -86,14 +88,17 @@ void addHeader(String name, String value) {
     }
   }
 
+  // url에 포함된 {path_param} 부분을 실제 값으로 치환하는 부분.
   void addPathParam(String name, String value, boolean encoded) {
+    // @Query랑 @Path를 함께 쓰면 안되기 때문에..
     if (relativeUrl == null) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
     relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
   }
-
+  
+  // 인코딩이 필요한지 테스트. - 필요 시 인코딩하고 아니면 안함
   private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
     int codePoint;
     for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
@@ -113,6 +118,7 @@ private static String canonicalizeForPath(String input, boolean alreadyEncoded)
     return input;
   }
 
+  // URL Encoding 수행
   private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
       boolean alreadyEncoded) {
     Buffer utf8Buffer = null; // Lazily allocated.
@@ -129,6 +135,9 @@ private static void canonicalizeForPath(Buffer out, String input, int pos, int l
         if (utf8Buffer == null) {
           utf8Buffer = new Buffer();
         }
+        // 안 -> utf8Buffer
+        // utf8Buffer.readByte() -> first 1byte of 안 -> %EC
+        // utf8Buffer.readByte() -> second 1byte of 안 -> %95
         utf8Buffer.writeUtf8CodePoint(codePoint);
         while (!utf8Buffer.exhausted()) {
           int b = utf8Buffer.readByte() & 0xff;
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index ee7cdba41..08d92d29a 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -26,7 +26,9 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import javax.annotation.Nullable;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -58,7 +60,15 @@
 import static retrofit2.Utils.methodError;
 import static retrofit2.Utils.parameterError;
 
+/**
+ * 자, 이제 여기서 annotation handling의 진수를 확인할 수 있음. 잘 보고 최대한 배워보자!!
+ * RequestFactory - 이 녀석의 역할은 뭘까? 말 그대로 Request를 만들어내는 공장임.
+ * Factory인 이유는.. 아마도 한 번 annotation processing을 한 다음 여러 개의 request를 보낼 때
+ * 이걸 이용해서 하기 때문인 것 같음.
+ */
+
 final class RequestFactory {
+  // Retrofit과 Method 정의(API inteface의)를 가지고 RequestFactory를 만드는 작업.
   static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     return new Builder(retrofit, method).build();
   }
@@ -106,6 +116,9 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   }
 
   /**
+   * 역시나 Builder 패턴을 사용했음.
+   * 설명을 보니 계산 비용이 매우 큰 reflection을 사용하니 한 번 만들고 재사용하는게 좋을 거라고 하네..
+   *
    * Inspects the annotations on an interface method to construct a reusable service method. This
    * requires potentially-expensive reflection so it is best to build each service method only once
    * and reuse it. Builders cannot be reused.
@@ -113,6 +126,8 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   static final class Builder {
     // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
     private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    
+    // @GET("some/url/{param}") 이런걸 찾을 때 쓰는 regex
     private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
     private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
 
@@ -122,6 +137,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     final Annotation[][] parameterAnnotationsArray;
     final Type[] parameterTypes;
 
+    // got - parameter processing 여부를 나타내는 boolean 값
     boolean gotField;
     boolean gotPart;
     boolean gotBody;
@@ -130,11 +146,13 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     boolean gotQueryName;
     boolean gotQueryMap;
     boolean gotUrl;
+    
     String httpMethod;
     boolean hasBody;
     boolean isFormEncoded;
     boolean isMultipart;
     String relativeUrl;
+    
     Headers headers;
     MediaType contentType;
     Set<String> relativeUrlParamNames;
@@ -149,10 +167,12 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     }
 
     RequestFactory build() {
+      // 메소드에 달린 annotation 처리.
       for (Annotation annotation : methodAnnotations) {
         parseMethodAnnotation(annotation);
       }
 
+      // 파싱한거에 대해서 여러 가지 테스트
       if (httpMethod == null) {
         throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
       }
@@ -168,6 +188,7 @@ RequestFactory build() {
         }
       }
 
+      // 각 파라미터에 달린 annotation 처리.
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
@@ -185,6 +206,7 @@ RequestFactory build() {
         parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
       }
 
+      // 파싱한거에 대해서 여러 가지 테스트
       if (relativeUrl == null && !gotUrl) {
         throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
       }
@@ -201,7 +223,9 @@ RequestFactory build() {
       return new RequestFactory(this);
     }
 
+    // 메소드 지정 어노테이션 파싱
     private void parseMethodAnnotation(Annotation annotation) {
+      // REST API method별로 설정하고~
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
       } else if (annotation instanceof GET) {
@@ -220,6 +244,7 @@ private void parseMethodAnnotation(Annotation annotation) {
         HTTP http = (HTTP) annotation;
         parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
       } else if (annotation instanceof retrofit2.http.Headers) {
+        // 헤더 파싱하고~
         String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
         if (headersToParse.length == 0) {
           throw methodError(method, "@Headers annotation is empty.");
@@ -237,8 +262,13 @@ private void parseMethodAnnotation(Annotation annotation) {
         isFormEncoded = true;
       }
     }
-
+  
+    /**
+     * 메소드 지정 annotation에서 여러 가지 값들을 추출.
+     * @param hasBody - POST, PUT, PATCH는 true.
+     */
     private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+      // HTTP method가 여러개인지 체크.
       if (this.httpMethod != null) {
         throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
             this.httpMethod, httpMethod);
@@ -250,11 +280,13 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
         return;
       }
 
+      // path에 quert string이 포함되있을 경우 빼내야함.
       // Get the relative URL path and existing query string, if present.
       int question = value.indexOf('?');
       if (question != -1 && question < value.length() - 1) {
         // Ensure the query string does not have any named parameters.
         String queryParams = value.substring(question + 1);
+        // GET("some/url/?param={param}") 이런거 잡아냄. 이건 안됨.
         Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
         if (queryParamMatcher.find()) {
           throw methodError(method, "URL query string \"%s\" must not have replace block. "
@@ -266,16 +298,21 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       this.relativeUrlParamNames = parsePathParameters(value);
     }
 
+    // Content-Type: text/plain 이런 헤더들을 파싱하는거~~
+    // Okhttp쪽은 잘 모르겠음.
     private Headers parseHeaders(String[] headers) {
       Headers.Builder builder = new Headers.Builder();
       for (String header : headers) {
+        // colon이 있고 맨 앞이나 맨 끝이 아니어야함
         int colon = header.indexOf(':');
         if (colon == -1 || colon == 0 || colon == header.length() - 1) {
           throw methodError(method,
               "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
         }
+        // name, value 나누고
         String headerName = header.substring(0, colon);
         String headerValue = header.substring(colon + 1).trim();
+        // content-type일 때 특수 처리
         if ("Content-Type".equalsIgnoreCase(headerName)) {
           try {
             contentType = MediaType.get(headerValue);
@@ -288,9 +325,12 @@ private Headers parseHeaders(String[] headers) {
       }
       return builder.build();
     }
-
+  
+    // 한 파라미터에 대한 어노테이션 프로세싱 + 여러 가지 검사
     private ParameterHandler<?> parseParameter(
         int p, Type parameterType, Annotation[] annotations) {
+      // 여러 어노테이션이 붙어있을 수 있으므로
+      // 유효한 하나의 annotation에 해당하는 ParameterHandler만 골라냄
       ParameterHandler<?> result = null;
       for (Annotation annotation : annotations) {
         ParameterHandler<?> annotationAction = parseParameterAnnotation(
@@ -300,6 +340,7 @@ private Headers parseHeaders(String[] headers) {
           continue;
         }
 
+        // 이중 annotation 잡음.
         if (result != null) {
           throw parameterError(method, p, "Multiple Retrofit annotations found, only one allowed.");
         }
@@ -313,10 +354,12 @@ private Headers parseHeaders(String[] headers) {
 
       return result;
     }
-
+  
+    // 파라미터 한 개의 어노테이션 processing
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        // url은 두 번 이상 나올 수 없고 이것들과 같이 쓸 수 없음.
         if (gotUrl) {
           throw parameterError(method, p, "Multiple @Url method annotations found.");
         }
@@ -338,6 +381,8 @@ private Headers parseHeaders(String[] headers) {
 
         gotUrl = true;
 
+        // @Url이 붙은 걸로는 이 4개만 받습니다~
+        // android.net.Uri가 저렇게 되있는 이유는, Retrofit이 순수 자바 프로젝트라서 ㅋㅋ
         if (type == HttpUrl.class
             || type == String.class
             || type == URI.class
@@ -381,7 +426,9 @@ private Headers parseHeaders(String[] headers) {
 
         Class<?> rawParameterType = Utils.getRawType(type);
         gotQuery = true;
+        // @Query("something") List<String> 이런 상황
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          // 그냥 List면 안되겠지?
           if (!(type instanceof ParameterizedType)) {
             throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
@@ -394,6 +441,7 @@ private Headers parseHeaders(String[] headers) {
               retrofit.stringConverter(iterableType, annotations);
           return new ParameterHandler.Query<>(name, converter, encoded).iterable();
         } else if (rawParameterType.isArray()) {
+          // @Query("something") String[] 이런 상황
           Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
           Converter<?, String> converter =
               retrofit.stringConverter(arrayComponentType, annotations);
@@ -436,9 +484,11 @@ private Headers parseHeaders(String[] headers) {
       } else if (annotation instanceof QueryMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         gotQueryMap = true;
+        // 일단 맵이어야하고..
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, "@QueryMap parameter type must be Map.");
         }
+        // HashMap<K, V> 같은 걸 Map<K, V>으로 만들려고 하는걸까?
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
           throw parameterError(method, p,
@@ -574,6 +624,7 @@ private Headers parseHeaders(String[] headers) {
 
         String partName = part.value();
         Class<?> rawParameterType = Utils.getRawType(type);
+        // param - MultipartBody.Part
         if (partName.isEmpty()) {
           if (Iterable.class.isAssignableFrom(rawParameterType)) {
             if (!(type instanceof ParameterizedType)) {
@@ -603,6 +654,7 @@ private Headers parseHeaders(String[] headers) {
                 "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
           }
         } else {
+          // 여기서 multipart 헤더를 설정해줌.
           Headers headers =
               Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
                   "Content-Transfer-Encoding", part.encoding());
@@ -621,6 +673,11 @@ private Headers parseHeaders(String[] headers) {
                   "@Part parameters using the MultipartBody.Part must not "
                       + "include a part name in the annotation.");
             }
+            // 여기서는 아까랑 다르게 왜 RequestBodyConverter를 사용할까? (아까는 StringConverter였음)
+            // 이유는 바로 Multipart request 자체가 곧바로 request body를 만들기 때문.
+            // 아마 Body도 마찬가지일듯?
+            // 여기서 Converter를 interface로 사용했을 때의 이득을 볼 수 있음.
+            // RequestBodyConverter와 StringConverter가 같은 converter를 구현하고 있기 때문에
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
             return new ParameterHandler.Part<>(headers, converter).iterable();
@@ -673,11 +730,11 @@ private Headers parseHeaders(String[] headers) {
               + "Use @Part List<Part> or a different value type instead.");
         }
 
-        Converter<?, RequestBody> valueConverter =
+        Converter<?, RequestBody> converter =
             retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
 
         PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+        return new ParameterHandler.PartMap<>(converter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
         if (isFormEncoded || isMultipart) {
@@ -702,18 +759,23 @@ private Headers parseHeaders(String[] headers) {
       return null; // Not a Retrofit annotation.
     }
 
+    // @Path의 value를 검증.
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
         throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
             PARAM_URL_REGEX.pattern(), name);
       }
       // Verify URL replacement name is actually present in the URL path.
+      // 앞서서 method level annotation을 처리할 때 relativeUrlParamNames를 저장한 이유가 여기있었음.
+      // 이후 parameter processing을 할 때 정의되어 있는 값과 일치하는지 검사하기 위해서.. ㄷㄷ
       if (!relativeUrlParamNames.contains(name)) {
         throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
       }
     }
 
     /**
+     * GET("some/{param}/") 이런거 찾아서 Set으로 반환해줌 ㅎㅎ
+     *
      * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
      * in the URI, it will only show up once in the set.
      */
@@ -726,6 +788,7 @@ private void validatePathName(int p, String name) {
       return patterns;
     }
 
+    // 박싱까지 깔끔하게!
     private static Class<?> boxIfPrimitive(Class<?> type) {
       if (boolean.class == type) return Boolean.class;
       if (byte.class == type) return Byte.class;
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 1db6eb479..4258360a2 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import javax.annotation.Nullable;
+
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -23,6 +24,9 @@
 
 import static retrofit2.Utils.checkNotNull;
 
+// 고냥 okhttp3을 Wrapping한 친구인 듯 함!
+// 여러 가지 static 메소드들이 있지만 결국 상황에 따라서 여러 response를 만들 수 있게 해놓은듯.
+
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 498d006eb..648459b0b 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -25,7 +25,9 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+
 import javax.annotation.Nullable;
+
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -58,13 +60,23 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
+  // 간단한 in-memory cache임. ConcurrentHashMap을 사용한 이유는 아무래도 멀티쓰레드 환경을 감안한 것일듯.
   private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
 
   final okhttp3.Call.Factory callFactory;
   final HttpUrl baseUrl;
   final List<Converter.Factory> converterFactories;
   final List<CallAdapter.Factory> callAdapterFactories;
+  
+  
   final @Nullable Executor callbackExecutor;
+  
+  /**
+   * Validate Eagerly - 설정할 경우 Retrofit 인스턴스를 생성하는 시점에 service method를 로드함
+   * 즉 말 그대로 미리 확인하는 거라고 보면 된다. default는 false이고 false일 경우 생성 시점이 아니라
+   * 사용 시점에 validate가 되겠지? (죽거나.. 등등)
+   * Fast fail이라는 관점에서는 true로 하면 좋을듯 ㅋㅋ
+   */
   final boolean validateEagerly;
 
   Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
@@ -127,6 +139,8 @@
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
     Utils.validateServiceInterface(service);
+    // validateEagerly가 설정되있을 경우 미리 한 번 Service method들을 로드하면서
+    // 잘못된 것은 없는지 검증한다.
     if (validateEagerly) {
       eagerlyValidateMethods(service);
     }
@@ -136,6 +150,7 @@
 
           @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
+            // 여기서 왜 이게 필요할까? toString(), equals()같은 Object의 메소드를 호출할 수도 있기 때문!
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
               return method.invoke(this, args);
@@ -148,6 +163,7 @@
         });
   }
 
+  // 결국 근본적으로는 위의 create() 메소드의 InvocationHandler#invoke에서 하는 것과 동일함.
   private void eagerlyValidateMethods(Class<?> service) {
     Platform platform = Platform.get();
     for (Method method : service.getDeclaredMethods()) {
@@ -157,10 +173,17 @@ private void eagerlyValidateMethods(Class<?> service) {
     }
   }
 
+  // Method -> ServiceMethod로 바꾸는 작업
   ServiceMethod<?> loadServiceMethod(Method method) {
+    // 먼저 캐시를 확인 -> 캐시를 사용하는 이유는
+    // annotation processing 작업이 reflection을 사용하기 때문에
+    // 성능적으로 문제가 될 수 있기 때문임!
     ServiceMethod<?> result = serviceMethodCache.get(method);
     if (result != null) return result;
 
+    // ConcurrentHashMap을 사용했는데 왜 또 synchronized를 쓰는걸까?
+    // 그냥 아래 코드를 보면 이해가 됨. load는 단 한 번만 하면 되고,
+    // load가 되기 전까지는 접근하면 안되니까!
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
@@ -349,6 +372,8 @@ public HttpUrl baseUrl() {
   }
 
   /**
+   * converterFactory에서 stringConverter를 찾는다.
+   *
    * Returns a {@link Converter} for {@code type} to {@link String} from the available
    * {@linkplain #converterFactories() factories}.
    */
@@ -538,6 +563,9 @@ public Builder callbackExecutor(Executor executor) {
       return this;
     }
 
+    // 이 메소드들은 테스트를 위해서 필요한 것 같다.
+    // 만약 Retrofit이 Android 라이브러리였다면 @VisibleForTesting 을 쓰지 않았을까?
+    
     /** Returns a modifiable list of call adapter factories. */
     public List<CallAdapter.Factory> callAdapterFactories() {
       return this.callAdapterFactories;
@@ -579,6 +607,7 @@ public Retrofit build() {
       }
 
       // Make a defensive copy of the adapters and add the default Call adapter.
+      // Defensive copy - 의도치 않게 this.callAdapterFactories를 수정하는 일을 막음
       List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
       callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
 
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 2ae44628e..949b10f0f 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -17,17 +17,26 @@
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+
 import javax.annotation.Nullable;
 
 import static retrofit2.Utils.methodError;
 
+// 이 녀셕은 뭘 하는 녀석일까?
 abstract class ServiceMethod<T> {
+  // 1. 타입 검사 수행
+  // 2. 실질적으로 Api가 정의된 interface의 메소드를 ServiceMethod로 바꾸는 작업을 수행함
   static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    // getGenericReturnType() -> return generic Type (with Type parameter)
     Type returnType = method.getGenericReturnType();
+    
+    // String - 일반 타입이거나
+    // List<String> - ParameterizedType 이거나 등등이어야 함.
     if (Utils.hasUnresolvableType(returnType)) {
       throw methodError(method,
           "Method return type must not include a type variable or wildcard: %s", returnType);
     }
+    
     if (returnType == void.class) {
       throw methodError(method, "Service methods cannot return void.");
     }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 85258222c..e43bfecaf 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -27,10 +27,14 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+
 import javax.annotation.Nullable;
+
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
+// 여러 가지 쓸만한 것들이 있군..
+
 final class Utils {
   static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
 
@@ -38,6 +42,7 @@ private Utils() {
     // No instances.
   }
 
+  // Method 파싱/호출할 때 에러 발생 알림
   static RuntimeException methodError(Method method, String message, Object... args) {
     return methodError(method, null, message, args);
   }
@@ -51,7 +56,8 @@ static RuntimeException methodError(Method method, @Nullable Throwable cause, St
         + "."
         + method.getName(), cause);
   }
-
+  
+  // Parameter 파싱/호출할 때 에러 발생 알림
   static RuntimeException parameterError(Method method,
       Throwable cause, int p, String message, Object... args) {
     return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
@@ -61,6 +67,8 @@ static RuntimeException parameterError(Method method, int p, String message, Obj
     return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
   }
 
+  // 실제 Type을 반환.
+  // 가령 List<String> - parameterizedType 이라면 Class<List>를 반환하는것임..
   static Class<?> getRawType(Type type) {
     checkNotNull(type, "type == null");
 
@@ -138,6 +146,10 @@ static boolean equals(Type a, Type b) {
   }
 
   /**
+   * 와우..
+   * IntegerSet, Set.class -> {@code Set<Integer>}
+   * IntegerSet, Collection.class -> {@code Collection<Integer>}
+   *
    * Returns the generic supertype for {@code supertype}. For example, given a class {@code
    * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
    * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
@@ -152,6 +164,8 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
         if (interfaces[i] == toResolve) {
           return rawType.getGenericInterfaces()[i];
         } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          // 그러니까.. 인터페이스 상속 계층을 DFS 방식으로, 역으로 탐색해서 올라가는 개념임.
+          // IntegerSet -> Set이 인터페이스에 있을텐데 이걸 가져오는게 rawType.getGenericInterfaces()[i].
           return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
         }
       }
@@ -323,10 +337,13 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
+  // Retrofit에 전달된 interface가 Service interface인지 검증하는 작업.
   static <T> void validateServiceInterface(Class<T> service) {
+    // 인터페이스여야 하고
     if (!service.isInterface()) {
       throw new IllegalArgumentException("API declarations must be interfaces.");
     }
+    // 다른 인터페이스를 상속하면 안됨. (버그를 피할수도 있고 권장 패턴이라고 함)
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
     // the recommended pattern.
@@ -335,6 +352,14 @@ static ResponseBody buffer(final ResponseBody body) throws IOException {
     }
   }
 
+  // Map<? extends Jam, String>
+  // -> type.getActualTypeArguments - ? extends Jam(wildcard type), String
+  // -> ((WildcardType) paramType).getUpperBounds()[0] -> Jam
+  //
+  // 즉.. List<? extends Jam> -> Jam, List<Jam> -> Jam
+  //
+  // 왜 인덱스가 있는걸까? - 자바8 부터는 multiple bounds가 가능함
+  // e.g. ? extends Iterable & Comparable
   static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
     if (index < 0 || index >= types.length) {
@@ -348,12 +373,16 @@ static Type getParameterUpperBound(int index, ParameterizedType type) {
     return paramType;
   }
 
+  // resolvable - Type 정보를 알아 낼 수 있는건지..
+  // TypeVariable이나 WildcardType은 true인걸 보면 T, 혹은 List<? extends Object> 같은 것들은 안되나봄
   static boolean hasUnresolvableType(@Nullable Type type) {
     if (type instanceof Class<?>) {
       return false;
     }
+    // ParameterizedType - Map<String, Object>
     if (type instanceof ParameterizedType) {
       ParameterizedType parameterizedType = (ParameterizedType) type;
+      // getActualTypeArguments() - String, Object
       for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
         if (hasUnresolvableType(typeArgument)) {
           return true;
@@ -361,6 +390,7 @@ static boolean hasUnresolvableType(@Nullable Type type) {
       }
       return false;
     }
+    // GenericArrayType - List<String>[] or <T> T[]
     if (type instanceof GenericArrayType) {
       return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
     }
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 98d1d8684..c75e3728b 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -18,12 +18,15 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// POST나 PUT 요청을 할 때 ResponseBody를 직접 때려넣고 싶을 경우 사용함
+
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
diff --git a/retrofit/src/main/java/retrofit2/http/DELETE.java b/retrofit/src/main/java/retrofit2/http/DELETE.java
index 4a2b3e519..1f7c7e45d 100644
--- a/retrofit/src/main/java/retrofit2/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit2/http/DELETE.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Delete request 선언할 때 사용.
+
 /** Make a DELETE request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 06e369bc7..3489b2fb7 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -20,11 +20,16 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// 이건.. @Query와 비슷한데 @FormUrlEncoded를 사용할 때 씀.
+// Query의 경우 URL에 &id=1 이런 식으로 붙이는거라면
+// Field는 정의된 내용을 가지고 Request Body를 해당 형식으로 만듦.
+
 /**
  * Named pair for a form-encoded request.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index a7eb1ee86..02679a473 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -22,6 +22,10 @@
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// @Field와 비슷하지만 Field는 interface에서 정의할 때 상수로 name이 정해지지만
+// 이건 Map의 key가 name, value가 곧 value가 됨
+// 아래 예시처럼 ImmutableMap.of("foo", "bar", "kit", "kat") -> foo=bar&kit=kat 이 생성됨
+
 /**
  * Named key/value pairs for a form-encoded request.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java b/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java
index cb00931d0..56915e83b 100644
--- a/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java
+++ b/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java
@@ -22,6 +22,11 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Request의 MIME type을 application/x-www-form-urlencoded로 해줌.
+// -> request body가 URL인코딩 되었다는 걸 알려줌
+// ex) statement=this+is+an+apple
+// @Field에서 서술한 것처럼 함께 묶여서 사용됨.
+
 /**
  * Denotes that the request body will use form URL encoding. Fields should be declared as
  * parameters and annotated with {@link Field @Field}.
diff --git a/retrofit/src/main/java/retrofit2/http/GET.java b/retrofit/src/main/java/retrofit2/http/GET.java
index deca1820d..0152da4ff 100644
--- a/retrofit/src/main/java/retrofit2/http/GET.java
+++ b/retrofit/src/main/java/retrofit2/http/GET.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Get request 선언할 때 사용
+
 /** Make a GET request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/HEAD.java b/retrofit/src/main/java/retrofit2/http/HEAD.java
index 077787d4f..ea5836aab 100644
--- a/retrofit/src/main/java/retrofit2/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit2/http/HEAD.java
@@ -18,11 +18,16 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// GET request와 동일하게 요청을 하지만,
+// Response Body가 없고 Response Header만 가져온다.
+// 헤더에 들어있는 메타데이터만 필요할 떄 유용함.
+
 /** Make a HEAD request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index 101eecf3b..f6546e839 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// 기본적인 REST API 말고 다른 동작을 하고싶을 때 사용.
+
 /**
  * Use a custom HTTP verb for a request.
  * <pre><code>
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index b8f7a70ea..bdab3bec7 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -22,6 +22,8 @@
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Request 헤더를 작성할 때 쓰는 parameter 단위 annotation.
+
 /**
  * Replaces the header with the value of its target.
  * <pre><code>
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index 248abc15e..07578eaba 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -15,17 +15,20 @@
  */
 package retrofit2.http;
 
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
 import java.util.Map;
+
 import retrofit2.Retrofit;
 
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+// Header의 Map 버전
+
 /**
  * Adds headers specified in the {@link Map}.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index b360f3ec3..bf0ab4738 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -22,6 +22,8 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Request 헤더를 작성할 때 쓰는 method 단위 annotation
+
 /**
  * Adds headers literally supplied in the {@code value}.
  * <pre><code>
diff --git a/retrofit/src/main/java/retrofit2/http/Multipart.java b/retrofit/src/main/java/retrofit2/http/Multipart.java
index 2e88926bc..a4cc9477d 100644
--- a/retrofit/src/main/java/retrofit2/http/Multipart.java
+++ b/retrofit/src/main/java/retrofit2/http/Multipart.java
@@ -22,6 +22,8 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// 파일 업로드 등을 할 떄 사용하는 Multipart request 지정.
+
 /**
  * Denotes that the request body is multi-part. Parts should be declared as parameters and
  * annotated with {@link Part @Part}.
diff --git a/retrofit/src/main/java/retrofit2/http/OPTIONS.java b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
index 17dc085e3..807a6abff 100644
--- a/retrofit/src/main/java/retrofit2/http/OPTIONS.java
+++ b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
@@ -18,11 +18,16 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Options request를 나타냄.
+// OPTIONS - pre-flight request라고 부르는데, 서버에 어떤 METHOD를 사용할 수 있는지 물어보는 요청임.
+// ref: https://stackoverflow.com/questions/29954037/why-is-an-options-request-sent-and-can-i-disable-it
+
 /** Make an OPTIONS request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/PATCH.java b/retrofit/src/main/java/retrofit2/http/PATCH.java
index 035276982..2b6b84b71 100644
--- a/retrofit/src/main/java/retrofit2/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit2/http/PATCH.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Patch request 선언할 때 사용
+
 /** Make a PATCH request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/POST.java b/retrofit/src/main/java/retrofit2/http/POST.java
index 34352cd34..b0e3daca0 100644
--- a/retrofit/src/main/java/retrofit2/http/POST.java
+++ b/retrofit/src/main/java/retrofit2/http/POST.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Post request 선언할 때 사용
+
 /** Make a POST request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/PUT.java b/retrofit/src/main/java/retrofit2/http/PUT.java
index 0d4437f86..4d9efad54 100644
--- a/retrofit/src/main/java/retrofit2/http/PUT.java
+++ b/retrofit/src/main/java/retrofit2/http/PUT.java
@@ -18,11 +18,15 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Put request 선언할 때 사용
+// PUT - only allows complete replacement of document.
+
 /** Make a PUT request. */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index f320c088f..93b996198 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Multipart request를 할 때 parameter에 붙여야 하는 annotation.
+
 /**
  * Denotes a single part of a multi-part request.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 79eae2147..12b06243d 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -18,11 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// Part의 Map 버전. okhttp3.MultipartBody.Part를 지원하지 않는 듯..
+
 /**
  * Denotes name and value parts of a multi-part request.
  * <p>
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index 52af62511..70b03e833 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -20,11 +20,14 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// URL 경로 세그먼트에 파라미터 값을 전달할 때 사용.
+
 /**
  * Named replacement in a URL path segment. Values are converted to strings using
  * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()},
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 17c36c154..4fa91dacc 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -20,12 +20,17 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// URL에 ?id=1&type=SOMETHING 과 같은 식으로 파라미터를 덧붙일 수 있다.
+
 /**
+ * @see retrofit2.ParameterHandler.Query
+ *
  * Query parameter appended to the URL.
  * <p>
  * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index a9d7a30ea..d08ea189d 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -20,12 +20,18 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import retrofit2.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// @Query와 비슷하지만 name을 동적으로 사용할 수 있음.
+
 /**
+ * @see FieldMap
+ * @see retrofit2.ParameterHandler.QueryMap
+ *
  * Query parameter keys and values appended to the URL.
  * <p>
  * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
diff --git a/retrofit/src/main/java/retrofit2/http/QueryName.java b/retrofit/src/main/java/retrofit2/http/QueryName.java
index 5d6f0e948..1bf409660 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryName.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryName.java
@@ -22,7 +22,12 @@
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+// @Query와 비슷하지만 이건 값이 없음
+
 /**
+ * @see Query
+ * @see retrofit2.ParameterHandler.QueryName
+ *
  * Query parameter appended to the URL that has no value.
  * <p>
  * Passing a {@link java.util.List List} or array will result in a query parameter for each
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index 31187ca3d..99aaa28a9 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 import retrofit2.Retrofit;
 
@@ -25,6 +26,12 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
+ * Dynamic한 url을 지원하기 위해서 만들어진 어노테이션.
+ * 일반적인 GET, POST 등에서 경로를 생략하고 대신 첫 번째 파라미터를 Url로 annotate하면 된다.
+ * Retrofit#baseUrl()을 기준으로 하는 상대 경로임을 명심하자!
+ * Paramter handling에는 이걸 사용한다.
+ * @see retrofit2.ParameterHandler.RelativeUrl
+ *
  * URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
  * <pre><code>
  * &#64;GET
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 05e4cf928..0bd956234 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -15,6 +15,9 @@
  */
 package retrofit2;
 
+import org.junit.Rule;
+import org.junit.Test;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
@@ -31,6 +34,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -39,8 +43,6 @@
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Rule;
-import org.junit.Test;
 import retrofit2.helpers.DelegatingCallAdapterFactory;
 import retrofit2.helpers.NonMatchingCallAdapterFactory;
 import retrofit2.helpers.NonMatchingConverterFactory;
@@ -68,6 +70,7 @@
 public final class RetrofitTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
+  // Call로 감싸진 method들을 테스트하기 위한 interface
   interface CallMethod {
     @GET("/") Call<String> disallowed();
     @POST("/") Call<ResponseBody> disallowed(@Body String body);
@@ -81,9 +84,13 @@
     @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
     @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
   }
+  
+  // Future로 감싸진 method를 테스트하기 위한 interface
   interface FutureMethod {
     @GET("/") Future<String> method();
   }
+  
+  // API interface의 상속 금지를 확인하기 위한 interface
   interface Extending extends CallMethod {
   }
   interface StringService {
@@ -142,6 +149,8 @@
     }
   }
 
+  // one.newBuilder()를 호출했을 때 제대로 clone이 되는지 확인
+  // Builder(Retrofit)을 테스트
   @Test public void cloneSharesStatefulInstances() {
     CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
     Converter.Factory converter = mock(Converter.Factory.class);
@@ -172,6 +181,7 @@
     assertSame(callFactory, two.callFactory());
   }
 
+  // 클론 시 동작 확인.
   @Test public void builtInConvertersAbsentInCloneBuilder() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -234,6 +244,7 @@
     retrofit.create(VoidService.class);
   }
 
+  // validateEagerly 설정에 대한 테스트.
   @Test public void validateEagerlyDisabledByUser() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -243,7 +254,8 @@
     // Should not throw exception about incorrect configuration of the VoidService
     retrofit.create(VoidService.class);
   }
-
+  
+  // validateEagerly 설정에 대한 테스트.
   @Test public void validateEagerlyFailsAtCreation() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -1222,7 +1234,8 @@
     assertThat(delegatingFactory2.called).isTrue();
     assertThat(nonMatchingFactory.called).isTrue();
   }
-
+  
+  // 클론 시 동작 확인.
   @Test public void platformAwareAdapterAbsentInCloneBuilder() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -1230,7 +1243,8 @@
 
     assertEquals(0, retrofit.newBuilder().callAdapterFactories().size());
   }
-
+  
+  // callbackExecutor()를 호출할 때 null을 던지면 NPE가 나오는 것을 확인
   @Test public void callbackExecutorNullThrows() {
     try {
       new Retrofit.Builder().callbackExecutor(null);
@@ -1240,6 +1254,7 @@
     }
   }
 
+  // default callbackExecutor가 null이라는 걸 확인
   @Test public void callbackExecutorPropagatesDefaultJvm() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
@@ -1247,6 +1262,8 @@
     assertThat(retrofit.callbackExecutor()).isNull();
   }
 
+  // Retrofit.Builder()에 전달한 platform에 따라서
+  // Retrofit의 callbackExecutor가 제대로 반영이 됬는지 확인
   @Test public void callbackExecutorPropagatesDefaultAndroid() {
     final Executor executor = Executors.newSingleThreadExecutor();
     Platform platform = new Platform() {
@@ -1260,6 +1277,7 @@
     assertThat(retrofit.callbackExecutor()).isSameAs(executor);
   }
 
+  // Retrofit.Builder#callbackExecutor()로 전달한 executor가 제대로 반영되는지 확인
   @Test public void callbackExecutorPropagated() {
     Executor executor = mock(Executor.class);
     Retrofit retrofit = new Retrofit.Builder()
