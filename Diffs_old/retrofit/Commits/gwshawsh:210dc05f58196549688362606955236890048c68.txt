diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index a1b416a5f..a494b33ed 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,6 +18,8 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index c83be1b78..1606394fc 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -65,11 +65,9 @@
   private @Nullable FormBody.Builder formBuilder;
   private @Nullable RequestBody body;
   private final boolean isAop;
-  RequestBuilder(String method, HttpUrl baseUrl,
-      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
-      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
 
   private Map<String,String> formFieldCache =new HashMap<>();
+
   RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
       @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
       boolean isFormEncoded, boolean isMultipart,boolean isAop) {
@@ -106,7 +104,6 @@ void addHeader(String name, String value) {
       } catch (IllegalArgumentException e) {
         throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
-      contentType = type;
     } else {
       requestBuilder.addHeader(name, value);
     }
@@ -197,11 +194,32 @@ void addQueryParam(String name, @Nullable String value, boolean encoded) {
 
   @SuppressWarnings("ConstantConditions") // Only called when isFormEncoded was true.
   void addFormField(String name, String value, boolean encoded) {
+    if(isAop){
+      formFieldCache.put(name,value);
+      return;
+    }
     if (encoded) {
       formBuilder.addEncoded(name, value);
     } else {
       formBuilder.add(name, value);
     }
+
+  }
+
+  public Map<String, String> getFormFieldCache() {
+    return formFieldCache;
+  }
+
+  public void setFormFieldCache(Map<String, String> formFieldCache) {
+    this.formFieldCache = formFieldCache;
+  }
+
+  void handleFormFieldCache(){
+    if(isAop && formFieldCache!=null && formBuilder!=null){
+      for (Map.Entry<String, String> entry:formFieldCache.entrySet()){
+        formBuilder.add(entry.getKey(),entry.getValue());
+      }
+    }
   }
 
   @SuppressWarnings("ConstantConditions") // Only called when isMultipart was true.
@@ -237,6 +255,7 @@ void setBody(RequestBody body) {
     if (body == null) {
       // Try to pull from one of the builders.
       if (formBuilder != null) {
+        handleFormFieldCache();
         body = formBuilder.build();
       } else if (multipartBuilder != null) {
         body = multipartBuilder.build();
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 65845e2b7..cda76618c 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -57,11 +57,15 @@
 import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
+import static retrofit2.Utils.methodError;
+import static retrofit2.Utils.parameterError;
+
 final class RequestFactory {
   static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     return new Builder(retrofit, method).build();
   }
 
+  private final Method method;
   private final HttpUrl baseUrl;
   final String httpMethod;
   private final String relativeUrl;
@@ -76,6 +80,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   private Class<? extends MapGenerator> fieldMapGenerator;
   Class<? extends Wrapper> converter;
   RequestFactory(Builder builder) {
+    method = builder.method;
     baseUrl = builder.retrofit.baseUrl;
     httpMethod = builder.httpMethod;
     relativeUrl = builder.relativeUrl;
@@ -92,18 +97,20 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   }
 
   okhttp3.Request create(@Nullable Object[] args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart,converter!=null);
-
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    int argumentCount = args != null ? args.length : 0;
+    int argumentCount = args.length;
     if (argumentCount != handlers.length) {
       throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
+              + ") doesn't match expected count (" + handlers.length + ")");
     }
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+            contentType, hasBody, isFormEncoded, isMultipart,converter!=null);
+
+    List<Object> argumentList = new ArrayList<>(argumentCount);
     for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
       handlers[p].apply(requestBuilder, args[p]);
     }
     addGenerateFields(requestBuilder);
@@ -115,7 +122,10 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
         e.printStackTrace();
       }
     }
-    return requestBuilder.build();
+
+    return requestBuilder.get()
+            .tag(Invocation.class, new Invocation(method, argumentList))
+            .build();
   }
 
   private void addGenerateFields(RequestBuilder requestBuilder){
@@ -168,6 +178,8 @@ private void addGenerateFields(RequestBuilder requestBuilder){
     boolean gotBody;
     boolean gotPath;
     boolean gotQuery;
+    boolean gotQueryName;
+    boolean gotQueryMap;
     boolean gotUrl;
     String httpMethod;
     boolean hasBody;
@@ -202,16 +214,16 @@ RequestFactory build() {
       }
 
       if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+        throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
       }
 
       if (!hasBody) {
         if (isMultipart) {
-          throw methodError(
+          throw methodError(method,
               "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
         }
         if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+          throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
               + "request body (e.g., @POST).");
         }
       }
@@ -222,29 +234,29 @@ RequestFactory build() {
       for (; p < parameterCount; p++) {
         Type parameterType = parameterTypes[p];
         if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+          throw methodError(method, "Parameter type must not include a type variable or wildcard: %s",
               parameterType);
         }
 
         Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
         if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
+          throw methodError(method, "No Retrofit annotation found.");
         }
 
         parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
       }
 
       if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+        throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
       }
       if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
+        throw methodError(method, "Non-body HTTP method cannot contain @Body.");
       }
       if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
+        throw methodError(method, "Form-encoded method must contain at least one @Field.");
       }
       if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
+        throw methodError(method, "Multipart method must contain at least one @Part.");
       }
 
       return new RequestFactory(this);
@@ -301,17 +313,17 @@ private void parseMethodAnnotation(Annotation annotation) {
       } else if (annotation instanceof retrofit2.http.Headers) {
         String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
         if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
+          throw methodError(method, "@Headers annotation is empty.");
         }
         headers = parseHeaders(headersToParse);
       } else if (annotation instanceof Multipart) {
         if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
+          throw methodError(method, "Only one encoding annotation is allowed.");
         }
         isMultipart = true;
       } else if (annotation instanceof FormUrlEncoded) {
         if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
+          throw methodError(method, "Only one encoding annotation is allowed.");
         }
         isFormEncoded = true;
       }else {
@@ -321,7 +333,7 @@ private void parseMethodAnnotation(Annotation annotation) {
 
     private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
       if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+        throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
             this.httpMethod, httpMethod);
       }
       this.httpMethod = httpMethod;
@@ -338,7 +350,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
         String queryParams = value.substring(question + 1);
         Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
         if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
+          throw methodError(method, "URL query string \"%s\" must not have replace block. "
               + "For dynamic query parameters use @Query.", queryParams);
         }
       }
@@ -352,17 +364,17 @@ private Headers parseHeaders(String[] headers) {
       for (String header : headers) {
         int colon = header.indexOf(':');
         if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
+          throw methodError(method,
               "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
         }
         String headerName = header.substring(0, colon);
         String headerValue = header.substring(colon + 1).trim();
         if ("Content-Type".equalsIgnoreCase(headerName)) {
-          MediaType type = MediaType.parse(headerValue);
-          if (type == null) {
-            throw methodError("Malformed content type: %s", headerValue);
+          try {
+            contentType = MediaType.get(headerValue);
+          } catch (IllegalArgumentException e) {
+            throw methodError(method, e, "Malformed content type: %s", headerValue);
           }
-          contentType = type;
         } else {
           builder.add(headerName, headerValue);
         }
@@ -371,25 +383,28 @@ private Headers parseHeaders(String[] headers) {
     }
 
     private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
+        int p, Type parameterType, @Nullable Annotation[] annotations) {
       ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        if (annotationAction == null) {
-          continue;
-        }
+          if (annotationAction == null) {
+            continue;
+          }
 
-        if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
-        }
+          if (result != null) {
+            throw parameterError(method, p,
+                "Multiple Retrofit annotations found, only one allowed.");
+          }
 
-        result = annotationAction;
+          result = annotationAction;
+        }
       }
 
       if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
+        throw parameterError(method, p, "No Retrofit annotation found.");
       }
 
       return result;
@@ -398,17 +413,24 @@ private Headers parseHeaders(String[] headers) {
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        validateResolvableType(p, type);
         if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
+          throw parameterError(method, p, "Multiple @Url method annotations found.");
         }
         if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
         }
         if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
+          throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
         }
         if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+          throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
         }
 
         gotUrl = true;
@@ -419,19 +441,27 @@ private Headers parseHeaders(String[] headers) {
             || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
           return new ParameterHandler.RelativeUrl();
         } else {
-          throw parameterError(p,
+          throw parameterError(method, p,
               "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
         }
 
       } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
         if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
+          throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
+        }
+        if (gotQueryName) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+        }
+        if (gotQueryMap) {
+          throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
         }
         if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
+          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
         }
         if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+          throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+              httpMethod);
         }
         gotPath = true;
 
@@ -443,6 +473,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
         Query query = (Query) annotation;
         String name = query.value();
         boolean encoded = query.encoded();
@@ -451,7 +482,7 @@ private Headers parseHeaders(String[] headers) {
         gotQuery = true;
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -473,14 +504,15 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
         QueryName query = (QueryName) annotation;
         boolean encoded = query.encoded();
 
         Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
+        gotQueryName = true;
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -502,18 +534,21 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
+        gotQueryMap = true;
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
+          throw parameterError(method, p, "@QueryMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter =
@@ -522,13 +557,14 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
         Header header = (Header) annotation;
         String name = header.value();
 
         Class<?> rawParameterType = Utils.getRawType(type);
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -550,18 +586,20 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof HeaderMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
+          throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter =
@@ -570,8 +608,9 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.HeaderMap<>(valueConverter);
 
       } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
+          throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
         }
         Field field = (Field) annotation;
         String name = field.value();
@@ -582,7 +621,7 @@ private Headers parseHeaders(String[] headers) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (Iterable.class.isAssignableFrom(rawParameterType)) {
           if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
+            throw parameterError(method, p, rawParameterType.getSimpleName()
                 + " must include generic type (e.g., "
                 + rawParameterType.getSimpleName()
                 + "<String>)");
@@ -604,22 +643,24 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+          throw parameterError(method, p,
+              "@FieldMap parameters can only be used with form encoding.");
         }
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
+          throw parameterError(method, p, "@FieldMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
+          throw parameterError(method, p,
               "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
         }
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter =
@@ -629,8 +670,10 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+          throw parameterError(method, p,
+              "@Part parameters can only be used with multipart encoding.");
         }
         Part part = (Part) annotation;
         gotPart = true;
@@ -640,7 +683,7 @@ private Headers parseHeaders(String[] headers) {
         if (partName.isEmpty()) {
           if (Iterable.class.isAssignableFrom(rawParameterType)) {
             if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
+              throw parameterError(method, p, rawParameterType.getSimpleName()
                   + " must include generic type (e.g., "
                   + rawParameterType.getSimpleName()
                   + "<String>)");
@@ -648,21 +691,21 @@ private Headers parseHeaders(String[] headers) {
             ParameterizedType parameterizedType = (ParameterizedType) type;
             Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
             if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
+              throw parameterError(method, p,
                   "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
             }
             return ParameterHandler.RawPart.INSTANCE.iterable();
           } else if (rawParameterType.isArray()) {
             Class<?> arrayComponentType = rawParameterType.getComponentType();
             if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
+              throw parameterError(method, p,
                   "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
             }
             return ParameterHandler.RawPart.INSTANCE.array();
           } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
             return ParameterHandler.RawPart.INSTANCE;
           } else {
-            throw parameterError(p,
+            throw parameterError(method, p,
                 "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
           }
         } else {
@@ -672,7 +715,7 @@ private Headers parseHeaders(String[] headers) {
 
           if (Iterable.class.isAssignableFrom(rawParameterType)) {
             if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
+              throw parameterError(method, p, rawParameterType.getSimpleName()
                   + " must include generic type (e.g., "
                   + rawParameterType.getSimpleName()
                   + "<String>)");
@@ -680,8 +723,9 @@ private Headers parseHeaders(String[] headers) {
             ParameterizedType parameterizedType = (ParameterizedType) type;
             Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
             if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
@@ -689,15 +733,17 @@ private Headers parseHeaders(String[] headers) {
           } else if (rawParameterType.isArray()) {
             Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
             if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+              throw parameterError(method, p,
+                  "@Part parameters using the MultipartBody.Part must not "
+                      + "include a part name in the annotation.");
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
             return new ParameterHandler.Part<>(headers, converter).array();
           } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
+            throw parameterError(method, p,
+                "@Part parameters using the MultipartBody.Part must not "
+                    + "include a part name in the annotation.");
           } else {
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(type, annotations, methodAnnotations);
@@ -706,28 +752,31 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+          throw parameterError(method, p,
+              "@PartMap parameters can only be used with multipart encoding.");
         }
         gotPart = true;
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
+          throw parameterError(method, p, "@PartMap parameter type must be Map.");
         }
         Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
         if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+          throw parameterError(method, p,
+              "Map must include generic types (e.g., Map<String, String>)");
         }
         ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
         Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
         if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+          throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
         }
 
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+          throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
               + "Use @Part List<Part> or a different value type instead.");
         }
 
@@ -738,12 +787,13 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
         if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
+          throw parameterError(method, p,
               "@Body parameters cannot be used with form or multi-part encoding.");
         }
         if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
+          throw parameterError(method, p, "Multiple @Body method annotations found.");
         }
 
         Converter<?, RequestBody> converter;
@@ -751,7 +801,7 @@ private Headers parseHeaders(String[] headers) {
           converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
         } catch (RuntimeException e) {
           // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+          throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
         }
         gotBody = true;
         return new ParameterHandler.Body<>(converter);
@@ -760,39 +810,24 @@ private Headers parseHeaders(String[] headers) {
       return null; // Not a Retrofit annotation.
     }
 
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            "Parameter type must not include a type variable or wildcard: %s", type);
+      }
+    }
+
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+        throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
             PARAM_URL_REGEX.pattern(), name);
       }
       // Verify URL replacement name is actually present in the URL path.
       if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+        throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
       }
     }
 
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
-
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
-
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
-    }
-
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
-
     /**
      * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
      * in the URI, it will only show up once in the set.
