diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 000000000..fd12a9838
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/retrofit"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 000000000..91f444b22
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/.travis.yml b/.travis.yml
index 3ba5e9a65..e6a844e22 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,8 +1,26 @@
 language: java
 
+jdk:
+  - oraclejdk7
+  - oraclejdk8
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "M0bjPTMwinz0uXN6qjXcpyfvhz/YX9W7ty4RdV90jMU8ZJxSdGdKXRy1N0TsMO8ciOQ2fryE/FpiX+arrphnVvqUmGBh386lGvj1rhgrVqXNqlGE23cQpzHsQ0nNqTGIxnoE4dmJF3PjWoYG+B4WbFsSb3PB7sEjpLq7klqGeHk="
+    - secure: "iL5BdYAmMaEDRKxNx1d9Zxn0tfJhCzXBGUvn+p7QGeQDUSVCdCc8cXS4ePbRj0401pK20nK1OouIi0lLP+z0QpZY6RrKIEncGOZeSFPQbS/vnZ7niCYJQdXCZ/GOlYUkAW2AsQl5bzzHYbHKX/TVgTuO3iFlbyeoZZuIjD3VaiM="
+
 branches:
   except:
     - gh-pages
 
 notifications:
   email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
new file mode 100644
index 000000000..b2c35b2da
--- /dev/null
+++ b/BUG-BOUNTY.md
@@ -0,0 +1,10 @@
+Serious about security
+======================
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
+
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 681ad8147..80c420272 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,129 @@
 Change Log
 ==========
 
+Version 1.9.0 *(2015-01-07)*
+----------------------------
+
+ * Update to OkHttp 2.x's native API. If you are using OkHttp you must use version 2.0 or newer (the latest
+   is 2.2 at time of writing) and you no longer need to use the `okhttp-urlconnection` shim.
+ * New: Allow disabling Simple XML Framework's strict parsing.
+ * New: `@Header` now accepts a `List` or array for a type.
+ * New: `@Field` and `@FieldMap` now have options for enabling or disabling URL encoding of names and values.
+ * Fix: Remove query parameters from thread name when running background requests for asynchronous use.
+
+
+Version 1.8.0 *(2014-11-18)*
+----------------------------
+
+ * Update to RxJava 1.0. This comes with the project's 'groupId' change from `com.netflix.rxjava` to
+   `io.reactivex` which is why the minor version was bumped.
+
+
+Version 1.7.1 *(2014-10-23)*
+----------------------------
+
+ * Fix: Correctly log `null` request arguments for `HEADERS_AND_ARGS` log level.
+
+
+Version 1.7.0 *(2014-10-08)*
+----------------------------
+
+ * New: `RetrofitError`'s `getKind()` now disambiguates the type of error represented.
+ * New: `HEADERS_AND_ARGS` log level displays parameters passed to method invocation along with normal
+   header list.
+ * New: `@Part` and `@PartMap` now support specifying the `Content-Transfer-Encoding` of their respective
+   values.
+ * New: `@Path`, `@Query`, and `@QueryMap` now have options for enabling or disabling URL encoding on
+   names (where appropriate) and values.
+ * `@Header` now accepts all object types, invoking `String.valueOf` when neccesary.
+ * Attempting to use a `@Path` replacement block (`{name}`) in a query parameter now suggested `@Query` in
+   the exception message.
+ * Fix: Correct NPE when `Content-Type` override is specified on requests without a body.
+ * Fix: `WireConverter` now correctly throws `ConversionException` on incorrect MIME types for parity with
+   `ProtoConverter`.
+ * Fix: Include `Content-Type` on AppEngine requests.
+ * Fix: Account for NPE on AppEngine when the response URL was not automatically populated in certain cases.
+ * Fix: `MockRestAdapter`'s RxJava support now correctly schedules work on the HTTP executor, specifically
+   when chaining multiple requests together.
+ * Experimental RxJava support updated for v0.20.
+
+
+Version 1.6.1 *(2014-07-02)*
+----------------------------
+
+ * Fix: Add any explicitly-specified 'Content-Type' header (via annotation or param) to the request even
+   if there is no request body (e.g., DELETE).
+ * Fix: Include trailing CRLF in multi-part uploads to work around a bug in .NET MVC 4 parsing.
+ * Fix: Allow `null` mock exception bodies and use the success type from the declared service interface.
+
+
+Version 1.6.0 *(2014-06-06)*
+----------------------------
+
+ * New: `@Streaming` on a `Response` type will skip buffering the body to a `byte[]` before delivering.
+ * When using OkHttp, version 1.6.0 or newer (including 2.0.0+) is now required.
+ * The absence of a response body and an empty body are now differentiated in the log messages.
+ * Fix: If set, the `RequestInterceptor` is now applied at the time of `Observable` subscription rather
+   than at the time of its creation.
+ * Fix: `Callback` subtypes are now supported when using `MockRestAdapter`.
+ * Fix: `RetrofitError` now contains a useful message indicating the reason for the failure.
+ * Fix: Exceptions thrown when parsing the response type of the interface are now properly propagated.
+ * Fix: Calling `Response#getBody` when `null` body now correctly returns instead of throwing an NPE.
+ * Experimental RxJava support updated for v0.19.
+ * The `Content-Type` and `Content-Length` headers are no longer automatically added to the header list
+   on the `Request` object. This reverts erroneous behavior added in v1.5.0. Custom `Client` implementations
+   should revert to adding these headers based on the `TypedInput` body of the `Request`.
+
+
+Version 1.5.1 *(2014-05-08)*
+----------------------------
+
+ * New: `@PartMap` annotation accepts a `Map` of key/value pairs for multi-part.
+ * Fix: `MockRestAdpater` uses the `ErrorHandler` from its parent `RestAdapter`.
+ * Experimental RxJava support updated for v0.18 and is now lazily initialized.
+
+
+Version 1.5.0 *(2014-03-20)*
+----------------------------
+
+ * New: Support for AppEngine's [URL Fetch](https://developers.google.com/appengine/docs/java/urlfetch/)
+   HTTP client.
+ * New: Multipart requests of unknown length are now supported.
+ * New: HTTP `Content-Type` can be overridden with a method-level or paramter header annotation.
+ * New: Exceptions from malformed interface methods now include detailed information.
+ * Fix: Support empty HTTP response status reason.
+ * If an `ErrorHandler` is supplied it will be invoked for `Callback` and `Observable` methods.
+ * HTTP `PATCH` method using `HttpUrlConnection` is no longer supported. Add the
+   [OkHttp](http://square.github.io/okhttp) jar to your project if you need this behavior.
+ * Custom `Client` implementations should no longer set `Content-Type` or `Content-Length` headers
+   based on the `TypedInput` body of the `Request`. These headers will now be added automatically
+   as part of the standard `Request` header list.
+
+
+Version 1.4.1 *(2014-02-01)*
+----------------------------
+
+ * Fix: `@QueryMap`, `@EncodedFieldMap`, and `@FieldMap` now correctly detect `Map`-based parameter
+   types.
+
+
+Version 1.4.0 *(2014-01-31)*
+----------------------------
+
+ * New: `@Query` and `@EncodedQuery` now accept `List` or arrays for multiple values.
+ * New: `@QueryMap` and `@EncodedQueryMap` accept a `Map` of key/value pairs for query parameters.
+ * New: `@Field` now accepts `List` or arrays for multiple values.
+ * New: `@FieldMap` accepts a `Map` of name/value pairs for form URL-encoded request bodies.
+ * New: `Endpoint` replaces `Server` as the representation of the remote API root. The `Endpoints`
+   utility class contains factories methods for creating instances. `Server` and `ChangeableServer`
+   are now deprecated.
+ * `SimpleXmlConverter` and `JacksonConverter` now have a default constructor.
+ * `Response` now includes the URL.
+ * Fix: Hide references to optional classes to prevent over-eager class verifiers from
+   complaining (e.g., Dalvik).
+ * Fix: Properly detect and reject interfaces which extend from other interfaces.
+
+
 Version 1.3.0 *(2013-11-25)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 96a762649..c101a0078 100644
--- a/README.md
+++ b/README.md
@@ -10,15 +10,21 @@ Download
 --------
 
 Download [the latest JAR][2] or grab via Maven:
-
 ```xml
 <dependency>
-    <groupId>com.squareup.retrofit</groupId>
-    <artifactId>retrofit</artifactId>
-    <version>(insert latest version)</version>
+  <groupId>com.squareup.retrofit</groupId>
+  <artifactId>retrofit</artifactId>
+  <version>1.9.0</version>
 </dependency>
 ```
+or Gradle:
+```groovy
+compile 'com.squareup.retrofit:retrofit:1.9.0'
+```
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
+Retrofit requires at minimum Java 6 or Android 2.3.
 
 
 
@@ -41,4 +47,5 @@ License
 
 
  [1]: http://square.github.io/retrofit/
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.retrofit&a=retrofit&v=LATEST
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/checkstyle.xml b/checkstyle.xml
index 7da88bbd1..de5302db0 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -43,7 +43,9 @@
         <module name="AvoidStarImport"/>
         <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
         <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
+        <module name="UnusedImports">
+          <property name="processJavadoc" value="true"/>
+        </module>
 
 
         <!-- Checks for Size Violations.                    -->
@@ -51,7 +53,7 @@
         <module name="LineLength">
             <property name="max" value="100"/>
         </module>
-        <module name="MethodLength"/>
+        <!--<module name="MethodLength"/>-->
         <!--module name="ParameterNumber"/-->
 
 
@@ -90,13 +92,12 @@
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
         <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
         <module name="EmptyStatement"/>
         <module name="EqualsAvoidNull"/>
         <module name="EqualsHashCode"/>
         <!--module name="HiddenField"/-->
         <module name="IllegalInstantiation"/>
-        <module name="InnerAssignment"/>
+        <!--module name="InnerAssignment"/-->
         <!--module name="MagicNumber"/-->
         <module name="MissingSwitchDefault"/>
         <module name="RedundantThrows"/>
diff --git a/deploy_website.sh b/deploy_website.sh
index 3d007cd5b..134675d3a 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -27,7 +27,7 @@ rm -rf *
 cp -R ../website/* .
 
 # Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
 mkdir javadoc
 unzip javadoc.zip -d javadoc
 rm javadoc.zip
diff --git a/pom.xml b/pom.xml
index 37924f1a6..370df5043 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>parent</artifactId>
-  <version>1.3.1-SNAPSHOT</version>
+  <version>2.0.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -34,9 +34,10 @@
 
   <modules>
     <module>retrofit</module>
+    <module>retrofit-adapters</module>
     <module>retrofit-converters</module>
-    <module>retrofit-mock</module>
-    <module>retrofit-samples</module>
+    <!--<module>retrofit-mock</module>-->
+    <module>samples</module>
   </modules>
 
   <properties>
@@ -44,32 +45,33 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
+    <java.version>1.7</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.4</gson.version>
-    <okhttp.version>1.2.1</okhttp.version>
-    <rxjava.version>0.14.9</rxjava.version>
+    <gson.version>2.3.1</gson.version>
+    <okhttp.version>2.4.0</okhttp.version>
+    <rxjava.version>1.0.10</rxjava.version>
 
     <!-- Converter Dependencies -->
     <protobuf.version>2.5.0</protobuf.version>
-    <jackson.version>2.2.2</jackson.version>
-    <wire.version>1.2.0</wire.version>
+    <jackson.version>2.4.3</jackson.version>
+    <wire.version>1.5.2</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
-    <fest.version>2.0M10</fest.version>
+    <junit.version>4.11</junit.version>
+    <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>15.0</guava.version>
+    <guava.version>18.0</guava.version>
   </properties>
 
   <scm>
     <url>http://github.com/square/retrofit</url>
     <connection>scm:git:git://github.com/square/retrofit.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
@@ -107,8 +109,8 @@
         <version>${gson.version}</version>
       </dependency>
       <dependency>
-        <groupId>com.netflix.rxjava</groupId>
-        <artifactId>rxjava-core</artifactId>
+        <groupId>io.reactivex</groupId>
+        <artifactId>rxjava</artifactId>
         <version>${rxjava.version}</version>
       </dependency>
 
@@ -139,9 +141,9 @@
         <version>${junit.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.easytesting</groupId>
-        <artifactId>fest-assert-core</artifactId>
-        <version>${fest.version}</version>
+        <groupId>org.assertj</groupId>
+        <artifactId>assertj-core</artifactId>
+        <version>${assertj.version}</version>
       </dependency>
       <dependency>
         <groupId>org.mockito</groupId>
@@ -153,18 +155,17 @@
         <artifactId>guava</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.squareup.okhttp</groupId>
+        <artifactId>mockwebserver</artifactId>
+        <version>${okhttp.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
   <build>
     <pluginManagement>
       <plugins>
-        <plugin>
-          <groupId>org.sonatype.plugins</groupId>
-          <artifactId>jarjar-maven-plugin</artifactId>
-          <version>1.7</version>
-        </plugin>
-
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
@@ -181,6 +182,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
+        <version>2.5</version>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
@@ -189,7 +191,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
+        <version>2.15</version>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
diff --git a/retrofit-adapters/README.md b/retrofit-adapters/README.md
new file mode 100644
index 000000000..2dd0b7d47
--- /dev/null
+++ b/retrofit-adapters/README.md
@@ -0,0 +1,4 @@
+Retrofit Adapters
+=================
+
+TODO
diff --git a/retrofit-samples/pom.xml b/retrofit-adapters/pom.xml
similarity index 69%
rename from retrofit-samples/pom.xml
rename to retrofit-adapters/pom.xml
index bea7ffdf8..2b0b0e146 100644
--- a/retrofit-samples/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,17 +6,15 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <groupId>com.squareup.retrofit.samples</groupId>
-  <artifactId>parent</artifactId>
-  <name>Samples</name>
+  <artifactId>retrofit-adapters</artifactId>
+  <name>Adapters</name>
   <packaging>pom</packaging>
 
   <modules>
-    <module>github-client</module>
-    <module>mock-github-client</module>
+    <module>rxjava</module>
   </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
new file mode 100644
index 000000000..2a0ac8787
--- /dev/null
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava</artifactId>
+  <name>Adapter: RxJava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
new file mode 100644
index 000000000..b40be0e69
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Action0;
+import rx.functions.Func1;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * TODO docs
+ */
+public final class ObservableCallAdapterFactory implements CallAdapter.Factory {
+  /**
+   * TODO
+   */
+  public static ObservableCallAdapterFactory create() {
+    return new ObservableCallAdapterFactory();
+  }
+
+  private ObservableCallAdapterFactory() {
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName();
+  }
+
+  @Override public CallAdapter<?> get(Type returnType) {
+    if (Utils.getRawType(returnType) != Observable.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Observable return type must be parameterized"
+          + " as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+    Class<?> rawObservableType = Utils.getRawType(observableType);
+
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResponseCallAdapter<>(responseType);
+    }
+
+    if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResultCallAdapter<>(responseType);
+    }
+
+    return new SimpleCallAdapter(observableType);
+  }
+
+  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
+    private final Call<T> originalCall;
+
+    private CallOnSubscribe(Call<T> originalCall) {
+      this.originalCall = originalCall;
+    }
+
+    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
+      // Since Call is a one-shot type, clone it for each new subscriber.
+      final Call<T> call = originalCall.clone();
+
+      // Attempt to cancel the call if it is still in-flight on unsubscription.
+      subscriber.add(Subscriptions.create(new Action0() {
+        @Override public void call() {
+          call.cancel();
+        }
+      }));
+
+      call.enqueue(new Callback<T>() {
+        @Override public void success(Response<T> response) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          try {
+            subscriber.onNext(response);
+          } catch (Throwable t) {
+            subscriber.onError(t);
+            return;
+          }
+          subscriber.onCompleted();
+        }
+
+        @Override public void failure(Throwable t) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          subscriber.onError(t);
+        }
+      });
+    }
+  }
+
+  static final class ResponseCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<Response<T>> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call));
+    }
+  }
+
+  static final class SimpleCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    SimpleCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<T> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .flatMap(new Func1<Response<T>, Observable<T>>() {
+            @Override public Observable<T> call(Response<T> response) {
+              if (response.isSuccess()) {
+                return Observable.just(response.body());
+              }
+              return Observable.error(new IOException()); // TODO non-suck message.
+            }
+          });
+    }
+  }
+
+  static final class ResultCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    ResultCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<Result<T>> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .map(new Func1<Response<T>, Result<T>>() {
+            @Override public Result<T> call(Response<T> response) {
+              return Result.fromResponse(response);
+            }
+          })
+          .onErrorReturn(new Func1<Throwable, Result<T>>() {
+            @Override public Result<T> call(Throwable throwable) {
+              return Result.fromError(throwable);
+            }
+          });
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
new file mode 100644
index 000000000..1302136ce
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+
+import static retrofit.Utils.checkNotNull;
+
+/** The result of executing an HTTP request. */
+public final class Result<T> {
+  static <T> Result<T> fromError(Throwable error) {
+    return new Result<>(null, checkNotNull(error, "error == null"));
+  }
+
+  static <T> Result<T> fromResponse(Response<T> response) {
+    return new Result<>(checkNotNull(response, "response == null"), null);
+  }
+
+  private final Response<T> response;
+  private final Throwable error;
+
+  Result(Response<T> response, Throwable error) {
+    this.response = response;
+    this.error = error;
+  }
+
+  /**
+   * The response received from executing an HTTP request. Only present when {@link #isError()} is
+   * false, null otherwise.
+   */
+  public Response<T> response() {
+    return response;
+  }
+
+  /**
+   * The error experienced while attempting to execute an HTTP request. Only present when {@link
+   * #isError()} is true, null otherwise.
+   * <p>
+   * If the error is an {@link IOException} then there was a problem with the transport to the
+   * remote server. Any other exception type indicates an unexpected failure and should be
+   * considered fatal (configuration error, programming error, etc.).
+   */
+  public Throwable error() {
+    return error;
+  }
+
+  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+  public boolean isError() {
+    return error != null;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
new file mode 100644
index 000000000..7f0969bbb
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.GET;
+import rx.Observable;
+import rx.observables.BlockingObservable;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ObservableCallAdapterFactoryTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .callAdapterFactory(ObservableCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    assertThat(o.first()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      // TODO assert on some indicator of 404.
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+
+  @Test public void responseType() {
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    Type classType = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType).responseType()) //
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseType).responseType()).isEqualTo(String.class);
+    Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultType).responseType()).isEqualTo(String.class);
+  }
+
+  @Test public void rawTypeThrows() {
+    Type type = new TypeToken<Observable>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    try {
+      factory.get(type);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type type = new TypeToken<Observable<Response>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    try {
+      factory.get(type);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type type = new TypeToken<Observable<Result>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    try {
+      factory.get(type);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+
+  static class StringConverter implements Converter {
+    @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+      return body.string();
+    }
+
+    @Override public RequestBody toBody(Object object, Type type) {
+      return RequestBody.create(MediaType.parse("text/plain"), String.valueOf(object));
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
new file mode 100644
index 000000000..f995a24c8
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResultTest {
+  @Test public void response() {
+    Response<String> response = Response.fromBody("Hi");
+    Result<String> result = Result.fromResponse(response);
+    assertThat(result.isError()).isFalse();
+    assertThat(result.error()).isNull();
+    assertThat(result.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      Result.fromResponse(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+
+  @Test public void error() {
+    Throwable error = new IOException();
+    Result<Object> result = Result.fromError(error);
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isSameAs(error);
+    assertThat(result.response()).isNull();
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Result.fromError(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("error == null");
+    }
+  }
+}
diff --git a/retrofit-converters/README.md b/retrofit-converters/README.md
index e646f2cb1..acd5bc5c1 100644
--- a/retrofit-converters/README.md
+++ b/retrofit-converters/README.md
@@ -4,11 +4,11 @@ Retrofit Converters
 Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
 agnostic. The child modules contained herein are additional converters for other popular formats.
 
-To use, supply an instance of your desired converter when building your `RestAdapter` instance.
+To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setServer("https://api.fake.google.com")
-    .setConverter(new ProtoConverter())
+Retrofit retrofit = new Retrofit.Builder()
+    .endpoint("https://api.example.com")
+    .converter(new ProtoConverter())
     .build();
 ```
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
new file mode 100644
index 000000000..1568926f2
--- /dev/null
+++ b/retrofit-converters/gson/README.md
@@ -0,0 +1,10 @@
+Gson Converter
+==============
+
+A `Converter` which uses [Gson][1] for serialization to and from JSON.
+
+A default `Gson` instance will be created or one can be configured and passed to the
+`GsonConverter` construction to further control the serialization.
+
+
+ [1]: https://github.com/google/gson
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
new file mode 100644
index 000000000..e353bb325
--- /dev/null
+++ b/retrofit-converters/gson/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-gson</artifactId>
+  <name>Converter: Gson</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
new file mode 100644
index 000000000..cb19c8cf6
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Type;
+import java.nio.charset.Charset;
+
+/**
+ * A {@link Converter} which uses GSON for serialization and deserialization of entities.
+ */
+public class GsonConverter implements Converter {
+  private final Gson gson;
+  private final Charset charset;
+  private final MediaType mediaType;
+
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public GsonConverter() {
+    this(new Gson());
+  }
+
+  /**
+   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public GsonConverter(Gson gson) {
+    this(gson, Charset.forName("UTF-8"));
+  }
+
+  /**
+   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
+   */
+  public GsonConverter(Gson gson, Charset charset) {
+    if (gson == null) throw new NullPointerException("gson == null");
+    if (charset == null) throw new NullPointerException("charset == null");
+    this.gson = gson;
+    this.charset = charset;
+    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
+  }
+
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    Charset charset = this.charset;
+    if (body.contentType() != null) {
+      charset = body.contentType().charset(charset);
+    }
+
+    InputStream is = body.byteStream();
+    try {
+      return gson.fromJson(new InputStreamReader(is, charset), type);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(Object object, Type type) {
+    String json = gson.toJson(object, type);
+    return RequestBody.create(mediaType, json);
+  }
+}
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java
new file mode 100644
index 000000000..a4449757c
--- /dev/null
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java
@@ -0,0 +1,78 @@
+// Copyright 2015 Square, Inc.
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+
+public final class GsonConverterTest {
+  private Converter converter;
+
+  interface Example {
+    String getName();
+  }
+
+  class Impl implements Example {
+    private final String theName;
+
+    Impl(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  @Before public void setUp() {
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapter(Example.class, new JsonSerializer<Example>() {
+          @Override public JsonElement serialize(Example example, Type type,
+              JsonSerializationContext json) {
+            JsonObject object = new JsonObject();
+            object.addProperty("name", example.getName());
+            return object;
+          }
+        })
+        .create();
+    converter = new GsonConverter(gson);
+  }
+
+  @Test public void serialization() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
+    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
+  }
+
+  @Test public void serializationTypeUsed() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Example.class);
+    assertBody(body).isEqualTo("{\"name\":\"value\"}");
+  }
+
+  @Test public void deserialization() throws IOException {
+    ResponseBody body =
+        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
+    Impl impl = (Impl) converter.fromBody(body, Impl.class);
+    assertEquals("value", impl.getName());
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
+}
diff --git a/retrofit-converters/jackson/README.md b/retrofit-converters/jackson/README.md
new file mode 100644
index 000000000..d07b0afa6
--- /dev/null
+++ b/retrofit-converters/jackson/README.md
@@ -0,0 +1,10 @@
+Jackson Converter
+=================
+
+A `Converter` which uses [Jackson][1] for serialization to and from JSON.
+
+A default `ObjectMapper` instance will be created or one can be configured and passed to the
+`JacksonConverter` construction to further control the serialization.
+
+
+ [1]: http://wiki.fasterxml.com/JacksonHome
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 4c920c8ab..06c5a2992 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,8 +30,8 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
new file mode 100644
index 000000000..3740fd4cb
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
@@ -0,0 +1,54 @@
+package retrofit;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Type;
+
+/**
+ * A {@link Converter} which uses Jackson for reading and writing entities.
+ *
+ * @author Kai Waldron (kaiwaldron@gmail.com)
+ */
+public class JacksonConverter implements Converter {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private final ObjectMapper objectMapper;
+
+  public JacksonConverter() {
+    this(new ObjectMapper());
+  }
+
+  public JacksonConverter(ObjectMapper objectMapper) {
+    if (objectMapper == null) throw new NullPointerException("objectMapper == null");
+    this.objectMapper = objectMapper;
+  }
+
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
+    try {
+      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
+      return objectMapper.readValue(is, javaType);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(Object object, Type type) {
+    try {
+      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
+      String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
+      return RequestBody.create(MEDIA_TYPE, json);
+    } catch (JsonProcessingException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
deleted file mode 100644
index 49cd8aee8..000000000
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package retrofit.converter;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.lang.reflect.Type;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-import com.fasterxml.jackson.core.JsonParseException;
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.JsonMappingException;
-import com.fasterxml.jackson.databind.ObjectMapper;
-
-/**
- * A {@link Converter} which uses Jackson for reading and writing entities.
- *
- * @author Kai Waldron (kaiwaldron@gmail.com)
- */
-public class JacksonConverter implements Converter {
-  private static final String MIME_TYPE = "application/json; charset=UTF-8";
-
-  private final ObjectMapper objectMapper;
-
-  public JacksonConverter(ObjectMapper objectMapper) {
-    this.objectMapper = objectMapper;
-  }
-
-  @Override public Object fromBody(TypedInput body, final Type type) throws ConversionException {
-    try {
-      final JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      return objectMapper.readValue(body.in(), javaType);
-    } catch (final JsonParseException e) {
-      throw new ConversionException(e);
-    } catch (final JsonMappingException e) {
-      throw new ConversionException(e);
-    } catch (final IOException e) {
-      throw new ConversionException(e);
-    }
-  }
-
-  @Override public TypedOutput toBody(Object object) {
-    try {
-      final String json = objectMapper.writeValueAsString(object);
-      return new TypedByteArray(MIME_TYPE, json.getBytes("UTF-8"));
-    } catch (final JsonProcessingException e) {
-      throw new AssertionError(e);
-    } catch (final UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
new file mode 100644
index 000000000..8df5529d9
--- /dev/null
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
@@ -0,0 +1,89 @@
+package retrofit;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class JacksonConverterTest {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MyObject OBJECT = new MyObject("hello world", 10);
+  private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
+
+  private final JacksonConverter converter = new JacksonConverter();
+
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(OBJECT, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(JSON);
+  }
+
+  @Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+    assertThat(result).isEqualTo(OBJECT);
+  }
+
+  @Test public void deserializeWrongValue() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
+    try {
+      converter.fromBody(body, MyObject.class);
+    } catch (UnrecognizedPropertyException ignored) {
+    }
+  }
+
+  @Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    try {
+      converter.fromBody(body, String.class);
+    } catch (JsonMappingException ignored) {
+    }
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
+
+  static class MyObject {
+    private final String message;
+    private final int count;
+
+    public MyObject(@JsonProperty("message") String message, @JsonProperty("count") int count) {
+      this.message = message;
+      this.count = count;
+    }
+
+    public String getMessage() {
+      return message;
+    }
+
+    public int getCount() {
+      return count;
+    }
+
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+
+      MyObject myObject = (MyObject) o;
+      return count == myObject.count
+          && !(message != null ? !message.equals(myObject.message) : myObject.message != null);
+    }
+
+    @Override public int hashCode() {
+      int result = message != null ? message.hashCode() : 0;
+      result = 31 * result + count;
+      return result;
+    }
+  }
+}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
deleted file mode 100644
index 6235c7c42..000000000
--- a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package retrofit.converter;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-import java.io.ByteArrayOutputStream;
-
-import org.junit.Test;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.databind.ObjectMapper;
-
-public class JacksonConverterTest {
-  private static final String MIME_TYPE = "application/json; charset=UTF-8";
-
-  private final MyObject obj = new MyObject("hello world", 10);
-  private final String objAsJson = String.format("{\"message\":\"%s\",\"count\":%d}", obj.getMessage(), obj.getCount());
-  private final JacksonConverter converter = new JacksonConverter(new ObjectMapper());
-
-  @Test public void serialize() throws Exception {
-    final TypedOutput typedOutput = converter.toBody(obj);
-    assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
-    assertThat(asString(typedOutput)).isEqualTo(objAsJson);
-  }
-
-  @Test public void deserialize() throws Exception {
-    final TypedInput input = new TypedByteArray(MIME_TYPE, objAsJson.getBytes());
-    final MyObject result = (MyObject) converter.fromBody(input, MyObject.class);
-    assertThat(result).isEqualTo(obj);
-  }
-
-  @Test(expected = ConversionException.class) public void deserializeWrongValue() throws Exception {
-    final TypedInput input = new TypedByteArray(MIME_TYPE, "{\"foo\":\"bar\"}".getBytes());
-    converter.fromBody(input, MyObject.class);
-  }
-
-  @Test(expected = ConversionException.class) public void deserializeWrongClass() throws Exception {
-    final TypedInput input = new TypedByteArray(MIME_TYPE, objAsJson.getBytes());
-    converter.fromBody(input, String.class);
-  }
-
-  private String asString(TypedOutput typedOutput) throws Exception {
-    final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    typedOutput.writeTo(bytes);
-    return new String(bytes.toByteArray());
-  }
-
-  static class MyObject {
-    private final String message;
-    private final int count;
-
-    public MyObject(@JsonProperty("message") String message, @JsonProperty("count") int count) {
-      this.message = message;
-      this.count = count;
-    }
-
-    public String getMessage() {
-      return message;
-    }
-
-    public int getCount() {
-      return count;
-    }
-
-    @Override
-    public int hashCode() {
-      final int prime = 31;
-      int result = 1;
-      result = prime * result + count;
-      result = prime * result + ((message == null) ? 0 : message.hashCode());
-      return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null) {
-        return false;
-      }
-      if (getClass() != obj.getClass()) {
-        return false;
-      }
-      MyObject other = (MyObject) obj;
-      if (count != other.count) {
-        return false;
-      }
-      if (message == null) {
-        if (other.message != null) {
-          return false;
-        }
-      } else if (!message.equals(other.message)) {
-        return false;
-      }
-      return true;
-    }
-  }
-}
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 95ec0d67e..457a2c365 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -15,6 +15,7 @@
   <packaging>pom</packaging>
 
   <modules>
+    <module>gson</module>
     <module>protobuf</module>
     <module>jackson</module>
     <module>wire</module>
diff --git a/retrofit-converters/protobuf/README.md b/retrofit-converters/protobuf/README.md
new file mode 100644
index 000000000..ca4334147
--- /dev/null
+++ b/retrofit-converters/protobuf/README.md
@@ -0,0 +1,7 @@
+Google Protocol Buffer Converter
+================================
+
+A `Converter` which uses [Protocol Buffer][1] binary serialization.
+
+
+ [1]: https://developers.google.com/protocol-buffers/
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 0c80f9094..d2808b7ea 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,8 +30,8 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
similarity index 63%
rename from retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
index f4c0b6778..5de16192d 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
@@ -1,21 +1,21 @@
 // Copyright 2013 Square, Inc.
-package retrofit.converter;
+package retrofit;
 
 import com.google.protobuf.AbstractMessageLite;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers. */
 public class ProtoConverter implements Converter {
-  private static final String MIME_TYPE = "application/x-protobuf";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -24,32 +24,31 @@
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     }
 
-    String mimeType = body.mimeType();
-    if (!MIME_TYPE.equals(mimeType)) {
-      throw new ConversionException("Response content type was not a proto: " + mimeType);
-    }
-
+    InputStream is = body.byteStream();
     try {
       Method parseFrom = c.getMethod("parseFrom", InputStream.class);
-      return parseFrom.invoke(null, body.in());
+      return parseFrom.invoke(null, is);
     } catch (InvocationTargetException e) {
-      throw new ConversionException(c.getName() + ".parseFrom() failed", e.getCause());
+      throw new RuntimeException(c.getName() + ".parseFrom() failed", e.getCause());
     } catch (NoSuchMethodException e) {
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     } catch (IllegalAccessException e) {
       throw new AssertionError();
-    } catch (IOException e) {
-      throw new ConversionException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object object) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof AbstractMessageLite)) {
       throw new IllegalArgumentException(
           "Expected a protobuf message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((AbstractMessageLite) object).toByteArray();
-    return new TypedByteArray(MIME_TYPE, bytes);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
similarity index 85%
rename from retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java
rename to retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
index 460f8cc35..1f233452a 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
@@ -1,7 +1,9 @@
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
 // source: protos/phone.proto
 
-package retrofit.converter;
+package retrofit;
+
+import com.google.protobuf.AbstractMessage;
 
 public final class PhoneProtos {
   private PhoneProtos() {}
@@ -96,14 +98,14 @@ private Phone(
     }
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
-      return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+      return PhoneProtos.internal_static_retrofit_Phone_descriptor;
     }
 
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
-      return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+      return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
           .ensureFieldAccessorsInitialized(
-              retrofit.converter.PhoneProtos.Phone.class, retrofit.converter.PhoneProtos.Phone.Builder.class);
+              PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
     }
 
     public static com.google.protobuf.Parser<Phone> PARSER =
@@ -208,53 +210,53 @@ public int getSerializedSize() {
       return super.writeReplace();
     }
 
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(byte[] data)
+    public static PhoneProtos.Phone parseFrom(byte[] data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         byte[] data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+    public static PhoneProtos.Phone parseFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseFrom(input, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+    public static PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseDelimitedFrom(
+    public static PhoneProtos.Phone parseDelimitedFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
@@ -263,7 +265,7 @@ public int getSerializedSize() {
 
     public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(retrofit.converter.PhoneProtos.Phone prototype) {
+    public static Builder newBuilder(PhoneProtos.Phone prototype) {
       return newBuilder().mergeFrom(prototype);
     }
     public Builder toBuilder() { return newBuilder(this); }
@@ -279,20 +281,20 @@ protected Builder newBuilderForType(
      */
     public static final class Builder extends
         com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements retrofit.converter.PhoneProtos.PhoneOrBuilder {
+       implements PhoneProtos.PhoneOrBuilder {
       public static final com.google.protobuf.Descriptors.Descriptor
           getDescriptor() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
       }
 
       protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
           internalGetFieldAccessorTable() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+        return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
             .ensureFieldAccessorsInitialized(
-                retrofit.converter.PhoneProtos.Phone.class, retrofit.converter.PhoneProtos.Phone.Builder.class);
+                PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
       }
 
-      // Construct using retrofit.converter.PhoneProtos.Phone.newBuilder()
+      // Construct using retrofit.PhoneProtos.Phone.newBuilder()
       private Builder() {
         maybeForceBuilderInitialization();
       }
@@ -323,23 +325,23 @@ public Builder clone() {
 
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
       }
 
-      public retrofit.converter.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit.converter.PhoneProtos.Phone.getDefaultInstance();
+      public PhoneProtos.Phone getDefaultInstanceForType() {
+        return PhoneProtos.Phone.getDefaultInstance();
       }
 
-      public retrofit.converter.PhoneProtos.Phone build() {
-        retrofit.converter.PhoneProtos.Phone result = buildPartial();
+      public PhoneProtos.Phone build() {
+        PhoneProtos.Phone result = buildPartial();
         if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
+          throw AbstractMessage.Builder.newUninitializedMessageException(result);
         }
         return result;
       }
 
-      public retrofit.converter.PhoneProtos.Phone buildPartial() {
-        retrofit.converter.PhoneProtos.Phone result = new retrofit.converter.PhoneProtos.Phone(this);
+      public PhoneProtos.Phone buildPartial() {
+        PhoneProtos.Phone result = new PhoneProtos.Phone(this);
         int from_bitField0_ = bitField0_;
         int to_bitField0_ = 0;
         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
@@ -352,16 +354,16 @@ public Builder clone() {
       }
 
       public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit.converter.PhoneProtos.Phone) {
-          return mergeFrom((retrofit.converter.PhoneProtos.Phone)other);
+        if (other instanceof PhoneProtos.Phone) {
+          return mergeFrom((PhoneProtos.Phone)other);
         } else {
           super.mergeFrom(other);
           return this;
         }
       }
 
-      public Builder mergeFrom(retrofit.converter.PhoneProtos.Phone other) {
-        if (other == retrofit.converter.PhoneProtos.Phone.getDefaultInstance()) return this;
+      public Builder mergeFrom(PhoneProtos.Phone other) {
+        if (other == PhoneProtos.Phone.getDefaultInstance()) return this;
         if (other.hasNumber()) {
           bitField0_ |= 0x00000001;
           number_ = other.number_;
@@ -379,11 +381,11 @@ public Builder mergeFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
           throws java.io.IOException {
-        retrofit.converter.PhoneProtos.Phone parsedMessage = null;
+        PhoneProtos.Phone parsedMessage = null;
         try {
           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
         } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit.converter.PhoneProtos.Phone) e.getUnfinishedMessage();
+          parsedMessage = (PhoneProtos.Phone) e.getUnfinishedMessage();
           throw e;
         } finally {
           if (parsedMessage != null) {
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
new file mode 100644
index 000000000..e10956d9b
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
@@ -0,0 +1,73 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static retrofit.PhoneProtos.Phone;
+
+public final class ProtoConverterTest {
+  private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
+  private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
+
+  private final ProtoConverter converter = new ProtoConverter();
+
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(PROTO, Phone.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
+  }
+
+  @Test public void deserialize() throws Exception {
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
+    assertThat(proto).isEqualTo(PROTO);
+  }
+
+  @Test public void deserializeWrongClass() throws Exception {
+    try {
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
+    }
+  }
+
+  @Test public void deserializeWrongType() throws Exception {
+    try {
+      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
+    }
+  }
+
+  @Test public void deserializeWrongValue() throws Exception {
+    try {
+      converter.fromBody(protoResponse("////"), Phone.class);
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
+    }
+  }
+
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
+        encodedProto).toByteArray());
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
+  }
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
deleted file mode 100644
index 12a73df6f..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.google.common.io.BaseEncoding;
-import com.google.protobuf.InvalidProtocolBufferException;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static retrofit.converter.PhoneProtos.Phone;
-
-public final class ProtoConverterTest {
-  private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
-  private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
-
-  private final ProtoConverter protoConverter = new ProtoConverter();
-
-  @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = protoConverter.toBody(PROTO);
-    assertThat(protoBytes.mimeType()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(ENCODED_PROTO)));
-  }
-
-  @Test public void deserialize() throws Exception {
-    Object proto = protoConverter.fromBody(decodeBase64(ENCODED_PROTO), Phone.class);
-    assertThat(proto).isEqualTo(PROTO);
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), String.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
-    }
-  }
-
-  @Test public void deserializeWrongType() throws Exception {
-    try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
-    }
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    try {
-      protoConverter.fromBody(decodeBase64("////"), Phone.class);
-      fail();
-    } catch (ConversionException expected) {
-      assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
-    }
-  }
-
-  @Test public void deserializeWrongMime() throws Exception {
-    try {
-      protoConverter.fromBody(decodeBase64("////", "yummy/bytes"), Phone.class);
-      fail();
-    } catch (ConversionException e) {
-      assertThat(e).hasMessage("Response content type was not a proto: yummy/bytes");
-    }
-  }
-
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
-  }
-
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, "application/x-protobuf");
-  }
-
-  private static TypedByteArray decodeBase64(String base64, String mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(mime, BaseEncoding.base64().decode(base64));
-  }
-}
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 63a39a470..918c94570 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,6 +1,6 @@
 package retrofit;
 
-option java_package = "retrofit.converter";
+option java_package = "retrofit";
 option java_outer_classname = "PhoneProtos";
 
 message Phone {
diff --git a/retrofit-converters/simplexml/README.md b/retrofit-converters/simplexml/README.md
new file mode 100644
index 000000000..8d5b8e369
--- /dev/null
+++ b/retrofit-converters/simplexml/README.md
@@ -0,0 +1,19 @@
+Simple XML Converter
+====================
+
+A `Converter` which uses [Simple][1] for XML serialization.
+
+A default `Serializer` instance will be created or one can be configured and passed to the
+`SimpleXMLConverter` construction to further control the serialization.
+
+
+Android
+-------
+
+Simple depends on artifacts which are already provided by the Android platform. When specifying as
+a Maven or Gradle dependency, exclude the following transitive dependencies: `stax:stax-api`,
+`stax:stax`, and `xpp3:xpp3`.
+
+
+
+ [1]: http://simple.sourceforge.net/
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index 333dd231a..4a83d0a78 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -30,8 +30,8 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
new file mode 100644
index 000000000..36ba06f86
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
@@ -0,0 +1,79 @@
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import java.lang.reflect.Type;
+import okio.Buffer;
+import org.simpleframework.xml.Serializer;
+import org.simpleframework.xml.core.Persister;
+
+/**
+ * A {@link Converter} which uses SimpleXML for reading and writing entities.
+ *
+ * @author Fabien Ric (fabien.ric@gmail.com)
+ */
+public class SimpleXmlConverter implements Converter {
+  private static final boolean DEFAULT_STRICT = true;
+  private static final String CHARSET = "UTF-8";
+  private static final MediaType MEDIA_TYPE =
+      MediaType.parse("application/xml; charset=" + CHARSET);
+
+  private final Serializer serializer;
+
+  private final boolean strict;
+
+  public SimpleXmlConverter() {
+    this(DEFAULT_STRICT);
+  }
+
+  public SimpleXmlConverter(boolean strict) {
+    this(new Persister(), strict);
+  }
+
+  public SimpleXmlConverter(Serializer serializer) {
+    this(serializer, DEFAULT_STRICT);
+  }
+
+  public SimpleXmlConverter(Serializer serializer, boolean strict) {
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
+    try {
+      return serializer.read((Class<?>) type, is, strict);
+    } catch (IOException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(Object source, Type type) {
+    byte[] bytes;
+    try {
+      Buffer buffer = new Buffer();
+      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+      serializer.write(source, osw);
+      osw.flush();
+      bytes = buffer.readByteArray();
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+
+  public boolean isStrict() {
+    return strict;
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
deleted file mode 100644
index 98d36887f..000000000
--- a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package retrofit.converter;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.lang.reflect.Type;
-
-import org.simpleframework.xml.Serializer;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-/**
- * A {@link Converter} which uses SimpleXML for reading and writing entities.
- *
- * @author Fabien Ric (fabien.ric@gmail.com)
- */
-public class SimpleXMLConverter implements Converter {
-  private static final String CHARSET = "UTF-8";
-  private static final String MIME_TYPE = "application/xml; charset=" + CHARSET;
-
-  private final Serializer serializer;
-
-  public SimpleXMLConverter(Serializer serializer) {
-    this.serializer = serializer;
-  }
-
-  @Override
-  public Object fromBody(TypedInput body, Type type) throws ConversionException {
-    try {
-      return serializer.read((Class<?>) type, body.in());
-    } catch (Exception e) {
-      throw new ConversionException(e);
-    }
-  }
-
-  @Override
-  public TypedOutput toBody(Object source) {
-    OutputStreamWriter osw = null;
-
-    try {
-      ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      osw = new OutputStreamWriter(bos, CHARSET);
-      serializer.write(source, osw);
-      osw.flush();
-      return new TypedByteArray(MIME_TYPE, bos.toByteArray());
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    } finally {
-      try {
-        if (osw != null) {
-          osw.close();
-        }
-      } catch (IOException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
new file mode 100644
index 000000000..e47c44a6f
--- /dev/null
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
@@ -0,0 +1,128 @@
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Before;
+import org.junit.Test;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import org.simpleframework.xml.Element;
+import org.simpleframework.xml.core.Persister;
+import org.simpleframework.xml.stream.Format;
+import org.simpleframework.xml.stream.HyphenStyle;
+import org.simpleframework.xml.stream.Verbosity;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class SimpleXmlConverterTest {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MyObject OBJ = new MyObject("hello world", 10);
+  private static final String XML =
+      "<my-object><message>hello world</message><count>10</count></my-object>";
+
+  private Converter converter;
+
+  @Before public void setUp() {
+    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+    Persister persister = new Persister(format);
+    converter = new SimpleXmlConverter(persister);
+  }
+
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(OBJ, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(XML);
+  }
+
+  @Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+    assertThat(result).isEqualTo(OBJ);
+  }
+
+  @Test public void deserializeWrongValue() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
+    try {
+      converter.fromBody(body, MyObject.class);
+    } catch (RuntimeException ignored) {
+    }
+  }
+
+  @Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+    Object result = converter.fromBody(body, String.class);
+    assertThat(result).isNull();
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
+      throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
+
+  @Default(value = DefaultType.FIELD) static class MyObject {
+    @Element private String message;
+    @Element private int count;
+
+    public MyObject() {
+    }
+
+    public MyObject(String message, int count) {
+      this.message = message;
+      this.count = count;
+    }
+
+    public void setMessage(String message) {
+      this.message = message;
+    }
+
+    public String getMessage() {
+      return message;
+    }
+
+    public void setCount(int count) {
+      this.count = count;
+    }
+
+    public int getCount() {
+      return count;
+    }
+
+    @Override public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      result = prime * result + count;
+      result = prime * result + ((message == null) ? 0 : message.hashCode());
+      return result;
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null) {
+        return false;
+      }
+      if (getClass() != obj.getClass()) {
+        return false;
+      }
+      MyObject other = (MyObject) obj;
+      if (count != other.count) {
+        return false;
+      }
+      if (message == null) {
+        if (other.message != null) {
+          return false;
+        }
+      } else if (!message.equals(other.message)) {
+        return false;
+      }
+      return true;
+    }
+  }
+}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
deleted file mode 100644
index 8eaa53b69..000000000
--- a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package retrofit.converter;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-import java.io.ByteArrayOutputStream;
-
-import org.junit.Test;
-import org.simpleframework.xml.Default;
-import org.simpleframework.xml.DefaultType;
-import org.simpleframework.xml.Element;
-import org.simpleframework.xml.core.Persister;
-import org.simpleframework.xml.stream.Format;
-import org.simpleframework.xml.stream.HyphenStyle;
-import org.simpleframework.xml.stream.Verbosity;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-public class SimpleXMLConverterTest {
-	private static final String MIME_TYPE = "application/xml; charset=UTF-8";
-
-	private final MyObject obj = new MyObject("hello world", 10);
-	private final String objAsXML = String.format(
-			"<my-object><message>%s</message><count>%d</count></my-object>",
-			obj.getMessage(), obj.getCount());
-	private final Converter converter = initConverter();
-
-	private static Converter initConverter() {
-		Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
-		Persister persister = new Persister(format);
-		return new SimpleXMLConverter(persister);
-	}
-
-	@Test
-	public void serialize() throws Exception {
-		final TypedOutput typedOutput = converter.toBody(obj);
-		assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
-		assertThat(asString(typedOutput)).isEqualTo(objAsXML);
-	}
-
-	@Test
-	public void deserialize() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				objAsXML.getBytes());
-		final MyObject result = (MyObject) converter.fromBody(input,
-				MyObject.class);
-		assertThat(result).isEqualTo(obj);
-	}
-
-	@Test(expected = ConversionException.class)
-	public void deserializeWrongValue() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				"<myObject><foo/><bar/></myObject>".getBytes());
-		converter.fromBody(input, MyObject.class);
-
-	}
-
-	@Test
-	public void deserializeWrongClass() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				objAsXML.getBytes());
-		Object result = converter.fromBody(input, String.class);
-		assertThat(result).isNull();
-	}
-
-	private String asString(TypedOutput typedOutput) throws Exception {
-		final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-		typedOutput.writeTo(bytes);
-		return new String(bytes.toByteArray());
-	}
-
-	@Default(value = DefaultType.FIELD)
-	static class MyObject {
-		@Element
-		private String message;
-		@Element
-		private int count;
-
-		public MyObject() {
-		}
-
-		public MyObject(String message, int count) {
-			this.message = message;
-			this.count = count;
-		}
-
-		public void setMessage(String message) {
-			this.message = message;
-		}
-
-		public String getMessage() {
-			return message;
-		}
-
-		public void setCount(int count) {
-			this.count = count;
-		}
-
-		public int getCount() {
-			return count;
-		}
-
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + count;
-			result = prime * result
-					+ ((message == null) ? 0 : message.hashCode());
-			return result;
-		}
-
-		@Override
-		public boolean equals(Object obj) {
-			if (this == obj) {
-				return true;
-			}
-			if (obj == null) {
-				return false;
-			}
-			if (getClass() != obj.getClass()) {
-				return false;
-			}
-			MyObject other = (MyObject) obj;
-			if (count != other.count) {
-				return false;
-			}
-			if (message == null) {
-				if (other.message != null) {
-					return false;
-				}
-			} else if (!message.equals(other.message)) {
-				return false;
-			}
-			return true;
-		}
-	}
-}
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
new file mode 100644
index 000000000..88069b48f
--- /dev/null
+++ b/retrofit-converters/wire/README.md
@@ -0,0 +1,10 @@
+Wire Converter
+==============
+
+A `Converter` which uses [Wire][1] for protocol buffer-compatible serialization.
+
+A default `Wire` instance will be created or one can be configured and passed to the
+`WireConverter` construction to further control the serialization.
+
+
+ [1]: https://github.com/square/wire
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 5ad698b4b..f56ef5fcb 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -34,8 +34,8 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
similarity index 62%
rename from retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
index 046769642..8098448c7 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
@@ -1,18 +1,18 @@
 // Copyright 2013 Square, Inc.
-package retrofit.converter;
+package retrofit;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.Wire;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers using Wire. */
 public class WireConverter implements Converter {
-  private static final String MIME_TYPE = "application/x-protobuf";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
   private final Wire wire;
 
@@ -23,11 +23,12 @@ public WireConverter() {
 
   /** Create a converter using the supplied {@link Wire} instance. */
   public WireConverter(Wire wire) {
+    if (wire == null) throw new NullPointerException("wire == null");
     this.wire = wire;
   }
 
   @SuppressWarnings("unchecked") //
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -36,33 +37,24 @@ public WireConverter(Wire wire) {
       throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
     }
 
-    if (!MIME_TYPE.equalsIgnoreCase(body.mimeType())) {
-      throw new IllegalArgumentException("Expected a proto but was: " + body.mimeType());
-    }
-
-    InputStream in = null;
+    InputStream in = body.byteStream();
     try {
-      in = body.in();
       return wire.parseFrom(in, (Class<Message>) c);
-    } catch (IOException e) {
-      throw new ConversionException(e);
     } finally {
-      if (in != null) {
-        try {
-          in.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        in.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof Message)) {
       throw new IllegalArgumentException(
           "Expected a proto message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((Message) object).toByteArray();
-    return new TypedByteArray(MIME_TYPE, bytes);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java b/retrofit-converters/wire/src/test/java/retrofit/Person.java
similarity index 77%
rename from retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
rename to retrofit-converters/wire/src/test/java/retrofit/Person.java
index 3c18499df..daf0bc322 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/Person.java
@@ -1,8 +1,6 @@
-// Copyright 2013 Square, Inc.
-
 // Code generated by Wire protocol buffer compiler, do not edit.
 // Source file: ../wire-runtime/src/test/proto/person.proto
-package retrofit.converter;
+package retrofit;
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoEnum;
@@ -42,21 +40,26 @@
   public final String email;
 
   /**
-   * A list of the user's phone numbers.
+   * A list of the customer's phone numbers.
    */
   @ProtoField(tag = 4, label = REPEATED)
   public final List<PhoneNumber> phone;
 
+  public Person(String name, Integer id, String email, List<PhoneNumber> phone) {
+    this.name = name;
+    this.id = id;
+    this.email = email;
+    this.phone = immutableCopyOf(phone);
+  }
+
   private Person(Builder builder) {
-    super(builder);
-    this.name = builder.name;
-    this.id = builder.id;
-    this.email = builder.email;
-    this.phone = immutableCopyOf(builder.phone);
+    this(builder.name, builder.id, builder.email, builder.phone);
+    setBuilder(builder);
   }
 
   @Override
   public boolean equals(Object other) {
+    if (other == this) return true;
     if (!(other instanceof Person)) return false;
     Person o = (Person) other;
     return equals(name, o.name)
@@ -72,7 +75,7 @@ public int hashCode() {
       result = name != null ? name.hashCode() : 0;
       result = result * 37 + (id != null ? id.hashCode() : 0);
       result = result * 37 + (email != null ? email.hashCode() : 0);
-      result = result * 37 + (phone != null ? phone.hashCode() : 0);
+      result = result * 37 + (phone != null ? phone.hashCode() : 1);
       hashCode = result;
     }
     return result;
@@ -97,23 +100,35 @@ public Builder(Person message) {
       this.phone = copyOf(message.phone);
     }
 
+    /**
+     * The customer's full name.
+     */
     public Builder name(String name) {
       this.name = name;
       return this;
     }
 
+    /**
+     * The customer's ID number.
+     */
     public Builder id(Integer id) {
       this.id = id;
       return this;
     }
 
+    /**
+     * Email address for the customer.
+     */
     public Builder email(String email) {
       this.email = email;
       return this;
     }
 
+    /**
+     * A list of the customer's phone numbers.
+     */
     public Builder phone(List<PhoneNumber> phone) {
-      this.phone = phone;
+      this.phone = checkForNulls(phone);
       return this;
     }
 
@@ -124,13 +139,25 @@ public Person build() {
     }
   }
 
-  public enum PhoneType {
-    @ProtoEnum(0)
-    MOBILE,
-    @ProtoEnum(1)
-    HOME,
-    @ProtoEnum(2)
-    WORK,
+  public enum PhoneType
+      implements ProtoEnum {
+    MOBILE(0),
+    HOME(1),
+    /**
+     * Could be phone or fax.
+     */
+    WORK(2);
+
+    private final int value;
+
+    private PhoneType(int value) {
+      this.value = value;
+    }
+
+    @Override
+    public int getValue() {
+      return value;
+    }
   }
 
   public static final class PhoneNumber extends Message {
@@ -139,7 +166,7 @@ public Person build() {
     public static final PhoneType DEFAULT_TYPE = PhoneType.HOME;
 
     /**
-     * The user's phone number.
+     * The customer's phone number.
      */
     @ProtoField(tag = 1, type = STRING, label = REQUIRED)
     public final String number;
@@ -150,14 +177,19 @@ public Person build() {
     @ProtoField(tag = 2, type = ENUM)
     public final PhoneType type;
 
+    public PhoneNumber(String number, PhoneType type) {
+      this.number = number;
+      this.type = type;
+    }
+
     private PhoneNumber(Builder builder) {
-      super(builder);
-      this.number = builder.number;
-      this.type = builder.type;
+      this(builder.number, builder.type);
+      setBuilder(builder);
     }
 
     @Override
     public boolean equals(Object other) {
+      if (other == this) return true;
       if (!(other instanceof PhoneNumber)) return false;
       PhoneNumber o = (PhoneNumber) other;
       return equals(number, o.number)
@@ -190,11 +222,17 @@ public Builder(PhoneNumber message) {
         this.type = message.type;
       }
 
+      /**
+       * The customer's phone number.
+       */
       public Builder number(String number) {
         this.number = number;
         return this;
       }
 
+      /**
+       * The type of phone stored here.
+       */
       public Builder type(PhoneType type) {
         this.type = type;
         return this;
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
new file mode 100644
index 000000000..b72c1f5fe
--- /dev/null
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
@@ -0,0 +1,72 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class WireConverterTest {
+  private static final Person PROTO =
+      new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
+  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
+
+  private final WireConverter converter = new WireConverter();
+
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(PROTO, Person.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
+  }
+
+  @Test public void deserialize() throws Exception {
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
+    assertThat(proto).isEqualTo(PROTO);
+  }
+
+  @Test public void deserializeWrongClass() throws Exception {
+    try {
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
+    }
+  }
+
+  @Test public void deserializeWrongType() throws Exception {
+    try {
+      converter.fromBody(protoResponse(ENCODED_PROTO),
+          ArrayList.class.getGenericSuperclass());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
+    }
+  }
+
+  @Test public void deserializeWrongValue() throws Exception {
+    try {
+      converter.fromBody(protoResponse("////"), Person.class);
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
+        ByteString.decodeBase64(encodedProto).toByteArray());
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
deleted file mode 100644
index d4f837d95..000000000
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
+++ /dev/null
@@ -1,85 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.google.common.io.BaseEncoding;
-import com.squareup.wire.Wire;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WireConverterTest {
-  private static final Person PROTO =
-      new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
-  private static final String PROTO_ENCODED = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
-
-  private WireConverter converter = new WireConverter(new Wire());
-
-  @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = converter.toBody(PROTO);
-    assertThat(protoBytes.mimeType()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(PROTO_ENCODED)));
-  }
-
-  @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(decodeBase64(PROTO_ENCODED), Person.class);
-    assertThat(proto).isEqualTo(PROTO);
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED), String.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
-    }
-  }
-
-  @Test public void deserializeWrongType() throws Exception {
-    try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED),
-          ArrayList.class.getGenericSuperclass());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
-    }
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    try {
-      converter.fromBody(decodeBase64("////"), Person.class);
-      fail();
-    } catch (ConversionException expected) {
-      assertThat(expected.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void deserializeWrongMime() throws Exception {
-    try {
-      converter.fromBody(decodeBase64("////", "yummy/bytes"), Person.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto but was: yummy/bytes");
-    }
-  }
-
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
-  }
-
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, "application/x-protobuf");
-  }
-
-  private static TypedByteArray decodeBase64(String base64, String mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(mime, BaseEncoding.base64().decode(base64));
-  }
-}
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 3ede42ec0..83c3a836e 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -20,26 +20,14 @@
       <version>${project.version}</version>
     </dependency>
 
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
-
-    <dependency>
-      <groupId>com.netflix.rxjava</groupId>
-      <artifactId>rxjava-core</artifactId>
-      <optional>true</optional>
-    </dependency>
-
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
index 87d18b3bf..34eaea450 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpException.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
@@ -1,10 +1,10 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.util.ArrayList;
-import java.util.List;
-import retrofit.client.Header;
-import retrofit.client.Response;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import retrofit.converter.Converter;
 
 import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
@@ -18,7 +18,7 @@
 /**
  * An exception used to trigger the simulation of an HTTP error for mock services.
  *
- * @see MockRestAdapter
+ * @see MockRetrofit
  */
 public class MockHttpException extends RuntimeException {
   /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
@@ -67,7 +67,7 @@ public static MockHttpException newInternalError(Object responseBody) {
   final int code;
   final String reason;
   final Object responseBody;
-  final List<Header> headers = new ArrayList<Header>(2);
+  final Headers.Builder headers = new Headers.Builder();
 
   /**
    * Create a new HTTP exception.
@@ -97,11 +97,18 @@ public MockHttpException withHeader(String name, String value) {
     if (value == null || "".equals(value.trim())) {
       throw new IllegalArgumentException("Header value must not be blank.");
     }
-    headers.add(new Header(name, value));
+    headers.add(name, value);
     return this;
   }
 
-  Response toResponse(Converter converter) {
-    return new Response(code, reason, headers, new MockTypedInput(converter, responseBody));
+  Response toResponse(Request request, Converter converter) {
+    return new Response.Builder()
+        .code(code)
+        .message(reason)
+        .headers(headers.build())
+        .body(new MockResponseBody(converter, responseBody))
+        .protocol(Protocol.HTTP_1_1)
+        .request(request)
+        .build();
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
deleted file mode 100644
index 209b07a72..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.lang.reflect.Type;
-import retrofit.client.Response;
-
-class MockHttpRetrofitError extends RetrofitError {
-  private final Object body;
-
-  MockHttpRetrofitError(String url, Response response, Object body) {
-    super(url, response, null, null, false, null);
-    this.body = body;
-  }
-
-  @Override public Object getBody() {
-    return body;
-  }
-
-  @Override public Object getBodyAs(Type type) {
-    return body;
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
new file mode 100644
index 000000000..03f1194e9
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
@@ -0,0 +1,46 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import retrofit.converter.Converter;
+
+class MockResponseBody extends ResponseBody {
+  private final Converter converter;
+  private final Object body;
+
+  private byte[] bytes;
+
+  MockResponseBody(Converter converter, Object body) {
+    this.converter = converter;
+    this.body = body;
+  }
+
+  @Override public MediaType contentType() {
+    return MediaType.parse("application/unknown");
+  }
+
+  @Override public long contentLength() {
+    try {
+      initBytes();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+    return bytes.length;
+  }
+
+  @Override public BufferedSource source() {
+    return new Buffer().write(bytes);
+  }
+
+  private synchronized void initBytes() throws IOException {
+    if (bytes == null) {
+      Buffer buffer = new Buffer();
+      converter.toBody(body, body.getClass()).writeTo(buffer);
+      bytes = buffer.readByteArray();
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
index 25c02dac5..9828db1e1 100644
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
@@ -1,25 +1,21 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
-import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import rx.Observable;
-import rx.Observer;
-import rx.Subscription;
-import rx.concurrency.Schedulers;
 
-import static retrofit.RestAdapter.LogLevel;
+import static retrofit.RetrofitError.unexpectedError;
 
 /**
- * Wraps mocks implementations of API interfaces so that they exhibit the delay and error
+ * Wraps mock implementations of API interfaces so that they exhibit the delay and error
  * characteristics of a real network.
  * <p>
  * Because APIs are defined as interfaces, versions of the API that use mock data can be created by
@@ -42,7 +38,7 @@
  * </pre>
  * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
  * <pre>
- *   MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+ *   MockRetrofit mockRetrofit = MockRetrofit.from(restAdapter);
  * </pre>
  * Instances of this class should be used as a singleton so that the behavior of every mock service
  * is consistent.
@@ -50,7 +46,7 @@
  * Rather than using the {@code MockUserService} directly, pass it through
  * {@link #create(Class, Object) the create method}.
  * <pre>
- *   UserService service = mockRestAdapter.create(UserService.class, new MockUserService());
+ *   UserService service = mockRetrofit.create(UserService.class, new MockUserService());
  * </pre>
  * The returned {@code UserService} instance will now behave like it is happening over the network
  * while allowing the mock implementation to be written synchronously.
@@ -59,56 +55,31 @@
  * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
  * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
  */
-public final class MockRestAdapter {
+public final class MockRetrofit {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
   private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
 
   /**
-   * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
+   * Create a new {@link MockRetrofit} which will act as a factory for mock services. Some of
    * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
    */
-  public static MockRestAdapter from(RestAdapter restAdapter) {
-    return new MockRestAdapter(restAdapter);
-  }
-
-  /** A listener invoked when the network behavior values for a {@link MockRestAdapter} change. */
-  public interface ValueChangeListener {
-    void onMockValuesChanged(long delayMs, int variancePct, int errorPct);
-
-    ValueChangeListener EMPTY = new ValueChangeListener() {
-      @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
-      }
-    };
+  public static MockRetrofit from(RestAdapter restAdapter, Executor executor) {
+    return new MockRetrofit(restAdapter, executor);
   }
 
   private final RestAdapter restAdapter;
-  private final MockRxSupport mockRxSupport;
+  private final Executor executor;
   final Random random = new Random();
 
-  private ValueChangeListener listener = ValueChangeListener.EMPTY;
   private int delayMs = DEFAULT_DELAY_MS;
   private int variancePct = DEFAULT_VARIANCE_PCT;
   private int errorPct = DEFAULT_ERROR_PCT;
 
-  private MockRestAdapter(RestAdapter restAdapter) {
+  private MockRetrofit(RestAdapter restAdapter, Executor executor) {
     this.restAdapter = restAdapter;
-
-    if (Platform.HAS_RX_JAVA) {
-      mockRxSupport = new MockRxSupport(restAdapter);
-    } else {
-      mockRxSupport = null;
-    }
-  }
-
-  /** Set a listener to be notified when any mock value changes. */
-  public void setValueChangeListener(ValueChangeListener listener) {
-    this.listener = listener;
-  }
-
-  private void notifyValueChangeListener() {
-    listener.onMockValuesChanged(delayMs, variancePct, errorPct);
+    this.executor = executor;
   }
 
   /** Set the network round trip delay, in milliseconds. */
@@ -119,10 +90,7 @@ public void setDelay(long delayMs) {
     if (delayMs > Integer.MAX_VALUE) {
       throw new IllegalArgumentException("Delay value too large. Max: " + Integer.MAX_VALUE);
     }
-    if (this.delayMs != delayMs) {
-      this.delayMs = (int) delayMs;
-      notifyValueChangeListener();
-    }
+    this.delayMs = (int) delayMs;
   }
 
   /** The network round trip delay, in milliseconds */
@@ -135,10 +103,7 @@ public void setVariancePercentage(int variancePct) {
     if (variancePct < 0 || variancePct > 100) {
       throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
     }
-    if (this.variancePct != variancePct) {
-      this.variancePct = variancePct;
-      notifyValueChangeListener();
-    }
+    this.variancePct = variancePct;
   }
 
   /** The plus-or-minus variance percentage of the network round trip delay. */
@@ -151,10 +116,7 @@ public void setErrorPercentage(int errorPct) {
     if (errorPct < 0 || errorPct > 100) {
       throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
     }
-    if (this.errorPct != errorPct) {
-      this.errorPct = errorPct;
-      notifyValueChangeListener();
-    }
+    this.errorPct = errorPct;
   }
 
   /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
@@ -216,16 +178,14 @@ public int calculateDelayForCall() {
   public <T> T create(Class<T> service, T mockService) {
     Utils.validateServiceClass(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new MockHandler(mockService, restAdapter.getMethodInfoCache(service)));
+        new MockHandler(service, mockService));
   }
 
   private class MockHandler implements InvocationHandler {
     private final Object mockService;
-    private final Map<Method, RestMethodInfo> methodInfoCache;
 
-    public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCache) {
+    public MockHandler(Object mockService, T service) {
       this.mockService = mockService;
-      this.methodInfoCache = methodInfoCache;
     }
 
     @Override public Object invoke(Object proxy, Method method, final Object[] args)
@@ -236,70 +196,48 @@ public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCac
       }
 
       // Load or create the details cache for the current method.
-      final RestMethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
-
-      if (methodInfo.isSynchronous) {
-        return invokeSync(methodInfo, restAdapter.requestInterceptor, args);
-      }
-
-      if (restAdapter.httpExecutor == null || restAdapter.callbackExecutor == null) {
-        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
-      }
-      // Apply the interceptor synchronously, recording the interception so we can replay it later.
-      // This way we still defer argument serialization to the background thread.
-      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-      restAdapter.requestInterceptor.intercept(interceptorTape);
-
-      if (methodInfo.isObservable) {
-        return mockRxSupport.createMockObservable(this, methodInfo, interceptorTape, args);
+      final MethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
+      final Request request = buildRequest(methodInfo, args);
+
+      if (methodInfo.executionType == MethodInfo.ExecutionType.SYNC) {
+        try {
+          return invokeSync(methodInfo, args, request);
+        } catch (RetrofitError error) {
+          Throwable newError = restAdapter.errorHandler.handleError(error);
+          if (newError == null) {
+            throw new IllegalStateException("Error handler returned null for wrapped exception.",
+                error);
+          }
+          throw newError;
+        }
       }
 
-      restAdapter.httpExecutor.execute(new Runnable() {
+      executor.execute(new Runnable() {
         @Override public void run() {
-          invokeAsync(methodInfo, interceptorTape, args);
+          invokeAsync(methodInfo, args, request);
         }
       });
       return null; // Asynchronous methods should have return type of void.
     }
 
-    private Request buildRequest(RestMethodInfo methodInfo, RequestInterceptor interceptor,
-        Object[] args) throws Throwable {
-      methodInfo.init();
-
+    private Request buildRequest(MethodInfo methodInfo, Object[] args) throws Throwable {
       // Begin building a normal request.
-      RequestBuilder requestBuilder = new RequestBuilder(restAdapter.converter, methodInfo);
-      requestBuilder.setApiUrl(restAdapter.server.getUrl());
+      String apiUrl = restAdapter.endpoint.url();
+      RequestBuilder requestBuilder = new RequestBuilder(apiUrl, methodInfo, restAdapter.converter);
       requestBuilder.setArguments(args);
-
-      // Run it through the interceptor.
-      interceptor.intercept(requestBuilder);
-
-      Request request = requestBuilder.build();
-
-      if (restAdapter.logLevel.log()) {
-        request = restAdapter.logAndReplaceRequest("MOCK", request);
-      }
-
-      return request;
+      return requestBuilder.build();
     }
 
-    private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor interceptor,
-        Object[] args) throws Throwable {
-      Request request = buildRequest(methodInfo, interceptor, args);
-      String url = request.getUrl();
+    private Object invokeSync(MethodInfo methodInfo, Object[] args, Request request)
+        throws Throwable {
+      String url = request.urlString();
 
       if (calculateIsFailure()) {
         sleep(calculateDelayForError());
         IOException exception = new IOException("Mock network error!");
-        if (restAdapter.logLevel.log()) {
-          restAdapter.logException(exception, url);
-        }
-        throw RetrofitError.networkError(url, exception);
+        throw RetrofitError.networkFailure(url, exception);
       }
 
-      LogLevel logLevel = restAdapter.logLevel;
-      RestAdapter.Log log = restAdapter.log;
-
       int callDelay = calculateDelayForCall();
       long beforeNanos = System.nanoTime();
       try {
@@ -309,14 +247,6 @@ private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor intercep
         long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
         sleep(callDelay - tookMs);
 
-        if (logLevel.log()) {
-          log.log(String.format("<--- MOCK 200 %s (%sms)", url, callDelay));
-          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-            log.log(returnValue + ""); // Hack to convert toString while supporting null.
-            log.log("<--- END MOCK");
-          }
-        }
-
         return returnValue;
       } catch (InvocationTargetException e) {
         Throwable innerEx = e.getCause();
@@ -324,152 +254,63 @@ private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor intercep
           throw innerEx;
         }
         MockHttpException httpEx = (MockHttpException) innerEx;
-        Response response = httpEx.toResponse(restAdapter.converter);
+        Response response = httpEx.toResponse(request, restAdapter.converter);
 
         // Sleep for whatever amount of time is left to satisfy the network delay, if any.
         long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
         sleep(callDelay - tookMs);
 
-        if (logLevel.log()) {
-          log.log(String.format("<---- MOCK %s %s (%sms)", httpEx.code, url, callDelay));
-          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-            log.log(httpEx.responseBody + ""); // Hack to convert toString while supporting null.
-            log.log("<--- END MOCK");
-          }
-        }
-
-        throw new MockHttpRetrofitError(url, response, httpEx.responseBody);
+        throw new MockHttpRetrofitError(httpEx.reason, url, response, httpEx.responseBody,
+            methodInfo.responseType);
       }
     }
 
-    private void invokeAsync(RestMethodInfo methodInfo, RequestInterceptor interceptorTape,
-        Object[] args) {
-      Request request;
-      try {
-        request = buildRequest(methodInfo, interceptorTape, args);
-      } catch (final Throwable throwable) {
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            throw new RuntimeException(throwable);
-          }
-        });
-        return;
-      }
-
-      LogLevel logLevel = restAdapter.logLevel;
-      RestAdapter.Log log = restAdapter.log;
-
-      long beforeNanos = System.nanoTime();
-      int callDelay = calculateDelayForCall();
-
-      final String url = request.getUrl();
-      final Callback realCallback = (Callback) args[args.length - 1];
+    private void invokeAsync(final MethodInfo methodInfo, final Object[] args,
+        final Request request) {
+      final String url = request.urlString();
+      final Callback callback = (Callback) args[args.length - 1];
 
       if (calculateIsFailure()) {
         sleep(calculateDelayForError());
-        final IOException exception = new IOException("Mock network error!");
-        if (restAdapter.logLevel.log()) {
-          restAdapter.logException(exception, url);
-        }
+        IOException exception = new IOException("Mock network error!");
+        RetrofitError error = RetrofitError.networkFailure(url, exception);
+        Throwable cause = restAdapter.errorHandler.handleError(error);
+        final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
         restAdapter.callbackExecutor.execute(new Runnable() {
           @Override public void run() {
-            realCallback.failure(RetrofitError.networkError(url, exception));
+            callback.failure(e);
           }
         });
         return;
       }
 
-      // Replace the normal callback with one which supports the delay.
-      Object[] newArgs = new Object[args.length];
-      System.arraycopy(args, 0, newArgs, 0, args.length - 1);
-      newArgs[args.length - 1] = new DelayingCallback(beforeNanos, callDelay, url, realCallback);
+      final int callDelay = calculateDelayForCall();
+      sleep(callDelay);
 
-      try {
-        methodInfo.method.invoke(mockService, newArgs);
-      } catch (Throwable throwable) {
-        final Throwable innerEx = throwable.getCause();
-        if (!(innerEx instanceof MockHttpException)) {
-          restAdapter.callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
+      restAdapter.callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            methodInfo.method.invoke(mockService, args);
+          } catch (Throwable throwable) {
+            final Throwable innerEx = throwable.getCause();
+            if (!(innerEx instanceof MockHttpException)) {
               if (innerEx instanceof RuntimeException) {
                 throw (RuntimeException) innerEx;
               }
               throw new RuntimeException(innerEx);
             }
-          });
-          return;
-        }
 
-        MockHttpException httpEx = (MockHttpException) innerEx;
-        Response response = httpEx.toResponse(restAdapter.converter);
-
-        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
-        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
-
-        sleep(callDelay - tookMs);
-
-        if (logLevel.log()) {
-          log.log(String.format("<---- MOCK %s %s (%sms)", httpEx.code, url, callDelay));
-          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-            log.log(httpEx.responseBody + ""); // Hack to convert toString while supporting null.
-            log.log("<--- END MOCK");
-          }
-        }
-
-        final RetrofitError error = new MockHttpRetrofitError(url, response, httpEx.responseBody);
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            realCallback.failure(error);
-          }
-        });
-      }
-    }
-
-    private class DelayingCallback implements Callback {
-      private final long beforeNanos;
-      private final String url;
-      private final Callback realCallback;
-      private final long callDelay;
-
-      private DelayingCallback(long beforeNanos, int callDelay, String url, Callback realCallback) {
-        this.beforeNanos = beforeNanos;
-        this.callDelay = callDelay;
-        this.url = url;
-        this.realCallback = realCallback;
-      }
-
-      @Override public void success(final Object object, final Response response) {
-        LogLevel logLevel = restAdapter.logLevel;
-        RestAdapter.Log log = restAdapter.log;
-
-        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
-        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
-        sleep(callDelay - tookMs);
+            MockHttpException httpEx = (MockHttpException) innerEx;
+            Response response = httpEx.toResponse(request, restAdapter.converter);
 
-        if (logLevel.log()) {
-          log.log(String.format("<--- MOCK 200 %s (%sms)", url, callDelay));
-          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-            log.log(object + ""); // Hack to convert toString while supporting null.
-            log.log("<--- END MOCK");
+            RetrofitError error = new MockHttpRetrofitError(httpEx.getMessage(), url, response,
+                httpEx.responseBody, methodInfo.responseType);
+            Throwable cause = restAdapter.errorHandler.handleError(error);
+            final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
+            callback.failure(e);
           }
         }
-
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @SuppressWarnings("unchecked") //
-          @Override public void run() {
-            realCallback.success(object, response);
-          }
-        });
-      }
-
-      @Override public void failure(final RetrofitError error) {
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            throw new IllegalStateException(
-                "Calling failure directly is not supported. Throw MockHttpException instead.");
-          }
-        });
-      }
+      });
     }
   }
 
@@ -507,29 +348,4 @@ private static void sleep(long ms) {
   private static long uptimeMillis() {
     return System.nanoTime() / 1000000L;
   }
-
-  /** Indirection to avoid VerifyError if RxJava isn't present. */
-  private static class MockRxSupport {
-    private final RestAdapter restAdapter;
-
-    MockRxSupport(RestAdapter restAdapter) {
-      this.restAdapter = restAdapter;
-    }
-
-    Observable createMockObservable(final MockHandler mockHandler, final RestMethodInfo methodInfo,
-        final RequestInterceptor interceptor, final Object[] args) {
-      return Observable.create(new Observable.OnSubscribeFunc<Object>() {
-        @Override public Subscription onSubscribe(Observer<? super Object> observer) {
-          try {
-            Observable observable =
-                (Observable) mockHandler.invokeSync(methodInfo, interceptor, args);
-            //noinspection unchecked
-            return observable.subscribe(observer);
-          } catch (Throwable throwable) {
-            return Observable.error(throwable).subscribe(observer);
-          }
-        }
-      }).subscribeOn(Schedulers.executor(restAdapter.httpExecutor));
-    }
-  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java b/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
deleted file mode 100644
index 278aebc02..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
-
-class MockTypedInput implements TypedInput {
-  private final Converter converter;
-  private final Object body;
-
-  private byte[] bytes;
-
-  MockTypedInput(Converter converter, Object body) {
-    this.converter = converter;
-    this.body = body;
-  }
-
-  @Override public String mimeType() {
-    return "application/unknown";
-  }
-
-  @Override public long length() {
-    try {
-      initBytes();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-    return bytes.length;
-  }
-
-  @Override public InputStream in() throws IOException {
-    initBytes();
-    return new ByteArrayInputStream(bytes);
-  }
-
-  private synchronized void initBytes() throws IOException {
-    if (bytes == null) {
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      converter.toBody(body).writeTo(out);
-      bytes = out.toByteArray();
-    }
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java b/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
deleted file mode 100644
index 80cab9abc..000000000
--- a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.android;
-
-import android.content.SharedPreferences;
-import retrofit.MockRestAdapter;
-
-/**
- * A {@link MockRestAdapter.ValueChangeListener value change listener} for {@link MockRestAdapter}
- * which stores any customized behavior values into shared preferences.
- */
-public final class AndroidMockValuePersistence implements MockRestAdapter.ValueChangeListener {
-  private static final String KEY_DELAY = "retrofit-mock-delay";
-  private static final String KEY_VARIANCE = "retrofit-mock-variance";
-  private static final String KEY_ERROR = "retrofit-mock-error";
-
-  /**
-   * Install a {@link MockRestAdapter.ValueChangeListener value change listener} on the supplied
-   * {@link MockRestAdapter} using the {@link SharedPreferences} for storing customized behavior
-   * values. Invoking this will load any existing stored values for the mock adapter's behavior.
-   */
-  public static void install(MockRestAdapter mockRestAdapter, SharedPreferences preferences) {
-    long delay = preferences.getLong(KEY_DELAY, -1);
-    if (delay != -1) {
-      mockRestAdapter.setDelay(delay);
-    }
-
-    int variance = preferences.getInt(KEY_VARIANCE, -1);
-    if (variance != -1) {
-      mockRestAdapter.setVariancePercentage(variance);
-    }
-
-    int error = preferences.getInt(KEY_ERROR, -1);
-    if (error != -1) {
-      mockRestAdapter.setErrorPercentage(error);
-    }
-
-    mockRestAdapter.setValueChangeListener(new AndroidMockValuePersistence(preferences));
-  }
-
-  private final SharedPreferences preferences;
-
-  private AndroidMockValuePersistence(SharedPreferences preferences) {
-    this.preferences = preferences;
-  }
-
-  @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
-    preferences.edit()
-        .putLong(KEY_DELAY, delayMs)
-        .putInt(KEY_VARIANCE, variancePct)
-        .putInt(KEY_ERROR, errorPct)
-        .apply();
-  }
-}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
index 443920bfd..c87b80bf7 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
@@ -1,7 +1,9 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -9,76 +11,80 @@
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.client.Client;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.http.GET;
 import rx.Observable;
-import rx.util.functions.Action1;
+import rx.functions.Action1;
 
-import static org.fest.assertions.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
-import static retrofit.MockRestAdapter.ValueChangeListener;
 import static retrofit.Utils.SynchronousExecutor;
 
-public class MockRestAdapterTest {
+public class MockRetrofitTest {
   interface SyncExample {
     @GET("/") Object doStuff();
   }
 
   interface AsyncExample {
-    @GET("/") void doStuff(Callback<Object> cb);
+    @GET("/") void doStuff(Callback<String> cb);
+  }
+
+  interface AsyncCallbackSubtypeExample {
+    abstract class Foo implements Callback<String> {}
+
+    @GET("/") void doStuff(Foo foo);
   }
 
   interface ObservableExample {
-    @GET("/") Observable<Object> doStuff();
+    @GET("/") Observable<String> doStuff();
   }
 
   private Executor httpExecutor;
   private Executor callbackExecutor;
-  private MockRestAdapter mockRestAdapter;
-  private ValueChangeListener valueChangeListener;
+  private MockRetrofit mockRetrofit;
+  private Throwable nextError;
 
   @Before public void setUp() throws IOException {
-    Client client = mock(Client.class);
-    doThrow(new AssertionError()).when(client).execute(any(Request.class));
-
     httpExecutor = spy(new SynchronousExecutor());
     callbackExecutor = spy(new SynchronousExecutor());
 
     RestAdapter restAdapter = new RestAdapter.Builder() //
-        .setClient(client)
-        .setExecutors(httpExecutor, callbackExecutor)
-        .setServer("http://example.com")
-        .setLogLevel(RestAdapter.LogLevel.NONE)
+        .callbackExecutor(callbackExecutor)
+        .endpoint("http://example.com")
+        .errorHandler(new ErrorHandler() {
+          @Override public Throwable handleError(RetrofitError cause) {
+            if (nextError != null) {
+              Throwable error = nextError;
+              nextError = null;
+              return error;
+            }
+            return cause;
+          }
+        })
         .build();
 
-    valueChangeListener = mock(ValueChangeListener.class);
-
-    mockRestAdapter = MockRestAdapter.from(restAdapter);
-    mockRestAdapter.setValueChangeListener(valueChangeListener);
+    mockRetrofit = MockRetrofit.from(restAdapter, httpExecutor);
 
     // Seed the random with a value so the tests are deterministic.
-    mockRestAdapter.random.setSeed(2847);
+    mockRetrofit.random.setSeed(2847);
   }
 
   @Test public void delayRestrictsRange() {
     try {
-      mockRestAdapter.setDelay(-1);
+      mockRetrofit.setDelay(-1);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Delay must be positive value.");
     }
     try {
-      mockRestAdapter.setDelay(Long.MAX_VALUE);
+      mockRetrofit.setDelay(Long.MAX_VALUE);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageStartingWith("Delay value too large.");
@@ -87,13 +93,13 @@
 
   @Test public void varianceRestrictsRange() {
     try {
-      mockRestAdapter.setVariancePercentage(-13);
+      mockRetrofit.setVariancePercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
     }
     try {
-      mockRestAdapter.setVariancePercentage(174);
+      mockRetrofit.setVariancePercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
@@ -102,13 +108,13 @@
 
   @Test public void errorRestrictsRange() {
     try {
-      mockRestAdapter.setErrorPercentage(-13);
+      mockRetrofit.setErrorPercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
     }
     try {
-      mockRestAdapter.setErrorPercentage(174);
+      mockRetrofit.setErrorPercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
@@ -116,15 +122,15 @@
   }
 
   @Test public void errorPercentageIsAccurate() {
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setErrorPercentage(0);
     for (int i = 0; i < 10000; i++) {
-      assertThat(mockRestAdapter.calculateIsFailure()).isFalse();
+      assertThat(mockRetrofit.calculateIsFailure()).isFalse();
     }
 
-    mockRestAdapter.setErrorPercentage(3);
+    mockRetrofit.setErrorPercentage(3);
     int failures = 0;
     for (int i = 0; i < 100000; i++) {
-      if (mockRestAdapter.calculateIsFailure()) {
+      if (mockRetrofit.calculateIsFailure()) {
         failures += 1;
       }
     }
@@ -132,18 +138,18 @@
   }
 
   @Test public void delayVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
-    mockRestAdapter.setVariancePercentage(0);
+    mockRetrofit.setVariancePercentage(0);
     for (int i = 0; i < 100000; i++) {
-      assertThat(mockRestAdapter.calculateDelayForCall()).isEqualTo(2000);
+      assertThat(mockRetrofit.calculateDelayForCall()).isEqualTo(2000);
     }
 
-    mockRestAdapter.setVariancePercentage(40);
+    mockRetrofit.setVariancePercentage(40);
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForCall();
+      int delay = mockRetrofit.calculateDelayForCall();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -156,12 +162,12 @@
   }
 
   @Test public void errorVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForError();
+      int delay = mockRetrofit.calculateDelayForError();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -173,33 +179,9 @@
     assertThat(lowerBound).isEqualTo(0);
   }
 
-  @Test public void changeListenerOnlyInvokedWhenValueHasChanged() {
-    long delay = mockRestAdapter.getDelay();
-    int variance = mockRestAdapter.getVariancePercentage();
-    int error = mockRestAdapter.getErrorPercentage();
-
-    long newDelay = delay + 1;
-    mockRestAdapter.setDelay(newDelay);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, error);
-
-    int newError = error + 1;
-    mockRestAdapter.setErrorPercentage(newError);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, newError);
-
-    int newVariance = variance + 1;
-    mockRestAdapter.setVariancePercentage(newVariance);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, newVariance, newError);
-
-    // Now try setting the same values and ensure the listener was never called.
-    mockRestAdapter.setDelay(newDelay);
-    mockRestAdapter.setVariancePercentage(newVariance);
-    mockRestAdapter.setErrorPercentage(newError);
-    verifyNoMoreInteractions(valueChangeListener);
-  }
-
   @Test public void syncFailureTriggersNetworkError() {
-    mockRestAdapter.setErrorPercentage(100);
-    mockRestAdapter.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
@@ -207,32 +189,32 @@
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     try {
       mockService.doStuff();
       fail();
     } catch (RetrofitError e) {
-      assertThat(e.isNetworkError()).isTrue();
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
       assertThat(e.getCause()).hasMessage("Mock network error!");
     }
   }
 
   @Test public void asyncFailureTriggersNetworkError() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new AssertionError();
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -245,14 +227,14 @@
     verify(callbackExecutor).execute(any(Runnable.class));
 
     RetrofitError error = errorRef.get();
-    assertThat(error.isNetworkError()).isTrue();
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
     assertThat(error.getCause()).hasMessage("Mock network error!");
   }
 
   @Test public void syncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     final AtomicBoolean called = new AtomicBoolean();
     final Object expected = new Object();
@@ -263,7 +245,7 @@
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     Object actual = mockService.doStuff();
@@ -275,24 +257,26 @@
   }
 
   @Test public void asyncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hi");
 
-    final Object expected = new Object();
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         cb.success(expected, null);
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<Object>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object result, Response response) {
+    final AtomicReference<Object> actual = new AtomicReference<>();
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String result, Response response) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         actual.set(result);
       }
@@ -310,23 +294,25 @@
   }
 
   @Test public void observableApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hello");
 
-    final Object expected = new Object();
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
-        return Observable.from(expected);
+      @Override public Observable<String> doStuff() {
+        return Observable.just(expected);
       }
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<Object>();
+    final AtomicReference<Object> actual = new AtomicReference<>();
     Action1<Object> onSuccess = new Action1<Object>() {
       @Override public void call(Object o) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
@@ -350,18 +336,20 @@
 
 
   @Test public void syncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hello");
 
-    final Object expected = new Object();
     class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
+      @Override public String doStuff() {
         throw new MockHttpException(404, "Not Found", expected);
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     try {
@@ -370,32 +358,35 @@
     } catch (RetrofitError e) {
       long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
       assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e.isNetworkError()).isFalse();
-      assertThat(e.getResponse().getStatus()).isEqualTo(404);
-      assertThat(e.getResponse().getReason()).isEqualTo("Not Found");
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+      assertThat(e.getResponse().code()).isEqualTo(404);
+      assertThat(e.getResponse().message()).isEqualTo("Not Found");
       assertThat(e.getBody()).isSameAs(expected);
+      assertThat(e.getSuccessType()).isEqualTo(Object.class);
     }
   }
 
   @Test public void asyncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Greetings");
 
-    final Object expected = new Object();
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new MockHttpException(404, "Not Found", expected);
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -410,30 +401,33 @@
 
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.isNetworkError()).isFalse();
-    assertThat(error.getResponse().getStatus()).isEqualTo(404);
-    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+    assertThat(error.getResponse().code()).isEqualTo(404);
+    assertThat(error.getResponse().message()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void observableHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hi");
 
-    final Object expected = new Object();
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw new MockHttpException(404, "Not Found", expected);
       }
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff().subscribe(new Action1<Object>() {
       @Override public void call(Object o) {
         throw new AssertionError();
@@ -446,34 +440,164 @@
       }
     });
 
-    verify(httpExecutor, atLeastOnce()).execute(any(Runnable.class));
+    verify(httpExecutor).execute(any(Runnable.class));
     verifyZeroInteractions(callbackExecutor);
 
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.isNetworkError()).isFalse();
-    assertThat(error.getResponse().getStatus()).isEqualTo(404);
-    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+    assertThat(error.getResponse().code()).isEqualTo(404);
+    assertThat(error.getResponse().message()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
-  @Test public void asyncCallToFailureIsNotAllowed() {
-    mockRestAdapter.setErrorPercentage(0);
+  @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
-        cb.failure(null);
+    class MockObservableExample implements ObservableExample {
+      @Override public Observable<String> doStuff() {
+        throw MockHttpException.newBadRequest(null);
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    ObservableExample mockService =
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
+    mockService.doStuff().subscribe(new Action1<Object>() {
+      @Override public void call(Object o) {
+        throw new AssertionError();
+      }
+    }, new Action1<Throwable>() {
+      @Override public void call(Throwable error) {
+        assertThat(error).isInstanceOf(RetrofitError.class);
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        errorRef.set((RetrofitError) error);
+      }
+    });
+
+    verify(httpExecutor).execute(any(Runnable.class));
+    verifyZeroInteractions(callbackExecutor);
+
+    RetrofitError error = errorRef.get();
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+    assertThat(error.getResponse().code()).isEqualTo(400);
+    assertThat(error.getResponse().message()).isEqualTo("Bad Request");
+    assertThat(error.getBody()).isNull();
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
+  }
+
+  @Test public void syncErrorUsesErrorHandler() {
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    class MockSyncExample implements SyncExample {
+      @Override public Object doStuff() {
+        throw MockHttpException.newNotFound(new Object());
+      }
+    }
+
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
+    nextError = new IllegalArgumentException("Test");
 
     try {
-      mockService.doStuff(mock(Callback.class));
+      mockService.doStuff();
       fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Calling failure directly is not supported. Throw MockHttpException instead.");
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Test");
+    }
+  }
+
+  @Test public void asyncErrorUsesErrorHandler() throws InterruptedException {
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    class MockAsyncExample implements AsyncExample {
+      @Override public void doStuff(Callback<String> cb) {
+        throw MockHttpException.newNotFound(new Object());
+      }
+    }
+
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
+    nextError = new IllegalArgumentException("Test");
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(RetrofitError error) {
+        assertThat(error.getCause()).hasMessage("Test");
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
+  }
+
+  @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    class MockObservableExample implements ObservableExample {
+      @Override public Observable<String> doStuff() {
+        throw MockHttpException.newNotFound(new Object());
+      }
     }
+
+    ObservableExample mockService =
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
+    nextError = new IllegalArgumentException("Test");
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    mockService.doStuff().subscribe(new Action1<Object>() {
+      @Override public void call(Object o) {
+        throw new AssertionError();
+      }
+    }, new Action1<Throwable>() {
+      @Override public void call(Throwable error) {
+        assertThat(error).hasMessage("Test");
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
+  }
+
+  @Test public void asyncCanUseCallbackSubtype() {
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
+
+    class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
+      @Override public void doStuff(Foo foo) {
+        foo.success("Hello!", null);
+      }
+    }
+
+    AsyncCallbackSubtypeExample mockService =
+        mockRetrofit.create(AsyncCallbackSubtypeExample.class,
+            new MockAsyncCallbackSubtypeExample());
+
+    final AtomicReference<String> actual = new AtomicReference<>();
+    mockService.doStuff(new AsyncCallbackSubtypeExample.Foo() {
+      @Override public void success(String result, Response response) {
+        actual.set(result);
+      }
+
+      @Override public void failure(RetrofitError error) {
+        throw new AssertionError();
+      }
+    });
+
+    assertThat(actual.get()).isNotNull().isEqualTo("Hello!");
   }
 }
diff --git a/retrofit-samples/github-client/pom.xml b/retrofit-samples/github-client/pom.xml
deleted file mode 100644
index 33fb0cf76..000000000
--- a/retrofit-samples/github-client/pom.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.retrofit.samples</groupId>
-    <artifactId>parent</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>github-client</artifactId>
-  <name>Sample: GitHub Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/retrofit-samples/mock-github-client/pom.xml b/retrofit-samples/mock-github-client/pom.xml
deleted file mode 100644
index ca9132f9c..000000000
--- a/retrofit-samples/mock-github-client/pom.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!--
-  ~ Copyright 2013 Square, Inc.
-  -->
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.retrofit.samples</groupId>
-    <artifactId>parent</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>mock-github-client</artifactId>
-  <name>Sample: Mock GitHub Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit-mock</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index c43d2f0f7..b4e355270 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.3.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -14,23 +14,14 @@
   <name>Retrofit</name>
 
   <dependencies>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>okhttp</artifactId>
-      <optional>true</optional>
     </dependency>
+
     <dependency>
-      <groupId>com.netflix.rxjava</groupId>
-      <artifactId>rxjava-core</artifactId>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
 
@@ -40,8 +31,8 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
@@ -54,5 +45,10 @@
       <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/retrofit/src/main/java/retrofit/mime/TypedString.java b/retrofit/src/main/java/retrofit/Call.java
similarity index 55%
rename from retrofit/src/main/java/retrofit/mime/TypedString.java
rename to retrofit/src/main/java/retrofit/Call.java
index 9c83230ff..30b09ba3e 100644
--- a/retrofit/src/main/java/retrofit/mime/TypedString.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,20 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit.mime;
+package retrofit;
 
-import java.io.UnsupportedEncodingException;
+import java.io.IOException;
 
-public class TypedString extends TypedByteArray {
-  public TypedString(String string) {
-    super("text/plain; charset=UTF-8", convertToBytes(string));
-  }
-
-  private static byte[] convertToBytes(String string) {
-    try {
-      return string.getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
-    }
-  }
+public interface Call<T> extends Cloneable {
+  void enqueue(Callback<T> callback);
+  Response<T> execute() throws IOException;
+  void cancel();
+  Call<T> clone();
 }
diff --git a/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java b/retrofit/src/main/java/retrofit/CallAdapter.java
similarity index 58%
rename from retrofit/src/main/java/retrofit/android/MainThreadExecutor.java
rename to retrofit/src/main/java/retrofit/CallAdapter.java
index 81440d041..51a1678f1 100644
--- a/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,18 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit.android;
+package retrofit;
 
-import android.os.Handler;
-import android.os.Looper;
+import java.lang.reflect.Type;
 
-import java.util.concurrent.Executor;
+public interface CallAdapter<T> {
+  Type responseType();
+  Object adapt(Call<T> call);
 
-/** Executor that runs tasks on Android's main thread. */
-public final class MainThreadExecutor implements Executor {
-  private final Handler handler = new Handler(Looper.getMainLooper());
-
-  @Override public void execute(Runnable r) {
-    handler.post(r);
+  interface Factory {
+    CallAdapter<?> get(Type returnType);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index d05acdb63..e62e20d07 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -15,13 +15,11 @@
  */
 package retrofit;
 
-import retrofit.client.Response;
-
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
  * <p>
- * Callback methods are executed using the {@link RestAdapter} callback executor. When none is
+ * Callback methods are executed using the {@link Retrofit} callback executor. When none is
  * specified, the following defaults are used:
  * <ul>
  * <li>Android: Callbacks are executed on the application's main (UI) thread.</li>
@@ -29,16 +27,11 @@
  * </ul>
  *
  * @param <T> expected response type
- * @see RestAdapter.Builder#setExecutors
  */
 public interface Callback<T> {
-
   /** Successful HTTP response. */
-  void success(T t, Response response);
+  void success(Response<T> response);
 
-  /**
-   * Unsuccessful HTTP response due to network failure, non-2XX status code, or unexpected
-   * exception.
-   */
-  void failure(RetrofitError error);
+  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
+  void failure(Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit/CallbackRunnable.java b/retrofit/src/main/java/retrofit/CallbackRunnable.java
deleted file mode 100644
index c11734003..000000000
--- a/retrofit/src/main/java/retrofit/CallbackRunnable.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.util.concurrent.Executor;
-
-/**
- * A {@link Runnable} executed on a background thread to invoke {@link #obtainResponse()} which
- * performs an HTTP request. The response of the request, whether it be an object or exception, is
- * then marshaled to the supplied {@link Executor} in the form of a method call on a
- * {@link Callback}.
- */
-abstract class CallbackRunnable<T> implements Runnable {
-  private final Callback<T> callback;
-  private final Executor callbackExecutor;
-
-  CallbackRunnable(Callback<T> callback, Executor callbackExecutor) {
-    this.callback = callback;
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @SuppressWarnings("unchecked")
-  @Override public final void run() {
-    try {
-      final ResponseWrapper wrapper = obtainResponse();
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.success((T) wrapper.responseBody, wrapper.response);
-        }
-      });
-    } catch (final RetrofitError e) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.failure(e);
-        }
-      });
-    }
-  }
-
-  public abstract ResponseWrapper obtainResponse();
-}
diff --git a/retrofit/src/main/java/retrofit/ChangeableServer.java b/retrofit/src/main/java/retrofit/ChangeableServer.java
deleted file mode 100644
index e2ad65b0d..000000000
--- a/retrofit/src/main/java/retrofit/ChangeableServer.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/** A {@link Server} whose URL and name can be changed at runtime. */
-public class ChangeableServer extends Server {
-  private String url;
-  private String name;
-
-  /** Create a changeable server with the provided URL and default name. */
-  public ChangeableServer(String url) {
-    super(url);
-    this.url = url;
-    this.name = DEFAULT_NAME;
-  }
-
-  /** Create a changeable server with the provided URL and name. */
-  public ChangeableServer(String url, String name) {
-    super(url, name);
-    this.url = url;
-    this.name = name;
-  }
-
-  /** Update the URL returned by {@link #getUrl()}. */
-  public void update(String url) {
-    this.url = url;
-  }
-
-  /** Update the URL and name returned by {@link #getUrl()} and {@link #getName()}, respectively. */
-  public void update(String url, String name) {
-    this.url = url;
-    this.name = name;
-  }
-
-  @Override public String getUrl() {
-    return url;
-  }
-
-  @Override public String getName() {
-    return name;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
similarity index 62%
rename from retrofit/src/main/java/retrofit/converter/Converter.java
rename to retrofit/src/main/java/retrofit/Converter.java
index 6ac5b6fa8..154ab177e 100644
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -13,16 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit.converter;
+package retrofit;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * Arbiter for converting objects to and from their representation in HTTP.
- *
- * @author Jake Wharton (jw@squareup.com)
  */
 public interface Converter {
   /**
@@ -31,18 +30,14 @@
    * @param body HTTP response body.
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
-   * @throws ConversionException if conversion was unable to complete. This will trigger a call to
-   * {@link retrofit.Callback#failure(retrofit.RetrofitError)} or throw a
-   * {@link retrofit.RetrofitError}. The exception message should report all necessary information
-   * about its cause as the response body will be set to {@code null}.
    */
-  Object fromBody(TypedInput body, Type type) throws ConversionException;
+  Object fromBody(ResponseBody body, Type type) throws IOException;
 
   /**
-   * Convert and object to an appropriate representation for HTTP transport.
+   * Convert an object to an appropriate representation for HTTP transport.
    *
    * @param object Object instance to convert.
    * @return Representation of the specified object as bytes.
    */
-  TypedOutput toBody(Object object);
+  RequestBody toBody(Object object, Type type);
 }
diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java
new file mode 100644
index 000000000..a4919c3d9
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+
+final class DefaultCallAdapterFactory implements CallAdapter.Factory {
+  private final Executor callbackExecutor;
+
+  DefaultCallAdapterFactory(Executor callbackExecutor) {
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  @Override public String toString() {
+    return "Built-in CallAdapterFactory";
+  }
+
+  @Override public CallAdapter<?> get(Type returnType) {
+    if (Utils.getRawType(returnType) != Call.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    final Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+
+    // Ensure the Call response type is not Response, we automatically deliver the Response object.
+    if (Utils.getRawType(responseType) == Response.class) {
+      throw new IllegalArgumentException(
+          "Call<T> cannot use Response as its generic parameter. "
+              + "Specify the response body type only (e.g., Call<TweetResponse>).");
+    }
+
+    return new CallAdapter<Object>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<Object> adapt(Call<Object> call) {
+        return new ExecutorCallbackCall<>(callbackExecutor, call);
+      }
+    };
+  }
+
+  static final class ExecutorCallbackCall<T> implements Call<T> {
+    private final Executor callbackExecutor;
+    private final Call<T> delegate;
+
+    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void enqueue(Callback<T> callback) {
+      delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback));
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      return delegate.execute();
+    }
+
+    @Override public void cancel() {
+      delegate.cancel();
+    }
+
+    @Override public Call<T> clone() {
+      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+    }
+  }
+
+  static final class ExecutorCallback<T> implements Callback<T> {
+    private final Executor callbackExecutor;
+    private final Callback<T> delegate;
+
+    ExecutorCallback(Executor callbackExecutor, Callback<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void success(final Response<T> response) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          delegate.success(response);
+        }
+      });
+    }
+
+    @Override public void failure(final Throwable t) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          delegate.failure(t);
+        }
+      });
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Endpoint.java b/retrofit/src/main/java/retrofit/Endpoint.java
new file mode 100644
index 000000000..dadaf3424
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Endpoint.java
@@ -0,0 +1,30 @@
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+
+import static retrofit.Utils.checkNotNull;
+
+/** An API endpoint. */
+public abstract class Endpoint {
+  /** Create an endpoint with the provided {@code url}. */
+  public static Endpoint createFixed(String url) {
+    checkNotNull(url, "url == null");
+    final HttpUrl httpUrl = HttpUrl.parse(url);
+    if (httpUrl == null) {
+      throw new IllegalArgumentException("Invalid URL: " + url);
+    }
+    return new Endpoint() {
+      @Override public HttpUrl url() {
+        return httpUrl;
+      }
+    };
+  }
+
+  /**
+   * The base URL.
+   * <p>
+   * Consumers will call this method every time they need to create a request allowing values
+   * to change over time.
+   */
+  public abstract HttpUrl url();
+}
diff --git a/retrofit/src/main/java/retrofit/ErrorHandler.java b/retrofit/src/main/java/retrofit/ErrorHandler.java
deleted file mode 100644
index 46dcfdbb0..000000000
--- a/retrofit/src/main/java/retrofit/ErrorHandler.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/**
- * A hook allowing clients to customize error exceptions for synchronous requests.
- *
- * @author Sam Beran sberan@gmail.com
- */
-public interface ErrorHandler {
-  /**
-   * Return a custom exception to be thrown for a {@link RetrofitError}. It is recommended that you
-   * pass the supplied error as the cause to any new exceptions.
-   * <p>
-   * If the return exception is checked it must be declared to be thrown on the interface method.
-   * <p>
-   * Example usage:
-   * <pre>
-   * class MyErrorHandler implements ErrorHandler {
-   *   &#64;Override public Throwable handleError(RetrofitError cause) {
-   *     Response r = cause.getResponse();
-   *     if (r != null && r.getStatus() == 401) {
-   *       return new UnauthorizedException(cause);
-   *     }
-   *     return cause;
-   *   }
-   * }
-   * </pre>
-   *
-   * @param cause the original {@link RetrofitError} exception
-   * @return Throwable an exception which will be thrown from the client interface method. Must not
-   *         be {@code null}.
-   */
-  Throwable handleError(RetrofitError cause);
-
-  /** An {@link ErrorHandler} which returns the original error. */
-  ErrorHandler DEFAULT = new ErrorHandler() {
-    @Override public Throwable handleError(RetrofitError cause) {
-      return cause;
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
new file mode 100644
index 000000000..dd7ba1496
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -0,0 +1,63 @@
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+
+final class ExceptionCatchingRequestBody extends ResponseBody {
+  private final ResponseBody delegate;
+  private IOException thrownException;
+
+  ExceptionCatchingRequestBody(ResponseBody delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() throws IOException {
+    try {
+      return delegate.contentLength();
+    } catch (IOException e) {
+      thrownException = e;
+      throw e;
+    }
+  }
+
+  @Override public BufferedSource source() throws IOException {
+    BufferedSource delegateSource;
+    try {
+      delegateSource = delegate.source();
+    } catch (IOException e) {
+      thrownException = e;
+      throw e;
+    }
+    return Okio.buffer(new ForwardingSource(delegateSource) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        try {
+          return super.read(sink, byteCount);
+        } catch (IOException e) {
+          thrownException = e;
+          throw e;
+        }
+      }
+    });
+  }
+
+  @Override public void close() throws IOException {
+    delegate.close();
+  }
+
+  IOException getThrownException() {
+    return thrownException;
+  }
+
+  boolean threwException() {
+    return thrownException != null;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java b/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java
deleted file mode 100644
index 40e222b15..000000000
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package retrofit;
-
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.mime.TypedInput;
-
-class ExceptionCatchingTypedInput implements TypedInput {
-  private final TypedInput delegate;
-  private final ExceptionCatchingInputStream delegateStream;
-
-  ExceptionCatchingTypedInput(TypedInput delegate) throws IOException {
-    this.delegate = delegate;
-    this.delegateStream = new ExceptionCatchingInputStream(delegate.in());
-  }
-
-  @Override public String mimeType() {
-    return delegate.mimeType();
-  }
-
-  @Override public long length() {
-    return delegate.length();
-  }
-
-  @Override public InputStream in() throws IOException {
-    return delegateStream;
-  }
-
-  IOException getThrownException() {
-    return delegateStream.thrownException;
-  }
-
-  boolean threwException() {
-    return delegateStream.thrownException != null;
-  }
-
-  private static class ExceptionCatchingInputStream extends InputStream {
-    private final InputStream delegate;
-    private IOException thrownException;
-
-    ExceptionCatchingInputStream(InputStream delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public int read() throws IOException {
-      try {
-        return delegate.read();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer) throws IOException {
-      try {
-        return delegate.read(buffer);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
-      try {
-        return delegate.read(buffer, offset, length);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public long skip(long byteCount) throws IOException {
-      try {
-        return delegate.skip(byteCount);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int available() throws IOException {
-      try {
-        return delegate.available();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      try {
-        delegate.close();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public synchronized void mark(int readLimit) {
-      delegate.mark(readLimit);
-    }
-
-    @Override public synchronized void reset() throws IOException {
-      try {
-        delegate.reset();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public boolean markSupported() {
-      return delegate.markSupported();
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
new file mode 100644
index 000000000..e8f70850e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -0,0 +1,397 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import retrofit.http.Body;
+import retrofit.http.DELETE;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.FormUrlEncoded;
+import retrofit.http.GET;
+import retrofit.http.HEAD;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+import retrofit.http.Headers;
+import retrofit.http.Multipart;
+import retrofit.http.PATCH;
+import retrofit.http.POST;
+import retrofit.http.PUT;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
+import retrofit.http.Streaming;
+import retrofit.http.Url;
+
+/**
+ * Request metadata about a service interface declaration.
+ */
+final class MethodInfo {
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+
+    enum BodyEncoding {
+        NONE,
+        MULTIPART,
+        FORM_URL_ENCODED
+    }
+
+    final Method method;
+    final CallAdapter.Factory adapterFactory;
+    final Converter converter;
+
+    // Method-level details
+    CallAdapter<?> adapter;
+
+    Type requestType;
+    BodyEncoding bodyEncoding = BodyEncoding.NONE;
+    String requestMethod;
+    boolean requestHasBody;
+    String requestUrl;
+    Set<String> requestUrlParamNames;
+    String requestQuery;
+    com.squareup.okhttp.Headers headers;
+    String contentTypeHeader;
+    boolean isStreaming;
+
+    // Parameter-level details
+    Annotation[] requestParamAnnotations;
+
+    MethodInfo(Method method, CallAdapter.Factory adapterFactory, Converter converter) {
+        this.method = method;
+        this.adapterFactory = adapterFactory;
+        this.converter = converter;
+        parseResponseType();
+        parseMethodAnnotations();
+        parseParameters();
+    }
+
+    private RuntimeException methodError(String message, Object... args) {
+        if (args.length > 0) {
+            message = String.format(message, args);
+        }
+        return new IllegalArgumentException(
+                method.getDeclaringClass().getSimpleName() + "." + method.getName() + ": " + message);
+    }
+
+    private RuntimeException parameterError(int index, String message, Object... args) {
+        return methodError(message + " (parameter #" + (index + 1) + ")", args);
+    }
+
+    /**
+     * Loads {@link #requestMethod} and {@link #bodyEncoding}.
+     */
+    private void parseMethodAnnotations() {
+        for (Annotation methodAnnotation : method.getAnnotations()) {
+            Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
+            if (annotationType == DELETE.class) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) methodAnnotation).value(), false);
+            } else if (annotationType == GET.class) {
+                parseHttpMethodAndPath("GET", ((GET) methodAnnotation).value(), false);
+            } else if (annotationType == HEAD.class) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) methodAnnotation).value(), false);
+            } else if (annotationType == PATCH.class) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) methodAnnotation).value(), true);
+            } else if (annotationType == POST.class) {
+                parseHttpMethodAndPath("POST", ((POST) methodAnnotation).value(), true);
+            } else if (annotationType == PUT.class) {
+                parseHttpMethodAndPath("PUT", ((PUT) methodAnnotation).value(), true);
+            } else if (annotationType == HTTP.class) {
+                HTTP http = (HTTP) methodAnnotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            } else if (annotationType == Headers.class) {
+                String[] headersToParse = ((Headers) methodAnnotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError("@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotationType == Multipart.class) {
+                if (bodyEncoding != BodyEncoding.NONE) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                bodyEncoding = BodyEncoding.MULTIPART;
+            } else if (annotationType == FormUrlEncoded.class) {
+                if (bodyEncoding != BodyEncoding.NONE) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                bodyEncoding = BodyEncoding.FORM_URL_ENCODED;
+            } else if (annotationType == Streaming.class) {
+                isStreaming = true;
+            }
+        }
+
+        if (requestMethod == null) {
+            throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+        }
+        if (!requestHasBody) {
+            if (bodyEncoding == BodyEncoding.MULTIPART) {
+                throw methodError(
+                        "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+            }
+            if (bodyEncoding == BodyEncoding.FORM_URL_ENCODED) {
+                throw methodError("FormUrlEncoded can only be specified on HTTP methods with request body "
+                        + "(e.g., @POST).");
+            }
+        }
+    }
+
+    /**
+     * Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}.
+     */
+    private void parseHttpMethodAndPath(String method, String path, boolean hasBody) {
+        if (requestMethod != null) {
+            throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
+                    method);
+        }
+        if (path == null || path.length() == 0 || path.charAt(0) != '/') {
+            throw methodError("URL path \"%s\" must start with '/'.", path);
+        }
+
+        // Get the relative URL path and existing query string, if present.
+        String url = path;
+        String query = null;
+        int question = path.indexOf('?');
+        if (question != -1 && question < path.length() - 1) {
+            url = path.substring(0, question);
+            query = path.substring(question + 1);
+
+            // Ensure the query string does not have any named parameters.
+            Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
+            if (queryParamMatcher.find()) {
+                throw methodError("URL query string \"%s\" must not have replace block. For dynamic query"
+                        + " parameters use @Query.", query);
+            }
+        }
+
+        Set<String> urlParams = parsePathParameters(path);
+
+        requestMethod = method;
+        requestHasBody = hasBody;
+        requestUrl = url;
+        requestUrlParamNames = urlParams;
+        requestQuery = query;
+    }
+
+    com.squareup.okhttp.Headers parseHeaders(String[] headers) {
+        com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
+        for (String header : headers) {
+            int colon = header.indexOf(':');
+            if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",
+                        header);
+            }
+            String headerName = header.substring(0, colon);
+            String headerValue = header.substring(colon + 1).trim();
+            if ("Content-Type".equalsIgnoreCase(headerName)) {
+                contentTypeHeader = headerValue;
+            } else {
+                builder.add(headerName, headerValue);
+            }
+        }
+        return builder.build();
+    }
+
+    /**
+     * Loads {@link #adapter}.
+     */
+    private void parseResponseType() {
+        Type returnType = method.getGenericReturnType();
+        if (Utils.hasUnresolvableType(returnType)) {
+            throw methodError("Method return type must not include a type variable or wildcard.");
+        }
+
+        // Check for invalid configurations.
+        if (returnType == void.class) {
+            throw methodError("Service methods cannot return void.");
+        }
+
+        //noinspection ForLoopReplaceableByForEach
+        CallAdapter adapter = adapterFactory.get(returnType);
+        if (adapter == null) {
+            throw methodError(
+                    "Registered call adapter factory was unable to handle return type " + returnType);
+        }
+        Type responseType = adapter.responseType();
+        if (converter == null && responseType != ResponseBody.class) {
+            throw methodError("Method response type is "
+                    + responseType
+                    + " but no converter registered. "
+                    + "Either add a converter to the Retrofit instance or use ResponseBody.");
+        }
+
+        this.adapter = adapter;
+    }
+
+    /**
+     * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
+     */
+    private void parseParameters() {
+        Type[] methodParameterTypes = method.getGenericParameterTypes();
+
+        Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+        int count = methodParameterAnnotationArrays.length;
+        Annotation[] requestParamAnnotations = new Annotation[count];
+
+        boolean gotField = false;
+        boolean gotPart = false;
+        boolean gotBody = false;
+
+        for (int i = 0; i < count; i++) {
+            Type methodParameterType = methodParameterTypes[i];
+            Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
+            if (methodParameterAnnotations != null) {
+                for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
+                    Class<? extends Annotation> methodAnnotationType =
+                            methodParameterAnnotation.annotationType();
+                    if (methodAnnotationType == Url.class) {
+
+                    } else if (methodAnnotationType == Path.class) {
+                        String name = ((Path) methodParameterAnnotation).value();
+                        validatePathName(i, name);
+                    } else if (methodAnnotationType == Query.class) {
+                        // Nothing to do.
+                    } else if (methodAnnotationType == QueryMap.class) {
+                        if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+                            throw parameterError(i, "@QueryMap parameter type must be Map.");
+                        }
+                    } else if (methodAnnotationType == Header.class) {
+                        // Nothing to do.
+                    } else if (methodAnnotationType == Field.class) {
+                        if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
+                            throw parameterError(i, "@Field parameters can only be used with form encoding.");
+                        }
+
+                        gotField = true;
+                    } else if (methodAnnotationType == FieldMap.class) {
+                        if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
+                            throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
+                        }
+                        if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+                            throw parameterError(i, "@FieldMap parameter type must be Map.");
+                        }
+
+                        gotField = true;
+                    } else if (methodAnnotationType == Part.class) {
+                        if (bodyEncoding != BodyEncoding.MULTIPART) {
+                            throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
+                        }
+                        if (converter == null && methodParameterType != BodyEncoding.class) {
+                            throw parameterError(i, "@Part parameter is "
+                                    + methodParameterType
+                                    + " but no converter registered. "
+                                    + "Either add a converter to the Retrofit instance or use RequestBody.");
+                        }
+
+                        gotPart = true;
+                    } else if (methodAnnotationType == PartMap.class) {
+                        if (bodyEncoding != BodyEncoding.MULTIPART) {
+                            throw parameterError(i,
+                                    "@PartMap parameters can only be used with multipart encoding.");
+                        }
+                        if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+                            throw parameterError(i, "@PartMap parameter type must be Map.");
+                        }
+
+                        gotPart = true;
+                    } else if (methodAnnotationType == Body.class) {
+                        if (bodyEncoding != BodyEncoding.NONE) {
+                            throw parameterError(i,
+                                    "@Body parameters cannot be used with form or multi-part encoding.");
+                        }
+                        if (gotBody) {
+                            throw methodError("Multiple @Body method annotations found.");
+                        }
+                        if (converter == null && methodParameterType != RequestBody.class) {
+                            throw parameterError(i, "@Body parameter is "
+                                    + methodParameterType
+                                    + " but no converter registered. "
+                                    + "Either add a converter to the Retrofit instance or use RequestBody.");
+                        }
+
+                        requestType = methodParameterType;
+                        gotBody = true;
+                    } else {
+                        // This is a non-Retrofit annotation. Skip to the next one.
+                        continue;
+                    }
+
+                    if (requestParamAnnotations[i] != null) {
+                        throw parameterError(i,
+                                "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
+                                requestParamAnnotations[i].annotationType().getSimpleName(),
+                                methodAnnotationType.getSimpleName());
+                    }
+                    requestParamAnnotations[i] = methodParameterAnnotation;
+                }
+            }
+
+            if (requestParamAnnotations[i] == null) {
+                throw parameterError(i, "No Retrofit annotation found.");
+            }
+        }
+
+        if (bodyEncoding == BodyEncoding.NONE && !requestHasBody && gotBody) {
+            throw methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
+        }
+        if (bodyEncoding == BodyEncoding.FORM_URL_ENCODED && !gotField) {
+            throw methodError("Form-encoded method must contain at least one @Field.");
+        }
+        if (bodyEncoding == BodyEncoding.MULTIPART && !gotPart) {
+            throw methodError("Multipart method must contain at least one @Part.");
+        }
+
+        this.requestParamAnnotations = requestParamAnnotations;
+    }
+
+    private void validatePathName(int index, String name) {
+        if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+            throw parameterError(index, "@Path parameter name must match %s. Found: %s",
+                    PARAM_URL_REGEX.pattern(), name);
+        }
+        // Verify URL replacement name is actually present in the URL path.
+        if (!requestUrlParamNames.contains(name)) {
+            throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", requestUrl, name);
+        }
+    }
+
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+        Matcher m = PARAM_URL_REGEX.matcher(path);
+        Set<String> patterns = new LinkedHashSet<>();
+        while (m.find()) {
+            patterns.add(m.group(1));
+        }
+        return patterns;
+    }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
new file mode 100644
index 000000000..b1687ea46
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+
+final class OkHttpCall<T> implements Call<T> {
+  private final Endpoint endpoint;
+  private final Converter converter;
+  private final OkHttpClient client;
+  private final MethodInfo methodInfo;
+  private final Object[] args;
+
+  private volatile com.squareup.okhttp.Call rawCall;
+  private boolean executed; // Guarded by this.
+
+  OkHttpCall(Endpoint endpoint, Converter converter, OkHttpClient client, MethodInfo methodInfo,
+      Object[] args) {
+    this.endpoint = endpoint;
+    this.converter = converter;
+    this.client = client;
+    this.methodInfo = methodInfo;
+    this.args = args;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public OkHttpCall<T> clone() {
+    return new OkHttpCall<>(endpoint, converter, client, methodInfo, args);
+  }
+
+  public void enqueue(final Callback<T> callback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+
+    com.squareup.okhttp.Call rawCall;
+    try {
+      rawCall = createRawCall();
+    } catch (Throwable t) {
+      callback.failure(t);
+      return;
+    }
+    this.rawCall = rawCall;
+
+    rawCall.enqueue(new com.squareup.okhttp.Callback() {
+      private void callFailure(Throwable e) {
+        try {
+          callback.failure(e);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      private void callSuccess(Response<T> response) {
+        try {
+          callback.success(response);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      @Override public void onFailure(Request request, IOException e) {
+        callFailure(e);
+      }
+
+      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
+        final Response<T> response;
+        try {
+          response = parseResponse(rawResponse);
+        } catch (final Throwable e) {
+          callFailure(e);
+          return;
+        }
+        callSuccess(response);
+      }
+    });
+  }
+
+  public Response<T> execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+
+    final com.squareup.okhttp.Call rawCall = createRawCall();
+    this.rawCall = rawCall;
+
+    return parseResponse(rawCall.execute());
+  }
+
+  private com.squareup.okhttp.Call createRawCall() {
+    HttpUrl url = endpoint.url();
+    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, converter);
+    requestBuilder.setArguments(args);
+    Request request = requestBuilder.build();
+
+    return client.newCall(request);
+  }
+
+  private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
+    ResponseBody rawBody = rawResponse.body();
+    // Remove the body (the only stateful object) from the raw response so we can pass it along.
+    rawResponse = rawResponse.newBuilder().body(null).build();
+
+    T converted = null;
+    ResponseBody body = null;
+
+    try {
+      int code = rawResponse.code();
+      if (code < 200 || code >= 300) {
+        // Buffer the entire body in the event of a non-2xx status to avoid future I/O.
+        body = Utils.readBodyToBytesIfNecessary(rawBody);
+      } else if (code != 204 && code != 205) {
+        Type responseType = methodInfo.adapter.responseType();
+        if (responseType == ResponseBody.class) {
+          //noinspection unchecked
+          converted = (T) Utils.readBodyToBytesIfNecessary(rawBody);
+        } else {
+          ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(rawBody);
+          try {
+            //noinspection unchecked
+            converted = (T) converter.fromBody(wrapped, responseType);
+          } catch (RuntimeException e) {
+            // If the underlying input stream threw an exception, propagate that rather than
+            // indicating that it was a conversion exception.
+            if (wrapped.threwException()) {
+              throw wrapped.getThrownException();
+            }
+
+            throw e;
+          }
+        }
+      }
+    } finally {
+      rawBody.close();
+    }
+
+    return new Response<>(rawResponse, converted, body);
+  }
+
+  public void cancel() {
+    com.squareup.okhttp.Call rawCall = this.rawCall;
+    if (rawCall == null) {
+      throw new IllegalStateException("enqueue or execute must be called first");
+    }
+    rawCall.cancel();
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 12a7472da..bd292c488 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -16,28 +16,15 @@
 package retrofit;
 
 import android.os.Build;
-import android.os.Process;
-import com.google.gson.Gson;
+import android.os.Handler;
+import android.os.Looper;
+import com.squareup.okhttp.OkHttpClient;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
-import retrofit.android.AndroidApacheClient;
-import retrofit.android.AndroidLog;
-import retrofit.android.MainThreadExecutor;
-import retrofit.client.Client;
-import retrofit.client.OkClient;
-import retrofit.client.UrlConnectionClient;
-import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
+import java.util.concurrent.TimeUnit;
 
-import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
-import static java.lang.Thread.MIN_PRIORITY;
-
-abstract class Platform {
+class Platform {
   private static final Platform PLATFORM = findPlatform();
 
-  static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
-
   static Platform get() {
     return PLATFORM;
   }
@@ -50,131 +37,34 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-    return new Base();
-  }
-
-  abstract Converter defaultConverter();
-  abstract Client.Provider defaultClient();
-  abstract Executor defaultHttpExecutor();
-  abstract Executor defaultCallbackExecutor();
-  abstract RestAdapter.Log defaultLog();
-
-  /** Provides sane defaults for operation on the JVM. */
-  private static class Base extends Platform {
-    @Override Converter defaultConverter() {
-      return new GsonConverter(new Gson());
-    }
-
-    @Override Client.Provider defaultClient() {
-      final Client client;
-      if (hasOkHttpOnClasspath()) {
-        client = OkClientInstantiator.instantiate();
-      } else {
-        client = new UrlConnectionClient();
-      }
-      return new Client.Provider() {
-        @Override public Client get() {
-          return client;
-        }
-      };
-    }
-
-    @Override Executor defaultHttpExecutor() {
-      return Executors.newCachedThreadPool(new ThreadFactory() {
-        @Override public Thread newThread(final Runnable r) {
-          return new Thread(new Runnable() {
-            @Override public void run() {
-              Thread.currentThread().setPriority(MIN_PRIORITY);
-              r.run();
-            }
-          }, RestAdapter.IDLE_THREAD_NAME);
-        }
-      });
-    }
-
-    @Override Executor defaultCallbackExecutor() {
-      return new Utils.SynchronousExecutor();
-    }
 
-    @Override RestAdapter.Log defaultLog() {
-      return new RestAdapter.Log() {
-        @Override public void log(String message) {
-          System.out.println(message);
-        }
-      };
-    }
+    return new Platform();
   }
 
-  /** Provides sane defaults for operation on Android. */
-  private static class Android extends Platform {
-    @Override Converter defaultConverter() {
-      return new GsonConverter(new Gson());
-    }
-
-    @Override Client.Provider defaultClient() {
-      final Client client;
-      if (hasOkHttpOnClasspath()) {
-        client = OkClientInstantiator.instantiate();
-      } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
-        client = new AndroidApacheClient();
-      } else {
-        client = new UrlConnectionClient();
-      }
-      return new Client.Provider() {
-        @Override public Client get() {
-          return client;
-        }
-      };
-    }
-
-    @Override Executor defaultHttpExecutor() {
-      return Executors.newCachedThreadPool(new ThreadFactory() {
-        @Override public Thread newThread(final Runnable r) {
-          return new Thread(new Runnable() {
-            @Override public void run() {
-              Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);
-              r.run();
-            }
-          }, RestAdapter.IDLE_THREAD_NAME);
-        }
-      });
-    }
-
-    @Override Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
-
-    @Override RestAdapter.Log defaultLog() {
-      return new AndroidLog("Retrofit");
-    }
+  CallAdapter.Factory defaultCallAdapterFactory() {
+    return new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
   }
 
-  /** Determine whether or not OkHttp is present on the runtime classpath. */
-  private static boolean hasOkHttpOnClasspath() {
-    try {
-      Class.forName("com.squareup.okhttp.OkHttpClient");
-      return true;
-    } catch (ClassNotFoundException e) {
-      return false;
-    }
+  OkHttpClient defaultClient() {
+    OkHttpClient client = new OkHttpClient();
+    client.setConnectTimeout(15, TimeUnit.SECONDS);
+    client.setReadTimeout(15, TimeUnit.SECONDS);
+    client.setWriteTimeout(15, TimeUnit.SECONDS);
+    return client;
   }
 
-  /**
-   * Indirection for OkHttp class to prevent VerifyErrors on Android 2.0 and earlier when the
-   * dependency is not present.
-   */
-  private static class OkClientInstantiator {
-    static Client instantiate() {
-      return new OkClient();
+  /** Provides sane defaults for operation on Android. */
+  static class Android extends Platform {
+    CallAdapter.Factory defaultCallAdapterFactory() {
+      return new DefaultCallAdapterFactory(new MainThreadExecutor());
     }
-  }
 
-  private static boolean hasRxJavaOnClasspath() {
-    try {
-      Class.forName("rx.Observable");
-      return true;
-    } catch (ClassNotFoundException e) {
+    static class MainThreadExecutor implements Executor {
+      private final Handler handler = new Handler(Looper.getMainLooper());
+
+      @Override public void execute(Runnable r) {
+        handler.post(r);
+      }
     }
-    return false;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Profiler.java b/retrofit/src/main/java/retrofit/Profiler.java
deleted file mode 100644
index 842d4504d..000000000
--- a/retrofit/src/main/java/retrofit/Profiler.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/**
- * A hook allowing clients to log HTTP method times and response status codes.
- *
- * @author Eric Burke (eric@squareup.com)
- */
-public interface Profiler<T> {
-
-  /**
-   * Invoked before an HTTP method call. The object returned by this method will be
-   * passed to {@link #afterCall} when the call returns.
-   * <p>
-   * This method gives implementers the opportunity to include information that may
-   * change during the server call in {@code afterCall} logic.
-   */
-  T beforeCall();
-
-  /**
-   * Invoked after an HTTP method completes. This is called from the
-   * RestAdapter's background thread.
-   *
-   * @param requestInfo information about the originating HTTP request.
-   * @param elapsedTime time in milliseconds it took the HTTP request to complete.
-   * @param statusCode response status code.
-   * @param beforeCallData the data returned by the corresponding {@link #beforeCall()}.
-   */
-  void afterCall(RequestInformation requestInfo, long elapsedTime, int statusCode,
-      T beforeCallData);
-
-  /** Information about the HTTP request. */
-  public static final class RequestInformation {
-    private final String method;
-    private final String baseUrl;
-    private final String relativePath;
-    private final long contentLength;
-    private final String contentType;
-
-    public RequestInformation(String method, String baseUrl, String relativePath,
-        long contentLength, String contentType) {
-      this.method = method;
-      this.baseUrl = baseUrl;
-      this.relativePath = relativePath;
-      this.contentLength = contentLength;
-      this.contentType = contentType;
-    }
-
-    /** Returns the HTTP method of the originating request. */
-    public String getMethod() {
-      return method;
-    }
-
-    /** Returns the URL to which the originating request was sent. */
-    public String getBaseUrl() {
-      return baseUrl;
-    }
-
-    /** Returns the path relative to the base URL to which the originating request was sent. */
-    public String getRelativePath() {
-      return relativePath;
-    }
-
-    /** Returns the number of bytes in the originating request. */
-    public long getContentLength() {
-      return contentLength;
-    }
-
-    /** Returns the content type header value of the originating request. */
-    public String getContentType() {
-      return contentType;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index fb7434994..ea6ee9b88 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -15,105 +15,107 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.FormEncodingBuilder;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.MultipartBuilder;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+
+import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
 import java.net.URLEncoder;
-import java.util.ArrayList;
-import java.util.List;
-
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.converter.Converter;
-import retrofit.mime.FormUrlEncodedTypedOutput;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-final class RequestBuilder implements RequestInterceptor.RequestFacade {
+import java.util.Map;
+
+import okio.BufferedSink;
+import retrofit.http.Body;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.Header;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
+import retrofit.http.Url;
+
+final class RequestBuilder {
+    private static final Headers NO_HEADERS = Headers.of();
+    private static final byte[] NO_BODY = new byte[0];
+
     private final Converter converter;
-    private final List<Header> headers;
-    private final StringBuilder queryParams;
-    private final String[] paramNames;
-    private final RestMethodInfo.ParamUsage[] paramUsages;
+    private final Annotation[] paramAnnotations;
     private final String requestMethod;
-    private final boolean isSynchronous;
-    private final boolean isObservable;
+    private final boolean requestHasBody;
+    private final HttpUrl.Builder urlBuilder;
 
-    private final FormUrlEncodedTypedOutput formBody;
-    private final MultipartTypedOutput multipartBody;
-    private TypedOutput body;
-
-    private String overrideAbsoluteUrl = null;
+    private MultipartBuilder multipartBuilder;
+    private FormEncodingBuilder formEncodingBuilder;
+    private RequestBody body;
 
+    private String mAbsoluteUrl;
     private String relativeUrl;
-    private String apiUrl;
+    private Headers.Builder headers;
+    private String contentTypeHeader;
 
-    RequestBuilder(Converter converter, RestMethodInfo methodInfo) {
+    RequestBuilder(HttpUrl url, MethodInfo methodInfo, Converter converter) {
         this.converter = converter;
 
-        paramNames = methodInfo.requestParamNames;
-        paramUsages = methodInfo.requestParamUsage;
+        paramAnnotations = methodInfo.requestParamAnnotations;
         requestMethod = methodInfo.requestMethod;
-        isSynchronous = methodInfo.isSynchronous;
-        isObservable = methodInfo.isObservable;
+        requestHasBody = methodInfo.requestHasBody;
 
-        headers = new ArrayList<Header>();
         if (methodInfo.headers != null) {
-            headers.addAll(methodInfo.headers);
+            headers = methodInfo.headers.newBuilder();
         }
-
-        queryParams = new StringBuilder();
+        contentTypeHeader = methodInfo.contentTypeHeader;
 
         relativeUrl = methodInfo.requestUrl;
 
+        urlBuilder = url.newBuilder();
+
         String requestQuery = methodInfo.requestQuery;
         if (requestQuery != null) {
-            queryParams.append('?').append(requestQuery);
+            urlBuilder.query(requestQuery);
         }
 
-        switch (methodInfo.requestType) {
+        switch (methodInfo.bodyEncoding) {
             case FORM_URL_ENCODED:
-                formBody = new FormUrlEncodedTypedOutput();
-                multipartBody = null;
-                body = formBody;
+                // Will be set to 'body' in 'build'.
+                formEncodingBuilder = new FormEncodingBuilder();
                 break;
             case MULTIPART:
-                formBody = null;
-                multipartBody = new MultipartTypedOutput();
-                body = multipartBody;
+                // Will be set to 'body' in 'build'.
+                multipartBuilder = new MultipartBuilder();
                 break;
-            case SIMPLE:
-                formBody = null;
-                multipartBody = null;
+            case NONE:
                 // If present, 'body' will be set in 'setArguments' call.
                 break;
             default:
-                throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
+                throw new IllegalArgumentException("Unknown request type: " + methodInfo.bodyEncoding);
         }
     }
 
-    void setApiUrl(String apiUrl) {
-        this.apiUrl = apiUrl;
-    }
-
-    @Override
     public void addHeader(String name, String value) {
         if (name == null) {
             throw new IllegalArgumentException("Header name must not be null.");
         }
-        headers.add(new Header(name, value));
-    }
-
-    @Override
-    public void addPathParam(String name, String value) {
-        addPathParam(name, value, true);
-    }
+        if ("Content-Type".equalsIgnoreCase(name)) {
+            contentTypeHeader = value;
+            return;
+        }
 
-    @Override
-    public void addEncodedPathParam(String name, String value) {
-        addPathParam(name, value, false);
+        Headers.Builder headers = this.headers;
+        if (headers == null) {
+            this.headers = headers = new Headers.Builder();
+        }
+        headers.add(name, value);
     }
 
-    void addPathParam(String name, String value, boolean urlEncodeValue) {
+    private void addPathParam(String name, String value, boolean encoded) {
         if (name == null) {
             throw new IllegalArgumentException("Path replacement name must not be null.");
         }
@@ -122,7 +124,7 @@ void addPathParam(String name, String value, boolean urlEncodeValue) {
                     "Path replacement \"" + name + "\" value must not be null.");
         }
         try {
-            if (urlEncodeValue) {
+            if (!encoded) {
                 String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
                 // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
                 // encode spaces rather than +. Query encoding difference specified in HTML spec.
@@ -138,33 +140,52 @@ void addPathParam(String name, String value, boolean urlEncodeValue) {
         }
     }
 
-    @Override
-    public void addQueryParam(String name, String value) {
-        addQueryParam(name, value, true);
+    private void addQueryParam(String name, Object value, boolean encoded) {
+        if (value instanceof Iterable) {
+            for (Object iterableValue : (Iterable<?>) value) {
+                if (iterableValue != null) { // Skip null values
+                    addQueryParam(name, iterableValue.toString(), encoded);
+                }
+            }
+        } else if (value.getClass().isArray()) {
+            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+                Object arrayValue = Array.get(value, x);
+                if (arrayValue != null) { // Skip null values
+                    addQueryParam(name, arrayValue.toString(), encoded);
+                }
+            }
+        } else {
+            addQueryParam(name, value.toString(), encoded);
+        }
     }
 
-    @Override
-    public void addEncodedQueryParam(String name, String value) {
-        addQueryParam(name, value, false);
+    private void addQueryParam(String name, String value, boolean encoded) {
+        if (encoded) {
+            urlBuilder.addEncodedQueryParameter(name, value);
+        } else {
+            urlBuilder.addQueryParameter(name, value);
+        }
     }
 
-    void addQueryParam(String name, String value, boolean urlEncodeValue) {
-        if (name == null) {
-            throw new IllegalArgumentException("Query param name must not be null.");
-        }
-        if (value == null) {
-            throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
-        }
-        try {
-            if (urlEncodeValue) {
-                value = URLEncoder.encode(String.valueOf(value), "UTF-8");
+    private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encoded) {
+        for (Map.Entry<?, ?> entry : map.entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+                throw new IllegalArgumentException(
+                        "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
             }
-            StringBuilder queryParams = this.queryParams;
-            queryParams.append(queryParams.length() > 0 ? '&' : '?');
-            queryParams.append(name).append('=').append(value);
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException(
-                    "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
+            Object entryValue = entry.getValue();
+            if (entryValue != null) { // Skip null values.
+                addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
+            }
+        }
+    }
+
+    private void addFormField(String name, String value, boolean encoded) {
+        if (encoded) {
+            formEncodingBuilder.addEncoded(name, value);
+        } else {
+            formEncodingBuilder.add(name, value);
         }
     }
 
@@ -172,111 +193,216 @@ void setArguments(Object[] args) {
         if (args == null) {
             return;
         }
-        int count = args.length;
-        if (!isSynchronous && !isObservable) {
-            count -= 1;
-        }
-        for (int i = 0; i < count; i++) {
-            String name = paramNames[i];
+        for (int i = 0; i < args.length; i++) {
             Object value = args[i];
-            RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
-            switch (paramUsage) {
-                case PATH:
-                    if (value == null) {
-                        throw new IllegalArgumentException(
-                                "Path parameter \"" + name + "\" value must not be null.");
-                    }
-                    addPathParam(name, value.toString());
-                    break;
-                case ENCODED_PATH:
-                    if (value == null) {
-                        throw new IllegalArgumentException(
-                                "Path parameter \"" + name + "\" value must not be null.");
-                    }
-                    addEncodedPathParam(name, value.toString());
-                    break;
-                case QUERY:
-                    if (value != null) { // Skip null values.
-                        addQueryParam(name, value.toString());
-                    }
-                    break;
-                case ENCODED_QUERY:
-                    if (value != null) { // Skip null values.
-                        addEncodedQueryParam(name, value.toString());
-                    }
-                    break;
-                case HEADER:
-                    if (value != null) { // Skip null values.
+
+            Annotation annotation = paramAnnotations[i];
+            Class<? extends Annotation> annotationType = annotation.annotationType();
+            if (annotationType == Url.class) {
+                //Every argument has to have an annotion
+                mAbsoluteUrl = (String) value;
+                addPathParam("absoluteUrl", "absoluteUrl", true);
+
+            } else if (annotationType == Path.class) {
+                Path path = (Path) annotation;
+                String name = path.value();
+                if (value == null) {
+                    throw new IllegalArgumentException(
+                            "Path parameter \"" + name + "\" value must not be null.");
+                }
+                addPathParam(name, value.toString(), path.encoded());
+            } else if (annotationType == Query.class) {
+                if (value != null) { // Skip null values.
+                    Query query = (Query) annotation;
+                    addQueryParam(query.value(), value, query.encoded());
+                }
+            } else if (annotationType == QueryMap.class) {
+                if (value != null) { // Skip null values.
+                    QueryMap queryMap = (QueryMap) annotation;
+                    addQueryParamMap(i, (Map<?, ?>) value, queryMap.encoded());
+                }
+            } else if (annotationType == Header.class) {
+                if (value != null) { // Skip null values.
+                    String name = ((Header) annotation).value();
+                    if (value instanceof Iterable) {
+                        for (Object iterableValue : (Iterable<?>) value) {
+                            if (iterableValue != null) { // Skip null values.
+                                addHeader(name, iterableValue.toString());
+                            }
+                        }
+                    } else if (value.getClass().isArray()) {
+                        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+                            Object arrayValue = Array.get(value, x);
+                            if (arrayValue != null) { // Skip null values.
+                                addHeader(name, arrayValue.toString());
+                            }
+                        }
+                    } else {
                         addHeader(name, value.toString());
                     }
-                    break;
-                case FIELD:
-                    if (value != null) { // Skip null values.
-                        formBody.addField(name, value.toString());
-                    }
-                    break;
-                case PART:
-                    if (value != null) { // Skip null values.
-                        if (value instanceof TypedOutput) {
-                            multipartBody.addPart(name, (TypedOutput) value);
-                        } else if (value instanceof String) {
-                            multipartBody.addPart(name, new TypedString((String) value));
-                        } else {
-                            multipartBody.addPart(name, converter.toBody(value));
+                }
+            } else if (annotationType == Field.class) {
+                if (value != null) { // Skip null values.
+                    Field field = (Field) annotation;
+                    String name = field.value();
+                    boolean encoded = field.encoded();
+                    if (value instanceof Iterable) {
+                        for (Object iterableValue : (Iterable<?>) value) {
+                            if (iterableValue != null) { // Skip null values.
+                                addFormField(name, iterableValue.toString(), encoded);
+                            }
+                        }
+                    } else if (value.getClass().isArray()) {
+                        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+                            Object arrayValue = Array.get(value, x);
+                            if (arrayValue != null) { // Skip null values.
+                                addFormField(name, arrayValue.toString(), encoded);
+                            }
                         }
+                    } else {
+                        addFormField(name, value.toString(), encoded);
                     }
-                    break;
-                case BODY:
-                    if (value == null) {
-                        throw new IllegalArgumentException("Body parameter value must not be null.");
+                }
+            } else if (annotationType == FieldMap.class) {
+                if (value != null) { // Skip null values.
+                    FieldMap fieldMap = (FieldMap) annotation;
+                    boolean encoded = fieldMap.encoded();
+                    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+                        Object entryKey = entry.getKey();
+                        if (entryKey == null) {
+                            throw new IllegalArgumentException(
+                                    "Parameter #" + (i + 1) + " field map contained null key.");
+                        }
+                        Object entryValue = entry.getValue();
+                        if (entryValue != null) { // Skip null values.
+                            addFormField(entryKey.toString(), entryValue.toString(), encoded);
+                        }
                     }
-                    if (value instanceof TypedOutput) {
-                        body = (TypedOutput) value;
+                }
+            } else if (annotationType == Part.class) {
+                if (value != null) { // Skip null values.
+                    String name = ((Part) annotation).value();
+                    String transferEncoding = ((Part) annotation).encoding();
+                    Headers headers = Headers.of(
+                            "Content-Disposition", "name=\"" + name + "\"",
+                            "Content-Transfer-Encoding", transferEncoding);
+                    if (value instanceof RequestBody) {
+                        multipartBuilder.addPart(headers, (RequestBody) value);
+                    } else if (value instanceof String) {
+                        multipartBuilder.addPart(headers,
+                                RequestBody.create(MediaType.parse("text/plain"), (String) value));
                     } else {
-                        body = converter.toBody(value);
+                        multipartBuilder.addPart(headers, converter.toBody(value, value.getClass()));
                     }
-                    break;
-                case URL:
-                    //No there is no uri support, just a simple string
-                    this.overrideAbsoluteUrl = (String) value;
-                    this.relativeUrl = overrideAbsoluteUrl;
-                    break;
-                default:
-                    throw new IllegalArgumentException("Unknown parameter usage: " + paramUsage);
+                }
+            } else if (annotationType == PartMap.class) {
+                if (value != null) { // Skip null values.
+                    String transferEncoding = ((PartMap) annotation).encoding();
+                    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+                        Object entryKey = entry.getKey();
+                        if (entryKey == null) {
+                            throw new IllegalArgumentException(
+                                    "Parameter #" + (i + 1) + " part map contained null key.");
+                        }
+                        String entryName = entryKey.toString();
+                        Object entryValue = entry.getValue();
+                        Headers headers = Headers.of(
+                                "Content-Disposition", "name=\"" + entryName + "\"",
+                                "Content-Transfer-Encoding", transferEncoding);
+                        if (entryValue != null) { // Skip null values.
+                            if (entryValue instanceof RequestBody) {
+                                multipartBuilder.addPart(headers, (RequestBody) entryValue);
+                            } else if (entryValue instanceof String) {
+                                multipartBuilder.addPart(headers,
+                                        RequestBody.create(MediaType.parse("text/plain"), (String) entryValue));
+                            } else {
+                                multipartBuilder.addPart(headers,
+                                        converter.toBody(entryValue, entryValue.getClass()));
+                            }
+                        }
+                    }
+                }
+            } else if (annotationType == Body.class) {
+                if (value == null) {
+                    throw new IllegalArgumentException("Body parameter value must not be null.");
+                }
+                if (value instanceof RequestBody) {
+                    body = (RequestBody) value;
+                } else {
+                    body = converter.toBody(value, value.getClass());
+                }
+            } else {
+                throw new IllegalArgumentException(
+                        "Unknown annotation: " + annotationType.getCanonicalName());
             }
         }
     }
 
-    Request build() throws UnsupportedEncodingException {
+    Request build() {
+        urlBuilder.encodedPath(relativeUrl);
 
-        if (multipartBody != null && multipartBody.getPartCount() == 0) {
-            throw new IllegalStateException("Multipart requests must contain at least one part.");
+        RequestBody body = this.body;
+        if (body == null) {
+            // Try to pull from one of the builders.
+            if (formEncodingBuilder != null) {
+                body = formEncodingBuilder.build();
+            } else if (multipartBuilder != null) {
+                body = multipartBuilder.build();
+            } else if (requestHasBody) {
+                // Body is absent, make an empty body.
+                body = RequestBody.create(null, NO_BODY);
+            }
         }
 
-        if (overrideAbsoluteUrl != null) {
-            //Override it
-            StringBuilder url = new StringBuilder(overrideAbsoluteUrl);
-            if (queryParams.length() > 0) {
-                url.append(queryParams);
+        Headers.Builder headerBuilder = this.headers;
+        if (contentTypeHeader != null) {
+            if (body != null) {
+                body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
+            } else {
+                if (headerBuilder == null) {
+                    headerBuilder = new Headers.Builder();
+                }
+                headerBuilder.add("Content-Type", contentTypeHeader);
             }
-            return new Request(requestMethod, url.toString(), headers, body);
         }
+        Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
 
-        String apiUrl = this.apiUrl;
+        if (mAbsoluteUrl != null) {
+            return new Request.Builder()
+                    .url(mAbsoluteUrl)
+                    .method(requestMethod, body)
+                    .headers(headers)
+                    .build();
+        }
+        return new Request.Builder()
+                .url(urlBuilder.build())
+                .method(requestMethod, body)
+                .headers(headers)
+                .build();
+    }
 
-        StringBuilder url = new StringBuilder(apiUrl);
-        if (apiUrl.endsWith("/")) {
-            // We require relative paths to start with '/'. Prevent a double-slash.
-            url.deleteCharAt(url.length() - 1);
+    private static class MediaTypeOverridingRequestBody extends RequestBody {
+        private final RequestBody delegate;
+        private final MediaType mediaType;
+
+        MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
+            this.delegate = delegate;
+            this.mediaType = MediaType.parse(mediaType);
         }
 
-        url.append(relativeUrl);
+        @Override
+        public MediaType contentType() {
+            return mediaType;
+        }
 
-        StringBuilder queryParams = this.queryParams;
-        if (queryParams.length() > 0) {
-            url.append(queryParams);
+        @Override
+        public long contentLength() throws IOException {
+            return delegate.contentLength();
         }
 
-        return new Request(requestMethod, url.toString(), headers, body);
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            delegate.writeTo(sink);
+        }
     }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptor.java b/retrofit/src/main/java/retrofit/RequestInterceptor.java
deleted file mode 100644
index 5fa484b35..000000000
--- a/retrofit/src/main/java/retrofit/RequestInterceptor.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package retrofit;
-
-/** Intercept every request before it is executed in order to add additional data. */
-public interface RequestInterceptor {
-  /** Called for every request. Add data using methods on the supplied {@link RequestFacade}. */
-  void intercept(RequestFacade request);
-
-  interface RequestFacade {
-    /** Add a header to the request. This will not replace any existing headers. */
-    void addHeader(String name, String value);
-
-    /**
-     * Add a path parameter replacement. This works exactly like a {@link retrofit.http.Path
-     * &#64;Path}-annotated method argument.
-     */
-    void addPathParam(String name, String value);
-
-    /**
-     * Add a path parameter replacement without first URI encoding. This works exactly like a
-     * {@link retrofit.http.EncodedPath &#64;EncodedPath}-annotated method argument.
-     */
-    void addEncodedPathParam(String name, String value);
-
-    /** Add an additional query parameter. This will not replace any existing query parameters. */
-    void addQueryParam(String name, String value);
-
-    /**
-     * Add an additional query parameter without first URI encoding. This will not replace any
-     * existing query parameters.
-     */
-    void addEncodedQueryParam(String name, String value);
-  }
-
-  /** A {@link RequestInterceptor} which does no modification of requests. */
-  RequestInterceptor NONE = new RequestInterceptor() {
-    @Override public void intercept(RequestFacade request) {
-      // Do nothing.
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptorTape.java b/retrofit/src/main/java/retrofit/RequestInterceptorTape.java
deleted file mode 100644
index d53d8f4ff..000000000
--- a/retrofit/src/main/java/retrofit/RequestInterceptorTape.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package retrofit;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Records methods called against it as a RequestFacade and replays them when called as a
- * RequestInterceptor.
- */
-final class RequestInterceptorTape implements RequestInterceptor.RequestFacade, RequestInterceptor {
-
-  private final List<CommandWithParams> tape = new ArrayList<CommandWithParams>();
-
-  @Override public void addHeader(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_HEADER, name, value));
-  }
-
-  @Override public void addPathParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_PATH_PARAM, name, value));
-  }
-
-  @Override public void addEncodedPathParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_ENCODED_PATH_PARAM, name, value));
-  }
-
-  @Override public void addQueryParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_QUERY_PARAM, name, value));
-  }
-
-  @Override public void addEncodedQueryParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_ENCODED_QUERY_PARAM, name, value));
-  }
-
-  @Override public void intercept(RequestFacade request) {
-    for (CommandWithParams cwp : tape) {
-      cwp.command.intercept(request, cwp.name, cwp.value);
-    }
-  }
-
-  private enum Command {
-    ADD_HEADER {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addHeader(name, value);
-      }
-    },
-    ADD_PATH_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addPathParam(name, value);
-      }
-    },
-    ADD_ENCODED_PATH_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addEncodedPathParam(name, value);
-      }
-    },
-    ADD_QUERY_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addQueryParam(name, value);
-      }
-    },
-    ADD_ENCODED_QUERY_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addEncodedQueryParam(name, value);
-      }
-    };
-
-    abstract void intercept(RequestFacade facade, String name, String value);
-  }
-
-  private static final class CommandWithParams {
-    final Command command;
-    final String name;
-    final String value;
-
-    CommandWithParams(Command command, String name, String value) {
-      this.command = command;
-      this.name = name;
-      this.value = value;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
new file mode 100644
index 000000000..8aaa9bcaa
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.ResponseBody;
+
+import static retrofit.Utils.checkNotNull;
+
+/**
+ * TODO
+ */
+public final class Response<T> {
+  /**
+   * TODO
+   */
+  public static <T, B extends T> Response<T> fromBody(B body) {
+    return fromBody(body, new com.squareup.okhttp.Response.Builder() //
+        .code(200)
+        .protocol(Protocol.HTTP_1_1)
+        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+            .build())
+        .build());
+  }
+
+  /**
+   * TODO
+   */
+  public static <T, B extends T> Response<T> fromBody(B body,
+      com.squareup.okhttp.Response rawResponse) {
+    return new Response<T>(rawResponse, body, null);
+  }
+
+  /**
+   * TODO
+   */
+  public static Response<Object> fromError(int code, ResponseBody body) {
+    return fromError(new com.squareup.okhttp.Response.Builder() //
+        .code(code)
+        .protocol(Protocol.HTTP_1_1)
+        .body(body)
+        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+            .build())
+        .build());
+  }
+
+  /**
+   * TODO
+   */
+  public static Response<Object> fromError(com.squareup.okhttp.Response rawResponse) {
+    ResponseBody errorBody = rawResponse.body();
+    if (errorBody == null) throw new IllegalArgumentException("Raw response must have body.");
+    rawResponse = rawResponse.newBuilder().body(null).build();
+    return new Response<>(rawResponse, null, errorBody);
+  }
+
+  private final com.squareup.okhttp.Response rawResponse;
+  private final T body;
+  private final ResponseBody errorBody;
+
+  Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+    this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
+    this.body = body;
+    this.errorBody = errorBody;
+  }
+
+  /** The raw response from the HTTP client. */
+  public com.squareup.okhttp.Response raw() {
+    return rawResponse;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return rawResponse.code();
+  }
+
+  public Headers headers() {
+    return rawResponse.headers();
+  }
+
+  /** {@code true} if {@link #code()} is in the range [200..300). */
+  public boolean isSuccess() {
+    return rawResponse.isSuccessful();
+  }
+
+  /** The deserialized response body of a {@linkplain #isSuccess() successful} response. */
+  public T body() {
+    return body;
+  }
+
+  /** The raw response body of an {@linkplain #isSuccess() unsuccessful} response. */
+  public ResponseBody errorBody() {
+    return errorBody;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/ResponseCallback.java b/retrofit/src/main/java/retrofit/ResponseCallback.java
deleted file mode 100644
index b841e99b2..000000000
--- a/retrofit/src/main/java/retrofit/ResponseCallback.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import retrofit.client.Response;
-
-/**
- * An extension of {@link Callback} which returns only {@link Response} object
- * in {@link Callback#success(Object, retrofit.client.Response)} method.
- */
-public abstract class ResponseCallback implements Callback<Response> {
-
-  @Override
-  public void success(Response response, Response response2) {
-    success(response);
-  }
-
-  /** Successful HTTP response. */
-  public abstract void success(Response response);
-}
diff --git a/retrofit/src/main/java/retrofit/ResponseWrapper.java b/retrofit/src/main/java/retrofit/ResponseWrapper.java
deleted file mode 100644
index 65b881367..000000000
--- a/retrofit/src/main/java/retrofit/ResponseWrapper.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import retrofit.client.Response;
-
-/**
- * A wrapper that holds the {@link Response} and {@link retrofit.converter.Converter} response to
- * be used by the {@link CallbackRunnable} for success method calls on {@link Callback}.
- *
- * @author JJ Ford (jj.n.ford@gmail.com)
- */
-final class ResponseWrapper {
-  final Response response;
-  final Object responseBody;
-
-  ResponseWrapper(Response response, Object responseBody) {
-    this.response = response;
-    this.responseBody = responseBody;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
deleted file mode 100644
index 465b6a5f7..000000000
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ /dev/null
@@ -1,720 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import retrofit.Profiler.RequestInformation;
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.converter.ConversionException;
-import retrofit.converter.Converter;
-import retrofit.mime.MimeUtil;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-import rx.Observable;
-import rx.Observer;
-import rx.Scheduler;
-import rx.Subscription;
-import rx.concurrency.Schedulers;
-import rx.subscriptions.Subscriptions;
-
-/**
- * Adapts a Java interface to a REST API.
- * <p>
- * API endpoints are defined as methods on an interface with annotations providing metadata about
- * the form in which the HTTP call should be made.
- * <p>
- * The relative path for a given method is obtained from an annotation on the method describing
- * the request type. The built-in methods are {@link retrofit.http.GET GET},
- * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.HEAD HEAD},
- * and {@link retrofit.http.DELETE DELETE}. You can define your own HTTP method by creating an
- * annotation that takes a {code String} value and itself is annotated with
- * {@link retrofit.http.RestMethod @RestMethod}.
- * <p>
- * Method parameters can be used to replace parts of the URL by annotating them with
- * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
- * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}. If the path or query element has already been URI encoded
- * use {@link retrofit.http.EncodedPath @EncodedPath} or
- * {@link retrofit.http.EncodedQuery @EncodedQuery} to prevent repeated encoding.
- * <p>
- * HTTP requests happen in one of two ways:
- * <ul>
- * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
- * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
- * response will be converted to the callback's parameter type using the specified
- * {@link retrofit.converter.Converter Converter}. If the callback parameter type uses a wildcard,
- * the lower bound will be used as the conversion type.
- * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
- * response will be converted to the method's return type using the specified
- * {@link retrofit.converter.Converter Converter}.
- * </ul>
- * <p>
- * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
- * will be converted to request representation by a call to
- * {@link retrofit.converter.Converter#toBody(Object) toBody} on the supplied
- * {@link retrofit.converter.Converter Converter} for this instance. The body can also be a
- * {@link TypedOutput} where it will be used directly.
- * <p>
- * Alternative request body formats are supported by method annotations and corresponding parameter
- * annotations:
- * <ul>
- * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
- * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
- * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
- * specified by the {@link retrofit.http.Part @Part} parameter annotation.
- * </ul>
- * <p>
- * Additional static headers can be added for an endpoint using the
- * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
- * annotate a parameter with {@link Header @Header}.
- * <p>
- * For example:
- * <pre>
- * public interface MyApi {
- *   &#64;POST("/category/{cat}") // Asynchronous execution.
- *   void categoryList(@Path("cat") String a, @Query("page") int b, Callback&lt;List&lt;Item>> cb);
- *   &#64;POST("/category/{cat}") // Synchronous execution.
- *   List&lt;Item> categoryList(@Path("cat") String a, @Query("page") int b);
- * }
- * </pre>
- * <p>
- * Calling {@link #create(Class)} with {@code MyApi.class} will validate and create a new
- * implementation of the API.
- *
- * @author Bob Lee (bob@squareup.com)
- * @author Jake Wharton (jw@squareup.com)
- */
-public class RestAdapter {
-  static final String THREAD_PREFIX = "Retrofit-";
-  static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
-
-  /** Simple logging abstraction for debug messages. */
-  public interface Log {
-    /** Log a debug message to the appropriate console. */
-    void log(String message);
-
-    /** A {@link Log} implementation which does not log anything. */
-    Log NONE = new Log() {
-      @Override public void log(String message) {
-      }
-    };
-  }
-
-  /** Controls the level of logging. */
-  public enum LogLevel {
-    /** No logging. */
-    NONE,
-    /** Log only the request method and URL and the response status code and execution time. */
-    BASIC,
-    /** Log the basic information along with request and response headers. */
-    HEADERS,
-    /**
-     * Log the headers, body, and metadata for both requests and responses.
-     * <p>
-     * Note: This requires that the entire request and response body be buffered in memory!
-     */
-    FULL;
-
-    public boolean log() {
-      return this != NONE;
-    }
-  }
-
-  private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
-
-  final Server server;
-  final Executor httpExecutor;
-  final Executor callbackExecutor;
-  final RequestInterceptor requestInterceptor;
-  final Converter converter;
-  final Log log;
-  final ErrorHandler errorHandler;
-
-  private final Client.Provider clientProvider;
-  private final Profiler profiler;
-  private final RxSupport rxSupport;
-
-  volatile LogLevel logLevel;
-
-  private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
-      Profiler profiler, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
-    this.server = server;
-    this.clientProvider = clientProvider;
-    this.httpExecutor = httpExecutor;
-    if (Platform.HAS_RX_JAVA && httpExecutor != null) {
-      this.rxSupport = new RxSupport(httpExecutor);
-    } else {
-      this.rxSupport = null;
-    }
-    this.callbackExecutor = callbackExecutor;
-    this.requestInterceptor = requestInterceptor;
-    this.converter = converter;
-    this.profiler = profiler;
-    this.errorHandler = errorHandler;
-    this.log = log;
-    this.logLevel = logLevel;
-  }
-
-  /** Change the level of logging. */
-  public void setLogLevel(LogLevel loglevel) {
-    if (logLevel == null) {
-      throw new NullPointerException("Log level may not be null.");
-    }
-    this.logLevel = loglevel;
-  }
-
-  /** The current logging level. */
-  public LogLevel getLogLevel() {
-    return logLevel;
-  }
-
-  /** Create an implementation of the API defined by the specified {@code service} interface. */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler(getMethodInfoCache(service)));
-  }
-
-  Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
-    synchronized (serviceMethodInfoCache) {
-      Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
-      if (methodInfoCache == null) {
-        methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
-        serviceMethodInfoCache.put(service, methodInfoCache);
-      }
-      return methodInfoCache;
-    }
-  }
-
-  static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
-    synchronized (cache) {
-      RestMethodInfo methodInfo = cache.get(method);
-      if (methodInfo == null) {
-        methodInfo = new RestMethodInfo(method);
-        cache.put(method, methodInfo);
-      }
-      return methodInfo;
-    }
-  }
-
-  /** Indirection to avoid VerifyError if RxJava isn't present. */
-  private static final class RxSupport {
-    private final Scheduler scheduler;
-
-    RxSupport(Executor executor) {
-      this.scheduler = Schedulers.executor(executor);
-    }
-
-    Scheduler getScheduler() {
-      return scheduler;
-    }
-
-    Observable createRequestObservable(final Callable<ResponseWrapper> request) {
-      return Observable.create(new Observable.OnSubscribeFunc<Object>() {
-        @Override public Subscription onSubscribe(Observer<? super Object> observer) {
-          try {
-            ResponseWrapper wrapper = request.call();
-            observer.onNext(wrapper.responseBody);
-            observer.onCompleted();
-          } catch (RetrofitError e) {
-            observer.onError(e);
-          } catch (Exception e) {
-            // This is from the Callable.  It shouldn't actually throw.
-            throw new RuntimeException(e);
-          }
-          return Subscriptions.empty();
-        }
-      });
-    }
-  }
-
-  private class RestHandler implements InvocationHandler {
-    private final Map<Method, RestMethodInfo> methodDetailsCache;
-
-    RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
-      this.methodDetailsCache = methodDetailsCache;
-    }
-
-    @SuppressWarnings("unchecked") //
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      // Load or create the details cache for the current method.
-      final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-
-      if (methodInfo.isSynchronous) {
-        try {
-          return invokeRequest(requestInterceptor, methodInfo, args);
-        } catch (RetrofitError error) {
-          Throwable newError = errorHandler.handleError(error);
-          if (newError == null) {
-            throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
-          }
-          throw newError;
-        }
-      }
-
-      if (httpExecutor == null || callbackExecutor == null) {
-        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
-      }
-
-      // Apply the interceptor synchronously, recording the interception so we can replay it later.
-      // This way we still defer argument serialization to the background thread.
-      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-      requestInterceptor.intercept(interceptorTape);
-
-      if (methodInfo.isObservable) {
-        return rxSupport.createRequestObservable(new Callable<ResponseWrapper>() {
-          @Override public ResponseWrapper call() throws Exception {
-            return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
-          }
-        }).subscribeOn(rxSupport.getScheduler());
-      }
-
-      Callback<?> callback = (Callback<?>) args[args.length - 1];
-      httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
-        @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
-        }
-      });
-      return null; // Asynchronous methods should have return type of void.
-    }
-
-    /**
-     * Execute an HTTP request.
-     *
-     * @return HTTP response object of specified {@code type} or {@code null}.
-     * @throws RetrofitError if any error occurs during the HTTP request.
-     */
-    private Object invokeRequest(RequestInterceptor requestInterceptor,
-        RestMethodInfo methodInfo, Object[] args) {
-      methodInfo.init(); // Ensure all relevant method information has been loaded.
-
-      String serverUrl = server.getUrl();
-      String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
-      try {
-        RequestBuilder requestBuilder = new RequestBuilder(converter, methodInfo);
-        requestBuilder.setApiUrl(serverUrl);
-        requestBuilder.setArguments(args);
-
-        requestInterceptor.intercept(requestBuilder);
-
-        Request request = requestBuilder.build();
-        url = request.getUrl();
-
-        if (!methodInfo.isSynchronous) {
-          // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
-        }
-
-        if (logLevel.log()) {
-          // Log the request data.
-          request = logAndReplaceRequest("HTTP", request);
-        }
-
-        Object profilerObject = null;
-        if (profiler != null) {
-          profilerObject = profiler.beforeCall();
-        }
-
-        long start = System.nanoTime();
-        Response response = clientProvider.get().execute(request);
-        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
-
-        int statusCode = response.getStatus();
-        if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(serverUrl, methodInfo, request);
-          //noinspection unchecked
-          profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
-        }
-
-        if (logLevel.log()) {
-          // Log the response data.
-          response = logAndReplaceResponse(url, response, elapsedTime);
-        }
-
-        Type type = methodInfo.responseObjectType;
-
-        if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-          // Caller requested the raw Response object directly.
-          if (type.equals(Response.class)) {
-            // Read the entire stream and replace with one backed by a byte[]
-            response = Utils.readBodyToBytesIfNecessary(response);
-
-            if (methodInfo.isSynchronous) {
-              return response;
-            }
-            return new ResponseWrapper(response, response);
-          }
-
-          TypedInput body = response.getBody();
-          if (body == null) {
-            return new ResponseWrapper(response, null);
-          }
-
-          ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
-          try {
-            Object convert = converter.fromBody(wrapped, type);
-            if (methodInfo.isSynchronous) {
-              return convert;
-            }
-            return new ResponseWrapper(response, convert);
-          } catch (ConversionException e) {
-            // If the underlying input stream threw an exception, propagate that rather than
-            // indicating that it was a conversion exception.
-            if (wrapped.threwException()) {
-              throw wrapped.getThrownException();
-            }
-
-            // The response body was partially read by the converter. Replace it with null.
-            response = Utils.replaceResponseBody(response, null);
-
-            throw RetrofitError.conversionError(url, response, converter, type, e);
-          }
-        }
-
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(url, response, converter, type);
-      } catch (RetrofitError e) {
-        throw e; // Pass through our own errors.
-      } catch (IOException e) {
-        if (logLevel.log()) {
-          logException(e, url);
-        }
-        throw RetrofitError.networkError(url, e);
-      } catch (Throwable t) {
-        if (logLevel.log()) {
-          logException(t, url);
-        }
-        throw RetrofitError.unexpectedError(url, t);
-      } finally {
-        if (!methodInfo.isSynchronous) {
-          Thread.currentThread().setName(IDLE_THREAD_NAME);
-        }
-      }
-    }
-  }
-
-  /** Log request headers and body. Consumes request body and returns identical replacement. */
-  Request logAndReplaceRequest(String name, Request request) throws IOException {
-    log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : request.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      long bodySize = 0;
-      TypedOutput body = request.getBody();
-      if (body != null) {
-        bodySize = body.length();
-        String bodyMime = body.mimeType();
-
-        if (bodyMime != null) {
-          log.log("Content-Type: " + bodyMime);
-        }
-        if (bodySize != -1) {
-          log.log("Content-Length: " + bodySize);
-        }
-
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!request.getHeaders().isEmpty()) {
-            log.log("");
-          }
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body to we can log it and replace the original response
-            request = Utils.readBodyToBytesIfNecessary(request);
-            body = request.getBody();
-          }
-
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          bodySize = bodyBytes.length;
-          String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          log.log(new String(bodyBytes, bodyCharset));
-        }
-      }
-
-      log.log(String.format("---> END %s (%s-byte body)", name, bodySize));
-    }
-
-    return request;
-  }
-
-  /** Log response headers and body. Consumes response body and returns identical replacement. */
-  private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
-      throws IOException {
-    log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : response.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      long bodySize = 0;
-      TypedInput body = response.getBody();
-      if (body != null) {
-        bodySize = body.length();
-
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!response.getHeaders().isEmpty()) {
-            log.log("");
-          }
-
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body so we can log it and replace the original response
-            response = Utils.readBodyToBytesIfNecessary(response);
-            body = response.getBody();
-          }
-
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          bodySize = bodyBytes.length;
-          String bodyMime = body.mimeType();
-          String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          log.log(new String(bodyBytes, bodyCharset));
-        }
-      }
-
-      log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
-    }
-
-    return response;
-  }
-
-  /** Log an exception that occurred during the processing of a request or response. */
-  void logException(Throwable t, String url) {
-    log.log(String.format("---- ERROR %s", url));
-    StringWriter sw = new StringWriter();
-    t.printStackTrace(new PrintWriter(sw));
-    log.log(sw.toString());
-    log.log("---- END ERROR");
-  }
-
-  private static Profiler.RequestInformation getRequestInfo(String serverUrl,
-      RestMethodInfo methodDetails, Request request) {
-    long contentLength = 0;
-    String contentType = null;
-
-    TypedOutput body = request.getBody();
-    if (body != null) {
-      contentLength = body.length();
-      contentType = body.mimeType();
-    }
-
-    return new Profiler.RequestInformation(methodDetails.requestMethod, serverUrl,
-        methodDetails.requestUrl, contentLength, contentType);
-  }
-
-  /**
-   * Build a new {@link RestAdapter}.
-   * <p>
-   * Calling the following methods is required before calling {@link #build()}:
-   * <ul>
-   * <li>{@link #setServer(Server)}</li>
-   * <li>{@link #setClient(Client.Provider)}</li>
-   * <li>{@link #setConverter(Converter)}</li>
-   * </ul>
-   * <p>
-   * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
-   * is also required:
-   * <ul>
-   * <li>{@link #setExecutors(java.util.concurrent.Executor, java.util.concurrent.Executor)}</li>
-   * </ul>
-   */
-  public static class Builder {
-    private Server server;
-    private Client.Provider clientProvider;
-    private Executor httpExecutor;
-    private Executor callbackExecutor;
-    private RequestInterceptor requestInterceptor;
-    private Converter converter;
-    private Profiler profiler;
-    private ErrorHandler errorHandler;
-    private Log log;
-    private LogLevel logLevel = LogLevel.NONE;
-
-    /** API server base URL. */
-    public Builder setServer(String endpoint) {
-      if (endpoint == null || endpoint.trim().length() == 0) {
-        throw new NullPointerException("Server may not be blank.");
-      }
-      return setServer(new Server(endpoint));
-    }
-
-    /** API server. */
-    public Builder setServer(Server server) {
-      if (server == null) {
-        throw new NullPointerException("Server may not be null.");
-      }
-      this.server = server;
-      return this;
-    }
-
-    /** The HTTP client used for requests. */
-    public Builder setClient(final Client client) {
-      if (client == null) {
-        throw new NullPointerException("Client may not be null.");
-      }
-      return setClient(new Client.Provider() {
-        @Override public Client get() {
-          return client;
-        }
-      });
-    }
-
-    /** The HTTP client used for requests. */
-    public Builder setClient(Client.Provider clientProvider) {
-      if (clientProvider == null) {
-        throw new NullPointerException("Client provider may not be null.");
-      }
-      this.clientProvider = clientProvider;
-      return this;
-    }
-
-    /**
-     * Executors used for asynchronous HTTP client downloads and callbacks.
-     *
-     * @param httpExecutor Executor on which HTTP client calls will be made.
-     * @param callbackExecutor Executor on which any {@link Callback} methods will be invoked. If
-     * this argument is {@code null} then callback methods will be run on the same thread as the
-     * HTTP client.
-     */
-    public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
-      if (httpExecutor == null) {
-        throw new NullPointerException("HTTP executor may not be null.");
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = new Utils.SynchronousExecutor();
-      }
-      this.httpExecutor = httpExecutor;
-      this.callbackExecutor = callbackExecutor;
-      return this;
-    }
-
-    /** A request interceptor for adding data to every request. */
-    public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
-      if (requestInterceptor == null) {
-        throw new NullPointerException("Request interceptor may not be null.");
-      }
-      this.requestInterceptor = requestInterceptor;
-      return this;
-    }
-
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder setConverter(Converter converter) {
-      if (converter == null) {
-        throw new NullPointerException("Converter may not be null.");
-      }
-      this.converter = converter;
-      return this;
-    }
-
-    /** Set the profiler used to measure requests. */
-    public Builder setProfiler(Profiler profiler) {
-      if (profiler == null) {
-        throw new NullPointerException("Profiler may not be null.");
-      }
-      this.profiler = profiler;
-      return this;
-    }
-
-    /**
-     * The error handler allows you to customize the type of exception thrown for errors on
-     * synchronous requests.
-     */
-    public Builder setErrorHandler(ErrorHandler errorHandler) {
-      if (errorHandler == null) {
-        throw new NullPointerException("Error handler may not be null.");
-      }
-      this.errorHandler = errorHandler;
-      return this;
-    }
-
-    /** Configure debug logging mechanism. */
-    public Builder setLog(Log log) {
-      if (log == null) {
-        throw new NullPointerException("Log may not be null.");
-      }
-      this.log = log;
-      return this;
-    }
-
-    /** Change the level of logging. */
-    public Builder setLogLevel(LogLevel logLevel) {
-      if (logLevel == null) {
-        throw new NullPointerException("Log level may not be null.");
-      }
-      this.logLevel = logLevel;
-      return this;
-    }
-
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
-      if (server == null) {
-        throw new IllegalArgumentException("Server may not be null.");
-      }
-      ensureSaneDefaults();
-      return new RestAdapter(server, clientProvider, httpExecutor, callbackExecutor,
-          requestInterceptor, converter, profiler, errorHandler, log, logLevel);
-    }
-
-    private void ensureSaneDefaults() {
-      if (converter == null) {
-        converter = Platform.get().defaultConverter();
-      }
-      if (clientProvider == null) {
-        clientProvider = Platform.get().defaultClient();
-      }
-      if (httpExecutor == null) {
-        httpExecutor = Platform.get().defaultHttpExecutor();
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = Platform.get().defaultCallbackExecutor();
-      }
-      if (errorHandler == null) {
-        errorHandler = ErrorHandler.DEFAULT;
-      }
-      if (log == null) {
-        log = Platform.get().defaultLog();
-      }
-      if (requestInterceptor == null) {
-        requestInterceptor = RequestInterceptor.NONE;
-      }
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
deleted file mode 100644
index a1f471ba8..000000000
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ /dev/null
@@ -1,482 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.WildcardType;
-import java.util.ArrayList;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import retrofit.http.Body;
-import retrofit.http.EncodedPath;
-import retrofit.http.EncodedQuery;
-import retrofit.http.Field;
-import retrofit.http.FormUrlEncoded;
-import retrofit.http.Header;
-import retrofit.http.Headers;
-import retrofit.http.Multipart;
-import retrofit.http.Part;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.RestMethod;
-import retrofit.http.Url;
-import rx.Observable;
-
-/**
- * Request metadata about a service interface declaration.
- */
-final class RestMethodInfo {
-
-    private enum ResponseType {
-        VOID,
-        OBSERVABLE,
-        OBJECT
-    }
-
-    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-    enum ParamUsage {
-        PATH, ENCODED_PATH, QUERY, ENCODED_QUERY, FIELD, PART, BODY, HEADER, URL
-    }
-
-    enum RequestType {
-        /**
-         * No content-specific logic required.
-         */
-        SIMPLE,
-        /**
-         * Multi-part request body.
-         */
-        MULTIPART,
-        /**
-         * Form URL-encoded request body.
-         */
-        FORM_URL_ENCODED
-    }
-
-    final Method method;
-
-    boolean loaded = false;
-
-    // Method-level details
-    final ResponseType responseType;
-    final boolean isSynchronous;
-    final boolean isObservable;
-    Type responseObjectType;
-    RequestType requestType = RequestType.SIMPLE;
-    String requestMethod;
-    boolean requestHasBody;
-    String requestUrl;
-    Set<String> requestUrlParamNames;
-    String requestQuery;
-    List<retrofit.client.Header> headers;
-
-    // Parameter-level details
-    String[] requestParamNames;
-    ParamUsage[] requestParamUsage;
-
-    RestMethodInfo(Method method) {
-        this.method = method;
-        responseType = parseResponseType();
-        isSynchronous = (responseType == ResponseType.OBJECT);
-        isObservable = (responseType == ResponseType.OBSERVABLE);
-    }
-
-    synchronized void init() {
-        if (loaded) return;
-
-        parseMethodAnnotations();
-        parseParameters();
-
-        loaded = true;
-    }
-
-    /**
-     * Loads {@link #requestMethod} and {@link #requestType}.
-     */
-    private void parseMethodAnnotations() {
-        for (Annotation methodAnnotation : method.getAnnotations()) {
-            Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
-            RestMethod methodInfo = null;
-
-            // Look for a @RestMethod annotation on the parameter annotation indicating request method.
-            for (Annotation innerAnnotation : annotationType.getAnnotations()) {
-                if (RestMethod.class == innerAnnotation.annotationType()) {
-                    methodInfo = (RestMethod) innerAnnotation;
-                    break;
-                }
-            }
-
-            if (methodInfo != null) {
-                if (requestMethod != null) {
-                    throw new IllegalArgumentException("Method "
-                            + method.getName()
-                            + " contains multiple HTTP methods. Found: "
-                            + requestMethod
-                            + " and "
-                            + methodInfo.value());
-                }
-                String path;
-                try {
-                    path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
-                } catch (Exception e) {
-                    throw new RuntimeException("Failed to extract path from "
-                            + annotationType.getSimpleName()
-                            + " annotation on "
-                            + method.getName()
-                            + ".", e);
-                }
-                parsePath(path);
-                requestMethod = methodInfo.value();
-                requestHasBody = methodInfo.hasBody();
-            } else if (annotationType == Headers.class) {
-                String[] headersToParse = ((Headers) methodAnnotation).value();
-                if (headersToParse.length == 0) {
-                    throw new IllegalStateException("Headers annotation was empty.");
-                }
-                headers = parseHeaders(headersToParse);
-            } else if (annotationType == Multipart.class) {
-                if (requestType != RequestType.SIMPLE) {
-                    throw new IllegalStateException(
-                            "Only one encoding annotation per method is allowed: " + method.getName());
-                }
-                requestType = RequestType.MULTIPART;
-            } else if (annotationType == FormUrlEncoded.class) {
-                if (requestType != RequestType.SIMPLE) {
-                    throw new IllegalStateException(
-                            "Only one encoding annotation per method is allowed: " + method.getName());
-                }
-                requestType = RequestType.FORM_URL_ENCODED;
-            }
-        }
-
-        if (requestMethod == null) {
-            throw new IllegalStateException(
-                    "Method " + method.getName() + " not annotated with request type (e.g., GET, POST).");
-        }
-        if (!requestHasBody) {
-            if (requestType == RequestType.MULTIPART) {
-                throw new IllegalStateException(
-                        "Multipart can only be specified on HTTP methods with request body (e.g., POST). ("
-                                + method.getName()
-                                + ")");
-            }
-            if (requestType == RequestType.FORM_URL_ENCODED) {
-                throw new IllegalStateException(
-                        "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., POST). ("
-                                + method.getName()
-                                + ")");
-            }
-        }
-    }
-
-    /**
-     * Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}.
-     */
-    private void parsePath(String path) {
-        if (path == null || path.length() == 0 || path.charAt(0) != '/') {
-            throw new IllegalArgumentException("URL path \""
-                    + path
-                    + "\" on method "
-                    + method.getName()
-                    + " must start with '/'. ("
-                    + method.getName()
-                    + ")");
-        }
-
-        // Get the relative URL path and existing query string, if present.
-        String url = path;
-        String query = null;
-        int question = path.indexOf('?');
-        if (question != -1 && question < path.length() - 1) {
-            url = path.substring(0, question);
-            query = path.substring(question + 1);
-
-            // Ensure the query string does not have any named parameters.
-            Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
-            if (queryParamMatcher.find()) {
-                throw new IllegalStateException("URL query string \""
-                        + query
-                        + "\" on method "
-                        + method.getName()
-                        + " may not have replace block.");
-            }
-        }
-
-        Set<String> urlParams = parsePathParameters(path);
-
-        requestUrl = url;
-        requestUrlParamNames = urlParams;
-        requestQuery = query;
-    }
-
-    private List<retrofit.client.Header> parseHeaders(String[] headers) {
-        List<retrofit.client.Header> headerList = new ArrayList<retrofit.client.Header>();
-        for (String header : headers) {
-            int colon = header.indexOf(':');
-            if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-                throw new IllegalStateException(
-                        "Header must be in the form \"Name: Value\": \"" + header + "\"");
-            }
-            headerList.add(new retrofit.client.Header(header.substring(0, colon),
-                    header.substring(colon + 1).trim()));
-        }
-        return headerList;
-    }
-
-    /**
-     * Loads {@link #responseObjectType}. Returns {@code true} if method is synchronous.
-     */
-    private ResponseType parseResponseType() {
-        // Synchronous methods have a non-void return type.
-        // Observable methods have a return type of Observable.
-        Type returnType = method.getGenericReturnType();
-
-        // Asynchronous methods should have a Callback type as the last argument.
-        Type lastArgType = null;
-        Class<?> lastArgClass = null;
-        Type[] parameterTypes = method.getGenericParameterTypes();
-        if (parameterTypes.length > 0) {
-            Type typeToCheck = parameterTypes[parameterTypes.length - 1];
-            lastArgType = typeToCheck;
-            if (typeToCheck instanceof ParameterizedType) {
-                typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
-            }
-            if (typeToCheck instanceof Class) {
-                lastArgClass = (Class<?>) typeToCheck;
-            }
-        }
-
-        boolean hasReturnType = returnType != void.class;
-        boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
-
-        // Check for invalid configurations.
-        if (hasReturnType && hasCallback) {
-            throw new IllegalArgumentException("Method "
-                    + method.getName()
-                    + " may only have return type or Callback as last argument, not both.");
-        }
-        if (!hasReturnType && !hasCallback) {
-            throw new IllegalArgumentException("Method "
-                    + method.getName()
-                    + " must have either a return type or Callback as last argument.");
-        }
-
-        if (hasReturnType) {
-            if (Platform.HAS_RX_JAVA) {
-                Class rawReturnType = Types.getRawType(returnType);
-                if (RxSupport.isObservable(rawReturnType)) {
-                    returnType = RxSupport.getObservableType(returnType, rawReturnType);
-                    responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
-                    return ResponseType.OBSERVABLE;
-                }
-            }
-            responseObjectType = returnType;
-            return ResponseType.OBJECT;
-        }
-
-        lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
-        if (lastArgType instanceof ParameterizedType) {
-            responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
-            return ResponseType.VOID;
-        }
-
-        throw new IllegalArgumentException("Last parameter of "
-                + method.getName()
-                + " must be of type Callback<X> or Callback<? super X>. Found: "
-                + lastArgType);
-    }
-
-
-    private static Type getParameterUpperBound(ParameterizedType type) {
-        Type[] types = type.getActualTypeArguments();
-        for (int i = 0; i < types.length; i++) {
-            Type paramType = types[i];
-            if (paramType instanceof WildcardType) {
-                types[i] = ((WildcardType) paramType).getUpperBounds()[0];
-            }
-        }
-        return types[0];
-    }
-
-    /**
-     * Loads {@link #requestParamNames} and {@link #requestParamUsage}. Must be called after
-     * {@link #parseMethodAnnotations()}.
-     */
-    private void parseParameters() {
-        Class<?>[] parameterTypes = method.getParameterTypes();
-
-        Annotation[][] parameterAnnotationArrays = method.getParameterAnnotations();
-        int count = parameterAnnotationArrays.length;
-        if (!isSynchronous && !isObservable) {
-            count -= 1; // Callback is last argument when not a synchronous method.
-        }
-
-        String[] paramNames = new String[count];
-        requestParamNames = paramNames;
-        ParamUsage[] paramUsage = new ParamUsage[count];
-        requestParamUsage = paramUsage;
-
-        boolean gotField = false;
-        boolean gotPart = false;
-        boolean gotBody = false;
-
-        for (int i = 0; i < count; i++) {
-            Class<?> parameterType = parameterTypes[i];
-            Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
-            if (parameterAnnotations != null) {
-                for (Annotation parameterAnnotation : parameterAnnotations) {
-                    Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
-
-                    if (annotationType == Url.class) {
-                        paramNames[i] = "";
-                        paramUsage[i] = ParamUsage.URL;
-                    }
-                    if (annotationType == Path.class) {
-                        String name = ((Path) parameterAnnotation).value();
-                        validatePathName(name);
-
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.PATH;
-                    } else if (annotationType == EncodedPath.class) {
-                        String name = ((EncodedPath) parameterAnnotation).value();
-                        validatePathName(name);
-
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.ENCODED_PATH;
-                    } else if (annotationType == Query.class) {
-                        String name = ((Query) parameterAnnotation).value();
-
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.QUERY;
-                    } else if (annotationType == EncodedQuery.class) {
-                        String name = ((EncodedQuery) parameterAnnotation).value();
-
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.ENCODED_QUERY;
-                    } else if (annotationType == Header.class) {
-                        String name = ((Header) parameterAnnotation).value();
-                        if (parameterType != String.class) {
-                            throw new IllegalStateException("@Header parameter type must be String: " + name);
-                        }
-
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.HEADER;
-                    } else if (annotationType == Field.class) {
-                        if (requestType != RequestType.FORM_URL_ENCODED) {
-                            throw new IllegalStateException(
-                                    "@Field parameters can only be used with form encoding.");
-                        }
-
-                        String name = ((Field) parameterAnnotation).value();
-
-                        gotField = true;
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.FIELD;
-                    } else if (annotationType == Part.class) {
-                        if (requestType != RequestType.MULTIPART) {
-                            throw new IllegalStateException(
-                                    "@Part parameters can only be used with multipart encoding.");
-                        }
-
-                        String name = ((Part) parameterAnnotation).value();
-
-                        gotPart = true;
-                        paramNames[i] = name;
-                        paramUsage[i] = ParamUsage.PART;
-                    } else if (annotationType == Body.class) {
-                        if (requestType != RequestType.SIMPLE) {
-                            throw new IllegalStateException(
-                                    "@Body parameters cannot be used with form or multi-part encoding.");
-                        }
-                        if (gotBody) {
-                            throw new IllegalStateException(
-                                    "Method annotated with multiple Body method annotations: " + method);
-                        }
-
-                        gotBody = true;
-                        paramUsage[i] = ParamUsage.BODY;
-                    }
-                }
-            }
-
-            if (paramUsage[i] == null) {
-                throw new IllegalStateException(
-                        "No Retrofit annotation found on parameter " + (i + 1) + " of " + method.getName());
-            }
-        }
-
-        if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
-            throw new IllegalStateException("Non-body HTTP method cannot contain @Body or @TypedOutput.");
-        }
-        if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
-            throw new IllegalStateException("Form-encoded method must contain at least one @Field.");
-        }
-        if (requestType == RequestType.MULTIPART && !gotPart) {
-            throw new IllegalStateException("Multipart method must contain at least one @Part.");
-        }
-    }
-
-    private void validatePathName(String name) {
-        if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-            throw new IllegalStateException("Path parameter name is not valid: "
-                    + name
-                    + ". Must match "
-                    + PARAM_URL_REGEX.pattern());
-        }
-        // Verify URL replacement name is actually present in the URL path.
-        if (!requestUrlParamNames.contains(name)) {
-            throw new IllegalStateException(
-                    "Method URL \"" + requestUrl + "\" does not contain {" + name + "}.");
-        }
-    }
-
-    /**
-     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-     * in the URI, it will only show up once in the set.
-     */
-    static Set<String> parsePathParameters(String path) {
-        Matcher m = PARAM_URL_REGEX.matcher(path);
-        Set<String> patterns = new LinkedHashSet<String>();
-        while (m.find()) {
-            patterns.add(m.group(1));
-        }
-        return patterns;
-    }
-
-    /**
-     * Indirection to avoid log complaints if RxJava isn't present.
-     */
-    private static final class RxSupport {
-        public static boolean isObservable(Class rawType) {
-            return rawType == Observable.class;
-        }
-
-        public static Type getObservableType(Type contextType, Class contextRawType) {
-            return Types.getSupertype(contextType, contextRawType, Observable.class);
-        }
-    }
-}
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
new file mode 100644
index 000000000..06e4aa87a
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+
+import static retrofit.Utils.checkNotNull;
+
+/**
+ * Adapts a Java interface to a REST API.
+ * <p>
+ * API endpoints are defined as methods on an interface with annotations providing metadata about
+ * the form in which the HTTP call should be made.
+ * <p>
+ * The relative path for a given method is obtained from an annotation on the method describing
+ * the request type. The built-in methods are {@link retrofit.http.GET GET},
+ * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.PATCH
+ * PATCH}, {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a
+ * custom HTTP method with {@link HTTP @HTTP}.
+ * <p>
+ * Method parameters can be used to replace parts of the URL by annotating them with
+ * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
+ * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+ * {@link retrofit.http.Query @Query}.
+ * <p>
+ * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
+ * will be converted to request representation by a call to
+ * {@link Converter#toBody(Object, java.lang.reflect.Type) toBody}
+ * on the supplied {@link Converter} for this instance. A {@link RequestBody} can also be used
+ * which will not use the {@code Converter}.
+ * <p>
+ * Alternative request body formats are supported by method annotations and corresponding parameter
+ * annotations:
+ * <ul>
+ * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+ * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
+ * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
+ * specified by the {@link retrofit.http.Part @Part} parameter annotation.
+ * </ul>
+ * <p>
+ * Additional static headers can be added for an endpoint using the
+ * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
+ * annotate a parameter with {@link Header @Header}.
+ * <p>
+ * By default, methods return a {@link Call} which represents the HTTP request. The generic
+ * parameter of the call is the response body type and will be converted by a call to
+ * {@link Converter#fromBody(ResponseBody, Type) fromBody} on the supplied {@link Converter} for
+ * this instance. {@link ResponseBody} can also be used which will not use the {@code Converter}.
+ * <p>
+ * For example:
+ * <pre>
+ * public interface CategoryService {
+ *   &#64;POST("/category/{cat}")
+ *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+ * }
+ * </pre>
+ * <p>
+ * Calling {@link #create(Class) create()} with {@code CategoryService.class} will validate the
+ * annotations and create a new implementation of the service definition.
+ *
+ * @author Bob Lee (bob@squareup.com)
+ * @author Jake Wharton (jw@squareup.com)
+ */
+public final class Retrofit {
+  private final Map<Method, MethodInfo> methodInfoCache = new LinkedHashMap<>();
+  private final OkHttpClient client;
+  private final Endpoint endpoint;
+  private final Converter converter;
+  private final CallAdapter.Factory adapterFactory;
+
+  private Retrofit(OkHttpClient client, Endpoint endpoint, Converter converter,
+      CallAdapter.Factory adapterFactory) {
+    this.client = client;
+    this.endpoint = endpoint;
+    this.converter = converter;
+    this.adapterFactory = adapterFactory;
+  }
+
+  /** Create an implementation of the API defined by the {@code service} interface. */
+  @SuppressWarnings("unchecked") // Single interface proxy creation guarded by parameter safety.
+  public <T> T create(Class<T> service) {
+    Utils.validateServiceClass(service);
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
+        handler);
+  }
+
+  private final InvocationHandler handler = new InvocationHandler() {
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      // If the method is a method from Object then defer to normal invocation.
+      if (method.getDeclaringClass() == Object.class) {
+        return method.invoke(this, args);
+      }
+      return invokeMethod(method, args);
+    }
+  };
+
+  // Package-private avoids synthetic accessor method from InvocationHandler. Also for testing.
+  Object invokeMethod(Method method, Object... args) {
+    MethodInfo methodInfo = loadMethodInfo(method);
+    Call call = new OkHttpCall(endpoint, converter, client, methodInfo, args);
+    return methodInfo.adapter.adapt(call);
+  }
+
+  private MethodInfo loadMethodInfo(Method method) {
+    MethodInfo methodInfo = methodInfoCache.get(method);
+    if (methodInfo == null) {
+      synchronized (methodInfoCache) {
+        methodInfo = methodInfoCache.get(method);
+        if (methodInfo == null) {
+          methodInfo = new MethodInfo(method, adapterFactory, converter);
+          methodInfoCache.put(method, methodInfo);
+        }
+      }
+    }
+    return methodInfo;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public Endpoint endpoint() {
+    return endpoint;
+  }
+
+  /**
+   * TODO
+   * <p>
+   * May be null.
+   */
+  public Converter converter() {
+    return converter;
+  }
+
+  public CallAdapter.Factory callAdapterFactory() {
+    return adapterFactory;
+  }
+
+  /**
+   * Build a new {@link Retrofit}.
+   * <p>
+   * Calling {@link #endpoint} is required before calling {@link #build()}. All other methods
+   * are optional.
+   */
+  public static class Builder {
+    private OkHttpClient client;
+    private Endpoint endpoint;
+    private Converter converter;
+    private CallAdapter.Factory adapterFactory;
+
+    /** The HTTP client used for requests. */
+    public Builder client(OkHttpClient client) {
+      this.client = checkNotNull(client, "client == null");
+      return this;
+    }
+
+    /** API endpoint URL. */
+    public Builder endpoint(String url) {
+      return endpoint(Endpoint.createFixed(url));
+    }
+
+    /** API endpoint. */
+    public Builder endpoint(Endpoint endpoint) {
+      this.endpoint = checkNotNull(endpoint, "endpoint == null");
+      return this;
+    }
+
+    /** The converter used for serialization and deserialization of objects. */
+    public Builder converter(Converter converter) {
+      this.converter = checkNotNull(converter, "converter == null");
+      return this;
+    }
+
+    /**
+     * TODO
+     */
+    public Builder callAdapterFactory(CallAdapter.Factory adapterFactory) {
+      this.adapterFactory = checkNotNull(adapterFactory, "adapterFactory == null");
+      return this;
+    }
+
+    /** Create the {@link Retrofit} instances. */
+    public Retrofit build() {
+      checkNotNull(endpoint, "Endpoint required.");
+
+      // Set any platform-appropriate defaults for unspecified components.
+      if (client == null) {
+        client = Platform.get().defaultClient();
+      }
+      if (adapterFactory == null) {
+        adapterFactory = Platform.get().defaultCallAdapterFactory();
+      }
+
+      return new Retrofit(client, endpoint, converter, adapterFactory);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
deleted file mode 100644
index 3ee113207..000000000
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.io.IOException;
-import java.lang.reflect.Type;
-import retrofit.client.Response;
-import retrofit.converter.ConversionException;
-import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
-
-public class RetrofitError extends RuntimeException {
-  public static RetrofitError networkError(String url, IOException exception) {
-    return new RetrofitError(url, null, null, null, true, exception);
-  }
-
-  public static RetrofitError conversionError(String url, Response response, Converter converter,
-      Type successType, ConversionException exception) {
-    return new RetrofitError(url, response, converter, successType, false, exception);
-  }
-
-  public static RetrofitError httpError(String url, Response response, Converter converter,
-      Type successType) {
-    return new RetrofitError(url, response, converter, successType, false, null);
-  }
-
-  public static RetrofitError unexpectedError(String url, Throwable exception) {
-    return new RetrofitError(url, null, null, null, false, exception);
-  }
-
-  private final String url;
-  private final Response response;
-  private final Converter converter;
-  private final Type successType;
-  private final boolean networkError;
-
-  RetrofitError(String url, Response response, Converter converter, Type successType,
-      boolean networkError, Throwable exception) {
-    super(exception);
-    this.url = url;
-    this.response = response;
-    this.converter = converter;
-    this.successType = successType;
-    this.networkError = networkError;
-  }
-
-  /** The request URL which produced the error. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Response object containing status code, headers, body, etc. */
-  public Response getResponse() {
-    return response;
-  }
-
-  /** Whether or not this error was the result of a network error. */
-  public boolean isNetworkError() {
-    return networkError;
-  }
-
-  /**
-   * HTTP response body converted to the type declared by either the interface method return type or
-   * the generic type of the supplied {@link Callback} parameter.
-   */
-  public Object getBody() {
-    TypedInput body = response.getBody();
-    if (body == null) {
-      return null;
-    }
-    try {
-      return converter.fromBody(body, successType);
-    } catch (ConversionException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  /** HTTP response body converted to specified {@code type}. */
-  public Object getBodyAs(Type type) {
-    TypedInput body = response.getBody();
-    if (body == null) {
-      return null;
-    }
-    try {
-      return converter.fromBody(body, type);
-    } catch (ConversionException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Server.java b/retrofit/src/main/java/retrofit/Server.java
deleted file mode 100644
index d5f5327a2..000000000
--- a/retrofit/src/main/java/retrofit/Server.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/**
- * Represents an API endpoint URL and associated name. Callers should always consult the instance
- * for the latest values rather than caching the returned values.
- *
- * @author Bob Lee (bob@squareup.com)
- * @see ChangeableServer
- */
-public class Server {
-  public static final String DEFAULT_NAME = "default";
-
-  private final String apiUrl;
-  private final String name;
-
-  /** Create a server with the provided URL and default name. */
-  public Server(String apiUrl) {
-    this(apiUrl, DEFAULT_NAME);
-  }
-
-  /** Create a server with the provided URL and name. */
-  public Server(String apiUrl, String name) {
-    this.apiUrl = apiUrl;
-    this.name = name;
-  }
-
-  /** The base API URL. */
-  public String getUrl() {
-    return apiUrl;
-  }
-
-  /** A name for differentiating between multiple API URLs. */
-  public String getName() {
-    return name;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Types.java b/retrofit/src/main/java/retrofit/Types.java
deleted file mode 100644
index 0ad4e5518..000000000
--- a/retrofit/src/main/java/retrofit/Types.java
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.GenericDeclaration;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.NoSuchElementException;
-
-/**
- * Static methods for working with types.
- *
- * @author Bob Lee
- * @author Jesse Wilson
- */
-final class Types {
-  private static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
-
-  private Types() {
-    // No instances.
-  }
-
-  public static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
-    }
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  public static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
-    }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
-    }
-
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
-
-    // We can't resolve this further.
-    return toResolve;
-  }
-
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
-    }
-    throw new NoSuchElementException();
-  }
-
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  private static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  public static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
-        }
-
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
-
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
-
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
-        }
-        return original;
-
-      } else {
-        return toResolve;
-      }
-    }
-  }
-
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
-
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
-
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  private static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
-    }
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
-    }
-
-    public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
-    }
-
-    public Type getRawType() {
-      return rawType;
-    }
-
-    public Type getOwnerType() {
-      return ownerType;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);
-    }
-
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
-    }
-
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
-    }
-  }
-
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
-
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
-
-    public Type getGenericComponentType() {
-      return componentType;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Types.equals(this, (GenericArrayType) o);
-    }
-
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
-
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
-
-    public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
-
-    public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Types.equals(this, (WildcardType) other);
-    }
-
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
-    }
-
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index 4fbe02039..c9a6d53ac 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,84 +16,44 @@
  */
 package retrofit;
 
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
 import java.util.concurrent.Executor;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Source;
 
 final class Utils {
-  private static final int BUFFER_SIZE = 0x1000;
-
-  /**
-   * Creates a {@code byte[]} from reading the entirety of an {@link InputStream}. May return an
-   * empty array but never {@code null}.
-   * <p>
-   * Copied from Guava's {@code ByteStreams} class.
-   */
-  static byte[] streamToBytes(InputStream stream) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    if (stream != null) {
-      byte[] buf = new byte[BUFFER_SIZE];
-      int r;
-      while ((r = stream.read(buf)) != -1) {
-        baos.write(buf, 0, r);
-      }
+  static <T> T checkNotNull(T object, String message) {
+    if (object == null) {
+      throw new NullPointerException(message);
     }
-    return baos.toByteArray();
+    return object;
   }
 
   /**
-   * Conditionally replace a {@link Request} with an identical copy whose body is backed by a
-   * byte[] rather than an input stream.
+   * Replace a {@link Response} with an identical copy whose body is backed by a
+   * {@link Buffer} rather than a {@link Source}.
    */
-  static Request readBodyToBytesIfNecessary(Request request) throws IOException {
-    TypedOutput body = request.getBody();
-    if (body == null || body instanceof TypedByteArray) {
-      return request;
+  static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws IOException {
+    if (body == null) {
+      return null;
     }
 
-    String bodyMime = body.mimeType();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    body.writeTo(baos);
-    body = new TypedByteArray(bodyMime, baos.toByteArray());
+    BufferedSource source = body.source();
+    final Buffer buffer = new Buffer();
+    buffer.writeAll(source);
+    source.close();
 
-    return new Request(request.getMethod(), request.getUrl(), request.getHeaders(), body);
-  }
-
-  /**
-   * Conditionally replace a {@link Response} with an identical copy whose body is backed by a
-   * byte[] rather than an input stream.
-   */
-  static Response readBodyToBytesIfNecessary(Response response) throws IOException {
-    TypedInput body = response.getBody();
-    if (body == null || body instanceof TypedByteArray) {
-      return response;
-    }
-
-    String bodyMime = body.mimeType();
-    InputStream is = body.in();
-    try {
-      byte[] bodyBytes = Utils.streamToBytes(is);
-      body = new TypedByteArray(bodyMime, bodyBytes);
-
-      return replaceResponseBody(response, body);
-    } finally {
-      if (is != null) {
-        try {
-          is.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-  }
-
-  static Response replaceResponseBody(Response response, TypedInput body) {
-    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
+    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
   static <T> void validateServiceClass(Class<T> service) {
@@ -108,6 +68,80 @@ static Response replaceResponseBody(Response response, TypedInput body) {
     }
   }
 
+  public static Type getSingleParameterUpperBound(ParameterizedType type) {
+    Type[] types = type.getActualTypeArguments();
+    if (types.length != 1) {
+      throw new IllegalArgumentException(
+          "Expected one type argument but got: " + Arrays.toString(types));
+    }
+    Type paramType = types[0];
+    if (paramType instanceof WildcardType) {
+      return ((WildcardType) paramType).getUpperBounds()[0];
+    }
+    return paramType;
+  }
+
+  public static boolean hasUnresolvableType(Type type) {
+    if (type instanceof Class<?>) {
+      return false;
+    }
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+        if (hasUnresolvableType(typeArgument)) {
+          return true;
+        }
+      }
+      return false;
+    }
+    if (type instanceof GenericArrayType) {
+      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+    }
+    if (type instanceof TypeVariable) {
+      return true;
+    }
+    if (type instanceof WildcardType) {
+      return true;
+    }
+    String className = type == null ? "null" : type.getClass().getName();
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+        + "GenericArrayType, but <" + type + "> is of type " + className);
+  }
+
+  // This method is copyright 2008 Google Inc. and is taken from Gson under the Apache 2.0 license.
+  public static Class<?> getRawType(Type type) {
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+
+    } else if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+
+    } else if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+
+    } else if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    } else {
+      String className = type == null ? "null" : type.getClass().getName();
+      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+  }
+
   static class SynchronousExecutor implements Executor {
     @Override public void execute(Runnable runnable) {
       runnable.run();
diff --git a/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java b/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java
deleted file mode 100644
index d5ae3dc8a..000000000
--- a/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.android;
-
-import android.net.http.AndroidHttpClient;
-import retrofit.client.ApacheClient;
-
-/**
- * Provides a {@link retrofit.client.Client} which uses the Android-specific version of
- * {@link org.apache.http.client.HttpClient}, {@link AndroidHttpClient}.
- * <p>
- * If you need to provide a customized version of the {@link AndroidHttpClient} or a different
- * {@link org.apache.http.client.HttpClient} on Android use {@link ApacheClient} directly.
- */
-public final class AndroidApacheClient extends ApacheClient {
-  public AndroidApacheClient() {
-    super(AndroidHttpClient.newInstance("Retrofit"));
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/android/AndroidLog.java b/retrofit/src/main/java/retrofit/android/AndroidLog.java
deleted file mode 100644
index 13f0edd0a..000000000
--- a/retrofit/src/main/java/retrofit/android/AndroidLog.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package retrofit.android;
-
-import android.util.Log;
-import retrofit.RestAdapter;
-
-/** A {@link RestAdapter.Log logger} for Android. */
-public class AndroidLog implements RestAdapter.Log {
-  private static final int LOG_CHUNK_SIZE = 4000;
-
-  private final String tag;
-
-  public AndroidLog(String tag) {
-    this.tag = tag;
-  }
-
-  @Override public void log(String message) {
-    for (int i = 0, len = message.length(); i < len; i += LOG_CHUNK_SIZE) {
-      int end = Math.min(len, i + LOG_CHUNK_SIZE);
-      Log.d(tag, message.substring(i, end));
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/ApacheClient.java b/retrofit/src/main/java/retrofit/client/ApacheClient.java
deleted file mode 100644
index e65ff060a..000000000
--- a/retrofit/src/main/java/retrofit/client/ApacheClient.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.List;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.entity.AbstractHttpEntity;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.message.BasicHeader;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.util.EntityUtils;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
-
-/** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
-public class ApacheClient implements Client {
-  private static HttpClient createDefaultClient() {
-    HttpParams params = new BasicHttpParams();
-    HttpConnectionParams.setConnectionTimeout(params, Defaults.CONNECT_TIMEOUT_MILLIS);
-    HttpConnectionParams.setSoTimeout(params, Defaults.READ_TIMEOUT_MILLIS);
-    return new DefaultHttpClient(params);
-  }
-
-  private final HttpClient client;
-
-  /** Creates an instance backed by {@link DefaultHttpClient}. */
-  public ApacheClient() {
-    this(createDefaultClient());
-  }
-
-  public ApacheClient(HttpClient client) {
-    this.client = client;
-  }
-
-  @Override public Response execute(Request request) throws IOException {
-    HttpUriRequest apacheRequest = createRequest(request);
-    HttpResponse apacheResponse = execute(client, apacheRequest);
-    return parseResponse(apacheResponse);
-  }
-
-  /** Execute the specified {@code request} using the provided {@code client}. */
-  protected HttpResponse execute(HttpClient client, HttpUriRequest request) throws IOException {
-    return client.execute(request);
-  }
-
-  static HttpUriRequest createRequest(Request request) {
-    return new GenericHttpRequest(request);
-  }
-
-  static Response parseResponse(HttpResponse response) throws IOException {
-    StatusLine statusLine = response.getStatusLine();
-    int status = statusLine.getStatusCode();
-    String reason = statusLine.getReasonPhrase();
-
-    List<Header> headers = new ArrayList<Header>();
-    String contentType = "application/octet-stream";
-    for (org.apache.http.Header header : response.getAllHeaders()) {
-      String name = header.getName();
-      String value = header.getValue();
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        contentType = value;
-      }
-      headers.add(new Header(name, value));
-    }
-
-    TypedByteArray body = null;
-    HttpEntity entity = response.getEntity();
-    if (entity != null) {
-      byte[] bytes = EntityUtils.toByteArray(entity);
-      body = new TypedByteArray(contentType, bytes);
-    }
-
-    return new Response(status, reason, headers, body);
-  }
-
-  private static class GenericHttpRequest extends HttpEntityEnclosingRequestBase {
-    private final String method;
-
-    GenericHttpRequest(Request request) {
-      super();
-      method = request.getMethod();
-      setURI(URI.create(request.getUrl()));
-
-      // Add all headers.
-      for (Header header : request.getHeaders()) {
-        addHeader(new BasicHeader(header.getName(), header.getValue()));
-      }
-
-      // Add the content body, if any.
-      TypedOutput body = request.getBody();
-      if (body != null) {
-        setEntity(new TypedOutputEntity(body));
-      }
-    }
-
-    @Override public String getMethod() {
-      return method;
-    }
-  }
-
-  /** Container class for passing an entire {@link TypedOutput} as an {@link HttpEntity}. */
-  static class TypedOutputEntity extends AbstractHttpEntity {
-    final TypedOutput typedOutput;
-
-    TypedOutputEntity(TypedOutput typedOutput) {
-      this.typedOutput = typedOutput;
-      setContentType(typedOutput.mimeType());
-    }
-
-    @Override public boolean isRepeatable() {
-      return true;
-    }
-
-    @Override public long getContentLength() {
-      return typedOutput.length();
-    }
-
-    @Override public InputStream getContent() throws IOException {
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      typedOutput.writeTo(out);
-      return new ByteArrayInputStream(out.toByteArray());
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      typedOutput.writeTo(out);
-    }
-
-    @Override public boolean isStreaming() {
-      return false;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Client.java b/retrofit/src/main/java/retrofit/client/Client.java
deleted file mode 100644
index 5608b5352..000000000
--- a/retrofit/src/main/java/retrofit/client/Client.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.IOException;
-
-/**
- * Abstraction of an HTTP client which can execute {@link Request Requests}. This class must be
- * thread-safe as invocation may happen from multiple threads simultaneously.
- */
-public interface Client {
-  /**
-   * Synchronously execute an HTTP represented by {@code request} and encapsulate all response data
-   * into a {@link Response} instance.
-   */
-  Response execute(Request request) throws IOException;
-
-  /**
-   * Deferred means of obtaining a {@link Client}. For asynchronous requests this will always be
-   * called on a background thread.
-   */
-  interface Provider {
-    /** Obtain an HTTP client. Called once for each request. */
-    Client get();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Defaults.java b/retrofit/src/main/java/retrofit/client/Defaults.java
deleted file mode 100644
index 616a9825c..000000000
--- a/retrofit/src/main/java/retrofit/client/Defaults.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package retrofit.client;
-
-class Defaults {
-  static final int CONNECT_TIMEOUT_MILLIS = 15 * 1000; // 15s
-  static final int READ_TIMEOUT_MILLIS = 20 * 1000; // 20s
-}
diff --git a/retrofit/src/main/java/retrofit/client/Header.java b/retrofit/src/main/java/retrofit/client/Header.java
deleted file mode 100644
index 41daf5b22..000000000
--- a/retrofit/src/main/java/retrofit/client/Header.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-/** Represents an HTTP header name/value pair. */
-public final class Header {
-  private final String name;
-  private final String value;
-
-  public Header(String name, String value) {
-    this.name = name;
-    this.value = value;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public String getValue() {
-    return value;
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    Header header = (Header) o;
-
-    if (name != null ? !name.equals(header.name) : header.name != null) return false;
-    if (value != null ? !value.equals(header.value) : header.value != null) return false;
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = name != null ? name.hashCode() : 0;
-    result = 31 * result + (value != null ? value.hashCode() : 0);
-    return result;
-  }
-
-  @Override public String toString() {
-    return (name != null ? name : "") + ": " + (value != null ? value : "");
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/OkClient.java b/retrofit/src/main/java/retrofit/client/OkClient.java
deleted file mode 100644
index 7eac535c1..000000000
--- a/retrofit/src/main/java/retrofit/client/OkClient.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import com.squareup.okhttp.OkHttpClient;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.concurrent.TimeUnit;
-
-/** Retrofit client that uses OkHttp for communication. */
-public class OkClient extends UrlConnectionClient {
-  private final OkHttpClient client;
-
-  public OkClient() {
-    this(generateDefaultOkHttp());
-  }
-
-  public OkClient(OkHttpClient client) {
-    this.client = client;
-  }
-
-  @Override protected HttpURLConnection openConnection(Request request) throws IOException {
-    return client.open(new URL(request.getUrl()));
-  }
-
-  private static OkHttpClient generateDefaultOkHttp() {
-    OkHttpClient okHttp = new OkHttpClient();
-    okHttp.setConnectTimeout(Defaults.CONNECT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-    okHttp.setReadTimeout(Defaults.READ_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-    return okHttp;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Request.java b/retrofit/src/main/java/retrofit/client/Request.java
deleted file mode 100644
index 8d2199def..000000000
--- a/retrofit/src/main/java/retrofit/client/Request.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import retrofit.mime.TypedOutput;
-
-/** Encapsulates all of the information necessary to make an HTTP request. */
-public final class Request {
-  private final String method;
-  private final String url;
-  private final List<Header> headers;
-  private final TypedOutput body;
-
-  public Request(String method, String url, List<Header> headers, TypedOutput body) {
-    if (method == null) {
-      throw new NullPointerException("Method must not be null.");
-    }
-    if (url == null) {
-      throw new NullPointerException("URL must not be null.");
-    }
-    this.method = method;
-    this.url = url;
-
-    if (headers == null) {
-      this.headers = Collections.emptyList();
-    } else {
-      this.headers = Collections.unmodifiableList(new ArrayList<Header>(headers));
-    }
-
-    this.body = body;
-  }
-
-  /** HTTP method verb. */
-  public String getMethod() {
-    return method;
-  }
-
-  /** Target URL. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Returns an unmodifiable list of headers, never {@code null}. */
-  public List<Header> getHeaders() {
-    return headers;
-  }
-
-  /** Returns the request body or {@code null}. */
-  public TypedOutput getBody() {
-    return body;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Response.java b/retrofit/src/main/java/retrofit/client/Response.java
deleted file mode 100644
index 44c1406b9..000000000
--- a/retrofit/src/main/java/retrofit/client/Response.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import retrofit.mime.TypedInput;
-
-/** An HTTP response. */
-public final class Response {
-  private final int status;
-  private final String reason;
-  private final List<Header> headers;
-  private final TypedInput body;
-
-  public Response(int status, String reason, List<Header> headers, TypedInput body) {
-    if (status < 200) {
-      throw new IllegalArgumentException("Invalid status code: " + status);
-    }
-    if (reason == null) {
-      throw new IllegalArgumentException("reason == null");
-    }
-    if (headers == null) {
-      throw new IllegalArgumentException("headers == null");
-    }
-
-    this.status = status;
-    this.reason = reason;
-    this.headers = Collections.unmodifiableList(new ArrayList<Header>(headers));
-    this.body = body;
-  }
-
-  /** Status line code. */
-  public int getStatus() {
-    return status;
-  }
-
-  /** Status line reason phrase. */
-  public String getReason() {
-    return reason;
-  }
-
-  /** An unmodifiable collection of headers. */
-  public List<Header> getHeaders() {
-    return headers;
-  }
-
-  /** Response body. May be {@code null}. */
-  public TypedInput getBody() {
-    return body;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
deleted file mode 100644
index 10eaf3723..000000000
--- a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Field;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import retrofit.RetrofitError;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-/** Retrofit client that uses {@link HttpURLConnection} for communication. */
-public class UrlConnectionClient implements Client {
-  private static final int CHUNK_SIZE = 4096;
-  private final Field methodField;
-
-  public UrlConnectionClient() {
-    try {
-      this.methodField = HttpURLConnection.class.getDeclaredField("method");
-      this.methodField.setAccessible(true);
-    } catch (NoSuchFieldException e) {
-      throw RetrofitError.unexpectedError(null, e);
-    }
-  }
-
-  @Override public Response execute(Request request) throws IOException {
-    HttpURLConnection connection = openConnection(request);
-    prepareRequest(connection, request);
-    return readResponse(connection);
-  }
-
-  protected HttpURLConnection openConnection(Request request) throws IOException {
-    HttpURLConnection connection =
-        (HttpURLConnection) new URL(request.getUrl()).openConnection();
-    connection.setConnectTimeout(Defaults.CONNECT_TIMEOUT_MILLIS);
-    connection.setReadTimeout(Defaults.READ_TIMEOUT_MILLIS);
-    return connection;
-  }
-
-  void prepareRequest(HttpURLConnection connection, Request request) throws IOException {
-    // HttpURLConnection artificially restricts request method
-    try {
-      connection.setRequestMethod(request.getMethod());
-    } catch (ProtocolException e) {
-      try {
-        methodField.set(connection, request.getMethod());
-      } catch (IllegalAccessException e1) {
-        throw RetrofitError.unexpectedError(request.getUrl(), e1);
-      }
-    }
-
-    connection.setDoInput(true);
-
-    for (Header header : request.getHeaders()) {
-      connection.addRequestProperty(header.getName(), header.getValue());
-    }
-
-    TypedOutput body = request.getBody();
-    if (body != null) {
-      connection.setDoOutput(true);
-      connection.addRequestProperty("Content-Type", body.mimeType());
-      long length = body.length();
-      if (length != -1) {
-        connection.setFixedLengthStreamingMode((int) length);
-        connection.addRequestProperty("Content-Length", String.valueOf(length));
-      } else {
-        connection.setChunkedStreamingMode(CHUNK_SIZE);
-      }
-      body.writeTo(connection.getOutputStream());
-    }
-  }
-
-  Response readResponse(HttpURLConnection connection) throws IOException {
-    int status = connection.getResponseCode();
-    String reason = connection.getResponseMessage();
-
-    List<Header> headers = new ArrayList<Header>();
-    for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet()) {
-      String name = field.getKey();
-      for (String value : field.getValue()) {
-        headers.add(new Header(name, value));
-      }
-    }
-
-    String mimeType = connection.getContentType();
-    int length = connection.getContentLength();
-    InputStream stream;
-    if (status >= 400) {
-      stream = connection.getErrorStream();
-    } else {
-      stream = connection.getInputStream();
-    }
-    TypedInput responseBody = new TypedInputStream(mimeType, length, stream);
-    return new Response(status, reason, headers, responseBody);
-  }
-
-  private static class TypedInputStream implements TypedInput {
-    private final String mimeType;
-    private final long length;
-    private final InputStream stream;
-
-    private TypedInputStream(String mimeType, long length, InputStream stream) {
-      this.mimeType = mimeType;
-      this.length = length;
-      this.stream = stream;
-    }
-
-    @Override public String mimeType() {
-      return mimeType;
-    }
-
-    @Override public long length() {
-      return length;
-    }
-
-    @Override public InputStream in() throws IOException {
-      return stream;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/converter/ConversionException.java b/retrofit/src/main/java/retrofit/converter/ConversionException.java
deleted file mode 100644
index 6673efc0b..000000000
--- a/retrofit/src/main/java/retrofit/converter/ConversionException.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.converter;
-
-/** Indicate that conversion was unable to complete successfully. */
-@SuppressWarnings("UnusedDeclaration")
-public class ConversionException extends Exception {
-  public ConversionException(String message) {
-    super(message);
-  }
-
-  public ConversionException(String message, Throwable throwable) {
-    super(message, throwable);
-  }
-
-  public ConversionException(Throwable throwable) {
-    super(throwable);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
deleted file mode 100644
index 6aa1d7d41..000000000
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.converter;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonParseException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.lang.reflect.Type;
-import retrofit.mime.MimeUtil;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-/**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- *
- * @author Jake Wharton (jw@squareup.com)
- */
-public class GsonConverter implements Converter {
-  private final Gson gson;
-  private String encoding;
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, "UTF-8");
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified encoding.
-   */
-  public GsonConverter(Gson gson, String encoding) {
-    this.gson = gson;
-    this.encoding = encoding;
-  }
-
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
-    String charset = "UTF-8";
-    if (body.mimeType() != null) {
-      charset = MimeUtil.parseCharset(body.mimeType());
-    }
-    InputStreamReader isr = null;
-    try {
-      isr = new InputStreamReader(body.in(), charset);
-      return gson.fromJson(isr, type);
-    } catch (IOException e) {
-      throw new ConversionException(e);
-    } catch (JsonParseException e) {
-      throw new ConversionException(e);
-    } finally {
-      if (isr != null) {
-        try {
-          isr.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-  }
-
-  @Override public TypedOutput toBody(Object object) {
-    try {
-      return new JsonTypedOutput(gson.toJson(object).getBytes(encoding), encoding);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static class JsonTypedOutput implements TypedOutput {
-    private final byte[] jsonBytes;
-    private final String mimeType;
-
-    JsonTypedOutput(byte[] jsonBytes, String encode) {
-      this.jsonBytes = jsonBytes;
-      this.mimeType = "application/json; charset=" + encode;
-    }
-
-    @Override public String fileName() {
-      return null;
-    }
-
-    @Override public String mimeType() {
-      return mimeType;
-    }
-
-    @Override public long length() {
-      return jsonBytes.length;
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      out.write(jsonBytes);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/Body.java b/retrofit/src/main/java/retrofit/http/Body.java
index 95368be0c..782559502 100644
--- a/retrofit/src/main/java/retrofit/http/Body.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -18,6 +18,8 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,11 +27,8 @@
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body). If the value of the parameter implements {@link retrofit.mime.TypedOutput TypedOutput},
- * the request body will be written exactly as specified by
- * {@link retrofit.mime.TypedOutput#writeTo(java.io.OutputStream)}. If the value does not implement
- * TypedOutput, the object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
- * {@link retrofit.converter.Converter Converter} and the result will be set directly as the
+ * body). The object will be serialized using the {@link Retrofit Retrofit} instance
+ * {@link Converter Converter} and the result will be set directly as the
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index 82968958b..6f13b99fe 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod("DELETE")
 public @interface DELETE {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
index 1c3d50a58..bfe020ec0 100644
--- a/retrofit/src/main/java/retrofit/http/Field.java
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -24,19 +24,39 @@
 
 /**
  * Named pair for a form-encoded request.
- *
+ * <p>
+ * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * field pair for each non-{@code null} item.
+ * <p>
+ * Simple Example:
  * <pre>
  * &#64;FormUrlEncoded
  * &#64;POST("/")
- * void example(@Field("name") String name, @Field("occupation") String occupation, ..);
+ * void example(@Field("name") String name, @Field("occupation") String occupation);
  * }
  * </pre>
+ * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
+ * {@code name=Bob+Smith&occupation=President}.
  * <p>
- * Field parameters may be {@code null} which will omit them from the request body.
+ * Array Example:
+ * <pre>
+ * &#64;FormUrlEncoded
+ * &#64;POST("/list")
+ * void example(@Field("name") String... names);
+ * </pre>
+ * Calling with {@code foo.example("Bob Smith", "Jane Doe")} yields a request body of
+ * {@code name=Bob+Smith&name=Jane+Doe}.
+ *
+ * @see FormUrlEncoded
+ * @see FieldMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Field {
   String value();
+
+  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/EncodedPath.java b/retrofit/src/main/java/retrofit/http/FieldMap.java
similarity index 60%
rename from retrofit/src/main/java/retrofit/http/EncodedPath.java
rename to retrofit/src/main/java/retrofit/http/FieldMap.java
index 142aca057..97c5684a2 100644
--- a/retrofit/src/main/java/retrofit/http/EncodedPath.java
+++ b/retrofit/src/main/java/retrofit/http/FieldMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2014 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,20 +23,27 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Named replacement in the URL path. Values are converted to string using
- * {@link String#valueOf(Object)}. Values are used literally without URL encoding. See
- * {@link retrofit.http.Path @Path} for URL encoding equivalent.
+ * Named key/value pairs for a form-encoded request.
  * <p>
+ * Field values may be {@code null} which will omit them from the request body.
+ * <p>
+ * Simple Example:
  * <pre>
- * &#64;GET("/image/{id}")
- * void example(@EncodedPath("id") int id, ..);
+ * &#64;FormUrlEncoded
+ * &#64;POST("/things")
+ * void things(@FieldMap Map&lt;String, String&gt; fields);
+ * }
  * </pre>
- * <p>
- * Path parameters may not be {@code null}.
+ * Calling with {@code foo.things(ImmutableMap.of("foo", "bar", "kit", "kat")} yields a request
+ * body of {@code foo=bar&kit=kat}.
+ *
+ * @see FormUrlEncoded
+ * @see Field
  */
 @Documented
-@Retention(RUNTIME)
 @Target(PARAMETER)
-public @interface EncodedPath {
-  String value();
+@Retention(RUNTIME)
+public @interface FieldMap {
+  /** Specifies whether the names and values are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index 3cc64990b..de81a111c 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod("GET")
 public @interface GET {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index 9f5f9e718..b73685295 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod("HEAD")
 public @interface HEAD {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/RestMethod.java b/retrofit/src/main/java/retrofit/http/HTTP.java
similarity index 86%
rename from retrofit/src/main/java/retrofit/http/RestMethod.java
rename to retrofit/src/main/java/retrofit/http/HTTP.java
index dec22637b..759c5939f 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethod.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -19,13 +19,14 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 @Documented
-@Target(ANNOTATION_TYPE)
+@Target(METHOD)
 @Retention(RUNTIME)
-public @interface RestMethod {
-  String value();
+public @interface HTTP {
+  String method();
+  String path();
   boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
index 7aadc3af6..4ce2cf166 100644
--- a/retrofit/src/main/java/retrofit/http/Header.java
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -27,10 +27,11 @@
  * <p>
  * <pre>
  * &#64;GET("/")
- * void foo(@Header("Accept-Language") String lang, Callback&lt;Response> cb);
+ * void foo(@Header("Accept-Language") String lang, Callback&lt;Response&gt; cb);
  * </pre>
  * <p>
- * Header parameters may be {@code null} which will omit them from the request.
+ * Header parameters may be {@code null} which will omit them from the request. Passing a
+ * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
  * <p>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
diff --git a/retrofit/src/main/java/retrofit/http/PATCH.java b/retrofit/src/main/java/retrofit/http/PATCH.java
index c978a2877..83b061978 100644
--- a/retrofit/src/main/java/retrofit/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit/http/PATCH.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod(value = "PATCH", hasBody = true)
 public @interface PATCH {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index c85f62daf..b1f7b1088 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod(value = "POST", hasBody = true)
 public @interface POST {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index e8e006fca..915df56d7 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod(value = "PUT", hasBody = true)
 public @interface PUT {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index e1f85c45e..fb1a77fb5 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -27,14 +27,14 @@
  * <p>
  * The parameter type on which this annotation exists will be processed in one of three ways:
  * <ul>
- * <li>If the type implements {@link retrofit.mime.TypedOutput TypedOutput} the headers and
- * body will be used directly.</li>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
  * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object)}.</li>
+ * retrofit.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
  * </ul>
  * <p>
+ * Values may be {@code null} which will omit them from the request body.
+ * <p>
  * <pre>
  * &#64;Multipart
  * &#64;POST("/")
@@ -51,4 +51,6 @@
 @Retention(RUNTIME)
 public @interface Part {
   String value();
+  /** The {@code Content-Transfer-Encoding} of this part. */
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
new file mode 100644
index 000000000..faf8abe25
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes name and value parts of a multi-part request
+ * <p>
+ * Values of the map on which this annotation exists will be processed in one of three ways:
+ * <ul>
+ * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
+ * content type.</li>
+ * <li>Other object types will be converted to an appropriate representation by calling {@link
+ * retrofit.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * </ul>
+ * <p>
+ * <pre>
+ * &#64;Multipart
+ * &#64;POST("/upload")
+ * void upload(&#64;Part("file") TypedFile file, &#64;PartMap Map&lt;String, String&gt; params);
+ * </pre>
+ *
+ * @see Multipart
+ * @see Part
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface PartMap {
+  /** The {@code Content-Transfer-Encoding} of this part. */
+  String encoding() default "binary";
+}
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
index cd0ae4115..0a3afa4e8 100644
--- a/retrofit/src/main/java/retrofit/http/Path.java
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -24,12 +24,25 @@
 
 /**
  * Named replacement in the URL path. Values are converted to string using
- * {@link String#valueOf(Object)}. Replaced values will be URL encoded.
+ * {@link String#valueOf(Object)} and URL encoded.
  * <p>
+ * Simple example:
  * <pre>
  * &#64;GET("/image/{id}")
- * void example(@Path("id") int id, ..);
+ * void example(@Path("id") int id);
  * </pre>
+ * Calling with {@code foo.example(1)} yields {@code /image/1}.
+ * <p>
+ * Values are URL encoded by default. Disable with {@code encode=false}.
+ * <pre>
+ * &#64;GET("/user/{name}")
+ * void encoded(@Path("name") String name);
+ *
+ * &#64;GET("/user/{name}")
+ * void notEncoded(@Path(value="name", encode=false) String name);
+ * </pre>
+ * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
+ * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
  * <p>
  * Path parameters may not be {@code null}.
  */
@@ -38,4 +51,9 @@
 @Target(PARAMETER)
 public @interface Path {
   String value();
+
+  /**
+   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+   */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
index 2ece22f18..8e53a9c6a 100644
--- a/retrofit/src/main/java/retrofit/http/Query.java
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -23,19 +23,53 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Query parameter appended to the URL. Values are converted to strings using
- * {@link String#valueOf(Object)}. Parameter values will be URL encoded.
+ * Query parameter appended to the URL.
  * <p>
+ * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * query parameter for each non-{@code null} item.
+ * <p>
+ * Simple Example:
  * <pre>
  * &#64;GET("/list")
- * void example(@Query("page") int page, ..);
+ * void list(@Query("page") int page);
  * </pre>
+ * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
  * <p>
- * Query parameters may be {@code null} which will omit them from the URL.
+ * Example with {@code null}:
+ * <pre>
+ * &#64;GET("/list")
+ * void list(@Query("category") String category);
+ * </pre>
+ * Calling with {@code foo.list(null)} yields {@code /list}.
+ * <p>
+ * Array Example:
+ * <pre>
+ * &#64;GET("/list")
+ * void list(@Query("category") String... categories);
+ * </pre>
+ * Calling with {@code foo.list("bar", "baz")} yields
+ * {@code /list?category=bar&category=baz}.
+ * <p>
+ * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
+ * to change this behavior.
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@Query(value="foo", encoded=true) String foo);
+ * </pre>
+ * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
+ *
+ * @see QueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
+  /** The query parameter name. */
   String value();
+
+  /**
+   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+   */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/QueryMap.java b/retrofit/src/main/java/retrofit/http/QueryMap.java
new file mode 100644
index 000000000..6aaaab78f
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/QueryMap.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter keys and values appended to the URL.
+ * <p>
+ * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
+ * URL encoded and {@code null} will not include the query parameter in the URL. {@code null} keys
+ * are not allowed.
+ * <p>
+ * Simple Example:
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@QueryMap Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
+ * {@code /search?foo=bar&kit=kat}.
+ * <p>
+ * Map keys and values representing parameter values are URL encoded by default. Specify
+ * {@link #encoded() encoded=true} to change this behavior.
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+foo"))} yields
+ * {@code /search?foo=foo%2Bbar}.
+ *
+ * @see Query
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryMap {
+  /** Specifies whether parameter names and values are already URL encoded. */
+  boolean encoded() default false;
+}
diff --git a/retrofit/src/main/java/retrofit/http/EncodedQuery.java b/retrofit/src/main/java/retrofit/http/Streaming.java
similarity index 57%
rename from retrofit/src/main/java/retrofit/http/EncodedQuery.java
rename to retrofit/src/main/java/retrofit/http/Streaming.java
index db14daa71..28cd9b794 100644
--- a/retrofit/src/main/java/retrofit/http/EncodedQuery.java
+++ b/retrofit/src/main/java/retrofit/http/Streaming.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2014 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,24 +19,15 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Query parameter appended to the URL. Values are converted to strings using
- * {@link String#valueOf(Object)}. Parameter Values are used literally without URL encoding. See
- * {@link retrofit.http.Query @Query} for URL encoding equivalent.
- * <p>
- * <pre>
- * &#64;GET("/list")
- * void example(@EncodedQuery("page") int page, ..);
- * </pre>
- * <p>
- * Query parameters may be {@code null} which will omit them from the URL.
+ * Treat the response body on methods returning {@link com.squareup.okhttp.Response Response} as is,
+ * i.e. without converting {@link com.squareup.okhttp.Response#body() body()} to {@code byte[]}.
  */
 @Documented
-@Target(PARAMETER)
+@Target(METHOD)
 @Retention(RUNTIME)
-public @interface EncodedQuery {
-  String value();
+public @interface Streaming {
 }
diff --git a/retrofit/src/main/java/retrofit/http/package-info.java b/retrofit/src/main/java/retrofit/http/package-info.java
new file mode 100644
index 000000000..2dae09c79
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/package-info.java
@@ -0,0 +1,4 @@
+// Copyright 2014 Square, Inc.
+
+/** Annotations for interface methods to control the HTTP request behavior. */
+package retrofit.http;
diff --git a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java b/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
deleted file mode 100644
index d807195a2..000000000
--- a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.URLEncoder;
-
-public final class FormUrlEncodedTypedOutput implements TypedOutput {
-  final ByteArrayOutputStream content = new ByteArrayOutputStream();
-
-  public void addField(String name, String value) {
-    if (name == null) {
-      throw new NullPointerException("name");
-    }
-    if (value == null) {
-      throw new NullPointerException("value");
-    }
-    if (content.size() > 0) {
-      content.write('&');
-    }
-    try {
-      name = URLEncoder.encode(name, "UTF-8");
-      value = URLEncoder.encode(value, "UTF-8");
-
-      content.write(name.getBytes("UTF-8"));
-      content.write('=');
-      content.write(value.getBytes("UTF-8"));
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return "application/x-www-form-urlencoded; charset=UTF-8";
-  }
-
-  @Override public long length() {
-    return content.size();
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(content.toByteArray());
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/MimeUtil.java b/retrofit/src/main/java/retrofit/mime/MimeUtil.java
deleted file mode 100644
index 7307703d5..000000000
--- a/retrofit/src/main/java/retrofit/mime/MimeUtil.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import static java.util.regex.Pattern.CASE_INSENSITIVE;
-
-public final class MimeUtil {
-  private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
-
-  /** Parse the MIME type from a {@code Content-Type} header value. */
-  public static String parseCharset(String mimeType) {
-    Matcher match = CHARSET.matcher(mimeType);
-    if (match.find()) {
-      return match.group(1).replaceAll("[\"\\\\]", "");
-    }
-    return "UTF-8";
-  }
-
-  private MimeUtil() {
-    // No instances.
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
deleted file mode 100644
index 347e691ed..000000000
--- a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.UUID;
-
-public final class MultipartTypedOutput implements TypedOutput {
-
-  private static final class MimePart {
-    private final TypedOutput body;
-    private final String name;
-    private final boolean isFirst;
-    private final String boundary;
-
-    private byte[] partBoundary;
-    private byte[] partHeader;
-    private boolean isBuilt;
-
-    public MimePart(String name, TypedOutput body, String boundary, boolean isFirst) {
-      this.name = name;
-      this.body = body;
-      this.isFirst = isFirst;
-      this.boundary = boundary;
-    }
-
-    public void writeTo(OutputStream out) throws IOException {
-      build();
-      out.write(partBoundary);
-      out.write(partHeader);
-      body.writeTo(out);
-    }
-
-    public long size() {
-      build();
-      if (body.length() > -1) {
-        return body.length() + partBoundary.length + partHeader.length;
-      } else {
-        return -1;
-      }
-    }
-
-    private void build() {
-      if (isBuilt) return;
-      partBoundary = buildBoundary(boundary, isFirst, false);
-      partHeader = buildHeader(name, body);
-      isBuilt = true;
-    }
-  }
-
-  private final List<MimePart> mimeParts = new LinkedList<MimePart>();
-
-  private final byte[] footer;
-  private final String boundary;
-  private long length;
-
-  public MultipartTypedOutput() {
-    this(UUID.randomUUID().toString());
-  }
-
-  MultipartTypedOutput(String boundary) {
-    this.boundary = boundary;
-    footer = buildBoundary(boundary, false, true);
-    length = footer.length;
-  }
-
-  List<byte[]> getParts() throws IOException {
-    List<byte[]> parts = new ArrayList<byte[]>(mimeParts.size());
-    for (MimePart part : mimeParts) {
-      ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      part.writeTo(bos);
-      parts.add(bos.toByteArray());
-    }
-    return parts;
-  }
-
-  public void addPart(String name, TypedOutput body) {
-    if (name == null) {
-      throw new NullPointerException("Part name must not be null.");
-    }
-    if (body == null) {
-      throw new NullPointerException("Part body must not be null.");
-    }
-
-    MimePart part = new MimePart(name, body, boundary, mimeParts.isEmpty());
-    mimeParts.add(part);
-
-    length += part.size();
-  }
-
-  public int getPartCount() {
-    return mimeParts.size();
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return "multipart/form-data; boundary=" + boundary;
-  }
-
-  @Override public long length() {
-    return length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    for (MimePart part : mimeParts) {
-      part.writeTo(out);
-    }
-    out.write(footer);
-  }
-
-  private static byte[] buildBoundary(String boundary, boolean first, boolean last) {
-    try {
-      StringBuilder sb = new StringBuilder();
-      if (!first) {
-        sb.append("\r\n");
-      }
-      sb.append("--");
-      sb.append(boundary);
-      if (last) {
-        sb.append("--");
-      } else {
-        sb.append("\r\n");
-      }
-      return sb.toString().getBytes("UTF-8");
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart boundary", ex);
-    }
-  }
-
-  private static byte[] buildHeader(String name, TypedOutput value) {
-    try {
-      StringBuilder headers = new StringBuilder();
-      headers.append("Content-Disposition: form-data; name=\"");
-      headers.append(name);
-      if (value.fileName() != null) {
-        headers.append("\"; filename=\"");
-        headers.append(value.fileName());
-      }
-      headers.append("\"\r\nContent-Type: ");
-      headers.append(value.mimeType());
-      if (value.length() != -1) {
-        headers.append("\r\nContent-Length: ").append(value.length());
-      }
-      headers.append("\r\nContent-Transfer-Encoding: binary\r\n\r\n");
-      return headers.toString().getBytes("UTF-8");
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart header", ex);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java b/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
deleted file mode 100644
index a167ae9c9..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-
-/**
- * Byte array and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedByteArray implements TypedInput, TypedOutput {
-  private final String mimeType;
-  private final byte[] bytes;
-
-  /**
-   * Constructs a new typed byte array.  Sets mimeType to {@code application/unknown} if absent.
-   *
-   * @throws NullPointerException if bytes are null
-   */
-  public TypedByteArray(String mimeType, byte[] bytes) {
-    if (mimeType == null) {
-      mimeType = "application/unknown";
-    }
-    if (bytes == null) {
-      throw new NullPointerException("bytes");
-    }
-    this.mimeType = mimeType;
-    this.bytes = bytes;
-  }
-
-  public byte[] getBytes() {
-    return bytes;
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return mimeType;
-  }
-
-  @Override public long length() {
-    return bytes.length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(bytes);
-  }
-
-  @Override public InputStream in() throws IOException {
-    return new ByteArrayInputStream(bytes);
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    TypedByteArray that = (TypedByteArray) o;
-
-    if (!Arrays.equals(bytes, that.bytes)) return false;
-    if (!mimeType.equals(that.mimeType)) return false;
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = mimeType.hashCode();
-    result = 31 * result + Arrays.hashCode(bytes);
-    return result;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedFile.java b/retrofit/src/main/java/retrofit/mime/TypedFile.java
deleted file mode 100644
index 43fcd3a07..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedFile.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/**
- * File and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedFile implements TypedInput, TypedOutput {
-  private static final int BUFFER_SIZE = 4096;
-
-  private final String mimeType;
-  private final File file;
-
-  /**
-   * Constructs a new typed file.
-   *
-   * @throws NullPointerException if file or mimeType is null
-   */
-  public TypedFile(String mimeType, File file) {
-    if (mimeType == null) {
-      throw new NullPointerException("mimeType");
-    }
-    if (file == null) {
-      throw new NullPointerException("file");
-    }
-    this.mimeType = mimeType;
-    this.file = file;
-  }
-
-  /** Returns the file. */
-  public File file() {
-    return file;
-  }
-
-  @Override public String mimeType() {
-    return mimeType;
-  }
-
-  @Override public long length() {
-    return file.length();
-  }
-
-  @Override public String fileName() {
-    return file.getName();
-  }
-
-  @Override public InputStream in() throws IOException {
-    return new FileInputStream(file);
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    byte[] buffer = new byte[BUFFER_SIZE];
-    FileInputStream in = new FileInputStream(file);
-    try {
-      int read;
-      while ((read = in.read(buffer)) != -1) {
-        out.write(buffer, 0, read);
-      }
-    } finally {
-      in.close();
-    }
-  }
-
-  /**
-   * Atomically moves the contents of this file to a new location.
-   *
-   * @param destination file
-   * @throws java.io.IOException if the move fails
-   */
-  public void moveTo(TypedFile destination) throws IOException {
-    if (!mimeType().equals(destination.mimeType())) {
-      throw new IOException("Type mismatch.");
-    }
-    if (!file.renameTo(destination.file())) {
-      throw new IOException("Rename failed!");
-    }
-  }
-
-  @Override public String toString() {
-    return file.getAbsolutePath() + " (" + mimeType() + ")";
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o instanceof TypedFile) {
-      TypedFile rhs = (TypedFile) o;
-      return file.equals(rhs.file);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    return file.hashCode();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedInput.java b/retrofit/src/main/java/retrofit/mime/TypedInput.java
deleted file mode 100644
index f05afb84d..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedInput.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Binary data with an associated mime type.
- *
- * @author Jake Wharton (jw@squareup.com)
- */
-public interface TypedInput {
-
-  /** Returns the mime type. */
-  String mimeType();
-
-  /** Length in bytes. Returns {@code -1} if length is unknown. */
-  long length();
-
-  /**
-   * Read bytes as stream. Unless otherwise specified, this method may only be called once. It is
-   * the responsibility of the caller to close the stream.
-   */
-  InputStream in() throws IOException;
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedOutput.java b/retrofit/src/main/java/retrofit/mime/TypedOutput.java
deleted file mode 100644
index f15055f8f..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedOutput.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Binary data with an associated mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public interface TypedOutput {
-  /** Original filename.
-   *
-   * Used only for multipart requests, may be null. */
-  String fileName();
-
-  /** Returns the mime type. */
-  String mimeType();
-
-  /** Length in bytes or -1 if unknown. */
-  long length();
-
-  /** Writes these bytes to the given output stream. */
-  void writeTo(OutputStream out) throws IOException;
-}
diff --git a/retrofit/src/main/java/retrofit/package-info.java b/retrofit/src/main/java/retrofit/package-info.java
new file mode 100644
index 000000000..0c6596b3e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/package-info.java
@@ -0,0 +1,12 @@
+// Copyright 2014 Square, Inc.
+
+/**
+ * Retrofit turns your REST API into a Java interface.
+ * <pre>
+ * public interface GitHubService {
+ *   &#64;GET("/users/{user}/repos")
+ *   List&lt;Repo&gt; listRepos(@Path("user") String user);
+ * }
+ * </pre>
+ */
+package retrofit;
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
new file mode 100644
index 000000000..687e91b3c
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class CallTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface Service {
+    @GET("/") Call<String> getMethod();
+    @POST("/") Call<String> postMethod(@Body Object body);
+  }
+
+  @Test public void http200Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<String> response = example.getMethod().execute();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http200Async() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getMethod().enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void failure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    Response<String> response = example.getMethod().execute();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Async() throws InterruptedException, IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getMethod().enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void failure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void transportProblemSync() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    Call<String> call = example.getMethod();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void transportProblemAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getMethod().enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Throwable failure = failureRef.get();
+    assertThat(failure).isInstanceOf(IOException.class);
+  }
+
+  @Test public void conversionProblemOutgoingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter() {
+          @Override public RequestBody toBody(Object object, Type type) {
+            throw new UnsupportedOperationException("I am broken!");
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    Call<String> call = example.postMethod("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter() {
+          @Override public RequestBody toBody(Object object, Type type) {
+            throw new UnsupportedOperationException("I am broken!");
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postMethod("Hi").enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void conversionProblemIncomingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter() {
+          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+            throw new UnsupportedOperationException("I am broken!");
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.postMethod("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter() {
+          @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+            throw new UnsupportedOperationException("I am broken!");
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postMethod("Hi").enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void http204SkipsConverter() throws IOException {
+    Converter converter = spy(new StringConverter());
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(converter)
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+    Response<String> response = example.getMethod().execute();
+    assertThat(response.code()).isEqualTo(204);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void http205SkipsConverter() throws IOException {
+    Converter converter = spy(new StringConverter());
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(converter)
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+    Response<String> response = example.getMethod().execute();
+    assertThat(response.code()).isEqualTo(205);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(server.getUrl("/").toString())
+        .converter(new StringConverter())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+    Response<String> response = example.getMethod().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/CallbackRunnableTest.java b/retrofit/src/test/java/retrofit/CallbackRunnableTest.java
deleted file mode 100644
index 6d6617d22..000000000
--- a/retrofit/src/test/java/retrofit/CallbackRunnableTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.util.concurrent.Executor;
-import org.junit.Before;
-import org.junit.Test;
-import retrofit.Callback;
-import retrofit.CallbackRunnable;
-import retrofit.ResponseWrapper;
-import retrofit.RetrofitError;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class CallbackRunnableTest {
-  private Executor executor = spy(new SynchronousExecutor());
-  private CallbackRunnable<Object> callbackRunnable;
-  private Callback<Object> callback;
-
-  @Before public void setUp() {
-    callback = mock(Callback.class);
-    callbackRunnable = spy(new CallbackRunnable<Object>(callback, executor) {
-      @Override public ResponseWrapper obtainResponse() {
-        return null; // Must be mocked.
-      }
-    });
-  }
-
-  @Test public void responsePassedToSuccess() {
-    ResponseWrapper wrapper = new ResponseWrapper(null, new Object());
-    when(callbackRunnable.obtainResponse()).thenReturn(wrapper);
-
-    callbackRunnable.run();
-
-    verify(executor).execute(any(Runnable.class));
-    verify(callback).success(same(wrapper.responseBody), same(wrapper.response));
-  }
-
-  @Test public void errorPassedToFailure() {
-    RetrofitError exception = RetrofitError.unexpectedError("", null);
-    when(callbackRunnable.obtainResponse()).thenThrow(exception);
-
-    callbackRunnable.run();
-
-    verify(executor).execute(any(Runnable.class));
-    verify(callback).failure(same(exception));
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
new file mode 100644
index 000000000..f16032821
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.Executor;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class DefaultCallAdapterFactoryTest {
+  @SuppressWarnings("unchecked")
+  private final Callback<Object> callback = mock(Callback.class);
+  private final Executor callbackExecutor = spy(new Utils.SynchronousExecutor());
+  private final CallAdapter.Factory factory = new DefaultCallAdapterFactory(callbackExecutor);
+
+  @Test public void rawTypeThrows() {
+    try {
+      factory.get(Call.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+  }
+
+  @Test public void responseThrows() {
+    Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
+    try {
+      factory.get(returnType);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
+          + "Specify the response body type only (e.g., Call<TweetResponse>).");
+    }
+  }
+
+  @Test public void responseType() {
+    Type classType = new TypeToken<Call<String>>() {}.getType();
+    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType).responseType()) //
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+  }
+
+  @Test public void adaptedCallExecute() throws IOException {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter adapter = factory.get(returnType);
+    final Response<Object> response = Response.fromBody("Hi");
+    Call call = (Call) adapter.adapt(new EmptyCall() {
+      @Override public Response<Object> execute() throws IOException {
+        return response;
+      }
+    });
+    assertThat(call.execute()).isSameAs(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter adapter = factory.get(returnType);
+    final Response<Object> response = Response.fromBody("Hi");
+    Call call = (Call) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<Object> callback) {
+        callback.success(response);
+      }
+    });
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verify(callback).success(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter adapter = factory.get(returnType);
+    final Throwable throwable = new IOException();
+    Call call = (Call) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<Object> callback) {
+        callback.failure(throwable);
+      }
+    });
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(callbackExecutor);
+    verify(callback).failure(throwable);
+    verifyNoMoreInteractions(callback);
+  }
+
+  @Test public void adaptedCallCloneDeepCopy() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter adapter = factory.get(returnType);
+    Call delegate = mock(Call.class);
+    Call call = (Call) adapter.adapt(delegate);
+    Call cloned = call.clone();
+    assertThat(cloned).isNotSameAs(call);
+    verify(delegate).clone();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  @Test public void adaptedCallCancel() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter adapter = factory.get(returnType);
+    Call delegate = mock(Call.class);
+    Call call = (Call) adapter.adapt(delegate);
+    call.cancel();
+    verify(delegate).cancel();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  static class EmptyCall implements Call<Object> {
+    @Override public void enqueue(Callback<Object> callback) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Response<Object> execute() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public void cancel() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Call<Object> clone() {
+      throw new UnsupportedOperationException();
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/EndpointsTest.java b/retrofit/src/test/java/retrofit/EndpointsTest.java
new file mode 100644
index 000000000..190b8b1fc
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/EndpointsTest.java
@@ -0,0 +1,24 @@
+// Copyright 2014 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class EndpointsTest {
+  @Test public void endpoint() {
+    Endpoint endpoint = Endpoint.createFixed("http://example.com");
+    assertThat(endpoint.url()).isEqualTo(HttpUrl.parse("http://example.com"));
+  }
+
+  @Test public void invalidEndpointEagerlyThrows() {
+    try {
+      Endpoint.createFixed("ftp://foo");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Invalid URL: ftp://foo");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
deleted file mode 100644
index 981b3b05b..000000000
--- a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
+++ /dev/null
@@ -1,74 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.io.IOException;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.http.GET;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-
-public class ErrorHandlerTest {
-
-  interface ExampleClient {
-    @GET("/")
-    Response throwsCustomException() throws TestException;
-  }
-
-  static class TestException extends Exception {
-  }
-
-  /* An HTTP client which always returns a 400 response */
-  static class MockInvalidResponseClient implements Client {
-    @Override public Response execute(Request request) throws IOException {
-      return new Response(400, "invalid request", Collections.<Header>emptyList(), null);
-    }
-  }
-
-  ExampleClient client;
-  ErrorHandler errorHandler;
-
-  @Before public void setup() {
-    errorHandler = mock(ErrorHandler.class);
-
-    client = new RestAdapter.Builder() //
-        .setServer("http://example.com")
-        .setClient(new MockInvalidResponseClient())
-        .setErrorHandler(errorHandler)
-        .setExecutors(new Utils.SynchronousExecutor(), new Utils.SynchronousExecutor())
-        .build()
-        .create(ExampleClient.class);
-  }
-
-  @Test public void customizedExceptionUsed() throws Throwable {
-    TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    try {
-      client.throwsCustomException();
-      fail();
-    } catch (TestException e) {
-      assertThat(e).isSameAs(exception);
-    }
-  }
-
-  @Test public void returningNullThrowsException() throws Exception {
-    doReturn(null).when(errorHandler).handleError(any(RetrofitError.class));
-
-    try {
-      client.throwsCustomException();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Error handler returned null for wrapped exception.");
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/MethodInfoTest.java b/retrofit/src/test/java/retrofit/MethodInfoTest.java
new file mode 100644
index 000000000..4eabe60a6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/MethodInfoTest.java
@@ -0,0 +1,89 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+@SuppressWarnings("unused") // Lots of unused parameters for example code.
+public final class MethodInfoTest {
+  private static CallAdapter.Factory FACTORY =
+      new DefaultCallAdapterFactory(Executors.newSingleThreadExecutor());
+  private static Converter CONVERTER = new StringConverter();
+
+  @Test public void pathParameterParsing() throws Exception {
+    expectParams("/");
+    expectParams("/foo");
+    expectParams("/foo/bar");
+    expectParams("/foo/bar/{}");
+    expectParams("/foo/bar/{taco}", "taco");
+    expectParams("/foo/bar/{t}", "t");
+    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+    expectParams("/foo/bar/{}/{taco}", "taco");
+    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("/foo/bar/{taco-shell}", "taco-shell");
+    expectParams("/foo/bar/{taco_shell}", "taco_shell");
+    expectParams("/foo/bar/{sha256}", "sha256");
+    expectParams("/foo/bar/{TACO}", "TACO");
+    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+  }
+
+  private static void expectParams(String path, String... expected) {
+    Set<String> calculated = MethodInfo.parsePathParameters(path);
+    assertThat(calculated).hasSize(expected.length);
+    if (expected.length > 0) {
+      assertThat(calculated).containsExactly(expected);
+    }
+  }
+
+  static class Dummy {
+  }
+
+  @Test public void concreteBodyType() {
+    class Example {
+      @POST("/foo") Call<Object> a(@Body Dummy body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    assertThat(methodInfo.requestType).isEqualTo(Dummy.class);
+  }
+
+  @Test public void genericBodyType() {
+    class Example {
+      @POST("/foo") Call<Object> a(@Body List<Dummy> body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    Type expected = new TypeToken<List<Dummy>>() {}.getType();
+    assertThat(methodInfo.requestType).isEqualTo(expected);
+  }
+
+  @Test public void wildcardBodyType() {
+    class Example {
+      @POST("/foo") Call<Object> a(@Body List<? super String> body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method, FACTORY, CONVERTER);
+    Type expected = new TypeToken<List<? super String>>() {}.getType();
+    assertThat(methodInfo.requestType).isEqualTo(expected);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 877661e56..340276a96 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -1,750 +1,1431 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.google.gson.Gson;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
-import java.util.ArrayList;
+import java.math.BigInteger;
 import java.util.Arrays;
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okio.Buffer;
+import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
-import retrofit.mime.MimeHelper;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
-import static retrofit.RestMethodInfo.ParamUsage;
-import static retrofit.RestMethodInfo.ParamUsage.BODY;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_PATH;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.FIELD;
-import static retrofit.RestMethodInfo.ParamUsage.HEADER;
-import static retrofit.RestMethodInfo.ParamUsage.PART;
-import static retrofit.RestMethodInfo.ParamUsage.PATH;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.RequestType;
-
-public class RequestBuilderTest {
-  @Test public void normalGet() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addEncodedPathParam("ping", "po%20ng") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithInterceptorPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addInterceptorPathParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addPathParam("ping", "pong") //
-        .addInterceptorPathParam("kit", "kat")
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addInterceptorQueryParam("butter", "finger") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .addInterceptorQueryParam("butter", "finger")
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithInterceptorPathParamAndInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addInterceptorPathParam("ping", "pong") //
-        .addInterceptorQueryParam("butter", "finger") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParamAndInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addPathParam("ping", "pong") //
-        .addInterceptorPathParam("kit", "kat")
-        .addInterceptorQueryParam("butter", "finger")
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void pathParamRequired() throws Exception {
-    try {
-      new Helper() //
-          .setMethod("GET") //
-          .setUrl("http://example.com") //
-          .setPath("/foo/bar/{ping}/") //
-          .addPathParam("ping", null) //
-          .build();
-      fail("Null path parameters not allowed.");
+import retrofit.http.Body;
+import retrofit.http.DELETE;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.FormUrlEncoded;
+import retrofit.http.GET;
+import retrofit.http.HEAD;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+import retrofit.http.Headers;
+import retrofit.http.Multipart;
+import retrofit.http.PATCH;
+import retrofit.http.POST;
+import retrofit.http.PUT;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderTest {
+  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+
+  @Test public void customMethodNoBody() {
+    class Example {
+      @HTTP(method = "CUSTOM1", path = "/foo")
+      Call<Object> method() {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("CUSTOM1");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.body()).isNull();
+  }
+
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodWithBody() {
+    class Example {
+      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("CUSTOM2");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
+    class Example {
+      @Multipart //
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+    }
+  }
+
+  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+    class Example {
+      @FormUrlEncoded //
+      @Multipart //
+      @POST("/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+    }
+  }
+
+  @Test public void invalidPathParam() throws Exception {
+    class Example {
+      @GET("/") //
+      Call<Object> method(@Path("hey!") String thing) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+              + " Found: hey! (parameter #1)");
+    }
+  }
+
+  @Test public void pathParamNotAllowedInQuery() throws Exception {
+    class Example {
+      @GET("/foo?bar={bar}") //
+      Call<Object> method(@Path("bar") String thing) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: URL query string \"bar={bar}\" must not have replace block."
+              + " For dynamic query parameters use @Query.");
+    }
+  }
+
+  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
+    class Example {
+      @GET("/") //
+      Call<Object> method(@Body @Query("nope") Object o) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Multiple Retrofit annotations found, only one allowed:"
+              + " @Body, @Query. (parameter #1)");
+    }
+  }
+
+  @Test public void twoMethodsFail() {
+    class Example {
+      @PATCH("/foo") //
+      @POST("/foo") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Only one HTTP method is allowed. Found: PATCH and POST.");
+    }
+  }
+
+  @Test public void pathMustBePrefixedWithSlash() {
+    class Example {
+      @GET("foo/bar") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: URL path \"foo/bar\" must start with '/'.");
+    }
+  }
+
+  @Test public void lackingMethod() {
+    class Example {
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+    }
+  }
+
+  @Test public void implicitMultipartForbidden() {
+    class Example {
+      @POST("/") //
+      Call<Object> method(@Part("a") int a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Part parameters can only be used with multipart encoding. (parameter #1)");
+    }
+  }
+
+  @Test public void implicitMultipartWithPartMapForbidden() {
+    class Example {
+      @POST("/") //
+      Call<Object> method(@PartMap Map<String, String> params) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
+    }
+  }
+
+  @Test public void multipartFailsOnNonBodyMethod() {
+    class Example {
+      @Multipart //
+      @GET("/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+    }
+  }
+
+  @Test public void multipartFailsWithNoParts() {
+    class Example {
+      @Multipart //
+      @POST("/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
+    }
+  }
+
+  @Test public void implicitFormEncodingByFieldForbidden() {
+    class Example {
+      @POST("/") //
+      Call<Object> method(@Field("a") int a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Field parameters can only be used with form encoding. (parameter #1)");
+    }
+  }
+
+  @Test public void implicitFormEncodingByFieldMapForbidden() {
+    class Example {
+      @POST("/") //
+      Call<Object> method(@FieldMap Map<String, String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @FieldMap parameters can only be used with form encoding. (parameter #1)");
+    }
+  }
+
+  @Test public void formEncodingFailsOnNonBodyMethod() {
+    class Example {
+      @FormUrlEncoded //
+      @GET("/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
+    }
+  }
+
+  @Test public void formEncodingFailsWithNoParts() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
+    }
+  }
+
+  @Test public void headersFailWhenEmptyOnMethod() {
+    class Example {
+      @GET("/") //
+      @Headers({}) //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: @Headers annotation is empty.");
+    }
+  }
+
+  @Test public void headersFailWhenMalformed() {
+    class Example {
+      @GET("/") //
+      @Headers("Malformed") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Headers value must be in the form \"Name: Value\". Found: \"Malformed\"");
+    }
+  }
+
+  @Test public void pathParamNonPathParamAndTypedBytes() {
+    class Example {
+      @PUT("/{a}") //
+      Call<Object> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: URL \"/{a}\" does not contain \"{b}\". (parameter #2)");
+    }
+  }
+
+  @Test public void parameterWithoutAnnotation() {
+    class Example {
+      @GET("/") //
+      Call<Object> method(String a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: No Retrofit annotation found. (parameter #1)");
+    }
+  }
+
+  @Test public void nonBodyHttpMethodWithSingleEntity() {
+    class Example {
+      @GET("/") //
+      Call<Object> method(@Body Object o) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Non-body HTTP method cannot contain @Body or @TypedOutput.");
+    }
+  }
+
+  @Test public void queryMapMustBeAMap() {
+    class Example {
+      @GET("/") //
+      Call<Object> method(@QueryMap List<String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: @QueryMap parameter type must be Map. (parameter #1)");
+    }
+  }
+
+  @Test public void queryMapRejectsNullKeys() {
+    class Example {
+      @GET("/") //
+      Call<Object> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<>();
+    queryParams.put("ping", "pong");
+    queryParams.put(null, "kat");
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter #1 query map contained null key.");
+    }
+  }
+
+  @Test public void twoBodies() {
+    class Example {
+      @PUT("/") //
+      Call<Object> method(@Body int o1, @Body int o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: Multiple @Body method annotations found.");
+    }
+  }
+
+  @Test public void bodyInNonBodyRequest() {
+    class Example {
+      @Multipart //
+      @PUT("/") //
+      Call<Object> method(@Part("one") int o1, @Body int o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
+    }
+  }
+
+  @Test public void get() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void delete() {
+    class Example {
+      @DELETE("/foo/bar/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("DELETE");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertNull(request.body());
+  }
+
+  @Test public void head() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("HEAD");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void post() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void put() {
+    class Example {
+      @PUT("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void patch() {
+    class Example {
+      @PATCH("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PATCH");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void getWithPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "po ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUnusedAndInvalidNamedPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/{kit,kat}/") //
+      Call<Object> method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "po%20ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void pathParamRequired() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
     }
   }
 
-  @Test public void getWithQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addEncodedQueryParam("ping", "p+o+n+g") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void queryParamOptional() throws Exception {
-    Request request1 = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("ping", null) //
-        .build();
-    assertThat(request1.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    Request request2 = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("foo", "bar") //
-        .addQueryParam("ping", null) //
-        .addQueryParam("kit", "kat") //
-        .build();
-    assertThat(request2.getUrl()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setQuery("hi=mom") //
-        .addQueryParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithQuery() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setQuery("hi=mom") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .addQueryParam("kit", "kat") //
-        .addQueryParam("riff", "raff") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong?") //
-        .addQueryParam("kit", "kat?") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong&") //
-        .addQueryParam("kit", "kat&") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong#") //
-        .addQueryParam("kit", "kat#") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void normalPost() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void normalPostWithPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void body() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setBody(Arrays.asList("quick", "brown", "fox")) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-
-  @Test public void bodyRequired() throws Exception {
-    try {
-      new Helper() //
-          .setMethod("POST") //
-          .setHasBody() //
-          .setUrl("http://example.com") //
-          .setPath("/foo/bar/") //
-          .setBody(null) //
-          .build();
-      fail("Null body not allowed.");
+  @Test public void getWithQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void queryParamOptionalOmitsQuery() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new Object[] { null });
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  }
+
+  @Test public void queryParamOptional() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query("foo") String foo, @Query("ping") String ping,
+          @Query("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+  }
+
+  @Test public void getWithQueryUrlAndParam() {
+    class Example {
+      @GET("/foo/bar/?hi=mom") //
+      Call<Object> method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQuery() {
+    class Example {
+      @GET("/foo/bar/?hi=mom") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit,
+          @Query("riff") String riff) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", "kat", "raff");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryQuestionMarkParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong?", "kat?");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryAmpersandParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong&", "kat&");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryHashParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong#", "kat#");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query("key") List<Object> keys) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+    Request request = buildRequest(Example.class, values);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query("key") Object[] keys) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three" };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamPrimitiveArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Query("key") int[] keys) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3 };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@QueryMap Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("kit", "kat");
+    params.put("foo", null);
+    params.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@QueryMap(encoded = true) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("kit", "k%20t");
+    params.put("foo", null);
+    params.put("pi%20ng", "p%20g");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void normalPostWithPathParam() {
+    class Example {
+      @POST("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Body Object body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void emptyBody() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "");
+  }
+
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodEmptyBody() {
+    class Example {
+      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("CUSTOM");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "");
+  }
+
+  @Test public void bodyResponseBody() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void bodyRequired() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
     }
   }
 
-  @Test public void bodyWithPathParams() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addPathParam("ping", "pong") //
-        .setBody(Arrays.asList("quick", "brown", "fox")) //
-        .addPathParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-
-  @Test public void simpleMultipart() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setMultipart() //
-        .addPart("ping", "pong") //
-        .addPart("kit", new TypedString("kat")) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), "UTF-8");
-    assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-
-    String two = new String(iterator.next(), "UTF-8");
-    assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  }
-
-  @Test public void multipartNullRemovesPart() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setMultipart() //
-        .addPart("ping", "pong") //
-        .addPart("fizz", null) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(1);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), "UTF-8");
-    assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
-  }
-
-  @Test public void multipartPartOptional() throws Exception {
-    try {
-      new Helper() //
-          .setMethod("POST") //
-          .setHasBody() //
-          .setUrl("http://example.com") //
-          .setPath("/foo/bar/") //
-          .setMultipart() //
-          .addPart("ping", null) //
-          .build();
-      fail("Empty multipart request is not allowed.");
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", "bar") //
-        .addField("ping", "pong") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedFieldOptional() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", "bar") //
-        .addField("ping", null) //
-        .addField("kit", "kat") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=bar&kit=kat");
-  }
-
-  @Test public void simpleHeaders() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeader("ping", "pong") //
-        .addHeader("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void simpleInterceptorHeaders() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addInterceptorHeader("ping", "pong") //
-        .addInterceptorHeader("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void headersAndInterceptorHeaders() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeader("ping", "pong") //
-        .addInterceptorHeader("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void allThreeHeaderTypes() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeader("ping", "pong") //
-        .addInterceptorHeader("kit", "kat") //
-        .addHeaderParam("fizz", "buzz") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).containsExactly(new Header("ping", "pong"),
-        new Header("kit", "kat"), new Header("fizz", "buzz"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void methodHeader() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeader("ping", "pong") //
-        .addHeaderParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void headerParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeader("ping", "pong") //
-        .addHeaderParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void noDuplicateSlashes() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com/") //
-        .setPath("/foo/bar/") //
-        .build();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  private static void assertTypedBytes(TypedOutput bytes, String expected) throws IOException {
-    assertThat(bytes).isNotNull();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    bytes.writeTo(baos);
-    assertThat(new String(baos.toByteArray(), "UTF-8")).isEqualTo(expected);
-  }
-
-  private static class Helper {
-    private static final Converter GSON = new GsonConverter(new Gson());
-
-    private RequestType requestType = RequestType.SIMPLE;
-    private String method;
-    private boolean hasBody = false;
-    private String path;
-    private String query;
-    private final List<String> paramNames = new ArrayList<String>();
-    private final List<ParamUsage> paramUsages = new ArrayList<ParamUsage>();
-    private final List<Object> args = new ArrayList<Object>();
-    private final List<Header> headers = new ArrayList<Header>();
-    private final List<Header> interceptorHeaders = new ArrayList<Header>();
-    private final Map<String, String> interceptorPathParams = new LinkedHashMap<String, String>();
-    private final Map<String, String> interceptorQueryParams = new LinkedHashMap<String, String>();
-    private String url;
-
-    Helper setMethod(String method) {
-      this.method = method;
-      return this;
+  @Test public void bodyWithPathParams() {
+    class Example {
+      @POST("/foo/bar/{ping}/{kit}/") //
+      Call<Object> method(@Path("ping") String ping, @Body Object body, @Path("kit") String kit) {
+        return null;
+      }
     }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body, "kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertBody(request.body(), "Hi!");
+  }
 
-    Helper setHasBody() {
-      hasBody = true;
-      return this;
+  @Test public void simpleMultipart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") String ping, @Part("kit") ResponseBody kit) {
+        return null;
+      }
     }
 
-    Helper setUrl(String url) {
-      this.url = url;
-      return this;
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
+          @Part(value = "kit", encoding = "7-bit") ResponseBody kit) {
+        return null;
+      }
     }
 
-    Helper setPath(String path) {
-      this.path = path;
-      return this;
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString).contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString).contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 7-bit")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMap() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
     }
 
-    Helper setQuery(String query) {
-      this.query = query;
-      return this;
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put("kit", RequestBody.create(MediaType.parse("text/plain"), "kat"));
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMapWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+        return null;
+      }
     }
 
-    Helper addPathParam(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(PATH);
-      args.add(value);
-      return this;
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put("kit", RequestBody.create(MediaType.parse("text/plain"), "kat"));
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString).contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString).contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMapRejectsNullKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
     }
 
-    Helper addEncodedPathParam(String name, String value) {
-      paramNames.add(name);
-      paramUsages.add(ENCODED_PATH);
-      args.add(value);
-      return this;
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put(null, "kat");
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter #1 part map contained null key.");
     }
+  }
 
-    Helper addQueryParam(String name, String value) {
-      paramNames.add(name);
-      paramUsages.add(QUERY);
-      args.add(value);
-      return this;
+  @Test public void multipartNullRemovesPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class, "pong", null);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"")
+        .contains("\r\npong\r\n--");
+  }
 
-    Helper addEncodedQueryParam(String name, String value) {
-      paramNames.add(name);
-      paramUsages.add(ENCODED_QUERY);
-      args.add(value);
-      return this;
+  @Test public void multipartPartOptional() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") RequestBody ping) {
+        return null;
+      }
     }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+    }
+  }
 
-    Helper addField(String name, String value) {
-      paramNames.add(name);
-      paramUsages.add(FIELD);
-      args.add(value);
-      return this;
+  @Test public void simpleFormEncoded() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping) {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class, "bar", "pong");
+    assertBody(request.body(), "foo=bar&ping=pong");
+  }
 
-    Helper addPart(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(PART);
-      args.add(value);
-      return this;
+  @Test public void formEncodedWithEncodedNameFieldParam() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field(value = "na%20me", encoded = true) String foo) {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class, "ba%20r");
+    assertBody(request.body(), "na%20me=ba%20r");
+  }
 
-    Helper setBody(Object value) {
-      paramNames.add(null);
-      paramUsages.add(BODY);
-      args.add(value);
-      return this;
+  @Test public void formEncodedFieldOptional() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping,
+          @Field("kit") String kit) {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertBody(request.body(), "foo=bar&kit=kat");
+  }
 
-    Helper addHeaderParam(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(HEADER);
-      args.add(value);
-      return this;
+  @Test public void formEncodedFieldList() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+        return null;
+      }
     }
 
-    Helper addHeader(String name, String value) {
-      headers.add(new Header(name, value));
-      return this;
+    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedFieldArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+        return null;
+      }
     }
 
-    Helper addInterceptorHeader(String name, String value) {
-      interceptorHeaders.add(new Header(name, value));
-      return this;
+    Object[] values = { 1, 2, null, "three" };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  }
+
+  @Test public void formEncodedFieldPrimitiveArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+        return null;
+      }
     }
 
-    Helper addInterceptorPathParam(String name, String value) {
-      interceptorPathParams.put(name, value);
-      return this;
+    int[] values = { 1, 2, 3 };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParamMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+        return null;
+      }
     }
 
-    Helper addInterceptorQueryParam(String name, String value) {
-      interceptorQueryParams.put(name, value);
-      return this;
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("k%20it", "k%20at");
+    fieldMap.put("pin%20g", "po%20ng");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+  }
+
+  @Test public void formEncodedFieldMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@FieldMap Map<String, Object> fieldMap) {
+        return null;
+      }
     }
 
-    Helper setMultipart() {
-      requestType = RequestType.MULTIPART;
-      return this;
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+    fieldMap.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "kit=kat&ping=pong");
+  }
+
+  @Test public void fieldMapRejectsNullKeys() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
     }
 
-    Helper setFormEncoded() {
-      requestType = RequestType.FORM_URL_ENCODED;
-      return this;
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+    fieldMap.put(null, "pong");
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter #1 field map contained null key.");
     }
+  }
 
-    Request build() throws Exception {
-      if (method == null) {
-        throw new IllegalStateException("Method must be set.");
-      }
-      if (path == null) {
-        throw new IllegalStateException("Path must be set.");
+  @Test public void fieldMapMustBeAMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method(@FieldMap List<String> a) {
+        return null;
       }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
+    }
+  }
 
-      Method method = getClass().getDeclaredMethod("dummySync");
+  @Test public void simpleHeaders() {
+    class Example {
+      @GET("/foo/bar/")
+      @Headers({
+          "ping: pong",
+          "kit: kat"
+      })
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
 
-      RestMethodInfo methodInfo = new RestMethodInfo(method);
-      methodInfo.requestMethod = this.method;
-      methodInfo.requestHasBody = hasBody;
-      methodInfo.requestType = requestType;
-      methodInfo.requestUrl = path;
-      methodInfo.requestUrlParamNames = RestMethodInfo.parsePathParameters(path);
-      methodInfo.requestQuery = query;
-      methodInfo.requestParamNames = paramNames.toArray(new String[paramNames.size()]);
-      methodInfo.requestParamUsage = paramUsages.toArray(new ParamUsage[paramUsages.size()]);
-      methodInfo.headers = headers;
-      methodInfo.loaded = true;
+  @Test public void headerParamToString() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Header("kit") BigInteger kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new BigInteger("1234"));
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(1);
+    assertThat(headers.get("kit")).isEqualTo("1234");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
 
-      RequestBuilder requestBuilder = new RequestBuilder(GSON, methodInfo);
+  @Test public void headerParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      @Headers("ping: pong") //
+      Call<Object> method(@Header("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "kat");
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
 
-      // Simulate request interceptor invocation.
-      for (Header header : interceptorHeaders) {
-        requestBuilder.addHeader(header.getName(), header.getValue());
+  @Test public void headerParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Header("foo") List<String> kit) {
+        return null;
       }
-      for (Map.Entry<String, String> entry : interceptorPathParams.entrySet()) {
-        requestBuilder.addPathParam(entry.getKey(), entry.getValue());
+    }
+    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.values("foo")).containsExactly("bar", "baz");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<Object> method(@Header("foo") String[] kit) {
+        return null;
       }
-      for (Map.Entry<String, String> entry : interceptorQueryParams.entrySet()) {
-        requestBuilder.addQueryParam(entry.getKey(), entry.getValue());
+    }
+    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.values("foo")).containsExactly("bar", "baz");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void contentTypeAnnotationHeaderOverrides() {
+    class Example {
+      @POST("/") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
       }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
 
-      requestBuilder.setApiUrl(url);
-      requestBuilder.setArguments(args.toArray(new Object[args.size()]));
+  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
+    class Example {
+      @DELETE("/") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+  }
 
-      return requestBuilder.build();
+  @Test public void contentTypeParameterHeaderOverrides() {
+    class Example {
+      @POST("/") //
+      Call<Object> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+        return null;
+      }
     }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    Request request = buildRequest(Example.class, "text/not-plain", body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
 
-    @SuppressWarnings("UnusedDeclaration") // Accessed via reflection.
-    private Object dummySync() {
-      return null;
+  private static void assertBody(RequestBody body, String expected) {
+    assertThat(body).isNotNull();
+    Buffer buffer = new Buffer();
+    try {
+      body.writeTo(buffer);
+      assertThat(buffer.readUtf8()).isEqualTo(expected);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
     }
   }
+
+  private Request buildRequest(Class<?> cls, Object... args) {
+    HttpUrl url = HttpUrl.parse("http://example.com/");
+    Converter converter = new StringConverter();
+    CallAdapter.Factory factory = new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
+
+    Method method = TestingUtils.onlyMethod(cls);
+    MethodInfo methodInfo = new MethodInfo(method, factory, converter);
+
+    RequestBuilder builder = new RequestBuilder(url, methodInfo, converter);
+    builder.setArguments(args);
+    return builder.build();
+  }
 }
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
deleted file mode 100644
index 95cd03877..000000000
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ /dev/null
@@ -1,636 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.Executor;
-
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.converter.ConversionException;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.Headers;
-import retrofit.http.POST;
-import retrofit.http.Path;
-import retrofit.http.Url;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-import rx.Observable;
-import rx.util.functions.Action1;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-import static retrofit.Profiler.RequestInformation;
-import static retrofit.RestAdapter.LogLevel.BASIC;
-import static retrofit.RestAdapter.LogLevel.FULL;
-import static retrofit.RestAdapter.LogLevel.HEADERS;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class RestAdapterTest {
-    private static final List<Header> NO_HEADERS = Collections.emptyList();
-    private static final List<Header> TWO_HEADERS =
-            Arrays.asList(new Header("Content-Type", "application/json"),
-                    new Header("Content-Length", "42"));
-
-    /**
-     * Not all servers play nice and add content-type headers to responses.
-     */
-    private static final TypedInput NO_MIME_BODY = new TypedInput() {
-        @Override
-        public String mimeType() {
-            return null;
-        }
-
-        @Override
-        public long length() {
-            return 2;
-        }
-
-        @Override
-        public InputStream in() throws IOException {
-            return new ByteArrayInputStream("{}".getBytes("UTF-8"));
-        }
-    };
-
-    private interface Example {
-        @Headers("Foo: Bar")
-        @GET("/")
-        Object something();
-
-        @Headers("Foo: Bar")
-        @POST("/")
-        Object something(@Body TypedOutput body);
-
-        @GET("/")
-        void something(Callback<Object> callback);
-
-        @GET("/")
-        Response direct();
-
-        @GET("/")
-        void direct(Callback<Response> callback);
-
-        @POST("/")
-        Observable<String> observable(@Body String body);
-
-        @POST("/{x}/{y}")
-        Observable<Response> observable(@Path("x") String x, @Path("y") String y);
-
-        @GET("/")
-        Observable<Response> observableAbsolute(@Url String absoluteUrl);
-    }
-
-    private interface InvalidExample extends Example {
-    }
-
-    private Client mockClient;
-    private Executor mockRequestExecutor;
-    private Executor mockCallbackExecutor;
-    private Profiler<Object> mockProfiler;
-    private Example example;
-
-    @SuppressWarnings("unchecked") // Mock profiler type erasure.
-    @Before
-    public void setUp() throws Exception {
-        mockClient = mock(Client.class);
-        mockRequestExecutor = spy(new SynchronousExecutor());
-        mockCallbackExecutor = spy(new SynchronousExecutor());
-        mockProfiler = mock(Profiler.class);
-
-        example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .build()
-                .create(Example.class);
-    }
-
-    @Test
-    public void objectMethodsStillWork() {
-        assertThat(example.hashCode()).isNotZero();
-        assertThat(example.equals(this)).isFalse();
-        assertThat(example.toString()).isNotEmpty();
-    }
-
-    @Test
-    public void interfaceWithExtendIsNotSupported() {
-        try {
-            new RestAdapter.Builder().setServer("http://foo/").build().create(InvalidExample.class);
-            fail("Interface inheritance should not be supported.");
-        } catch (IllegalArgumentException e) {
-            assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
-        }
-    }
-
-    @Test
-    public void profilerObjectPassThrough() throws Exception {
-        Object data = new Object();
-        when(mockProfiler.beforeCall()).thenReturn(data);
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, null));
-
-        example.something();
-
-        verify(mockProfiler).beforeCall();
-        verify(mockClient).execute(any(Request.class));
-        verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
-    }
-
-    @Test
-    public void logRequestResponseBasic() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(BASIC)
-                .build()
-                .create(Example.class);
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-        example.something();
-        assertThat(logMessages).hasSize(2);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-        assertThat(logMessages.get(1)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    }
-
-    @Test
-    public void logRequestResponseHeaders() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(HEADERS)
-                .build()
-                .create(Example.class);
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-        example.something();
-        assertThat(logMessages).hasSize(7);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (2-byte body)");
-    }
-
-    @Test
-    public void logSuccessfulRequestResponseFullWhenResponseBodyPresent() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(FULL)
-                .build()
-                .create(Example.class);
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-        example.something(new TypedString("Hi"));
-        assertThat(logMessages).hasSize(13);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP POST http://example.com/");
-        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-        assertThat(logMessages.get(2)).isEqualTo("Content-Type: text/plain; charset=UTF-8");
-        assertThat(logMessages.get(3)).isEqualTo("Content-Length: 2");
-        assertThat(logMessages.get(4)).isEqualTo("");
-        assertThat(logMessages.get(5)).isEqualTo("Hi");
-        assertThat(logMessages.get(6)).isEqualTo("---> END HTTP (2-byte body)");
-        assertThat(logMessages.get(7)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-        assertThat(logMessages.get(8)).isEqualTo("Content-Type: application/json");
-        assertThat(logMessages.get(9)).isEqualTo("Content-Length: 42");
-        assertThat(logMessages.get(10)).isEqualTo("");
-        assertThat(logMessages.get(11)).isEqualTo("{}");
-        assertThat(logMessages.get(12)).isEqualTo("<--- END HTTP (2-byte body)");
-    }
-
-    @Test
-    public void logSuccessfulRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(FULL)
-                .build()
-                .create(Example.class);
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", TWO_HEADERS, null));
-
-        example.something();
-        assertThat(logMessages).hasSize(7);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-    }
-
-    @Test
-    public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, NO_MIME_BODY));
-
-        example.something();
-    }
-
-    @Test
-    public void logSuccessfulRequestResponseFullWhenMimeTypeMissing() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(FULL)
-                .build()
-                .create(Example.class);
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", TWO_HEADERS, NO_MIME_BODY));
-
-        example.something();
-        assertThat(logMessages).hasSize(9);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-        assertThat(logMessages.get(6)).isEqualTo("");
-        assertThat(logMessages.get(7)).isEqualTo("{}");
-        assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-    }
-
-    @Test
-    public void synchronousDoesNotUseExecutors() throws Exception {
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, null));
-
-        example.something();
-
-        verifyZeroInteractions(mockRequestExecutor);
-        verifyZeroInteractions(mockCallbackExecutor);
-    }
-
-    @Test
-    public void asynchronousUsesExecutors() throws Exception {
-        Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
-        when(mockClient.execute(any(Request.class))).thenReturn(response);
-        Callback<Object> callback = mock(Callback.class);
-
-        example.something(callback);
-
-        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-        verify(mockCallbackExecutor).execute(any(Runnable.class));
-        verify(callback).success(anyString(), same(response));
-    }
-
-    @Test
-    public void malformedResponseThrowsConversionException() throws Exception {
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("{")));
-
-        try {
-            example.something();
-            fail("RetrofitError expected on malformed response body.");
-        } catch (RetrofitError e) {
-            assertThat(e.getResponse().getStatus()).isEqualTo(200);
-            assertThat(e.getCause()).isInstanceOf(ConversionException.class);
-            assertThat(e.getResponse().getBody()).isNull();
-        }
-    }
-
-    @Test
-    public void errorResponseThrowsHttpError() throws Exception {
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(500, "Internal Server Error", NO_HEADERS, null));
-
-        try {
-            example.something();
-            fail("RetrofitError expected on non-2XX response code.");
-        } catch (RetrofitError e) {
-            assertThat(e.getResponse().getStatus()).isEqualTo(500);
-        }
-    }
-
-    @Test
-    public void logErrorRequestResponseFullWhenMimeTypeMissing() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(FULL)
-                .build()
-                .create(Example.class);
-
-        Response responseMissingMimeType = //
-                new Response(403, "Forbidden", TWO_HEADERS, NO_MIME_BODY);
-
-        when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
-
-        try {
-            example.something();
-            fail("RetrofitError expected on non-2XX response code.");
-        } catch (RetrofitError e) {
-            assertThat(e.getResponse().getStatus()).isEqualTo(403);
-        }
-
-        assertThat(logMessages).hasSize(9);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-        assertThat(logMessages.get(3)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
-        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-        assertThat(logMessages.get(6)).isEqualTo("");
-        assertThat(logMessages.get(7)).isEqualTo("{}");
-        assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-    }
-
-    @Test
-    public void logErrorRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-        final List<String> logMessages = new ArrayList<String>();
-        RestAdapter.Log log = new RestAdapter.Log() {
-            public void log(String message) {
-                logMessages.add(message);
-            }
-        };
-
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(log)
-                .setLogLevel(FULL)
-                .build()
-                .create(Example.class);
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(500, "Internal Server Error", TWO_HEADERS, null));
-
-        try {
-            example.something();
-            fail("RetrofitError expected on non-2XX response code.");
-        } catch (RetrofitError e) {
-            assertThat(e.getResponse().getStatus()).isEqualTo(500);
-        }
-
-        assertThat(logMessages).hasSize(7);
-        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (0-byte body)");
-        assertThat(logMessages.get(3)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
-        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-    }
-
-    @Test
-    public void clientExceptionThrowsNetworkError() throws Exception {
-        IOException exception = new IOException("I'm broken!");
-        when(mockClient.execute(any(Request.class))).thenThrow(exception);
-
-        try {
-            example.something();
-            fail("RetrofitError expected when client throws exception.");
-        } catch (RetrofitError e) {
-            assertThat(e.getCause()).isSameAs(exception);
-        }
-    }
-
-    @Test
-    public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
-        TypedInput body = spy(new TypedString("{}"));
-        InputStream bodyStream = mock(InputStream.class, new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                throw new IOException("I'm broken!");
-            }
-        });
-        doReturn(bodyStream).when(body).in();
-
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, body));
-
-        try {
-            example.something();
-            fail("RetrofitError expected on malformed response body.");
-        } catch (RetrofitError e) {
-            assertThat(e.isNetworkError());
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-            assertThat(e.getCause()).hasMessage("I'm broken!");
-        }
-    }
-
-    @Test
-    public void unexpectedExceptionThrows() {
-        RuntimeException exception = new RuntimeException("More breakage.");
-        when(mockProfiler.beforeCall()).thenThrow(exception);
-
-        try {
-            example.something();
-            fail("RetrofitError expected when unexpected exception thrown.");
-        } catch (RetrofitError e) {
-            assertThat(e.getCause()).isSameAs(exception);
-        }
-    }
-
-    @Test
-    public void getResponseDirectly() throws Exception {
-        Response response = new Response(200, "OK", NO_HEADERS, null);
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(response);
-        assertThat(example.direct()).isSameAs(response);
-    }
-
-    @Test
-    public void closeInputStream() throws IOException {
-        // Set logger and profiler on example to make sure we exercise all the code paths.
-        Example example = new RestAdapter.Builder() //
-                .setClient(mockClient)
-                .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-                .setServer("http://example.com")
-                .setProfiler(mockProfiler)
-                .setLog(RestAdapter.Log.NONE)
-                .setLogLevel(FULL)
-                .build()
-                .create(Example.class);
-
-        ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
-        TypedInput typedInput = mock(TypedInput.class);
-        when(typedInput.in()).thenReturn(is);
-        Response response = new Response(200, "OK", NO_HEADERS, typedInput);
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(response);
-        example.something();
-        verify(is).close();
-    }
-
-    @Test
-    public void getResponseDirectlyAsync() throws Exception {
-        Response response = new Response(200, "OK", NO_HEADERS, null);
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(response);
-        Callback<Response> callback = mock(Callback.class);
-
-        example.direct(callback);
-
-        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-        verify(mockCallbackExecutor).execute(any(Runnable.class));
-        verify(callback).success(eq(response), same(response));
-    }
-
-    @Test
-    public void observableCallsOnNext() throws Exception {
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
-        Action1<String> action = mock(Action1.class);
-        example.observable("Howdy").subscribe(action);
-        verify(action).call(eq("hello"));
-    }
-
-    @Test
-    public void observableCallsOnError() throws Exception {
-        when(mockClient.execute(any(Request.class))) //
-                .thenReturn(new Response(300, "FAIL", NO_HEADERS, new TypedString("bummer")));
-        Action1<String> onSuccess = mock(Action1.class);
-        Action1<Throwable> onError = mock(Action1.class);
-        example.observable("Howdy").subscribe(onSuccess, onError);
-        verifyZeroInteractions(onSuccess);
-        verify(onError).call(isA(RetrofitError.class));
-    }
-
-    @Test
-    public void observableHandlesParams() throws Exception {
-        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
-        when(mockClient.execute(requestCaptor.capture())) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
-        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
-        Action1<Response> action = mock(Action1.class);
-        example.observable("X", "Y").subscribe(action);
-
-        Request request = requestCaptor.getValue();
-        assertThat(request.getUrl()).contains("/X/Y");
-
-        verify(action).call(responseCaptor.capture());
-        Response response = responseCaptor.getValue();
-        assertThat(response.getStatus()).isEqualTo(200);
-    }
-
-    @Test
-    public void testAbsoluteUrl() throws Exception {
-        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
-        when(mockClient.execute(requestCaptor.capture())) //
-                .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
-        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
-        Action1<Response> action = mock(Action1.class);
-        example.observableAbsolute("http://appstrakt.com/").subscribe(action);
-
-        Request request = requestCaptor.getValue();
-        verify(action).call(responseCaptor.capture());
-        Response response = responseCaptor.getValue();
-        assertThat(response.getStatus()).isEqualTo(200);
-    }
-
-    @Test
-    public void observableUsesHttpExecutor() throws IOException {
-        Response response = new Response(200, "OK", NO_HEADERS, new TypedString("hello"));
-        when(mockClient.execute(any(Request.class))).thenReturn(response);
-
-        example.observable("Howdy").subscribe(mock(Action1.class));
-
-        verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
-        verifyZeroInteractions(mockCallbackExecutor);
-    }
-
-}
diff --git a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
deleted file mode 100644
index c4a21fa44..000000000
--- a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
+++ /dev/null
@@ -1,876 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.google.gson.reflect.TypeToken;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.DELETE;
-import retrofit.http.EncodedPath;
-import retrofit.http.EncodedQuery;
-import retrofit.http.Field;
-import retrofit.http.FormUrlEncoded;
-import retrofit.http.GET;
-import retrofit.http.HEAD;
-import retrofit.http.Header;
-import retrofit.http.Headers;
-import retrofit.http.Multipart;
-import retrofit.http.PATCH;
-import retrofit.http.POST;
-import retrofit.http.PUT;
-import retrofit.http.Part;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.RestMethod;
-import retrofit.mime.TypedOutput;
-import rx.Observable;
-
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static retrofit.RestMethodInfo.ParamUsage.BODY;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_PATH;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.HEADER;
-import static retrofit.RestMethodInfo.ParamUsage.PATH;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.RequestType.MULTIPART;
-import static retrofit.RestMethodInfo.RequestType.SIMPLE;
-
-public class RestMethodInfoTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
-
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = RestMethodInfo.parsePathParameters(path);
-    assertThat(calculated).hasSize(expected.length);
-    if (expected.length > 0) {
-      assertThat(calculated).containsExactly(expected);
-    }
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void pathMustBePrefixedWithSlash() {
-    class Example {
-      @GET("foo/bar") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test public void concreteCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void concreteCallbackTypesWithParams() {
-    class Example {
-      @GET("/foo") void a(@Query("id") String id, ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<Response> cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackTypesWithParams() {
-    class Example {
-      @GET("/foo") void a(@Query("id") String id, Callback<Response> c) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void wildcardGenericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<? extends Response> c) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackWithGenericType() {
-    class Example {
-      @GET("/foo") void a(Callback<List<String>> c) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
-  // a little of everything: a parameterized type, a generic array, and a wildcard.
-  private static Map<? extends String, Set<Long>[]> extendingGenericCallbackType;
-
-  @Test public void extendingGenericCallback() throws Exception {
-    class Example {
-      @GET("/foo") void a(MultimapCallback<String, Set<Long>> callback) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(
-        RestMethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
-  }
-
-  @Test public void synchronousResponse() {
-    class Example {
-      @GET("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isTrue();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void synchronousGenericResponse() {
-    class Example {
-      @GET("/foo") List<String> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isTrue();
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  @Test public void observableResponse() {
-    class Example {
-      @GET("/foo") Observable<Response> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.isObservable).isTrue();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void observableGenericResponse() {
-    class Example {
-      @GET("/foo") Observable<List<String>> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.isObservable).isTrue();
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void observableWithCallback() {
-    class Example {
-      @GET("/foo") Observable<Response> a(Callback<Response> callback) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    new RestMethodInfo(method);
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void missingCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(@Query("id") String id) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    new RestMethodInfo(method);
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void synchronousWithAsyncCallback() {
-    class Example {
-      @GET("/foo") Response a(Callback<Response> callback) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    new RestMethodInfo(method);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void lackingMethod() {
-    class Example {
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test public void deleteMethod() {
-    class Example {
-      @DELETE("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("DELETE");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void getMethod() {
-    class Example {
-      @GET("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("GET");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void headMethod() {
-    class Example {
-      @HEAD("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("HEAD");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void postMethod() {
-    class Example {
-      @POST("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("POST");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void putMethod() {
-    class Example {
-      @PUT("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("PUT");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void patchMethod() {
-    class Example {
-      @PATCH("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("PATCH");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @RestMethod("CUSTOM1")
-  @Target(METHOD) @Retention(RUNTIME)
-  private @interface CUSTOM1 {
-    String value();
-  }
-
-  @Test public void custom1Method() {
-    class Example {
-      @CUSTOM1("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("CUSTOM1");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @RestMethod(value = "CUSTOM2", hasBody = true)
-  @Target(METHOD) @Retention(RUNTIME)
-  private @interface CUSTOM2 {
-    String value();
-  }
-
-  @Test public void custom2Method() {
-    class Example {
-      @CUSTOM2("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("CUSTOM2");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void singlePathQueryParam() {
-    class Example {
-      @GET("/foo?a=b")
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-    assertThat(methodInfo.requestQuery).isEqualTo("a=b");
-  }
-
-  @Test public void emptyParams() {
-    class Example {
-      @GET("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).isEmpty();
-    assertThat(methodInfo.requestParamUsage).isEmpty();
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singlePathParam() {
-    class Example {
-      @GET("/{a}") Response a(@Path("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(PATH);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singleEncodedPathParam() {
-    class Example {
-      @GET("/{a}") Response a(@EncodedPath("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(ENCODED_PATH);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singleQueryParam() {
-    class Example {
-      @GET("/") Response a(@Query("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(QUERY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singleEncodedQueryParam() {
-    class Example {
-      @GET("/") Response a(@EncodedQuery("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(ENCODED_QUERY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void multipleQueryParams() {
-    class Example {
-      @GET("/") Response a(@Query("a") String a, @Query("b") String b, @Query("c") String c) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(3).containsExactly("a", "b", "c");
-    assertThat(methodInfo.requestParamUsage).hasSize(3).containsExactly(QUERY, QUERY, QUERY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void bodyObject() {
-    class Example {
-      @PUT("/") Response a(@Body Object o) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly(new String[] { null });
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(BODY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void bodyTypedBytes() {
-    class Example {
-      @PUT("/") Response a(@Body TypedOutput o) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly(new String[] { null });
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(BODY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void twoBodies() {
-    class Example {
-      @PUT("/") Response a(@Body int o1, @Body int o2) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test public void bodyWithOtherParams() {
-    class Example {
-      @PUT("/{a}/{c}") Response a(@Path("a") int a, @Body int b, @Path("c") int c) {
-        return null;
-      }
-    }
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).containsExactly("a", null, "c");
-    assertThat(methodInfo.requestParamUsage).containsExactly(PATH, BODY, PATH);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") Response a(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") Response a(String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") Response a(@Body Object o) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void nonBodyHttpMethodWithTypedBytes() {
-    class Example {
-      @GET("/") Response a(@Path("a") TypedOutput a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test public void simpleMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test public void twoTypedBytesMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a, @Part("b") TypedOutput b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test public void twoTypesMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a, @Part("b") int b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") Response a(@Part("a") int a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart @GET("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart @POST("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void implicitFormEncodingForbidden() {
-    class Example {
-      @POST("/") Response a(@Field("a") int a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded @GET("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded @POST("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") @Headers({}) Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test public void twoMethodHeaders() {
-
-    class Example {
-      @GET("/") @Headers({
-        "X-Foo: Bar",
-        "X-Ping: Pong"
-      }) Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.headers).isEqualTo(
-        Arrays.asList(new retrofit.client.Header("X-Foo", "Bar"),
-            new retrofit.client.Header("X-Ping", "Pong")));
-  }
-
-  @Test public void twoHeaderParams() {
-    class Example {
-      @GET("/")
-      Response a(@Header("a") String a, @Header("b") String b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).containsExactly("a", "b");
-    assertThat(methodInfo.requestParamUsage).containsExactly(HEADER, HEADER);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void headerParamMustBeString() {
-    class Example {
-      @GET("/")
-      Response a(@Header("a") TypedOutput a, @Header("b") int b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void onlyOneEncodingIsAllowed() {
-    class Example {
-      @Multipart
-      @FormUrlEncoded
-      @POST("/")
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") Response a(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).startsWith("Path parameter name is not valid: hey!.");
-    }
-  }
-
-  private static class Response {
-  }
-
-  private static interface ResponseCallback extends Callback<Response> {
-  }
-
-  private static interface MultimapCallback<K, V> extends Callback<Map<? extends K, V[]>> {
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
new file mode 100644
index 000000000..c4826dafb
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -0,0 +1,316 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+import retrofit.http.Url;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class RetrofitTest {
+    @Rule
+    public final MockWebServerRule server = new MockWebServerRule();
+
+    interface CallMethod {
+        @GET("/")
+        Call<String> disallowed();
+
+        @POST("/")
+        Call<ResponseBody> disallowed(@Body String body);
+
+        @GET("/")
+        Call<ResponseBody> allowed();
+
+        @POST("/")
+        Call<ResponseBody> allowed(@Body RequestBody body);
+
+        @GET("/")
+        Call<ResponseBody> TestAbsolute(@Url String url);
+    }
+
+    interface FutureMethod {
+        @GET("/")
+        Future<String> method();
+    }
+
+    interface Extending extends CallMethod {
+    }
+
+    interface StringService {
+        @GET("/")
+        String get();
+    }
+
+    interface Unresolvable {
+        @GET("/")
+        <T> Call<T> typeVariable();
+
+        @GET("/")
+        <T extends ResponseBody> Call<T> typeVariableUpperBound();
+
+        @GET("/")
+        <T> Call<List<Map<String, Set<T[]>>>> crazy();
+
+        @GET("/")
+        Call<?> wildcard();
+
+        @GET("/")
+        Call<? extends ResponseBody> wildcardUpperBound();
+    }
+
+    @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+    @Test
+    public void objectMethodsStillWork() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        assertThat(example.hashCode()).isNotZero();
+        assertThat(example.equals(this)).isFalse();
+        assertThat(example.toString()).isNotEmpty();
+    }
+
+    @Test
+    public void interfaceWithExtendIsNotSupported() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        try {
+            retrofit.create(Extending.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+        }
+    }
+
+    @Test
+    public void callReturnTypeAdapterAddedByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.allowed()).isNotNull();
+    }
+
+    @Test
+    public void callReturnTypeCustomAdapter() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        final AtomicBoolean adapterCalled = new AtomicBoolean();
+        class MyCallAdapterFactory implements CallAdapter.Factory {
+            @Override
+            public CallAdapter<?> get(final Type returnType) {
+                factoryCalled.set(true);
+                if (Utils.getRawType(returnType) != Call.class) {
+                    return null;
+                }
+                return new CallAdapter<Object>() {
+                    @Override
+                    public Type responseType() {
+                        return Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+                    }
+
+                    @Override
+                    public Object adapt(Call<Object> call) {
+                        adapterCalled.set(true);
+                        return call;
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .callAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.allowed()).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+        assertThat(adapterCalled.get()).isTrue();
+    }
+
+    @Test
+    public void customReturnTypeAdapter() {
+        class GreetingCallAdapterFactory implements CallAdapter.Factory {
+            @Override
+            public CallAdapter<?> get(Type returnType) {
+                if (Utils.getRawType(returnType) != String.class) {
+                    return null;
+                }
+                return new CallAdapter<Object>() {
+                    @Override
+                    public Type responseType() {
+                        return String.class;
+                    }
+
+                    @Override
+                    public String adapt(Call<Object> call) {
+                        return "Hi!";
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .converter(new StringConverter())
+                .callAdapterFactory(new GreetingCallAdapterFactory())
+                .build();
+        StringService example = retrofit.create(StringService.class);
+        assertThat(example.get()).isEqualTo("Hi!");
+    }
+
+    @Test
+    public void customReturnTypeAdapterMissingThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        FutureMethod example = retrofit.create(FutureMethod.class);
+        try {
+            example.method();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("FutureMethod.method: Registered call adapter factory was unable to handle return type java.util.concurrent.Future<java.lang.String>");
+        }
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonRequestBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        try {
+            example.disallowed("Hi!");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "CallMethod.disallowed: @Body parameter is class java.lang.String but no converter registered. "
+                            + "Either add a converter to the Retrofit instance or use RequestBody. (parameter #1)");
+        }
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonResponseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        try {
+            example.disallowed();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "CallMethod.disallowed: Method response type is class java.lang.String but no converter registered. "
+                            + "Either add a converter to the Retrofit instance or use ResponseBody.");
+        }
+    }
+
+    @Test
+    public void requestBodyOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<ResponseBody> response = example.allowed().execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+        Response<ResponseBody> response = example.allowed(body).execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+
+        assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+    }
+
+    @Test
+    public void absoluteWorking() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint("http://google.com")
+                .build();
+
+        CallMethod example = retrofit.create(CallMethod.class);
+        Response<ResponseBody> response = example.TestAbsolute("http://appstrakt.com").execute();
+        assertThat(response.code() ==200);
+    }
+
+    @Test
+    public void unresolvableTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .endpoint(server.getUrl("/").toString())
+                .converter(new StringConverter())
+                .build();
+        Unresolvable example = retrofit.create(Unresolvable.class);
+
+        try {
+            example.typeVariable();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Unresolvable.typeVariable: Method return type must not include a type variable or wildcard.");
+        }
+        try {
+            example.typeVariableUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Unresolvable.typeVariableUpperBound: Method return type must not include a type variable or wildcard.");
+        }
+        try {
+            example.crazy();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Unresolvable.crazy: Method return type must not include a type variable or wildcard.");
+        }
+        try {
+            example.wildcard();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Unresolvable.wildcard: Method return type must not include a type variable or wildcard.");
+        }
+        try {
+            example.wildcardUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Unresolvable.wildcardUpperBound: Method return type must not include a type variable or wildcard.");
+        }
+    }
+}
diff --git a/retrofit/src/test/java/retrofit/StringConverter.java b/retrofit/src/test/java/retrofit/StringConverter.java
new file mode 100644
index 000000000..6f66a004b
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/StringConverter.java
@@ -0,0 +1,17 @@
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+
+class StringConverter implements Converter {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    return body.string();
+  }
+
+  @Override public RequestBody toBody(Object object, Type type) {
+    return RequestBody.create(MediaType.parse("text/plain"), String.valueOf(object));
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/TestingUtils.java b/retrofit/src/test/java/retrofit/TestingUtils.java
index 709b1bcb5..cc65e72f6 100644
--- a/retrofit/src/test/java/retrofit/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/TestingUtils.java
@@ -2,35 +2,13 @@
 package retrofit;
 
 import java.lang.reflect.Method;
-import java.util.Map;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
 
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public abstract class TestingUtils {
-  public static Method getMethod(Class c, String name) {
-    for (Method method : c.getDeclaredMethods()) {
-      if (method.getName().equals(name)) {
-        return method;
-      }
-    }
-    throw new IllegalArgumentException("Unknown method '" + name + "' on " + c);
-  }
-
-  public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
-    MultipartTypedOutput typedOutput = new MultipartTypedOutput();
-    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
-      typedOutput.addPart(part.getKey(), part.getValue());
+public final class TestingUtils {
+  public static Method onlyMethod(Class c) {
+    Method[] declaredMethods = c.getDeclaredMethods();
+    if (declaredMethods.length == 1) {
+      return declaredMethods[0];
     }
-    return typedOutput;
-  }
-
-  public static void assertMultipart(TypedOutput typedOutput) {
-    assertThat(typedOutput).isInstanceOf(MultipartTypedOutput.class);
-  }
-
-  public static void assertBytes(byte[] bytes, String expected) throws Exception {
-    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
+    throw new IllegalArgumentException("More than one method declared.");
   }
 }
diff --git a/retrofit/src/test/java/retrofit/client/ApacheClientTest.java b/retrofit/src/test/java/retrofit/client/ApacheClientTest.java
deleted file mode 100644
index 82e51fb96..000000000
--- a/retrofit/src/test/java/retrofit/client/ApacheClientTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.client;
-
-import com.google.common.io.ByteStreams;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpEntityEnclosingRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpVersion;
-import org.apache.http.StatusLine;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.message.BasicHttpResponse;
-import org.apache.http.message.BasicStatusLine;
-import org.junit.Test;
-import retrofit.TestingUtils;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.TestingUtils.assertBytes;
-import static retrofit.TestingUtils.assertMultipart;
-import static retrofit.client.ApacheClient.TypedOutputEntity;
-
-public class ApacheClientTest {
-  private static final String HOST = "http://example.com";
-
-  @Test public void get() {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getMethod()).isEqualTo("GET");
-    assertThat(apacheRequest.getURI().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
-    assertThat(apacheRequest.getAllHeaders()).isEmpty();
-
-    if (apacheRequest instanceof HttpEntityEnclosingRequest) {
-      HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-      assertThat(entityRequest.getEntity()).isNull();
-    }
-  }
-
-  @Test public void post() throws Exception {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getMethod()).isEqualTo("POST");
-    assertThat(apacheRequest.getURI().toString()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(apacheRequest.getAllHeaders()).hasSize(0);
-
-    assertThat(apacheRequest).isInstanceOf(HttpEntityEnclosingRequest.class);
-    HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-    HttpEntity entity = entityRequest.getEntity();
-    assertThat(entity).isNotNull();
-    assertBytes(ByteStreams.toByteArray(entity.getContent()), "hi");
-    assertThat(entity.getContentType().getValue()).isEqualTo("text/plain; charset=UTF-8");
-  }
-
-  @Test public void multipart() {
-    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
-    bodyParams.put("foo", new TypedString("bar"));
-    bodyParams.put("ping", new TypedString("pong"));
-    TypedOutput body = TestingUtils.createMultipart(bodyParams);
-    Request request = new Request("POST", HOST + "/that/", null, body);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getMethod()).isEqualTo("POST");
-    assertThat(apacheRequest.getURI().toString()).isEqualTo(HOST + "/that/");
-    assertThat(apacheRequest.getAllHeaders()).hasSize(0);
-
-    assertThat(apacheRequest).isInstanceOf(HttpEntityEnclosingRequest.class);
-    HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-    TypedOutputEntity entity = (TypedOutputEntity) entityRequest.getEntity();
-    assertMultipart(entity.typedOutput);
-    // TODO test more?
-  }
-
-  @Test public void headers() {
-    List<Header> headers = new ArrayList<Header>();
-    headers.add(new Header("kit", "kat"));
-    headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, null);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getAllHeaders()).hasSize(2);
-    org.apache.http.Header kit = apacheRequest.getFirstHeader("kit");
-    assertThat(kit).isNotNull();
-    assertThat(kit.getValue()).isEqualTo("kat");
-    org.apache.http.Header foo = apacheRequest.getFirstHeader("foo");
-    assertThat(foo).isNotNull();
-    assertThat(foo.getValue()).isEqualTo("bar");
-  }
-
-  @Test public void response() throws Exception {
-    StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 200, "OK");
-    HttpResponse apacheResponse = new BasicHttpResponse(statusLine);
-    apacheResponse.setEntity(new TypedOutputEntity(new TypedString("hello")));
-    apacheResponse.addHeader("Content-Type", "text/plain");
-    apacheResponse.addHeader("foo", "bar");
-    apacheResponse.addHeader("kit", "kat");
-    Response response = ApacheClient.parseResponse(apacheResponse);
-
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void emptyResponse() throws Exception {
-    StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 200, "OK");
-    HttpResponse apacheResponse = new BasicHttpResponse(statusLine);
-    apacheResponse.addHeader("foo", "bar");
-    apacheResponse.addHeader("kit", "kat");
-    Response response = ApacheClient.parseResponse(apacheResponse);
-
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(2) //
-        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
-    assertThat(response.getBody()).isNull();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/client/DummyHttpUrlConnection.java b/retrofit/src/test/java/retrofit/client/DummyHttpUrlConnection.java
deleted file mode 100644
index 926e4b042..000000000
--- a/retrofit/src/test/java/retrofit/client/DummyHttpUrlConnection.java
+++ /dev/null
@@ -1,115 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.client;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Provides POJO behavior for all of the APIs {@link retrofit.client.UrlConnectionClient}
- * interacts with.
- */
-public class DummyHttpUrlConnection extends HttpURLConnection {
-  private final Map<String, List<String>> responseHeaders =
-      new LinkedHashMap<String, List<String>>();
-  private final Map<String, List<String>> requestHeaders =
-      new LinkedHashMap<String, List<String>>();
-  private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-  private int responseCode;
-  private String responseMessage;
-  private InputStream inputStream;
-  private InputStream errorStream;
-
-  protected DummyHttpUrlConnection(String url) throws MalformedURLException {
-    super(new URL(url));
-  }
-
-  public void setResponseCode(int responseCode) {
-    this.responseCode = responseCode;
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return responseCode;
-  }
-
-  public void setResponseMessage(String responseMessage) {
-    this.responseMessage = responseMessage;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return responseMessage;
-  }
-
-  @Override public ByteArrayOutputStream getOutputStream() throws IOException {
-    return outputStream;
-  }
-
-  public void setInputStream(InputStream inputStream) {
-    this.inputStream = inputStream;
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return inputStream;
-  }
-
-  public void setErrorStream(InputStream errorStream) {
-    this.errorStream = errorStream;
-  }
-
-  @Override public InputStream getErrorStream() {
-    return errorStream;
-  }
-
-  public void addResponseHeader(String name, String value) {
-    List<String> values = responseHeaders.get(name);
-    if (values == null) {
-      values = new ArrayList<String>();
-      responseHeaders.put(name, values);
-    }
-    values.add(value);
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    return responseHeaders;
-  }
-
-  @Override public void addRequestProperty(String name, String value) {
-    List<String> values = requestHeaders.get(name);
-    if (values == null) {
-      values = new ArrayList<String>();
-      requestHeaders.put(name, values);
-    }
-    values.add(value);
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    return requestHeaders;
-  }
-
-  @Override public String getRequestProperty(String name) {
-    List<String> values = requestHeaders.get(name);
-    if (values == null || values.isEmpty()) {
-      return null;
-    }
-    return values.get(0);
-  }
-
-  @Override public void disconnect() {
-    throw new AssertionError("Not implemented.");
-  }
-
-  @Override public boolean usingProxy() {
-    return false;
-  }
-
-  @Override public void connect() throws IOException {
-    throw new AssertionError("Not implemented.");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/client/UrlConnectionClientTest.java b/retrofit/src/test/java/retrofit/client/UrlConnectionClientTest.java
deleted file mode 100644
index e00f321ce..000000000
--- a/retrofit/src/test/java/retrofit/client/UrlConnectionClientTest.java
+++ /dev/null
@@ -1,167 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.client;
-
-import com.google.common.io.ByteStreams;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.Test;
-import retrofit.TestingUtils;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.TestingUtils.assertBytes;
-
-public class UrlConnectionClientTest {
-  private static final String HOST = "http://example.com";
-
-  private UrlConnectionClient client = new UrlConnectionClient() {
-    @Override protected HttpURLConnection openConnection(Request request) throws IOException {
-      return new DummyHttpUrlConnection(request.getUrl());
-    }
-  };
-
-  @Test public void get() throws Exception {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
-
-    HttpURLConnection connection = client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestMethod()).isEqualTo("GET");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
-    assertThat(connection.getHeaderFields()).isEmpty();
-  }
-
-  @Test public void patch() throws Exception {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("PATCH", HOST + "/foo/bar/", null, body);
-
-    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestMethod()).isEqualTo("PATCH");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("Content-Type")) //
-        .isEqualTo("text/plain; charset=UTF-8");
-    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo("2");
-    assertBytes(connection.getOutputStream().toByteArray(), "hi");
-  }
-
-  @Test public void post() throws Exception {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
-
-    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestMethod()).isEqualTo("POST");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("Content-Type")) //
-        .isEqualTo("text/plain; charset=UTF-8");
-    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo("2");
-    assertBytes(connection.getOutputStream().toByteArray(), "hi");
-  }
-
-  @Test public void multipart() throws Exception {
-    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
-    bodyParams.put("foo", new TypedString("bar"));
-    bodyParams.put("ping", new TypedString("pong"));
-    TypedOutput body = TestingUtils.createMultipart(bodyParams);
-    Request request = new Request("POST", HOST + "/that/", null, body);
-
-    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    byte[] output = connection.getOutputStream().toByteArray();
-
-    assertThat(connection.getRequestMethod()).isEqualTo("POST");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/that/");
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("Content-Type")).startsWith("multipart/form-data;");
-    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo(String.valueOf(output.length));
-    assertThat(output.length).isGreaterThan(0);
-  }
-
-  @Test public void headers() throws Exception {
-    List<Header> headers = new ArrayList<Header>();
-    headers.add(new Header("kit", "kat"));
-    headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, null);
-
-    HttpURLConnection connection = client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("kit")).isEqualTo("kat");
-    assertThat(connection.getRequestProperty("foo")).isEqualTo("bar");
-  }
-
-  @Test public void response() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(200);
-    connection.setResponseMessage("OK");
-    connection.addResponseHeader("Content-Type", "text/plain");
-    connection.addResponseHeader("foo", "bar");
-    connection.addResponseHeader("kit", "kat");
-    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void createdResponse() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(201);
-    connection.setResponseMessage("OK");
-    connection.addResponseHeader("Content-Type", "text/plain");
-    connection.addResponseHeader("foo", "bar");
-    connection.addResponseHeader("kit", "kat");
-    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getStatus()).isEqualTo(201);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void errorResponse() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(401);
-    connection.setResponseMessage("Not Authorized");
-    connection.addResponseHeader("Content-Type", "text/plain");
-    connection.setInputStream(new ByteArrayInputStream("input".getBytes("UTF-8")));
-    connection.setErrorStream(new ByteArrayInputStream("error".getBytes("UTF-8")));
-    Response response = client.readResponse(connection);
-
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "error");
-  }
-
-  @Test public void emptyResponse() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(200);
-    connection.setResponseMessage("OK");
-    connection.addResponseHeader("foo", "bar");
-    connection.addResponseHeader("kit", "kat");
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(2) //
-        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java b/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java
deleted file mode 100644
index a7a3914f9..000000000
--- a/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class FormUrlEncodingTypedOutputTest {
-  @Test public void urlEncoding() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("a&b", "c=d");
-    fe.addField("space, the", "final frontier");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    fe.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo("a%26b=c%3Dd&space%2C+the=final+frontier");
-  }
-
-  @Test public void utf8encoding() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("ooɟ", "ɹɐq");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    fe.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo("oo%C9%9F=%C9%B9%C9%90q");
-  }
-
-  @Test public void encodedPairs() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("sim", "ple");
-
-    ByteArrayOutputStream out1 = new ByteArrayOutputStream();
-    fe.writeTo(out1);
-    String actual1 = new String(out1.toByteArray(), "UTF-8");
-    assertThat(actual1).isEqualTo("sim=ple");
-
-    fe.addField("hey", "there");
-    fe.addField("help", "me");
-
-    ByteArrayOutputStream out2 = new ByteArrayOutputStream();
-    fe.writeTo(out2);
-    String actual2 = new String(out2.toByteArray(), "UTF-8");
-    assertThat(actual2).isEqualTo("sim=ple&hey=there&help=me");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MimeHelper.java b/retrofit/src/test/java/retrofit/mime/MimeHelper.java
deleted file mode 100644
index a78198ee3..000000000
--- a/retrofit/src/test/java/retrofit/mime/MimeHelper.java
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.util.List;
-
-public class MimeHelper {
-  public static List<byte[]> getParts(MultipartTypedOutput output) {
-    try {
-      return output.getParts();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
\ No newline at end of file
diff --git a/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java b/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java
deleted file mode 100644
index 03bce7fc9..000000000
--- a/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright 2012 Square, Inc.
-package retrofit.mime;
-
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static retrofit.mime.MimeUtil.parseCharset;
-
-public class MimeUtilTest {
-  @Test public void charsetParsing() {
-    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;charset=utf-8;other=thing")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase("UTF-8");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java b/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java
deleted file mode 100644
index 11820ec4d..000000000
--- a/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class MultipartTypedOutputTest {
-  @Test public void singlePart() throws Exception {
-    String expected = "" //
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"greet\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 13\r\n"
-        + "Content-Transfer-Encoding: binary\r\n" //
-        + "\r\n" //
-        + "Hello, World!\r\n" //
-        + "--123--";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("greet", new TypedString("Hello, World!"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-
-  @Test public void threeParts() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"quick\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 5\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "brown\r\n"
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"fox\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 5\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "jumps\r\n"
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"lazy\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 3\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "dog\r\n"
-        + "--123--";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("quick", new TypedString("brown"));
-    mto.addPart("fox", new TypedString("jumps"));
-    mto.addPart("lazy", new TypedString("dog"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java b/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java
deleted file mode 100644
index c6145e6b9..000000000
--- a/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.mime;
-
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class TypedByteArrayTest {
-  private static final String GIF = "image/gif";
-
-  @Test public void objectEquals() {
-    TypedByteArray a1 = new TypedByteArray(GIF, new byte[] { 10, 20 });
-    TypedByteArray a2 = new TypedByteArray(GIF, new byte[] { 10, 20 });
-    TypedByteArray b = new TypedByteArray(GIF, new byte[] { 8, 12 });
-
-    assertThat(a1).isEqualTo(a2);
-    assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
-    assertThat(a1).isNotEqualTo(b);
-    assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/TypedFileTest.java b/retrofit/src/test/java/retrofit/mime/TypedFileTest.java
deleted file mode 100644
index d9d114317..000000000
--- a/retrofit/src/test/java/retrofit/mime/TypedFileTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.mime;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class TypedFileTest {
-  private static final String PNG = "image/png";
-
-  @Test public void objectEquals() {
-    TypedFile a1 = new TypedFile(PNG, new File("a.png"));
-    TypedFile a2 = new TypedFile(PNG, new File("a.png"));
-    TypedFile b = new TypedFile(PNG, new File("b.png"));
-
-    assertThat(a1).isNotEqualTo(b);
-    assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
-    assertThat(a1).isEqualTo(a2);
-    assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
-  }
-
-  @Test public void objectToString() {
-    File file = new File("/path/to/file.png");
-
-    assertThat(new TypedFile(PNG, file).toString()) //
-        .isEqualTo(file.getAbsolutePath() + " (image/png)");
-  }
-
-  @Test public void length() throws IOException {
-    File tempFile = File.createTempFile("foo", ".tmp");
-    try {
-      TypedFile typedFile = new TypedFile(PNG, tempFile);
-      assertThat(typedFile.length()).isZero();
-
-      writeToFile(tempFile, new byte[] { 0, 1, 2, 3, 4 });
-
-      assertThat(tempFile.length()).isEqualTo(5);
-      assertThat(typedFile.length()).isEqualTo(5);
-    } finally {
-      tempFile.delete();
-    }
-  }
-
-  private static void writeToFile(File file, byte[] data) throws IOException {
-    FileOutputStream fos = new FileOutputStream(file);
-    try {
-      fos.write(data);
-    } finally {
-      fos.close();
-    }
-  }
-}
diff --git a/samples/pom.xml b/samples/pom.xml
new file mode 100644
index 000000000..f60dae06c
--- /dev/null
+++ b/samples/pom.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>samples</artifactId>
+  <name>Samples</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <!--<dependency>-->
+      <!--<groupId>com.squareup.retrofit</groupId>-->
+      <!--<artifactId>retrofit-mock</artifactId>-->
+      <!--<version>${project.version}</version>-->
+    <!--</dependency>-->
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
new file mode 100644
index 000000000..15d9a9393
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
+import retrofit.Call;
+import retrofit.CallAdapter;
+import retrofit.Callback;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+/**
+ * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
+ * a service method return type.
+ */
+public final class CustomCallAdapter {
+  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
+    @Override public CallAdapter<?> get(Type returnType) {
+      TypeToken<?> token = TypeToken.of(returnType);
+      if (token.getRawType() != ListenableFuture.class) {
+        return null;
+      }
+
+      TypeToken<?> componentType = token.getComponentType();
+      if (componentType == null) {
+        throw new IllegalStateException(); // TODO
+      }
+      final Type responseType = componentType.getType();
+
+      return new CallAdapter<Object>() {
+        @Override public Type responseType() {
+          return responseType;
+        }
+
+        @Override public ListenableFuture<?> adapt(Call<Object> call) {
+          CallFuture<Object> future = new CallFuture<>(call);
+          call.enqueue(future);
+          return future;
+        }
+      };
+    }
+
+    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
+      private final Call<T> call;
+
+      private CallFuture(Call<T> call) {
+        this.call = call;
+      }
+
+      @Override protected void interruptTask() {
+        call.cancel();
+      }
+
+      @Override public void success(Response<T> response) {
+        if (response.isSuccess()) {
+          set(response.body());
+        } else {
+          setException(new IOException()); // TODO something more useful.
+        }
+      }
+
+      @Override public void failure(Throwable t) {
+        setException(t);
+      }
+    }
+  }
+
+  interface HttpBinService {
+    @GET("/ip")
+    ListenableFuture<Ip> getIp();
+  }
+
+  static class Ip {
+    String origin;
+  }
+
+  public static void main(String... args) {
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint("http://httpbin.org")
+        .callAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .build();
+
+    HttpBinService service = retrofit.create(HttpBinService.class);
+    final ListenableFuture<Ip> ip = service.getIp();
+    ip.addListener(new Runnable() {
+      @Override public void run() {
+        try {
+          System.out.println("IP: " + ip.get().origin);
+        } catch (InterruptedException | ExecutionException e) {
+          e.printStackTrace();
+        }
+      }
+    }, Executors.newSingleThreadExecutor());
+  }
+}
diff --git a/retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
similarity index 53%
rename from retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/src/main/java/com/example/retrofit/SimpleService.java
index 8515e209b..bdaa12e82 100644
--- a/retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -15,38 +15,47 @@
  */
 package com.example.retrofit;
 
+import java.io.IOException;
 import java.util.List;
-import retrofit.RestAdapter;
+import retrofit.Call;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
 
-public class GitHubClient {
-  private static final String API_URL = "https://api.github.com";
+public final class SimpleService {
+  public static final String API_URL = "https://api.github.com";
 
-  static class Contributor {
-    String login;
-    int contributions;
+  public static class Contributor {
+    public final String login;
+    public final int contributions;
+
+    public Contributor(String login, int contributions) {
+      this.login = login;
+      this.contributions = contributions;
+    }
   }
 
-  interface GitHub {
+  public interface GitHub {
     @GET("/repos/{owner}/{repo}/contributors")
-    List<Contributor> contributors(
+    Call<List<Contributor>> contributors(
         @Path("owner") String owner,
-        @Path("repo") String repo
-    );
+        @Path("repo") String repo);
   }
 
-  public static void main(String... args) {
+  public static void main(String... args) throws IOException {
     // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setServer(API_URL)
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(API_URL)
         .build();
 
     // Create an instance of our GitHub API interface.
-    GitHub github = restAdapter.create(GitHub.class);
+    GitHub github = retrofit.create(GitHub.class);
+
+    // Create a call instance for looking up Retrofit contributors.
+    Call<List<Contributor>> call = github.contributors("square", "retrofit");
 
-    // Fetch and print a list of the contributors to this library.
-    List<Contributor> contributors = github.contributors("square", "retrofit");
+    // Fetch and print a list of the contributors to the library.
+    List<Contributor> contributors = call.execute().body();
     for (Contributor contributor : contributors) {
       System.out.println(contributor.login + " (" + contributor.contributions + ")");
     }
diff --git a/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/src/main/not_java/SimpleMockService.java
similarity index 73%
rename from retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/src/main/not_java/SimpleMockService.java
index 77a9ce2aa..0d7b53f2c 100644
--- a/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/src/main/not_java/SimpleMockService.java
@@ -1,40 +1,28 @@
 // Copyright 2013 Square, Inc.
 package com.example.retrofit;
 
+import com.example.retrofit.SimpleService.Contributor;
+import com.example.retrofit.SimpleService.GitHub;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import retrofit.MockRestAdapter;
-import retrofit.RestAdapter;
-import retrofit.http.GET;
-import retrofit.http.Path;
-
-public class GitHubClient {
-  private static final String API_URL = "https://api.github.com";
-
-  static class Contributor {
-    public final String login;
-    public final int contributions;
-
-    Contributor(String login, int contributions) {
-      this.login = login;
-      this.contributions = contributions;
-    }
-  }
-
-  public interface GitHub {
-    @GET("/repos/{owner}/{repo}/contributors")
-    List<Contributor> contributors(@Path("owner") String owner, @Path("repo") String repo);
-  }
-
+import java.util.concurrent.Executors;
+import retrofit.MockRetrofit;
+import retrofit.Retrofit;
+
+/**
+ * An example of using {@link MockRetrofit} to create a mock service implementation with
+ * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
+ */
+public final class SimpleMockService {
   /** A mock implementation of the {@link GitHub} API interface. */
-  static class MockGitHub implements GitHub {
+  static final class MockGitHub implements GitHub {
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
     public MockGitHub() {
-      ownerRepoContributors = new LinkedHashMap<String, Map<String, List<Contributor>>>();
+      ownerRepoContributors = new LinkedHashMap<>();
 
       // Seed some mock data.
       addContributor("square", "retrofit", "John Doe", 12);
@@ -59,12 +47,12 @@ public MockGitHub() {
     public void addContributor(String owner, String repo, String name, int contributions) {
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
       if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<String, List<Contributor>>();
+        repoContributors = new LinkedHashMap<>();
         ownerRepoContributors.put(owner, repoContributors);
       }
       List<Contributor> contributors = repoContributors.get(repo);
       if (contributors == null) {
-        contributors = new ArrayList<Contributor>();
+        contributors = new ArrayList<>();
         repoContributors.put(repo, contributors);
       }
       contributors.add(new Contributor(name, contributions));
@@ -73,17 +61,17 @@ public void addContributor(String owner, String repo, String name, int contribut
 
   public static void main(String... args) {
     // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setServer(API_URL)
+    Retrofit retrofit = new Retrofit.Builder()
+        .endpoint(SimpleService.API_URL)
         .build();
 
     // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+    MockRetrofit mockRetrofit = MockRetrofit.from(retrofit, Executors.newSingleThreadExecutor());
 
     // Instantiate a mock object so we can interact with it later.
     MockGitHub mockGitHub = new MockGitHub();
     // Use the mock REST adapter and our mock object to create the API interface.
-    GitHub gitHub = mockRestAdapter.create(GitHub.class, mockGitHub);
+    GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
     printContributors(gitHub, "square", "retrofit");
diff --git a/website/index.html b/website/index.html
index 9e4694cbc..7b7ca48bb 100644
--- a/website/index.html
+++ b/website/index.html
@@ -8,7 +8,7 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
     <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
   </head>
   <body data-target=".content-nav">
@@ -48,12 +48,12 @@ <h3 id="introduction">Introduction</h3>
   @GET("/users/{user}/repos")
   List&lt;Repo> listRepos(@Path("user") String user);
 }</pre>
-            <p>The <code>RestAdapter</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class="prettyprint">RestAdapter restAdapter = new RestAdapter.Builder()
-    .setServer("https://api.github.com")
+            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+    .setEndpoint("https://api.github.com")
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
             <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
             <pre class="prettyprint">List&lt;Repo> repos = service.listRepos("octocat");</pre>
             <p>Use annotations to describe the HTTP request:</p>
@@ -80,12 +80,15 @@ <h4>URL Manipulation</h4>
             <p>Query parameters can also be added.</p>
             <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
+            <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
+            <pre class="prettyprint">@GET("/group/{id}/users")
+List&lt;User> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
             <h4>Request Body</h4>
             <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
             <pre class="prettyprint">@POST("/users/new")
 void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>RestAdapter</code>'s converter.</p>
+            <p>The object will also be converted using the <code>Retrofit</code>'s converter.</p>
 
             <h4>Form Encoded and Multipart</h4>
             <p>Methods can also be declared to send form-encoded and multipart data.</p>
@@ -97,7 +100,35 @@ <h4>Form Encoded and Multipart</h4>
             <pre class="prettyprint">@Multipart
 @PUT("/user/photo")
 User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description);</pre>
-            <p>Multipart parts use the <code>RestAdapter</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+            <p>Multipart parts use the <code>Retrofit</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+
+            <h4>Header Manipulation</h4>
+            <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
+            <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
+@GET("/widget/list")
+List&lt;Widget> widgetList();</pre>
+            <pre class="prettyprint">@Headers({
+    "Accept: application/vnd.github.v3.full+json",
+    "User-Agent: Retrofit-Sample-App"
+})
+@GET("/users/{username}")
+User getUser(@Path("username") String username);</pre>
+            <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
+            <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
+            <pre class="prettyprint">@GET("/user")
+void getUser(@Header("Authorization") String authorization, Callback&lt;User> callback)</pre>
+            <p>Headers that need to be added to every request can be specified using a <code>RequestInterceptor</code>. The following code creates a <code>RequestInterceptor</code> that will add a <code>User-Agent</code> header to every request.</p>
+            <pre class="prettyprint">RequestInterceptor requestInterceptor = new RequestInterceptor() {
+  @Override
+  public void intercept(RequestFacade request) {
+    request.addHeader("User-Agent", "Retrofit-Sample-App");
+  }
+};
+
+Retrofit retrofit = new Retrofit.Builder()
+  .setEndpoint("https://api.github.com")
+  .setRequestInterceptor(requestInterceptor)
+  .build();</pre>
 
             <h4>Synchronous vs. Asynchronous vs. Observable</h4>
             <p>Methods can be declared for either synchronous or asynchronous execution.</p>
@@ -109,13 +140,13 @@ <h4>Synchronous vs. Asynchronous vs. Observable</h4>
 void getUserPhoto(@Path("id") int id, Callback&lt;Photo> cb);</pre>
             <p>On Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.</p>
 
-            <p>Retrofit also integrates <a href="https://github.com/Netflix/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
+            <p>Retrofit also integrates <a href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
             <pre class="prettyprint">@GET("/user/{id}/photo")
 Observable&lt;Photo> getUserPhoto(@Path("id") int id);</pre>
             <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
 
             <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
+            <p>HTTP responses are automatically converted to a specified type using the <code>Retrofit</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
             <pre class="prettyprint">@GET("/users/list")
 List&lt;User> userList();
 
@@ -134,11 +165,11 @@ <h4>Response Object Type</h4>
 @GET("/users/list")
 Observable&lt;Response> userList();</pre>
 
-            <h3 id="restadapter-configuration">RestAdapter Configuration</h3>
-            <p><code>RestAdapter</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+            <h3 id="restadapter-configuration">Retrofit Configuration</h3>
+            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
 
             <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>RestAdapter</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
+            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>Retrofit</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
             <h4>Custom Gson Converter Example</h4>
             <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
             <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
@@ -147,26 +178,55 @@ <h4>Custom Gson Converter Example</h4>
     .registerTypeAdapter(Date.class, new DateTypeAdapter())
     .create();
 
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setServer("https://api.github.com")
+Retrofit retrofit = new Retrofit.Builder()
+    .setEndpoint("https://api.github.com")
     .setConverter(new GsonConverter(gson))
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>RestAdapter</code>.</p>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
+            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>Retrofit</code>.</p>
             <h4>Content format Agnostic</h4>
             <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href="http://simple.sourceforge.net/">Simple</a>) and Protocol Buffers (using <a href="https://code.google.com/p/protobuf/">protobuf</a> or <a href="https://github.com/square/wire">Wire</a>). Please see the <a href="https://github.com/square/retrofit/tree/master/retrofit-converters">retrofit-converters</a> directory for the full listing of converters.</p>
             <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class="prettyprint">RestAdapter restAdapter = new RestAdapter.Builder()
-    .setServer("https://api.soundcloud.com")
+            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+    .setEndpoint("https://api.soundcloud.com")
     .setConverter(new SimpleXMLConverter())
     .build();
 
-SoundCloudService service = restAdapter.create(SoundCloudService.class);</pre>
+SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
             <h4>Custom Converters</h4>
             <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
+            <h4>Custom Error Handling</h4>
+            <p>If you need custom error handling for requests, you may provide your own <code>ErrorHandler</code>. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code</p>
+            <pre class="prettyprint">
+class MyErrorHandler implements ErrorHandler {
+  @Override public Throwable handleError(RetrofitError cause) {
+    Response r = cause.getResponse();
+    if (r != null && r.getStatus() == 401) {
+      return new UnauthorizedException(cause);
+    }
+    return cause;
+  }
+}
+
+Retrofit retrofit = new Retrofit.Builder()
+    .setEndpoint("https://api.github.com")
+    .setErrorHandler(new MyErrorHandler())
+    .build();</pre>
+            <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
+
+            <h4>Logging</h4>
+            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>Retrofit</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
+            <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
+            <pre class="prettyprint">
+Retrofit retrofit = new Retrofit.Builder()
+    .setLogLevel(Retrofit.LogLevel.FULL)
+    .setEndpoint("https://api.github.com")
+    .build();</pre>
+            <p>This logging can be added or changed at any point in the <code>Retrofit</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
+
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
             <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -174,7 +234,33 @@ <h4>Maven</h4>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
+            <h4>Gradle</h4>
+            <pre class="prettyprint">
+compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
+</pre>
+            <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
 
+            <h4>Integration with OkHttp</h4>
+            <p>Retrofit will automatically use OkHttp (version 2.0 or newer) when it is present.</p>
+            <h4>Maven</h4>
+            <pre class="prettyprint">&lt;dependency>
+  &lt;groupId>com.squareup.okhttp&lt;/groupId>
+  &lt;artifactId>okhttp&lt;/artifactId>
+  &lt;version>2.0.0&lt;/version>
+&lt;/dependency>
+</pre>
+            <h4>Gradle</h4>
+<pre class="prettyprint">
+compile 'com.squareup.okhttp:okhttp:2.0.0'
+</pre>
+            <h4>ProGuard</h4>
+            <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+            <pre class="prettyprint">
+-dontwarn retrofit.**
+-keep class retrofit.** { *; }
+-keepattributes Signature
+-keepattributes Exceptions
+</pre>
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
@@ -200,14 +286,14 @@ <h3 id="license">License</h3>
               <ul class="nav nav-tabs nav-stacked primary">
                 <li><a href="#introduction">Introduction</a></li>
                 <li><a href="#api-declaration">API Declaration</a></li>
-                <li><a href="#restadapter-configuration">RestAdapter Configuration</a></li>
+                <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
                 <li><a href="#download">Download</a></li>
                 <li><a href="#contributing">Contributing</a></li>
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="javadoc/index.html">Javadoc</a></li>
-                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/63e22a6d-b165-489a-92ab-d35f942beb5b">Google+ Community</a></li>
+                <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -219,7 +305,7 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </section>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/bootstrap.min.js"></script>
     <script src="static/jquery.smooth-scroll.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
@@ -231,7 +317,7 @@ <h3 id="license">License</h3>
 
         // Spy on scroll position for real-time updating of current section.
         $('body').scrollspy();
-        
+
         // Use smooth-scroll for internal links.
         $('a').smoothScroll();
 
