diff --git a/pom.xml b/pom.xml
index 271601784..9bf69434c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,6 +46,7 @@
 
     <!-- Compilation -->
     <java.version>1.7</java.version>
+    <kotlin.version>1.2.60</kotlin.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
@@ -108,6 +109,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-stdlib</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
       <dependency>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-annotations</artifactId>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index e665b66e2..a06ae3ac3 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -24,6 +24,11 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-stdlib</artifactId>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>org.codehaus.mojo</groupId>
@@ -70,6 +75,26 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>process-sources</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index 86228d5c3..f5e636214 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,11 +18,15 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import kotlin.Unit;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
+  /** Not volatile because we don't mind multiple threads discovering this. */
+  private boolean checkForKotlinUnit = true;
+
   @Override
   public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
       Retrofit retrofit) {
@@ -34,6 +38,15 @@
     if (type == Void.class) {
       return VoidResponseBodyConverter.INSTANCE;
     }
+    if (checkForKotlinUnit) {
+      try {
+        if (type == Unit.class) {
+          return UnitResponseBodyConverter.INSTANCE;
+        }
+      } catch (NoClassDefFoundError ignored) {
+        checkForKotlinUnit = false;
+      }
+    }
     return null;
   }
 
@@ -55,6 +68,15 @@
     }
   }
 
+  static final class UnitResponseBodyConverter implements Converter<ResponseBody, Unit> {
+    static final UnitResponseBodyConverter INSTANCE = new UnitResponseBodyConverter();
+
+    @Override public Unit convert(ResponseBody value) {
+      value.close();
+      return Unit.INSTANCE;
+    }
+  }
+
   static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
     static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index b6d13cedf..d149df56a 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -18,86 +18,75 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 
 import static retrofit2.Utils.methodError;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<ResponseT, ReturnT> callAdapter;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
-
-  HttpServiceMethod(Builder<ResponseT, ReturnT> builder) {
-    requestFactory = builder.requestFactory;
-    callFactory = builder.retrofit.callFactory();
-    callAdapter = builder.callAdapter;
-    responseConverter = builder.responseConverter;
-  }
-
-  @Override ReturnT invoke(@Nullable Object[] args) {
-    return callAdapter.adapt(
-        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
-  }
-
   /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
+   * Inspects the annotations on an interface method to construct a reusable service method that
+   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+   * method only once and reuse it.
    */
-  static final class Builder<ResponseT, ReturnT> {
-    final Retrofit retrofit;
-    final Method method;
-
-    RequestFactory requestFactory;
-    Type responseType;
-    Converter<ResponseBody, ResponseT> responseConverter;
-    CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
+  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
+      Retrofit retrofit, Method method, RequestFactory requestFactory) {
+    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);
+    Type responseType = callAdapter.responseType();
+    if (responseType == Response.class || responseType == okhttp3.Response.class) {
+      throw methodError(method, "'"
+          + Utils.getRawType(responseType).getName()
+          + "' is not a valid response body type. Did you mean ResponseBody?");
+    }
+    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+      throw methodError(method, "HEAD method must use Void as response type.");
     }
 
-    HttpServiceMethod<ResponseT, ReturnT> build() {
-      requestFactory = RequestFactory.parseAnnotations(retrofit, method);
-
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError(method, "'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
+    Converter<ResponseBody, ResponseT> responseConverter =
+        createResponseConverter(retrofit, method, responseType);
 
-      if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
-        throw methodError(method, "HEAD method must use Void as response type.");
-      }
+    okhttp3.Call.Factory callFactory = retrofit.callFactory;
+    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);
+  }
 
-      return new HttpServiceMethod<>(this);
+  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+      Retrofit retrofit, Method method) {
+    Type returnType = method.getGenericReturnType();
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      //noinspection unchecked
+      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, "Unable to create call adapter for %s", returnType);
     }
+  }
 
-    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, "Unable to create call adapter for %s", returnType);
-      }
+  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
+      Retrofit retrofit, Method method, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseBodyConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw methodError(method, e, "Unable to create converter for %s", responseType);
     }
+  }
 
-    private Converter<ResponseBody, ResponseT> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(method, e, "Unable to create converter for %s", responseType);
-      }
-    }
+  private final RequestFactory requestFactory;
+  private final okhttp3.Call.Factory callFactory;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
+
+  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
+      CallAdapter<ResponseT, ReturnT> callAdapter,
+      Converter<ResponseBody, ResponseT> responseConverter) {
+    this.requestFactory = requestFactory;
+    this.callFactory = callFactory;
+    this.callAdapter = callAdapter;
+    this.responseConverter = responseConverter;
+  }
+
+  @Override ReturnT invoke(Object[] args) {
+    return callAdapter.adapt(
+        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
new file mode 100644
index 000000000..8b599cfb3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Hide the class from Java consumers.
+@file:JvmName("-KotlinExtensions")
+
+package retrofit2
+
+inline fun <reified T> Retrofit.create(): T = create(T::class.java)
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 3a4d0562d..050def5da 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -31,7 +31,7 @@
 
 final class OkHttpCall<T> implements Call<T> {
   private final RequestFactory requestFactory;
-  private final @Nullable Object[] args;
+  private final Object[] args;
   private final okhttp3.Call.Factory callFactory;
   private final Converter<ResponseBody, T> responseConverter;
 
@@ -44,7 +44,7 @@
   @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(RequestFactory requestFactory, @Nullable Object[] args,
+  OkHttpCall(RequestFactory requestFactory, Object[] args,
       okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
     this.requestFactory = requestFactory;
     this.args = args;
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index ee7cdba41..2461b34c1 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -85,14 +85,14 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     parameterHandlers = builder.parameterHandlers;
   }
 
-  okhttp3.Request create(@Nullable Object[] args) throws IOException {
+  okhttp3.Request create(Object[] args) throws IOException {
     RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
         contentType, hasBody, isFormEncoded, isMultipart);
 
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    int argumentCount = args != null ? args.length : 0;
+    int argumentCount = args.length;
     if (argumentCount != handlers.length) {
       throw new IllegalArgumentException("Argument count (" + argumentCount
           + ") doesn't match expected count (" + handlers.length + ")");
@@ -171,18 +171,7 @@ RequestFactory build() {
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(method, p,
-              "Parameter type must not include a type variable or wildcard: %s", parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(method, p, "No Retrofit annotation found.");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
       }
 
       if (relativeUrl == null && !gotUrl) {
@@ -290,21 +279,24 @@ private Headers parseHeaders(String[] headers) {
     }
 
     private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
+        int p, Type parameterType, @Nullable Annotation[] annotations) {
       ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        if (annotationAction == null) {
-          continue;
-        }
+          if (annotationAction == null) {
+            continue;
+          }
 
-        if (result != null) {
-          throw parameterError(method, p, "Multiple Retrofit annotations found, only one allowed.");
-        }
+          if (result != null) {
+            throw parameterError(method, p,
+                "Multiple Retrofit annotations found, only one allowed.");
+          }
 
-        result = annotationAction;
+          result = annotationAction;
+        }
       }
 
       if (result == null) {
@@ -317,6 +309,7 @@ private Headers parseHeaders(String[] headers) {
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        validateResolvableType(p, type);
         if (gotUrl) {
           throw parameterError(method, p, "Multiple @Url method annotations found.");
         }
@@ -349,6 +342,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
         if (gotQuery) {
           throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
         }
@@ -375,6 +369,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
         Query query = (Query) annotation;
         String name = query.value();
         boolean encoded = query.encoded();
@@ -405,6 +400,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
         QueryName query = (QueryName) annotation;
         boolean encoded = query.encoded();
 
@@ -434,6 +430,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         gotQueryMap = true;
         if (!Map.class.isAssignableFrom(rawParameterType)) {
@@ -456,6 +453,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
         Header header = (Header) annotation;
         String name = header.value();
 
@@ -484,6 +482,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof HeaderMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
@@ -505,6 +504,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.HeaderMap<>(valueConverter);
 
       } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
         }
@@ -539,6 +539,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p,
               "@FieldMap parameters can only be used with form encoding.");
@@ -565,6 +566,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               "@Part parameters can only be used with multipart encoding.");
@@ -646,6 +648,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               "@PartMap parameters can only be used with multipart encoding.");
@@ -680,6 +683,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
         if (isFormEncoded || isMultipart) {
           throw parameterError(method, p,
               "@Body parameters cannot be used with form or multi-part encoding.");
@@ -702,6 +706,13 @@ private Headers parseHeaders(String[] headers) {
       return null; // Not a Retrofit annotation.
     }
 
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            "Parameter type must not include a type variable or wildcard: %s", type);
+      }
+    }
+
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
         throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 498d006eb..e94d3d181 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -133,6 +133,7 @@
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
+          private final Object[] emptyArgs = new Object[0];
 
           @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
@@ -143,7 +144,7 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            return loadServiceMethod(method).invoke(args);
+            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
           }
         });
   }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 2ae44628e..8ddd42254 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -17,12 +17,13 @@
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import javax.annotation.Nullable;
 
 import static retrofit2.Utils.methodError;
 
 abstract class ServiceMethod<T> {
   static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
+    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
       throw methodError(method,
@@ -32,8 +33,8 @@
       throw methodError(method, "Service methods cannot return void.");
     }
 
-    return new HttpServiceMethod.Builder<Object, T>(retrofit, method).build();
+    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
   }
 
-  abstract T invoke(@Nullable Object[] args);
+  abstract T invoke(Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Streaming.java b/retrofit/src/main/java/retrofit2/http/Streaming.java
index 4a87591df..23fc0e290 100644
--- a/retrofit/src/main/java/retrofit2/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit2/http/Streaming.java
@@ -18,13 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.ResponseBody;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
- * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link ResponseBody ResponseBody} as is,
+ * i.e. without converting the body to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
index 0861d3c87..e009b6473 100644
--- a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
+++ b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
@@ -1,5 +1,5 @@
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
+# Retrofit does reflection on generic parameters and InnerClass is required to use Signature.
+-keepattributes Signature, InnerClasses
 
 # Retain service method parameters when optimizing.
 -keepclassmembers,allowshrinking,allowobfuscation interface * {
@@ -11,3 +11,9 @@
 
 # Ignore JSR 305 annotations for embedding nullability information.
 -dontwarn javax.annotation.**
+
+# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.
+-dontwarn kotlin.Unit
+
+# Top-level functions that can only be used by Kotlin.
+-dontwarn retrofit2.-KotlinExtensions
diff --git a/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
new file mode 100644
index 000000000..b8196c7e6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import okhttp3.mockwebserver.MockWebServer
+import org.junit.Assert.assertNotNull
+import org.junit.Rule
+import org.junit.Test
+
+class KotlinExtensionsTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Empty
+
+  @Test fun reifiedCreate() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build()
+
+    assertNotNull(retrofit.create<Empty>())
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinUnitTest.java b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
new file mode 100644
index 000000000..e73f223c7
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinUnitTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import kotlin.Unit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class KotlinUnitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Call<Unit> empty();
+  }
+
+  @Test public void unitOnClasspath() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Unit> response = example.empty().execute();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(Unit.INSTANCE);
+  }
+
+  @Ignore("This is implicitly tested by integration tests of the adapters and converters")
+  @Test public void unitMissingFromClasspath() {
+  }
+}
