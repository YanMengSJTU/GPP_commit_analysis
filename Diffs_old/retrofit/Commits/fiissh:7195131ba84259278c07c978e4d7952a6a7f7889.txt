diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index eab2b859a..9d5097f28 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -114,6 +114,14 @@
           <excludePackageNames>retrofit2.internal</excludePackageNames>
         </configuration>
       </plugin>
+        <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-compiler-plugin</artifactId>
+            <configuration>
+                <source>8</source>
+                <target>8</target>
+            </configuration>
+        </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index bc8bdf814..a237eca7b 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -20,175 +20,158 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import javax.annotation.Nullable;
+
 import kotlin.coroutines.Continuation;
 import okhttp3.ResponseBody;
 
 import static retrofit2.Utils.getRawType;
 import static retrofit2.Utils.methodError;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
+/**
+ * Adapts an invocation of an interface method into an HTTP call.
+ */
 abstract class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method that
-   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
-   * method only once and reuse it.
-   */
-  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
-      Retrofit retrofit, Method method, RequestFactory requestFactory) {
-    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
-    boolean continuationWantsResponse = false;
-    boolean continuationBodyNullable = false;
-
-    Annotation[] annotations = method.getAnnotations();
-    Type adapterType;
-    if (isKotlinSuspendFunction) {
-      Type[] parameterTypes = method.getGenericParameterTypes();
-      Type responseType = Utils.getParameterLowerBound(0,
-          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
-      if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {
-        // Unwrap the actual body type from Response<T>.
-        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
-        continuationWantsResponse = true;
-      } else {
-        // TODO figure out if type is nullable or not
-        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
-        // Find the entry for method
-        // Determine if return type is nullable or not
-      }
-
-      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
-      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
-    } else {
-      adapterType = method.getGenericReturnType();
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method that
+     * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service
+     * method only once and reuse it.
+     */
+    static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(Retrofit retrofit, Method method, RequestFactory requestFactory) {
+        boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
+        boolean continuationWantsResponse = false;
+        boolean continuationBodyNullable = false;
+
+        Annotation[] annotations = method.getAnnotations();
+        Type adapterType;
+        if (isKotlinSuspendFunction) {
+            Type[] parameterTypes = method.getGenericParameterTypes();
+            Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]);
+            if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {
+                // Unwrap the actual body type from Response<T>.
+                responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);
+                continuationWantsResponse = true;
+            } else {
+                // TODO figure out if type is nullable or not
+                // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)
+                // Find the entry for method
+                // Determine if return type is nullable or not
+            }
+
+            adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);
+            annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);
+        } else {
+            adapterType = method.getGenericReturnType();
+        }
+
+        CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);
+        Type responseType = callAdapter.responseType();
+        if (responseType == okhttp3.Response.class) {
+            throw methodError(method, "'" + getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?");
+        }
+        if (responseType == Response.class) {
+            throw methodError(method, "Response must include generic type (e.g., Response<String>)");
+        }
+        // TODO support Unit for Kotlin?
+        if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
+            throw methodError(method, "HEAD method must use Void as response type.");
+        }
+
+        Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType);
+
+        okhttp3.Call.Factory callFactory = retrofit.callFactory;
+        if (!isKotlinSuspendFunction) {
+            return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);
+        } else if (continuationWantsResponse) {
+            //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
+            return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);
+        } else {
+            //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
+            return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter, continuationBodyNullable);
+        }
     }
 
-    CallAdapter<ResponseT, ReturnT> callAdapter =
-        createCallAdapter(retrofit, method, adapterType, annotations);
-    Type responseType = callAdapter.responseType();
-    if (responseType == okhttp3.Response.class) {
-      throw methodError(method, "'"
-          + getRawType(responseType).getName()
-          + "' is not a valid response body type. Did you mean ResponseBody?");
-    }
-    if (responseType == Response.class) {
-      throw methodError(method, "Response must include generic type (e.g., Response<String>)");
-    }
-    // TODO support Unit for Kotlin?
-    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {
-      throw methodError(method, "HEAD method must use Void as response type.");
+    private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
+            Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) {
+        try {
+            //noinspection unchecked
+            return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
+        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+            throw methodError(method, e, "Unable to create call adapter for %s", returnType);
+        }
     }
 
-    Converter<ResponseBody, ResponseT> responseConverter =
-        createResponseConverter(retrofit, method, responseType);
-
-    okhttp3.Call.Factory callFactory = retrofit.callFactory;
-    if (!isKotlinSuspendFunction) {
-      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);
-    } else if (continuationWantsResponse) {
-      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
-      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,
-          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);
-    } else {
-      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
-      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,
-          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,
-          continuationBodyNullable);
+    private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(Retrofit retrofit, Method method, Type responseType) {
+        Annotation[] annotations = method.getAnnotations();
+        try {
+            return retrofit.responseBodyConverter(responseType, annotations);
+        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+            throw methodError(method, e, "Unable to create converter for %s", responseType);
+        }
     }
-  }
-
-  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(
-      Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) {
-    try {
-      //noinspection unchecked
-      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw methodError(method, e, "Unable to create call adapter for %s", returnType);
-    }
-  }
-
-  private static <ResponseT> Converter<ResponseBody, ResponseT> createResponseConverter(
-      Retrofit retrofit, Method method, Type responseType) {
-    Annotation[] annotations = method.getAnnotations();
-    try {
-      return retrofit.responseBodyConverter(responseType, annotations);
-    } catch (RuntimeException e) { // Wide exception range because factories are user code.
-      throw methodError(method, e, "Unable to create converter for %s", responseType);
-    }
-  }
-
-  private final RequestFactory requestFactory;
-  private final okhttp3.Call.Factory callFactory;
-  private final Converter<ResponseBody, ResponseT> responseConverter;
-
-  HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
-      Converter<ResponseBody, ResponseT> responseConverter) {
-    this.requestFactory = requestFactory;
-    this.callFactory = callFactory;
-    this.responseConverter = responseConverter;
-  }
-
-  @Override final @Nullable ReturnT invoke(Object[] args) {
-    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
-    return adapt(call, args);
-  }
-
-  protected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);
-
-  static final class CallAdapted<ResponseT, ReturnT> extends HttpServiceMethod<ResponseT, ReturnT> {
-    private final CallAdapter<ResponseT, ReturnT> callAdapter;
-
-    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
-        Converter<ResponseBody, ResponseT> responseConverter,
-        CallAdapter<ResponseT, ReturnT> callAdapter) {
-      super(requestFactory, callFactory, responseConverter);
-      this.callAdapter = callAdapter;
+
+    private final RequestFactory requestFactory;
+    private final okhttp3.Call.Factory callFactory;
+    private final Converter<ResponseBody, ResponseT> responseConverter;
+
+    HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, Converter<ResponseBody, ResponseT> responseConverter) {
+        this.requestFactory = requestFactory;
+        this.callFactory = callFactory;
+        this.responseConverter = responseConverter;
     }
 
-    @Override protected ReturnT adapt(Call<ResponseT> call, Object[] args) {
-      return callAdapter.adapt(call);
+    @Override final @Nullable ReturnT invoke(Object[] args) {
+        Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
+        return adapt(call, args);
     }
-  }
 
-  static final class SuspendForResponse<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
-    private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
+    protected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);
 
-    SuspendForResponse(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
-        Converter<ResponseBody, ResponseT> responseConverter,
-        CallAdapter<ResponseT, Call<ResponseT>> callAdapter) {
-      super(requestFactory, callFactory, responseConverter);
-      this.callAdapter = callAdapter;
-    }
+    static final class CallAdapted<ResponseT, ReturnT> extends HttpServiceMethod<ResponseT, ReturnT> {
+        private final CallAdapter<ResponseT, ReturnT> callAdapter;
 
-    @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
-      call = callAdapter.adapt(call);
+        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, Converter<ResponseBody, ResponseT> responseConverter, CallAdapter<ResponseT, ReturnT> callAdapter) {
+            super(requestFactory, callFactory, responseConverter);
+            this.callAdapter = callAdapter;
+        }
 
-      //noinspection unchecked Checked by reflection inside RequestFactory.
-      Continuation<Response<ResponseT>> continuation =
-          (Continuation<Response<ResponseT>>) args[args.length - 1];
-      return KotlinExtensions.awaitResponse(call, continuation);
+        @Override protected ReturnT adapt(Call<ResponseT> call, Object[] args) {
+            return callAdapter.adapt(call);
+        }
     }
-  }
-
-  static final class SuspendForBody<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
-    private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
-    private final boolean isNullable;
-
-    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
-        Converter<ResponseBody, ResponseT> responseConverter,
-        CallAdapter<ResponseT, Call<ResponseT>> callAdapter, boolean isNullable) {
-      super(requestFactory, callFactory, responseConverter);
-      this.callAdapter = callAdapter;
-      this.isNullable = isNullable;
+
+    static final class SuspendForResponse<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
+        private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
+
+        SuspendForResponse(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, Converter<ResponseBody, ResponseT> responseConverter, CallAdapter<ResponseT, Call<ResponseT>> callAdapter) {
+            super(requestFactory, callFactory, responseConverter);
+            this.callAdapter = callAdapter;
+        }
+
+        @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
+            call = callAdapter.adapt(call);
+
+            //noinspection unchecked Checked by reflection inside RequestFactory.
+            Continuation<Response<ResponseT>> continuation = (Continuation<Response<ResponseT>>) args[args.length - 1];
+            return KotlinExtensions.awaitResponse(call, continuation);
+        }
     }
 
-    @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
-      call = callAdapter.adapt(call);
+    static final class SuspendForBody<ResponseT> extends HttpServiceMethod<ResponseT, Object> {
+        private final CallAdapter<ResponseT, Call<ResponseT>> callAdapter;
+        private final boolean isNullable;
+
+        SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, Converter<ResponseBody, ResponseT> responseConverter, CallAdapter<ResponseT, Call<ResponseT>> callAdapter, boolean isNullable) {
+            super(requestFactory, callFactory, responseConverter);
+            this.callAdapter = callAdapter;
+            this.isNullable = isNullable;
+        }
+
+        @Override protected Object adapt(Call<ResponseT> call, Object[] args) {
+            call = callAdapter.adapt(call);
 
-      //noinspection unchecked Checked by reflection inside RequestFactory.
-      Continuation<ResponseT> continuation = (Continuation<ResponseT>) args[args.length - 1];
-      return isNullable
-          ? KotlinExtensions.awaitNullable(call, continuation)
-          : KotlinExtensions.await(call, continuation);
+            //noinspection unchecked Checked by reflection inside RequestFactory.
+            Continuation<ResponseT> continuation = (Continuation<ResponseT>) args[args.length - 1];
+            return isNullable ? KotlinExtensions.awaitNullable(call, continuation) : KotlinExtensions.await(call, continuation);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index f24d4817a..79531381a 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,6 +18,7 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
@@ -26,6 +27,7 @@
 import java.util.List;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 import static java.util.Arrays.asList;
@@ -34,139 +36,157 @@
 import static java.util.Collections.unmodifiableList;
 
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    return new Platform();
-  }
-
-  @Nullable Executor defaultCallbackExecutor() {
-    return null;
-  }
-
-  List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
-      @Nullable Executor callbackExecutor) {
-    return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
-  }
-
-  int defaultCallAdapterFactoriesSize() {
-    return 1;
-  }
-
-  List<? extends Converter.Factory> defaultConverterFactories() {
-    return emptyList();
-  }
-
-  int defaultConverterFactoriesSize() {
-    return 0;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  @Nullable Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-      @Nullable Object... args) throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
-    }
+    private static final Platform PLATFORM = findPlatform();
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        @Nullable Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
+    static Platform get() {
+        return PLATFORM;
     }
 
-    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
-        @Nullable Executor callbackExecutor) {
-      List<CallAdapter.Factory> factories = new ArrayList<>(2);
-      factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
-      factories.add(new DefaultCallAdapterFactory(callbackExecutor));
-      return unmodifiableList(factories);
+    private static Platform findPlatform() {
+        try {
+            // 尝试反射 android.os.Build 类，如果没有抛出异常，说明是 Android 平台
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+
+        // 尝试反射 java.util.Optional 类，如果没有抛出异常，说明是 Java5 平台
+        try {
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
+        return new Platform();
     }
 
-    @Override int defaultCallAdapterFactoriesSize() {
-      return 2;
+    @Nullable
+    Executor defaultCallbackExecutor() {
+        return null;
     }
 
-    @Override List<? extends Converter.Factory> defaultConverterFactories() {
-      return singletonList(OptionalConverterFactory.INSTANCE);
+    List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+            @Nullable Executor callbackExecutor) {
+        return singletonList(new DefaultCallAdapterFactory(callbackExecutor));
     }
 
-    @Override int defaultConverterFactoriesSize() {
-      return 1;
+    int defaultCallAdapterFactoriesSize() {
+        return 1;
     }
-  }
 
-  static class Android extends Platform {
-    @IgnoreJRERequirement // Guarded by API check.
-    @Override boolean isDefaultMethod(Method method) {
-      if (Build.VERSION.SDK_INT < 24) {
-        return false;
-      }
-      return method.isDefault();
-    }
-
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    List<? extends Converter.Factory> defaultConverterFactories() {
+        return emptyList();
     }
 
-    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
-        @Nullable Executor callbackExecutor) {
-      if (callbackExecutor == null) throw new AssertionError();
-      DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);
-      return Build.VERSION.SDK_INT >= 24
-        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
-        : singletonList(executorFactory);
+    int defaultConverterFactoriesSize() {
+        return 0;
     }
 
-    @Override int defaultCallAdapterFactoriesSize() {
-      return Build.VERSION.SDK_INT >= 24 ? 2 : 1;
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
 
-    @Override List<? extends Converter.Factory> defaultConverterFactories() {
-      return Build.VERSION.SDK_INT >= 24
-          ? singletonList(OptionalConverterFactory.INSTANCE)
-          : Collections.<Converter.Factory>emptyList();
+    @Nullable
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                               @Nullable Object... args) throws Throwable {
+        throw new UnsupportedOperationException();
     }
 
-    @Override int defaultConverterFactoriesSize() {
-      return Build.VERSION.SDK_INT >= 24 ? 1 : 0;
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
+
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                   @Nullable Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                    .unreflectSpecial(method, declaringClass)
+                    .bindTo(object)
+                    .invokeWithArguments(args);
+        }
+
+        @Override
+        List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+                @Nullable Executor callbackExecutor) {
+            List<CallAdapter.Factory> factories = new ArrayList<>(2);
+            factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
+            factories.add(new DefaultCallAdapterFactory(callbackExecutor));
+            return unmodifiableList(factories);
+        }
+
+        @Override
+        int defaultCallAdapterFactoriesSize() {
+            return 2;
+        }
+
+        @Override
+        List<? extends Converter.Factory> defaultConverterFactories() {
+            return singletonList(OptionalConverterFactory.INSTANCE);
+        }
+
+        @Override
+        int defaultConverterFactoriesSize() {
+            return 1;
+        }
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
-
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+    static class Android extends Platform {
+        @IgnoreJRERequirement // Guarded by API check.
+        @Override
+        boolean isDefaultMethod(Method method) {
+            if (Build.VERSION.SDK_INT < 24) {
+                return false;
+            }
+            return method.isDefault();
+        }
+
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
+
+        @Override
+        List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+                @Nullable Executor callbackExecutor) {
+            if (callbackExecutor == null) throw new AssertionError();
+            DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);
+            return Build.VERSION.SDK_INT >= 24
+                    ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
+                    : singletonList(executorFactory);
+        }
+
+        @Override
+        int defaultCallAdapterFactoriesSize() {
+            return Build.VERSION.SDK_INT >= 24 ? 2 : 1;
+        }
+
+        @Override
+        List<? extends Converter.Factory> defaultConverterFactories() {
+            return Build.VERSION.SDK_INT >= 24
+                    ? singletonList(OptionalConverterFactory.INSTANCE)
+                    : Collections.<Converter.Factory>emptyList();
+        }
+
+        @Override
+        int defaultConverterFactoriesSize() {
+            return Build.VERSION.SDK_INT >= 24 ? 1 : 0;
+        }
+
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
+
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index cc43226ed..3c862a21c 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -29,6 +29,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+
 import kotlin.coroutines.Continuation;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -63,743 +64,765 @@
 import static retrofit2.Utils.parameterError;
 
 final class RequestFactory {
-  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
-    return new Builder(retrofit, method).build();
-  }
-
-  private final Method method;
-  private final HttpUrl baseUrl;
-  final String httpMethod;
-  private final @Nullable String relativeUrl;
-  private final @Nullable Headers headers;
-  private final @Nullable MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-  final boolean isKotlinSuspendFunction;
-
-  RequestFactory(Builder builder) {
-    method = builder.method;
-    baseUrl = builder.retrofit.baseUrl;
-    httpMethod = builder.httpMethod;
-    relativeUrl = builder.relativeUrl;
-    headers = builder.headers;
-    contentType = builder.contentType;
-    hasBody = builder.hasBody;
-    isFormEncoded = builder.isFormEncoded;
-    isMultipart = builder.isMultipart;
-    parameterHandlers = builder.parameterHandlers;
-    isKotlinSuspendFunction = builder.isKotlinSuspendFunction;
-  }
-
-  okhttp3.Request create(Object[] args) throws IOException {
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args.length;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
-    }
-
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
-        headers, contentType, hasBody, isFormEncoded, isMultipart);
-
-    if (isKotlinSuspendFunction) {
-      // The Continuation is the last parameter and the handlers array contains null at that index.
-      argumentCount--;
+    /**
+     * 将 Method 解析成对应的 Request
+     *
+     * @param retrofit
+     * @param method
+     * @return
+     */
+    static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
+        return new Builder(retrofit, method).build();
     }
 
-    List<Object> argumentList = new ArrayList<>(argumentCount);
-    for (int p = 0; p < argumentCount; p++) {
-      argumentList.add(args[p]);
-      handlers[p].apply(requestBuilder, args[p]);
+    private final Method method;
+    private final HttpUrl baseUrl;
+    final String httpMethod;
+    private final @Nullable String relativeUrl;
+    private final @Nullable Headers headers;
+    private final @Nullable MediaType contentType;
+    private final boolean hasBody;
+    private final boolean isFormEncoded;
+    private final boolean isMultipart;
+    private final ParameterHandler<?>[] parameterHandlers;
+    final boolean isKotlinSuspendFunction;
+
+    RequestFactory(Builder builder) {
+        method = builder.method;
+        baseUrl = builder.retrofit.baseUrl;
+        httpMethod = builder.httpMethod;
+        relativeUrl = builder.relativeUrl;
+        headers = builder.headers;
+        contentType = builder.contentType;
+        hasBody = builder.hasBody;
+        isFormEncoded = builder.isFormEncoded;
+        isMultipart = builder.isMultipart;
+        parameterHandlers = builder.parameterHandlers;
+        isKotlinSuspendFunction = builder.isKotlinSuspendFunction;
     }
 
-    return requestBuilder.get()
-        .tag(Invocation.class, new Invocation(method, argumentList))
-        .build();
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder {
-    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotQueryName;
-    boolean gotQueryMap;
-    boolean gotUrl;
-    @Nullable String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    @Nullable String relativeUrl;
-    @Nullable Headers headers;
-    @Nullable MediaType contentType;
-    @Nullable Set<String> relativeUrlParamNames;
-    @Nullable ParameterHandler<?>[] parameterHandlers;
-    boolean isKotlinSuspendFunction;
-
-    Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
+    okhttp3.Request create(Object[] args) throws IOException {
+        @SuppressWarnings("unchecked")
+        // It is an error to invoke a method with the wrong arg types.
+                ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    RequestFactory build() {
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
+        int argumentCount = args.length;
+        if (argumentCount != handlers.length) {
+            throw new IllegalArgumentException("Argument count (" + argumentCount + ") doesn't match expected count (" + handlers.length + ")");
+        }
 
-      if (httpMethod == null) {
-        throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
+        RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart);
 
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(method,
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
+        if (isKotlinSuspendFunction) {
+            // The Continuation is the last parameter and the handlers array contains null at that index.
+            argumentCount--;
         }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0, lastParameter = parameterCount - 1; p < parameterCount; p++) {
-        parameterHandlers[p] =
-            parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError(method, "Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError(method, "Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError(method, "Multipart method must contain at least one @Part.");
-      }
-
-      return new RequestFactory(this);
-    }
 
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError(method, "@Headers annotation is empty.");
+        List<Object> argumentList = new ArrayList<>(argumentCount);
+        for (int p = 0; p < argumentCount; p++) {
+            argumentList.add(args[p]);
+            handlers[p].apply(requestBuilder, args[p]);
         }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
+
+        return requestBuilder.get().tag(Invocation.class, new Invocation(method, argumentList)).build();
     }
 
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError(method, "URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
-        }
-      }
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method. This
+     * requires potentially-expensive reflection so it is best to build each service method only once
+     * and reuse it. Builders cannot be reused.
+     */
+    static final class Builder {
+        // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+        private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+        private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+        private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+        final Retrofit retrofit;
+        final Method method;
+        final Annotation[] methodAnnotations;
+        final Annotation[][] parameterAnnotationsArray;
+        final Type[] parameterTypes;
+
+        boolean gotField;
+        boolean gotPart;
+        boolean gotBody;
+        boolean gotPath;
+        boolean gotQuery;
+        boolean gotQueryName;
+        boolean gotQueryMap;
+        boolean gotUrl;
+        @Nullable String httpMethod;
+        boolean hasBody;
+        boolean isFormEncoded;
+        boolean isMultipart;
+        @Nullable String relativeUrl;
+        @Nullable Headers headers;
+        @Nullable MediaType contentType;
+        @Nullable Set<String> relativeUrlParamNames;
+        @Nullable ParameterHandler<?>[] parameterHandlers;
+        boolean isKotlinSuspendFunction;
+
+        Builder(Retrofit retrofit, Method method) {
+            this.retrofit = retrofit;
+            this.method = method;
+            this.methodAnnotations = method.getAnnotations();
+            this.parameterTypes = method.getGenericParameterTypes();
+            this.parameterAnnotationsArray = method.getParameterAnnotations();
+        }
+
+        RequestFactory build() {
+            for (Annotation annotation : methodAnnotations) {
+                parseMethodAnnotation(annotation);
+            }
 
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
+            if (httpMethod == null) {
+                throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+            }
 
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(method,
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-        }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          try {
-            contentType = MediaType.get(headerValue);
-          } catch (IllegalArgumentException e) {
-            throw methodError(method, e, "Malformed content type: %s", headerValue);
-          }
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
+            if (!hasBody) {
 
-    private @Nullable ParameterHandler<?> parseParameter(
-        int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) {
-      ParameterHandler<?> result = null;
-      if (annotations != null) {
-        for (Annotation annotation : annotations) {
-          ParameterHandler<?> annotationAction =
-              parseParameterAnnotation(p, parameterType, annotations, annotation);
+                if (isMultipart) {
+                    throw methodError(method, "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+                }
 
-          if (annotationAction == null) {
-            continue;
-          }
+                if (isFormEncoded) {
+                    throw methodError(method, "FormUrlEncoded can only be specified on HTTP methods with " + "request body (e.g., @POST).");
+                }
+            }
 
-          if (result != null) {
-            throw parameterError(method, p,
-                "Multiple Retrofit annotations found, only one allowed.");
-          }
+            int parameterCount = parameterAnnotationsArray.length;
+            parameterHandlers = new ParameterHandler<?>[parameterCount];
+            for (int p = 0, lastParameter = parameterCount - 1; p < parameterCount; p++) {
+                parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);
+            }
 
-          result = annotationAction;
-        }
-      }
-
-      if (result == null) {
-        if (allowContinuation) {
-          try {
-            if (Utils.getRawType(parameterType) == Continuation.class) {
-              isKotlinSuspendFunction = true;
-              return null;
+            if (relativeUrl == null && !gotUrl) {
+                throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
             }
-          } catch (NoClassDefFoundError ignored) {
-          }
-        }
-        throw parameterError(method, p, "No Retrofit annotation found.");
-      }
 
-      return result;
-    }
+            if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+                throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+            }
 
-    @Nullable
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        validateResolvableType(p, type);
-        if (gotUrl) {
-          throw parameterError(method, p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
-        }
-        if (gotQueryName) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
-        }
-        if (gotQueryMap) {
-          throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
-        }
+            if (isFormEncoded && !gotField) {
+                throw methodError(method, "Form-encoded method must contain at least one @Field.");
+            }
 
-        gotUrl = true;
+            if (isMultipart && !gotPart) {
+                throw methodError(method, "Multipart method must contain at least one @Part.");
+            }
 
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl(method, p);
-        } else {
-          throw parameterError(method, p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+            return new RequestFactory(this);
+        }
+
+        private void parseMethodAnnotation(Annotation annotation) {
+            if (annotation instanceof DELETE) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+            } else if (annotation instanceof GET) {
+                parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+            } else if (annotation instanceof HEAD) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+            } else if (annotation instanceof PATCH) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+            } else if (annotation instanceof POST) {
+                parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+            } else if (annotation instanceof PUT) {
+                parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+            } else if (annotation instanceof OPTIONS) {
+                parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+            } else if (annotation instanceof HTTP) {
+                HTTP http = (HTTP) annotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            } else if (annotation instanceof retrofit2.http.Headers) {
+                String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError(method, "@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotation instanceof Multipart) {
+                if (isFormEncoded) {
+                    throw methodError(method, "Only one encoding annotation is allowed.");
+                }
+                isMultipart = true;
+            } else if (annotation instanceof FormUrlEncoded) {
+                if (isMultipart) {
+                    throw methodError(method, "Only one encoding annotation is allowed.");
+                }
+                isFormEncoded = true;
+            }
         }
 
-      } else if (annotation instanceof Path) {
-        validateResolvableType(p, type);
-        if (gotQuery) {
-          throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotQueryName) {
-          throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
-        }
-        if (gotQueryMap) {
-          throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
-        }
-        if (gotUrl) {
-          throw parameterError(method, p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(method, p, "@Path can only be used with relative url on @%s",
-              httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(method, p, name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        validateResolvableType(p, type);
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
-        }
+        private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+            if (this.httpMethod != null) {
+                throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+                        this.httpMethod, httpMethod);
+            }
+            this.httpMethod = httpMethod;
+            this.hasBody = hasBody;
 
-      } else if (annotation instanceof QueryName) {
-        validateResolvableType(p, type);
-        QueryName query = (QueryName) annotation;
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQueryName = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded);
-        }
+            if (value.isEmpty()) {
+                return;
+            }
 
-      } else if (annotation instanceof QueryMap) {
-        validateResolvableType(p, type);
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQueryMap = true;
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(method, p,
-                valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        validateResolvableType(p, type);
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
-        }
+            // Get the relative URL path and existing query string, if present.
+            int question = value.indexOf('?');
+            if (question != -1 && question < value.length() - 1) {
+                // Ensure the query string does not have any named parameters.
+                String queryParams = value.substring(question + 1);
+                Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+                if (queryParamMatcher.find()) {
+                    throw methodError(method, "URL query string \"%s\" must not have replace block. "
+                            + "For dynamic query parameters use @Query.", queryParams);
+                }
+            }
 
-      } else if (annotation instanceof HeaderMap) {
-        if (type == Headers.class) {
-          return new ParameterHandler.Headers(method, p);
+            this.relativeUrl = value;
+            this.relativeUrlParamNames = parsePathParameters(value);
+        }
+
+        private Headers parseHeaders(String[] headers) {
+            Headers.Builder builder = new Headers.Builder();
+            for (String header : headers) {
+                int colon = header.indexOf(':');
+                if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                    throw methodError(method,
+                            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+                }
+                String headerName = header.substring(0, colon);
+                String headerValue = header.substring(colon + 1).trim();
+                if ("Content-Type".equalsIgnoreCase(headerName)) {
+                    try {
+                        contentType = MediaType.get(headerValue);
+                    } catch (IllegalArgumentException e) {
+                        throw methodError(method, e, "Malformed content type: %s", headerValue);
+                    }
+                } else {
+                    builder.add(headerName, headerValue);
+                }
+            }
+            return builder.build();
         }
 
-        validateResolvableType(p, type);
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+        private @Nullable ParameterHandler<?> parseParameter(
+                int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) {
+            ParameterHandler<?> result = null;
+            if (annotations != null) {
+                for (Annotation annotation : annotations) {
+                    ParameterHandler<?> annotationAction =
+                            parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
+                    if (annotationAction == null) {
+                        continue;
+                    }
 
-      } else if (annotation instanceof Field) {
-        validateResolvableType(p, type);
-        if (!isFormEncoded) {
-          throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(method, p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
-        }
+                    if (result != null) {
+                        throw parameterError(method, p,
+                                "Multiple Retrofit annotations found, only one allowed.");
+                    }
 
-      } else if (annotation instanceof FieldMap) {
-        validateResolvableType(p, type);
-        if (!isFormEncoded) {
-          throw parameterError(method, p,
-              "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(method, p,
-                valueConverter, ((FieldMap) annotation).encoded());
-
-      } else if (annotation instanceof Part) {
-        validateResolvableType(p, type);
-        if (!isMultipart) {
-          throw parameterError(method, p,
-              "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(method, p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
+                    result = annotationAction;
+                }
             }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(method, p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(method, p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(method, p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(method, p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(method, p,
-                  "@Part parameters using the MultipartBody.Part must not "
-                      + "include a part name in the annotation.");
+
+            if (result == null) {
+                if (allowContinuation) {
+                    try {
+                        if (Utils.getRawType(parameterType) == Continuation.class) {
+                            isKotlinSuspendFunction = true;
+                            return null;
+                        }
+                    } catch (NoClassDefFoundError ignored) {
+                    }
+                }
+                throw parameterError(method, p, "No Retrofit annotation found.");
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(method, p, headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(method, p,
-                  "@Part parameters using the MultipartBody.Part must not "
-                      + "include a part name in the annotation.");
+
+            return result;
+        }
+
+        @Nullable
+        private ParameterHandler<?> parseParameterAnnotation(
+                int p, Type type, Annotation[] annotations, Annotation annotation) {
+            if (annotation instanceof Url) {
+                validateResolvableType(p, type);
+                if (gotUrl) {
+                    throw parameterError(method, p, "Multiple @Url method annotations found.");
+                }
+                if (gotPath) {
+                    throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+                }
+                if (gotQuery) {
+                    throw parameterError(method, p, "A @Url parameter must not come after a @Query.");
+                }
+                if (gotQueryName) {
+                    throw parameterError(method, p, "A @Url parameter must not come after a @QueryName.");
+                }
+                if (gotQueryMap) {
+                    throw parameterError(method, p, "A @Url parameter must not come after a @QueryMap.");
+                }
+                if (relativeUrl != null) {
+                    throw parameterError(method, p, "@Url cannot be used with @%s URL", httpMethod);
+                }
+
+                gotUrl = true;
+
+                if (type == HttpUrl.class
+                        || type == String.class
+                        || type == URI.class
+                        || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+                    return new ParameterHandler.RelativeUrl(method, p);
+                } else {
+                    throw parameterError(method, p,
+                            "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+                }
+
+            } else if (annotation instanceof Path) {
+                validateResolvableType(p, type);
+                if (gotQuery) {
+                    throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
+                }
+                if (gotQueryName) {
+                    throw parameterError(method, p, "A @Path parameter must not come after a @QueryName.");
+                }
+                if (gotQueryMap) {
+                    throw parameterError(method, p, "A @Path parameter must not come after a @QueryMap.");
+                }
+                if (gotUrl) {
+                    throw parameterError(method, p, "@Path parameters may not be used with @Url.");
+                }
+                if (relativeUrl == null) {
+                    throw parameterError(method, p, "@Path can only be used with relative url on @%s",
+                            httpMethod);
+                }
+                gotPath = true;
+
+                Path path = (Path) annotation;
+                String name = path.value();
+                validatePathName(p, name);
+
+                Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+                return new ParameterHandler.Path<>(method, p, name, converter, path.encoded());
+
+            } else if (annotation instanceof Query) {
+                validateResolvableType(p, type);
+                Query query = (Query) annotation;
+                String name = query.value();
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQuery = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof QueryName) {
+                validateResolvableType(p, type);
+                QueryName query = (QueryName) annotation;
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQueryName = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.QueryName<>(converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.QueryName<>(converter, encoded);
+                }
+
+            } else if (annotation instanceof QueryMap) {
+                validateResolvableType(p, type);
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQueryMap = true;
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@QueryMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@QueryMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.QueryMap<>(method, p,
+                        valueConverter, ((QueryMap) annotation).encoded());
+
+            } else if (annotation instanceof Header) {
+                validateResolvableType(p, type);
+                Header header = (Header) annotation;
+                String name = header.value();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Header<>(name, converter);
+                }
+
+            } else if (annotation instanceof HeaderMap) {
+                if (type == Headers.class) {
+                    return new ParameterHandler.Headers(method, p);
+                }
+
+                validateResolvableType(p, type);
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@HeaderMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
+
+            } else if (annotation instanceof Field) {
+                validateResolvableType(p, type);
+                if (!isFormEncoded) {
+                    throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
+                }
+                Field field = (Field) annotation;
+                String name = field.value();
+                boolean encoded = field.encoded();
+
+                gotField = true;
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(method, p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof FieldMap) {
+                validateResolvableType(p, type);
+                if (!isFormEncoded) {
+                    throw parameterError(method, p,
+                            "@FieldMap parameters can only be used with form encoding.");
+                }
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@FieldMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@FieldMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                gotField = true;
+                return new ParameterHandler.FieldMap<>(method, p,
+                        valueConverter, ((FieldMap) annotation).encoded());
+
+            } else if (annotation instanceof Part) {
+                validateResolvableType(p, type);
+                if (!isMultipart) {
+                    throw parameterError(method, p,
+                            "@Part parameters can only be used with multipart encoding.");
+                }
+                Part part = (Part) annotation;
+                gotPart = true;
+
+                String partName = part.value();
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (partName.isEmpty()) {
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(method, p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(method, p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = rawParameterType.getComponentType();
+                        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(method, p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        return ParameterHandler.RawPart.INSTANCE;
+                    } else {
+                        throw parameterError(method, p,
+                                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                    }
+                } else {
+                    Headers headers =
+                            Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                                    "Content-Transfer-Encoding", part.encoding());
+
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(method, p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(method, p,
+                                    "@Part parameters using the MultipartBody.Part must not "
+                                            + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(method, p, headers, converter).iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(method, p,
+                                    "@Part parameters using the MultipartBody.Part must not "
+                                            + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(method, p, headers, converter).array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        throw parameterError(method, p,
+                                "@Part parameters using the MultipartBody.Part must not "
+                                        + "include a part name in the annotation.");
+                    } else {
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(method, p, headers, converter);
+                    }
+                }
+
+            } else if (annotation instanceof PartMap) {
+                validateResolvableType(p, type);
+                if (!isMultipart) {
+                    throw parameterError(method, p,
+                            "@PartMap parameters can only be used with multipart encoding.");
+                }
+                gotPart = true;
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(method, p, "@PartMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(method, p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+                }
+
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+                    throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
+                            + "Use @Part List<Part> or a different value type instead.");
+                }
+
+                Converter<?, RequestBody> valueConverter =
+                        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+                PartMap partMap = (PartMap) annotation;
+                return new ParameterHandler.PartMap<>(method, p, valueConverter, partMap.encoding());
+
+            } else if (annotation instanceof Body) {
+                validateResolvableType(p, type);
+                if (isFormEncoded || isMultipart) {
+                    throw parameterError(method, p,
+                            "@Body parameters cannot be used with form or multi-part encoding.");
+                }
+                if (gotBody) {
+                    throw parameterError(method, p, "Multiple @Body method annotations found.");
+                }
+
+                Converter<?, RequestBody> converter;
+                try {
+                    converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                } catch (RuntimeException e) {
+                    // Wide exception range because factories are user code.
+                    throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
+                }
+                gotBody = true;
+                return new ParameterHandler.Body<>(method, p, converter);
+
+            } else if (annotation instanceof Tag) {
+                validateResolvableType(p, type);
+
+                Class<?> tagType = Utils.getRawType(type);
+                for (int i = p - 1; i >= 0; i--) {
+                    ParameterHandler<?> otherHandler = parameterHandlers[i];
+                    if (otherHandler instanceof ParameterHandler.Tag
+                            && ((ParameterHandler.Tag) otherHandler).cls.equals(tagType)) {
+                        throw parameterError(method, p, "@Tag type "
+                                + tagType.getName()
+                                + " is duplicate of parameter #"
+                                + (i + 1)
+                                + " and would always overwrite its value.");
+                    }
+                }
+
+                return new ParameterHandler.Tag<>(tagType);
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(method, p, headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(method, p,
-                "@Part parameters using the MultipartBody.Part must not "
-                    + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(method, p, headers, converter);
-          }
-        }
 
-      } else if (annotation instanceof PartMap) {
-        validateResolvableType(p, type);
-        if (!isMultipart) {
-          throw parameterError(method, p,
-              "@PartMap parameters can only be used with multipart encoding.");
+            return null; // Not a Retrofit annotation.
         }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(method, p, "@PartMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(method, p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(method, p, "@PartMap keys must be of type String: " + keyType);
+        private void validateResolvableType(int p, Type type) {
+            if (Utils.hasUnresolvableType(type)) {
+                throw parameterError(method, p,
+                        "Parameter type must not include a type variable or wildcard: %s", type);
+            }
         }
 
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(method, p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
+        private void validatePathName(int p, String name) {
+            if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+                throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
+                        PARAM_URL_REGEX.pattern(), name);
+            }
+            // Verify URL replacement name is actually present in the URL path.
+            if (!relativeUrlParamNames.contains(name)) {
+                throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+            }
         }
 
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
-
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(method, p, valueConverter, partMap.encoding());
-
-      } else if (annotation instanceof Body) {
-        validateResolvableType(p, type);
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(method, p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(method, p, "Multiple @Body method annotations found.");
+        /**
+         * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+         * in the URI, it will only show up once in the set.
+         */
+        static Set<String> parsePathParameters(String path) {
+            Matcher m = PARAM_URL_REGEX.matcher(path);
+            Set<String> patterns = new LinkedHashSet<>();
+            while (m.find()) {
+                patterns.add(m.group(1));
+            }
+            return patterns;
         }
 
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
-        }
-        gotBody = true;
-        return new ParameterHandler.Body<>(method, p, converter);
-
-      } else if (annotation instanceof Tag) {
-        validateResolvableType(p, type);
-
-        Class<?> tagType = Utils.getRawType(type);
-        for (int i = p - 1; i >= 0; i--) {
-          ParameterHandler<?> otherHandler = parameterHandlers[i];
-          if (otherHandler instanceof ParameterHandler.Tag
-              && ((ParameterHandler.Tag) otherHandler).cls.equals(tagType)) {
-            throw parameterError(method, p, "@Tag type "
-                + tagType.getName()
-                + " is duplicate of parameter #"
-                + (i + 1)
-                + " and would always overwrite its value.");
-          }
+        private static Class<?> boxIfPrimitive(Class<?> type) {
+            if (boolean.class == type) {
+                return Boolean.class;
+            }
+            if (byte.class == type) {
+                return Byte.class;
+            }
+            if (char.class == type) {
+                return Character.class;
+            }
+            if (double.class == type) {
+                return Double.class;
+            }
+            if (float.class == type) {
+                return Float.class;
+            }
+            if (int.class == type) {
+                return Integer.class;
+            }
+            if (long.class == type) {
+                return Long.class;
+            }
+            if (short.class == type) {
+                return Short.class;
+            }
+            return type;
         }
-
-        return new ParameterHandler.Tag<>(tagType);
-      }
-
-      return null; // Not a Retrofit annotation.
-    }
-
-    private void validateResolvableType(int p, Type type) {
-      if (Utils.hasUnresolvableType(type)) {
-        throw parameterError(method, p,
-            "Parameter type must not include a type variable or wildcard: %s", type);
-      }
-    }
-
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(method, p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
-
-    /**
-     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-     * in the URI, it will only show up once in the set.
-     */
-    static Set<String> parsePathParameters(String path) {
-      Matcher m = PARAM_URL_REGEX.matcher(path);
-      Set<String> patterns = new LinkedHashSet<>();
-      while (m.find()) {
-        patterns.add(m.group(1));
-      }
-      return patterns;
-    }
-
-    private static Class<?> boxIfPrimitive(Class<?> type) {
-      if (boolean.class == type) return Boolean.class;
-      if (byte.class == type) return Byte.class;
-      if (char.class == type) return Character.class;
-      if (double.class == type) return Double.class;
-      if (float.class == type) return Float.class;
-      if (int.class == type) return Integer.class;
-      if (long.class == type) return Long.class;
-      if (short.class == type) return Short.class;
-      return type;
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index a0cc56929..56d6acd5b 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
+
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -59,549 +60,569 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
-
-  final okhttp3.Call.Factory callFactory;
-  final HttpUrl baseUrl;
-  final List<Converter.Factory> converterFactories;
-  final List<CallAdapter.Factory> callAdapterFactories;
-  final @Nullable Executor callbackExecutor;
-  final boolean validateEagerly;
-
-  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> callAdapterFactories,
-      @Nullable Executor callbackExecutor, boolean validateEagerly) {
-    this.callFactory = callFactory;
-    this.baseUrl = baseUrl;
-    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
-    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
-    this.callbackExecutor = callbackExecutor;
-    this.validateEagerly = validateEagerly;
-  }
-
-  /**
-   * Create an implementation of the API endpoints defined by the {@code service} interface.
-   * <p>
-   * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
-   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
-   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
-   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
-   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
-   * parameter with {@link Url @Url}.
-   * <p>
-   * Method parameters can be used to replace parts of the URL by annotating them with
-   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
-   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
-   * {@link retrofit2.http.Query @Query}.
-   * <p>
-   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
-   * object will be converted to request representation by one of the {@link Converter.Factory}
-   * instances. A {@link RequestBody} can also be used for a raw representation.
-   * <p>
-   * Alternative request body formats are supported by method annotations and corresponding
-   * parameter annotations:
-   * <ul>
-   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
-   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
-   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
-   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
-   * </ul>
-   * <p>
-   * Additional static headers can be added for an endpoint using the
-   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
-   * header annotate a parameter with {@link Header @Header}.
-   * <p>
-   * By default, methods return a {@link Call} which represents the HTTP request. The generic
-   * parameter of the call is the response body type and will be converted by one of the
-   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
-   * representation. {@link Void} can be used if you do not care about the body contents.
-   * <p>
-   * For example:
-   * <pre>
-   * public interface CategoryService {
-   *   &#64;POST("category/{cat}/")
-   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
-   * }
-   * </pre>
-   */
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
+    private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
+
+    final okhttp3.Call.Factory callFactory;
+    final HttpUrl baseUrl;
+    final List<Converter.Factory> converterFactories;
+    final List<CallAdapter.Factory> callAdapterFactories;
+    final @Nullable Executor callbackExecutor;
+    final boolean validateEagerly;
+
+    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List<Converter.Factory> converterFactories, List<CallAdapter.Factory> callAdapterFactories, @Nullable Executor callbackExecutor, boolean validateEagerly) {
+        this.callFactory = callFactory;
+        this.baseUrl = baseUrl;
+        // Copy+unmodifiable at call site.
+        this.converterFactories = converterFactories;
+        // Copy+unmodifiable at call site.
+        this.callAdapterFactories = callAdapterFactories;
+        this.callbackExecutor = callbackExecutor;
+        this.validateEagerly = validateEagerly;
     }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new InvocationHandler() {
-          private final Platform platform = Platform.get();
-          private final Object[] emptyArgs = new Object[0];
-
-          @Override public @Nullable Object invoke(Object proxy, Method method,
-              @Nullable Object[] args) throws Throwable {
-            // If the method is a method from Object then defer to normal invocation.
-            if (method.getDeclaringClass() == Object.class) {
-              return method.invoke(this, args);
-            }
-            if (platform.isDefaultMethod(method)) {
-              return platform.invokeDefaultMethod(method, service, proxy, args);
+
+    /**
+     * Create an implementation of the API endpoints defined by the {@code service} interface.
+     * <p>
+     * The relative path for a given method is obtained from an annotation on the method describing
+     * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+     * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+     * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+     * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+     * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+     * parameter with {@link Url @Url}.
+     * <p>
+     * Method parameters can be used to replace parts of the URL by annotating them with
+     * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+     * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+     * {@link retrofit2.http.Query @Query}.
+     * <p>
+     * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+     * object will be converted to request representation by one of the {@link Converter.Factory}
+     * instances. A {@link RequestBody} can also be used for a raw representation.
+     * <p>
+     * Alternative request body formats are supported by method annotations and corresponding
+     * parameter annotations:
+     * <ul>
+     * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+     * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+     * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+     * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+     * </ul>
+     * <p>
+     * Additional static headers can be added for an endpoint using the
+     * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+     * header annotate a parameter with {@link Header @Header}.
+     * <p>
+     * By default, methods return a {@link Call} which represents the HTTP request. The generic
+     * parameter of the call is the response body type and will be converted by one of the
+     * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+     * representation. {@link Void} can be used if you do not care about the body contents.
+     * <p>
+     * For example:
+     * <pre>
+     * public interface CategoryService {
+     *   &#64;POST("category/{cat}/")
+     *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+     * }
+     * </pre>
+     */
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> T create(final Class<T> service) {
+        // 校验 service 是否合法：必须是 interface 且 不能 implements 其他的 interface
+        Utils.validateServiceInterface(service);
+        // 是否立刻对传入的 service 进行解析
+        if (validateEagerly) {
+            eagerlyValidateMethods(service);
+        }
+
+        // 通过 Proxy 获取代理实例
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service}, new InvocationHandler() {
+            private final Platform platform = Platform.get();
+            private final Object[] emptyArgs = new Object[0];
+
+            @Override
+            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {
+                // If the method is a method from Object then defer to normal invocation.
+                if (method.getDeclaringClass() == Object.class) {
+                    return method.invoke(this, args);
+                }
+                if (platform.isDefaultMethod(method)) {
+                    return platform.invokeDefaultMethod(method, service, proxy, args);
+                }
+                return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
             }
-            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
-          }
         });
-  }
-
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
-        loadServiceMethod(method);
-      }
-    }
-  }
-
-  ServiceMethod<?> loadServiceMethod(Method method) {
-    ServiceMethod<?> result = serviceMethodCache.get(method);
-    if (result != null) return result;
-
-    synchronized (serviceMethodCache) {
-      result = serviceMethodCache.get(method);
-      if (result == null) {
-        result = ServiceMethod.parseAnnotations(this, method);
-        serviceMethodCache.put(method, result);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
-   * Typically an instance of {@link OkHttpClient}.
-   */
-  public okhttp3.Call.Factory callFactory() {
-    return callFactory;
-  }
-
-  /** The API base URL. */
-  public HttpUrl baseUrl() {
-    return baseUrl;
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
-   */
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return callAdapterFactories;
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
-    return nextCallAdapter(null, returnType, annotations);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
-      Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = callAdapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
-      CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
-      if (adapter != null) {
-        return adapter;
-      }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(returnType)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns an unmodifiable list of the factories tried when creating a
-   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
-   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
-   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
-   */
-  public List<Converter.Factory> converterFactories() {
-    return converterFactories;
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(
-      @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
-      Annotation[] methodAnnotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
-    checkNotNull(methodAnnotations, "methodAnnotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter.Factory factory = converterFactories.get(i);
-      Converter<?, RequestBody> converter =
-          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, RequestBody>) converter;
-      }
+    // 对传入的 service 进行解析
+    private void eagerlyValidateMethods(Class<?> service) {
+        Platform platform = Platform.get();
+        // 获取 service 上声明的方法
+        for (Method method : service.getDeclaredMethods()) {
+            // 不是 defaultMethod 且不是 static 的
+            if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {
+                loadServiceMethod(method);
+            }
+        }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
-    return nextResponseBodyConverter(null, type, annotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
-      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).responseBodyConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<ResponseBody, T>) converter;
-      }
+    ServiceMethod<?> loadServiceMethod(Method method) {
+        ServiceMethod<?> result = serviceMethodCache.get(method);
+        // 已经存储了 method 对象，返回
+        if (result != null) {
+            return result;
+        }
+
+        synchronized (serviceMethodCache) {
+            result = serviceMethodCache.get(method);
+            if (result == null) {
+                result = ServiceMethod.parseAnnotations(this, method);
+                serviceMethodCache.put(method, result);
+            }
+        }
+        return result;
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link String} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, String>) converter;
-      }
+    /**
+     * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+     * Typically an instance of {@link OkHttpClient}.
+     */
+    public okhttp3.Call.Factory callFactory() {
+        return callFactory;
     }
 
-    // Nothing matched. Resort to default converter which just calls toString().
-    //noinspection unchecked
-    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
-  }
-
-  /**
-   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
-   * in which case callbacks should be made synchronously on the background thread.
-   */
-  public @Nullable Executor callbackExecutor() {
-    return callbackExecutor;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Build a new {@link Retrofit}.
-   * <p>
-   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static final class Builder {
-    private final Platform platform;
-    private @Nullable okhttp3.Call.Factory callFactory;
-    private @Nullable HttpUrl baseUrl;
-    private final List<Converter.Factory> converterFactories = new ArrayList<>();
-    private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>();
-    private @Nullable Executor callbackExecutor;
-    private boolean validateEagerly;
-
-    Builder(Platform platform) {
-      this.platform = platform;
+    /**
+     * The API base URL.
+     */
+    public HttpUrl baseUrl() {
+        return baseUrl;
     }
 
-    public Builder() {
-      this(Platform.get());
+    /**
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+     */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+        return callAdapterFactories;
     }
 
-    Builder(Retrofit retrofit) {
-      platform = Platform.get();
-      callFactory = retrofit.callFactory;
-      baseUrl = retrofit.baseUrl;
-
-      // Do not add the default BuiltIntConverters and platform-aware converters added by build().
-      for (int i = 1,
-          size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();
-          i < size; i++) {
-        converterFactories.add(retrofit.converterFactories.get(i));
-      }
-
-      // Do not add the default, platform-aware call adapters added by build().
-      for (int i = 0,
-          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
-          i < size; i++) {
-        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
-      }
-
-      callbackExecutor = retrofit.callbackExecutor;
-      validateEagerly = retrofit.validateEagerly;
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
+     */
+    public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
+        return nextCallAdapter(null, returnType, annotations);
     }
 
     /**
-     * The HTTP client used for requests.
-     * <p>
-     * This is a convenience method for calling {@link #callFactory}.
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
      */
-    public Builder client(OkHttpClient client) {
-      return callFactory(checkNotNull(client, "client == null"));
+    public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
+                                             Annotation[] annotations) {
+        checkNotNull(returnType, "returnType == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = callAdapterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+            CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
+            if (adapter != null) {
+                return adapter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+                .append(returnType)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = callAdapterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * Specify a custom call factory for creating {@link Call} instances.
-     * <p>
-     * Note: Calling {@link #client} automatically sets this value.
+     * Returns an unmodifiable list of the factories tried when creating a
+     * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+     * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+     * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
      */
-    public Builder callFactory(okhttp3.Call.Factory factory) {
-      this.callFactory = checkNotNull(factory, "factory == null");
-      return this;
+    public List<Converter.Factory> converterFactories() {
+        return converterFactories;
     }
 
     /**
-     * Set the API base URL.
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories}.
      *
-     * @see #baseUrl(HttpUrl)
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      return baseUrl(HttpUrl.get(baseUrl));
+    public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
     }
 
     /**
-     * Set the API base URL.
-     * <p>
-     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
-     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
-     * {@code <a href="">} link on a website resolving on the current URL.
-     * <p>
-     * <b>Base URLs should always end in {@code /}.</b>
-     * <p>
-     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
-     * append themselves to a base which has path components.
-     * <p>
-     * <b>Correct:</b><br>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/api/foo/bar/
-     * <p>
-     * <b>Incorrect:</b><br>
-     * Base URL: http://example.com/api<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * This method enforces that {@code baseUrl} has a trailing {@code /}.
-     * <p>
-     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
-     * <p>
-     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
-     * components.
-     * <p>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * <b>Endpoint values may be a full URL.</b>
-     * <p>
-     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
-     * replace the scheme of {@code baseUrl}.
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: https://github.com/square/retrofit/<br>
-     * Result: https://github.com/square/retrofit/
-     * <p>
-     * Base URL: http://example.com<br>
-     * Endpoint: //github.com/square/retrofit/<br>
-     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      List<String> pathSegments = baseUrl.pathSegments();
-      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
-        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
-      }
-      this.baseUrl = baseUrl;
-      return this;
-    }
-
-    /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory factory) {
-      converterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public <T> Converter<T, RequestBody> nextRequestBodyConverter(
+            @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,
+            Annotation[] methodAnnotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+        checkNotNull(methodAnnotations, "methodAnnotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter.Factory factory = converterFactories.get(i);
+            Converter<?, RequestBody> converter =
+                    factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, RequestBody>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * Add a call adapter factory for supporting service method return types other than {@link
-     * Call}.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      callAdapterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+        return nextResponseBodyConverter(null, type, annotations);
     }
 
     /**
-     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
-     * your service method.
-     * <p>
-     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
-     * return types}.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder callbackExecutor(Executor executor) {
-      this.callbackExecutor = checkNotNull(executor, "executor == null");
-      return this;
+    public <T> Converter<ResponseBody, T> nextResponseBodyConverter(
+            @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter<ResponseBody, ?> converter =
+                    converterFactories.get(i).responseBodyConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<ResponseBody, T>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
-    /** Returns a modifiable list of call adapter factories. */
-    public List<CallAdapter.Factory> callAdapterFactories() {
-      return this.callAdapterFactories;
-    }
+    /**
+     * Returns a {@link Converter} for {@code type} to {@link String} from the available
+     * {@linkplain #converterFactories() factories}.
+     */
+    public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<?, String> converter =
+                    converterFactories.get(i).stringConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, String>) converter;
+            }
+        }
 
-    /** Returns a modifiable list of converter factories. */
-    public List<Converter.Factory> converterFactories() {
-      return this.converterFactories;
+        // Nothing matched. Resort to default converter which just calls toString().
+        //noinspection unchecked
+        return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
     }
 
     /**
-     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
-     * the configuration of all methods in the supplied interface.
+     * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+     * in which case callbacks should be made synchronously on the background thread.
      */
-    public Builder validateEagerly(boolean validateEagerly) {
-      this.validateEagerly = validateEagerly;
-      return this;
+    public @Nullable
+    Executor callbackExecutor() {
+        return callbackExecutor;
+    }
+
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
     /**
-     * Create the {@link Retrofit} instance using the configured values.
+     * Build a new {@link Retrofit}.
      * <p>
-     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
-     * OkHttpClient} will be created and used.
+     * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+     * are optional.
      */
-    public Retrofit build() {
-      if (baseUrl == null) {
-        throw new IllegalStateException("Base URL required.");
-      }
-
-      okhttp3.Call.Factory callFactory = this.callFactory;
-      if (callFactory == null) {
-        callFactory = new OkHttpClient();
-      }
-
-      Executor callbackExecutor = this.callbackExecutor;
-      if (callbackExecutor == null) {
-        callbackExecutor = platform.defaultCallbackExecutor();
-      }
-
-      // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
-      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
-
-      // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(
-          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
-
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
-      converterFactories.addAll(this.converterFactories);
-      converterFactories.addAll(platform.defaultConverterFactories());
-
-      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
-          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
+    public static final class Builder {
+        // 平台类型（Android、Java）以及平台相关的属性
+        private final Platform platform;
+        // 构建 OKHttp 请求的 Call
+        private @Nullable okhttp3.Call.Factory callFactory;
+        // URL 前缀，形如 https://api.github.com
+        private @Nullable HttpUrl baseUrl;
+        // 所有的 Converter 集合
+        private final List<Converter.Factory> converterFactories = new ArrayList<>();
+        // 所有的 CallAdapter 集合
+        private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>();
+        // 用于处理结果回调的 Executor
+        private @Nullable Executor callbackExecutor;
+        // 是否立刻对传入的 service 进行解析
+        private boolean validateEagerly;
+
+        Builder(Platform platform) {
+            this.platform = platform;
+        }
+
+        public Builder() {
+            this(Platform.get());
+        }
+
+
+        Builder(Retrofit retrofit) {
+            platform = Platform.get();
+            callFactory = retrofit.callFactory;
+            baseUrl = retrofit.baseUrl;
+
+            // Do not add the default BuiltIntConverters and platform-aware converters added by build().
+            for (int i = 1, size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize(); i < size; i++) {
+                converterFactories.add(retrofit.converterFactories.get(i));
+            }
+
+            // Do not add the default, platform-aware call adapters added by build().
+            for (int i = 0, size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize(); i < size; i++) {
+                callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
+            }
+
+            callbackExecutor = retrofit.callbackExecutor;
+            validateEagerly = retrofit.validateEagerly;
+        }
+
+        /**
+         * The HTTP client used for requests.
+         * <p>
+         * This is a convenience method for calling {@link #callFactory}.
+         */
+        public Builder client(OkHttpClient client) {
+            return callFactory(checkNotNull(client, "client == null"));
+        }
+
+        /**
+         * Specify a custom call factory for creating {@link Call} instances.
+         * <p>
+         * Note: Calling {@link #client} automatically sets this value.
+         */
+        public Builder callFactory(okhttp3.Call.Factory factory) {
+            this.callFactory = checkNotNull(factory, "factory == null");
+            return this;
+        }
+
+        /**
+         * Set the API base URL.
+         *
+         * @see #baseUrl(HttpUrl)
+         */
+        public Builder baseUrl(String baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            return baseUrl(HttpUrl.get(baseUrl));
+        }
+
+        /**
+         * Set the API base URL.
+         * <p>
+         * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+         * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+         * {@code <a href="">} link on a website resolving on the current URL.
+         * <p>
+         * <b>Base URLs should always end in {@code /}.</b>
+         * <p>
+         * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+         * append themselves to a base which has path components.
+         * <p>
+         * <b>Correct:</b><br>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/api/foo/bar/
+         * <p>
+         * <b>Incorrect:</b><br>
+         * Base URL: http://example.com/api<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * This method enforces that {@code baseUrl} has a trailing {@code /}.
+         * <p>
+         * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+         * <p>
+         * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+         * components.
+         * <p>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * <b>Endpoint values may be a full URL.</b>
+         * <p>
+         * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+         * replace the scheme of {@code baseUrl}.
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: https://github.com/square/retrofit/<br>
+         * Result: https://github.com/square/retrofit/
+         * <p>
+         * Base URL: http://example.com<br>
+         * Endpoint: //github.com/square/retrofit/<br>
+         * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+         */
+        public Builder baseUrl(HttpUrl baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            List<String> pathSegments = baseUrl.pathSegments();
+            if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+                throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+            }
+            this.baseUrl = baseUrl;
+            return this;
+        }
+
+        /**
+         * Add converter factory for serialization and deserialization of objects.
+         */
+        public Builder addConverterFactory(Converter.Factory factory) {
+            converterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * Add a call adapter factory for supporting service method return types other than {@link
+         * Call}.
+         */
+        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+            callAdapterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+         * your service method.
+         * <p>
+         * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+         * return types}.
+         */
+        public Builder callbackExecutor(Executor executor) {
+            this.callbackExecutor = checkNotNull(executor, "executor == null");
+            return this;
+        }
+
+        /**
+         * Returns a modifiable list of call adapter factories.
+         */
+        public List<CallAdapter.Factory> callAdapterFactories() {
+            return this.callAdapterFactories;
+        }
+
+        /**
+         * Returns a modifiable list of converter factories.
+         */
+        public List<Converter.Factory> converterFactories() {
+            return this.converterFactories;
+        }
+
+        /**
+         * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+         * the configuration of all methods in the supplied interface.
+         */
+        public Builder validateEagerly(boolean validateEagerly) {
+            this.validateEagerly = validateEagerly;
+            return this;
+        }
+
+        /**
+         * Create the {@link Retrofit} instance using the configured values.
+         * <p>
+         * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+         * OkHttpClient} will be created and used.
+         */
+        public Retrofit build() {
+            if (baseUrl == null) {
+                throw new IllegalStateException("Base URL required.");
+            }
+
+            okhttp3.Call.Factory callFactory = this.callFactory;
+            if (callFactory == null) {
+                callFactory = new OkHttpClient();
+            }
+
+            Executor callbackExecutor = this.callbackExecutor;
+            if (callbackExecutor == null) {
+                callbackExecutor = platform.defaultCallbackExecutor();
+            }
+
+            // Make a defensive copy of the adapters and add the default Call adapter.
+            List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
+            callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
+
+            // Make a defensive copy of the converters.
+            List<Converter.Factory> converterFactories = new ArrayList<>(1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
+
+            // Add the built-in converter factory first. This prevents overriding its behavior but also
+            // ensures correct behavior when using converters that consume all types.
+            converterFactories.add(new BuiltInConverters());
+            converterFactories.addAll(this.converterFactories);
+            converterFactories.addAll(platform.defaultConverterFactories());
+
+            return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 758511f5f..dc47ddb04 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -22,20 +22,29 @@
 import static retrofit2.Utils.methodError;
 
 abstract class ServiceMethod<T> {
-  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
-    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+    /**
+     * 解析 method 上声明的注解
+     *
+     * @param retrofit
+     * @param method
+     * @param <T>
+     * @return
+     */
+    static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {
 
-    Type returnType = method.getGenericReturnType();
-    if (Utils.hasUnresolvableType(returnType)) {
-      throw methodError(method,
-          "Method return type must not include a type variable or wildcard: %s", returnType);
-    }
-    if (returnType == void.class) {
-      throw methodError(method, "Service methods cannot return void.");
-    }
+        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
+
+        Type returnType = method.getGenericReturnType();
+        if (Utils.hasUnresolvableType(returnType)) {
+            throw methodError(method, "Method return type must not include a type variable or wildcard: %s", returnType);
+        }
 
-    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
-  }
+        if (returnType == void.class) {
+            throw methodError(method, "Service methods cannot return void.");
+        }
+
+        return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
+    }
 
-  abstract @Nullable T invoke(Object[] args);
+    abstract @Nullable T invoke(Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 25fdcbf5e..3cb603236 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -28,502 +28,524 @@
 import java.util.Arrays;
 import java.util.NoSuchElementException;
 import javax.annotation.Nullable;
+
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
 final class Utils {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
-
-  private Utils() {
-    // No instances.
-  }
-
-  static RuntimeException methodError(Method method, String message, Object... args) {
-    return methodError(method, null, message, args);
-  }
-
-  static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
-      Object... args) {
-    message = String.format(message, args);
-    return new IllegalArgumentException(message
-        + "\n    for method "
-        + method.getDeclaringClass().getSimpleName()
-        + "."
-        + method.getName(), cause);
-  }
-
-  static RuntimeException parameterError(Method method,
-      Throwable cause, int p, String message, Object... args) {
-    return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
-  }
-
-  static RuntimeException parameterError(Method method, int p, String message, Object... args) {
-    return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
-  }
-
-  static Class<?> getRawType(Type type) {
-    checkNotNull(type, "type == null");
-
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-    }
-    if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-    }
-    if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
+    static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+    private Utils() {
+        // No instances.
     }
-    if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    static RuntimeException methodError(Method method, String message, Object... args) {
+        return methodError(method, null, message, args);
     }
 
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      Object ownerA = pa.getOwnerType();
-      Object ownerB = pb.getOwnerType();
-      return (ownerA == ownerB || (ownerA != null && ownerA.equals(ownerB)))
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
+    static RuntimeException methodError(Method method, @Nullable Throwable cause, String message,
+                                        Object... args) {
+        message = String.format(message, args);
+        return new IllegalArgumentException(message
+                + "\n    for method "
+                + method.getDeclaringClass().getSimpleName()
+                + "."
+                + method.getName(), cause);
     }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
+
+    static RuntimeException parameterError(Method method,
+                                           Throwable cause, int p, String message, Object... args) {
+        return methodError(method, cause, message + " (parameter #" + (p + 1) + ")", args);
     }
 
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
+    static RuntimeException parameterError(Method method, int p, String message, Object... args) {
+        return methodError(method, message + " (parameter #" + (p + 1) + ")", args);
     }
 
-    // We can't resolve this further.
-    return toResolve;
-  }
+    static Class<?> getRawType(Type type) {
+        checkNotNull(type, "type == null");
 
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
-    }
-    throw new NoSuchElementException();
-  }
-
-  static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
+        if (type instanceof Class<?>) {
+            // Type is a normal class.
+            return (Class<?>) type;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+
+            // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+            // suspects some pathological case related to nested classes exists.
+            Type rawType = parameterizedType.getRawType();
+            if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+            return (Class<?>) rawType;
+        }
+        if (type instanceof GenericArrayType) {
+            Type componentType = ((GenericArrayType) type).getGenericComponentType();
+            return Array.newInstance(getRawType(componentType), 0).getClass();
+        }
+        if (type instanceof TypeVariable) {
+            // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+            // type that's more general than necessary is okay.
+            return Object.class;
+        }
+        if (type instanceof WildcardType) {
+            return getRawType(((WildcardType) type).getUpperBounds()[0]);
         }
 
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+    }
+
+    /**
+     * Returns true if {@code a} and {@code b} are equal.
+     */
+    static boolean equals(Type a, Type b) {
+        if (a == b) {
+            return true; // Also handles (a == null && b == null).
+
+        } else if (a instanceof Class) {
+            return a.equals(b); // Class already specifies equals().
+
+        } else if (a instanceof ParameterizedType) {
+            if (!(b instanceof ParameterizedType)) return false;
+            ParameterizedType pa = (ParameterizedType) a;
+            ParameterizedType pb = (ParameterizedType) b;
+            Object ownerA = pa.getOwnerType();
+            Object ownerB = pb.getOwnerType();
+            return (ownerA == ownerB || (ownerA != null && ownerA.equals(ownerB)))
+                    && pa.getRawType().equals(pb.getRawType())
+                    && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+        } else if (a instanceof GenericArrayType) {
+            if (!(b instanceof GenericArrayType)) return false;
+            GenericArrayType ga = (GenericArrayType) a;
+            GenericArrayType gb = (GenericArrayType) b;
+            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+        } else if (a instanceof WildcardType) {
+            if (!(b instanceof WildcardType)) return false;
+            WildcardType wa = (WildcardType) a;
+            WildcardType wb = (WildcardType) b;
+            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+                    && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+        } else if (a instanceof TypeVariable) {
+            if (!(b instanceof TypeVariable)) return false;
+            TypeVariable<?> va = (TypeVariable<?>) a;
+            TypeVariable<?> vb = (TypeVariable<?>) b;
+            return va.getGenericDeclaration() == vb.getGenericDeclaration()
+                    && va.getName().equals(vb.getName());
+
+        } else {
+            return false; // This isn't a type we support!
+        }
+    }
 
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
+    /**
+     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+     */
+    static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+        if (toResolve == rawType) return context;
+
+        // We skip searching through interfaces if unknown is an interface.
+        if (toResolve.isInterface()) {
+            Class<?>[] interfaces = rawType.getInterfaces();
+            for (int i = 0, length = interfaces.length; i < length; i++) {
+                if (interfaces[i] == toResolve) {
+                    return rawType.getGenericInterfaces()[i];
+                } else if (toResolve.isAssignableFrom(interfaces[i])) {
+                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+                }
+            }
+        }
 
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
+        // Check our supertypes.
+        if (!rawType.isInterface()) {
+            while (rawType != Object.class) {
+                Class<?> rawSupertype = rawType.getSuperclass();
+                if (rawSupertype == toResolve) {
+                    return rawType.getGenericSuperclass();
+                } else if (toResolve.isAssignableFrom(rawSupertype)) {
+                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+                }
+                rawType = rawSupertype;
+            }
         }
-        return original;
 
-      } else {
+        // We can't resolve this further.
         return toResolve;
-      }
     }
-  }
 
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
+    private static int indexOf(Object[] array, Object toFind) {
+        for (int i = 0; i < array.length; i++) {
+            if (toFind.equals(array[i])) return i;
+        }
+        throw new NoSuchElementException();
+    }
+
+    static String typeToString(Type type) {
+        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+    }
+
+    /**
+     * Returns the generic form of {@code supertype}. For example, if this is {@code
+     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+     * Iterable.class}.
+     *
+     * @param supertype a superclass of, or interface implemented by, this.
+     */
+    static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+        if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+        return resolve(context, contextRawType,
+                getGenericSupertype(context, contextRawType, supertype));
+    }
+
+    static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+        // This implementation is made a little more complicated in an attempt to avoid object-creation.
+        while (true) {
+            if (toResolve instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+                if (toResolve == typeVariable) {
+                    return toResolve;
+                }
+
+            } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+                Class<?> original = (Class<?>) toResolve;
+                Type componentType = original.getComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof GenericArrayType) {
+                GenericArrayType original = (GenericArrayType) toResolve;
+                Type componentType = original.getGenericComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof ParameterizedType) {
+                ParameterizedType original = (ParameterizedType) toResolve;
+                Type ownerType = original.getOwnerType();
+                Type newOwnerType = resolve(context, contextRawType, ownerType);
+                boolean changed = newOwnerType != ownerType;
+
+                Type[] args = original.getActualTypeArguments();
+                for (int t = 0, length = args.length; t < length; t++) {
+                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+                    if (resolvedTypeArgument != args[t]) {
+                        if (!changed) {
+                            args = args.clone();
+                            changed = true;
+                        }
+                        args[t] = resolvedTypeArgument;
+                    }
+                }
+
+                return changed
+                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+                        : original;
+
+            } else if (toResolve instanceof WildcardType) {
+                WildcardType original = (WildcardType) toResolve;
+                Type[] originalLowerBound = original.getLowerBounds();
+                Type[] originalUpperBound = original.getUpperBounds();
+
+                if (originalLowerBound.length == 1) {
+                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+                    if (lowerBound != originalLowerBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{Object.class}, new Type[]{lowerBound});
+                    }
+                } else if (originalUpperBound.length == 1) {
+                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+                    if (upperBound != originalUpperBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{upperBound}, EMPTY_TYPE_ARRAY);
+                    }
+                }
+                return original;
+
+            } else {
+                return toResolve;
+            }
+        }
+    }
 
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
+    private static Type resolveTypeVariable(
+            Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+        Class<?> declaredByRaw = declaringClassOf(unknown);
 
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
+        // We can't reduce this further.
+        if (declaredByRaw == null) return unknown;
 
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static @Nullable Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
-    }
-  }
+        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+        if (declaredBy instanceof ParameterizedType) {
+            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+        }
 
-  static <T> T checkNotNull(@Nullable T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
-    }
-    return object;
-  }
-
-  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
-  static boolean isAnnotationPresent(Annotation[] annotations,
-      Class<? extends Annotation> cls) {
-    for (Annotation annotation : annotations) {
-      if (cls.isInstance(annotation)) {
-        return true;
-      }
+        return unknown;
     }
-    return false;
-  }
-
-  static ResponseBody buffer(final ResponseBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.source().readAll(buffer);
-    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
-  }
-
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("API declarations must be interfaces.");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
-    }
-  }
 
-  static Type getParameterUpperBound(int index, ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    if (index < 0 || index >= types.length) {
-      throw new IllegalArgumentException(
-          "Index " + index + " not in range [0," + types.length + ") for " + type);
-    }
-    Type paramType = types[index];
-    if (paramType instanceof WildcardType) {
-      return ((WildcardType) paramType).getUpperBounds()[0];
+    /**
+     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+     * a class.
+     */
+    private static @Nullable
+    Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
     }
-    return paramType;
-  }
 
-  static Type getParameterLowerBound(int index, ParameterizedType type) {
-    Type paramType = type.getActualTypeArguments()[index];
-    if (paramType instanceof WildcardType) {
-      return ((WildcardType) paramType).getLowerBounds()[0];
+    static void checkNotPrimitive(Type type) {
+        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+            throw new IllegalArgumentException();
+        }
     }
-    return paramType;
-  }
 
-  static boolean hasUnresolvableType(@Nullable Type type) {
-    if (type instanceof Class<?>) {
-      return false;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
-        if (hasUnresolvableType(typeArgument)) {
-          return true;
-        }
-      }
-      return false;
-    }
-    if (type instanceof GenericArrayType) {
-      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
-    }
-    if (type instanceof TypeVariable) {
-      return true;
-    }
-    if (type instanceof WildcardType) {
-      return true;
-    }
-    String className = type == null ? "null" : type.getClass().getName();
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-        + "GenericArrayType, but <" + type + "> is of type " + className);
-  }
-
-  static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final @Nullable Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      for (Type typeArgument : typeArguments) {
-        checkNotNull(typeArgument, "typeArgument == null");
-        checkNotPrimitive(typeArgument);
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
+    static <T> T checkNotNull(@Nullable T object, String message) {
+        if (object == null) {
+            throw new NullPointerException(message);
+        }
+        return object;
     }
 
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
+    /**
+     * Returns true if {@code annotations} contains an instance of {@code cls}.
+     */
+    static boolean isAnnotationPresent(Annotation[] annotations,
+                                       Class<? extends Annotation> cls) {
+        for (Annotation annotation : annotations) {
+            if (cls.isInstance(annotation)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    @Override public Type getRawType() {
-      return rawType;
+    static ResponseBody buffer(final ResponseBody body) throws IOException {
+        Buffer buffer = new Buffer();
+        body.source().readAll(buffer);
+        return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
     }
 
-    @Override public @Nullable Type getOwnerType() {
-      return ownerType;
+    static <T> void validateServiceInterface(Class<T> service) {
+        if (!service.isInterface()) {
+            throw new IllegalArgumentException("API declarations must be interfaces.");
+        }
+        // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+        // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+        // the recommended pattern.
+        if (service.getInterfaces().length > 0) {
+            throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+        }
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    static Type getParameterUpperBound(int index, ParameterizedType type) {
+        Type[] types = type.getActualTypeArguments();
+        if (index < 0 || index >= types.length) {
+            throw new IllegalArgumentException(
+                    "Index " + index + " not in range [0," + types.length + ") for " + type);
+        }
+        Type paramType = types[index];
+        if (paramType instanceof WildcardType) {
+            return ((WildcardType) paramType).getUpperBounds()[0];
+        }
+        return paramType;
     }
 
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments)
-          ^ rawType.hashCode()
-          ^ (ownerType != null ? ownerType.hashCode() : 0);
+    static Type getParameterLowerBound(int index, ParameterizedType type) {
+        Type paramType = type.getActualTypeArguments()[index];
+        if (paramType instanceof WildcardType) {
+            return ((WildcardType) paramType).getLowerBounds()[0];
+        }
+        return paramType;
     }
 
-    @Override public String toString() {
-      if (typeArguments.length == 0) return typeToString(rawType);
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
+    static boolean hasUnresolvableType(@Nullable Type type) {
+        if (type instanceof Class<?>) {
+            return false;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+                if (hasUnresolvableType(typeArgument)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        if (type instanceof GenericArrayType) {
+            return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+        }
+        if (type instanceof TypeVariable) {
+            return true;
+        }
+        if (type instanceof WildcardType) {
+            return true;
+        }
+        String className = type == null ? "null" : type.getClass().getName();
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + className);
     }
-  }
 
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
+    static final class ParameterizedTypeImpl implements ParameterizedType {
+        private final @Nullable Type ownerType;
+        private final Type rawType;
+        private final Type[] typeArguments;
 
-    GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
+        ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
+            // Require an owner type if the raw type needs it.
+            if (rawType instanceof Class<?>
+                    && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+                throw new IllegalArgumentException();
+            }
 
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
+            for (Type typeArgument : typeArguments) {
+                checkNotNull(typeArgument, "typeArgument == null");
+                checkNotPrimitive(typeArgument);
+            }
 
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Utils.equals(this, (GenericArrayType) o);
-    }
+            this.ownerType = ownerType;
+            this.rawType = rawType;
+            this.typeArguments = typeArguments.clone();
+        }
 
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
+        @Override
+        public Type[] getActualTypeArguments() {
+            return typeArguments.clone();
+        }
 
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final @Nullable Type lowerBound;
-
-    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
+        @Override
+        public Type getRawType() {
+            return rawType;
+        }
 
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
+        @Override
+        public @Nullable
+        Type getOwnerType() {
+            return ownerType;
+        }
 
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+        }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(typeArguments)
+                    ^ rawType.hashCode()
+                    ^ (ownerType != null ? ownerType.hashCode() : 0);
+        }
+
+        @Override
+        public String toString() {
+            if (typeArguments.length == 0) return typeToString(rawType);
+            StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+            result.append(typeToString(rawType));
+            result.append("<").append(typeToString(typeArguments[0]));
+            for (int i = 1; i < typeArguments.length; i++) {
+                result.append(", ").append(typeToString(typeArguments[i]));
+            }
+            return result.append(">").toString();
+        }
     }
 
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    private static final class GenericArrayTypeImpl implements GenericArrayType {
+        private final Type componentType;
+
+        GenericArrayTypeImpl(Type componentType) {
+            this.componentType = componentType;
+        }
+
+        @Override
+        public Type getGenericComponentType() {
+            return componentType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof GenericArrayType
+                    && Utils.equals(this, (GenericArrayType) o);
+        }
+
+        @Override
+        public int hashCode() {
+            return componentType.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return typeToString(componentType) + "[]";
+        }
     }
 
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
+    /**
+     * The WildcardType interface supports multiple upper bounds and multiple
+     * lower bounds. We only support what the Java 6 language needs - at most one
+     * bound. If a lower bound is set, the upper bound must be Object.class.
+     */
+    private static final class WildcardTypeImpl implements WildcardType {
+        private final Type upperBound;
+        private final @Nullable Type lowerBound;
+
+        WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+            if (lowerBounds.length > 1) throw new IllegalArgumentException();
+            if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+            if (lowerBounds.length == 1) {
+                if (lowerBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(lowerBounds[0]);
+                if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+                this.lowerBound = lowerBounds[0];
+                this.upperBound = Object.class;
+            } else {
+                if (upperBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(upperBounds[0]);
+                this.lowerBound = null;
+                this.upperBound = upperBounds[0];
+            }
+        }
+
+        @Override
+        public Type[] getUpperBounds() {
+            return new Type[]{upperBound};
+        }
+
+        @Override
+        public Type[] getLowerBounds() {
+            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        }
+
+        @Override
+        public String toString() {
+            if (lowerBound != null) return "? super " + typeToString(lowerBound);
+            if (upperBound == Object.class) return "?";
+            return "? extends " + typeToString(upperBound);
+        }
     }
-  }
-
-  // https://github.com/ReactiveX/RxJava/blob/6a44e5d0543a48f1c378dc833a155f3f71333bc2/
-  // src/main/java/io/reactivex/exceptions/Exceptions.java#L66
-  static void throwIfFatal(Throwable t) {
-    if (t instanceof VirtualMachineError) {
-      throw (VirtualMachineError) t;
-    } else if (t instanceof ThreadDeath) {
-      throw (ThreadDeath) t;
-    } else if (t instanceof LinkageError) {
-      throw (LinkageError) t;
+
+    // https://github.com/ReactiveX/RxJava/blob/6a44e5d0543a48f1c378dc833a155f3f71333bc2/
+    // src/main/java/io/reactivex/exceptions/Exceptions.java#L66
+    static void throwIfFatal(Throwable t) {
+        if (t instanceof VirtualMachineError) {
+            throw (VirtualMachineError) t;
+        } else if (t instanceof ThreadDeath) {
+            throw (ThreadDeath) t;
+        } else if (t instanceof LinkageError) {
+            throw (LinkageError) t;
+        }
     }
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 7c8a98e37..c0a4b9940 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -1,109 +1,113 @@
-// Copyright 2013 Square, Inc.
-package com.example.retrofit;
-
-import com.example.retrofit.SimpleService.Contributor;
-import com.example.retrofit.SimpleService.GitHub;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import retrofit2.Call;
-import retrofit2.Retrofit;
-import retrofit2.mock.BehaviorDelegate;
-import retrofit2.mock.MockRetrofit;
-import retrofit2.mock.NetworkBehavior;
-
-/**
- * An example of using {@link MockRetrofit} to create a mock service implementation with
- * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
- */
-public final class SimpleMockService {
-  /** A mock implementation of the {@link GitHub} API interface. */
-  static final class MockGitHub implements GitHub {
-    private final BehaviorDelegate<GitHub> delegate;
-    private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
-
-    MockGitHub(BehaviorDelegate<GitHub> delegate) {
-      this.delegate = delegate;
-      ownerRepoContributors = new LinkedHashMap<>();
-
-      // Seed some mock data.
-      addContributor("square", "retrofit", "John Doe", 12);
-      addContributor("square", "retrofit", "Bob Smith", 2);
-      addContributor("square", "retrofit", "Big Bird", 40);
-      addContributor("square", "picasso", "Proposition Joe", 39);
-      addContributor("square", "picasso", "Keiser Soze", 152);
-    }
-
-    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
-      List<Contributor> response = Collections.emptyList();
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors != null) {
-        List<Contributor> contributors = repoContributors.get(repo);
-        if (contributors != null) {
-          response = contributors;
-        }
-      }
-      return delegate.returningResponse(response).contributors(owner, repo);
-    }
-
-    void addContributor(String owner, String repo, String name, int contributions) {
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<>();
-        ownerRepoContributors.put(owner, repoContributors);
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        contributors = new ArrayList<>();
-        repoContributors.put(repo, contributors);
-      }
-      contributors.add(new Contributor(name, contributions));
-    }
-  }
-
-  public static void main(String... args) throws IOException {
-    // Create a very simple Retrofit adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(SimpleService.API_URL)
-        .build();
-
-    // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
-    NetworkBehavior behavior = NetworkBehavior.create();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-
-    BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
-    MockGitHub gitHub = new MockGitHub(delegate);
-
-    // Query for some contributors for a few repositories.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-
-    // Using the mock-only methods, add some additional data.
-    System.out.println("Adding more mock data...\n");
-    gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
-    gitHub.addContributor("square", "picasso", "Kit Kat", 53);
-
-    // Reduce the delay to make the next calls complete faster.
-    behavior.setDelay(500, TimeUnit.MILLISECONDS);
-
-    // Query for the contributors again so we can see the mock data that was added.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-  }
-
-  private static void printContributors(GitHub gitHub, String owner, String repo)
-      throws IOException {
-    System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors.execute().body()) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
-    }
-    System.out.println();
-  }
-}
+//// Copyright 2013 Square, Inc.
+//package com.example.retrofit;
+//
+//import com.example.retrofit.SimpleService.Contributor;
+//import com.example.retrofit.SimpleService.GitHub;
+//
+//import java.io.IOException;
+//import java.util.ArrayList;
+//import java.util.Collections;
+//import java.util.LinkedHashMap;
+//import java.util.List;
+//import java.util.Map;
+//import java.util.concurrent.TimeUnit;
+//
+//import retrofit2.Call;
+//import retrofit2.Retrofit;
+//import retrofit2.mock.BehaviorDelegate;
+//import retrofit2.mock.MockRetrofit;
+//import retrofit2.mock.NetworkBehavior;
+//
+///**
+// * An example of using {@link MockRetrofit} to create a mock service implementation with
+// * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
+// */
+//public final class SimpleMockService {
+//    /**
+//     * A mock implementation of the {@link GitHub} API interface.
+//     */
+//    static final class MockGitHub implements GitHub {
+//        private final BehaviorDelegate<GitHub> delegate;
+//        private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
+//
+//        MockGitHub(BehaviorDelegate<GitHub> delegate) {
+//            this.delegate = delegate;
+//            ownerRepoContributors = new LinkedHashMap<>();
+//
+//            // Seed some mock data.
+//            addContributor("square", "retrofit", "John Doe", 12);
+//            addContributor("square", "retrofit", "Bob Smith", 2);
+//            addContributor("square", "retrofit", "Big Bird", 40);
+//            addContributor("square", "picasso", "Proposition Joe", 39);
+//            addContributor("square", "picasso", "Keiser Soze", 152);
+//        }
+//
+//        @Override public Call<List<Contributor>> contributors(String owner, String repo) {
+//            List<Contributor> response = Collections.emptyList();
+//            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+//            if (repoContributors != null) {
+//                List<Contributor> contributors = repoContributors.get(repo);
+//                if (contributors != null) {
+//                    response = contributors;
+//                }
+//            }
+//            return delegate.returningResponse(response).contributors(owner, repo);
+//        }
+//
+//        void addContributor(String owner, String repo, String name, int contributions) {
+//            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+//            if (repoContributors == null) {
+//                repoContributors = new LinkedHashMap<>();
+//                ownerRepoContributors.put(owner, repoContributors);
+//            }
+//            List<Contributor> contributors = repoContributors.get(repo);
+//            if (contributors == null) {
+//                contributors = new ArrayList<>();
+//                repoContributors.put(repo, contributors);
+//            }
+//            contributors.add(new Contributor(name, contributions));
+//        }
+//    }
+//
+//    public static void main(String... args) throws IOException {
+//        // Create a very simple Retrofit adapter which points the GitHub API.
+//        Retrofit retrofit = new Retrofit.Builder()
+//                .baseUrl(SimpleService.API_URL)
+//                .build();
+//
+//        // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
+//        NetworkBehavior behavior = NetworkBehavior.create();
+//        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+//                .networkBehavior(behavior)
+//                .build();
+//
+//        BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
+//        MockGitHub gitHub = new MockGitHub(delegate);
+//
+//        // Query for some contributors for a few repositories.
+//        printContributors(gitHub, "square", "retrofit");
+//        printContributors(gitHub, "square", "picasso");
+//
+//        // Using the mock-only methods, add some additional data.
+//        System.out.println("Adding more mock data...\n");
+//        gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+//        gitHub.addContributor("square", "picasso", "Kit Kat", 53);
+//
+//        // Reduce the delay to make the next calls complete faster.
+//        behavior.setDelay(500, TimeUnit.MILLISECONDS);
+//
+//        // Query for the contributors again so we can see the mock data that was added.
+//        printContributors(gitHub, "square", "retrofit");
+//        printContributors(gitHub, "square", "picasso");
+//    }
+//
+//    private static void printContributors(GitHub gitHub, String owner, String repo)
+//            throws IOException {
+//        System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
+//        Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+//        for (Contributor contributor : contributors.execute().body()) {
+//            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+//        }
+//        System.out.println();
+//    }
+//}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index ef5a3060e..566a31df5 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -17,49 +17,101 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import retrofit2.Call;
+import retrofit2.Response;
 import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import retrofit2.http.Path;
 
 public final class SimpleService {
-  public static final String API_URL = "https://api.github.com";
+    public static final String API_URL = "https://api.github.com";
+
+    public static class Contributor {
+        public final String login;
+        public final int contributions;
+        public final String message;
+        public final String documentation_url;
+        public int id;
+        public String node_id;
+        public String avatar_url;
+        public String gravatar_id;
+        public String url;
+        public String html_url;
+        public String followers_url;
+        public String following_url;
+        public String gists_url;
+        public String starred_url;
+        public String subscriptions_url;
+        public String organizations_url;
+        public String repos_url;
+        public String events_url;
+        public String received_events_url;
+        public String type;
+        public boolean site_admin;
 
-  public static class Contributor {
-    public final String login;
-    public final int contributions;
+        public Contributor(String login, int contributions, String message, String documentation_url) {
+            this.login = login;
+            this.contributions = contributions;
+            this.message = message;
+            this.documentation_url = documentation_url;
+        }
 
-    public Contributor(String login, int contributions) {
-      this.login = login;
-      this.contributions = contributions;
+        @Override public String toString() {
+            return "Contributor{" +
+                    "login='" + login + '\'' +
+                    ", contributions=" + contributions +
+                    ", id=" + id +
+                    ", node_id='" + node_id + '\'' +
+                    ", avatar_url='" + avatar_url + '\'' +
+                    ", gravatar_id='" + gravatar_id + '\'' +
+                    ", url='" + url + '\'' +
+                    ", html_url='" + html_url + '\'' +
+                    ", followers_url='" + followers_url + '\'' +
+                    ", following_url='" + following_url + '\'' +
+                    ", gists_url='" + gists_url + '\'' +
+                    ", starred_url='" + starred_url + '\'' +
+                    ", subscriptions_url='" + subscriptions_url + '\'' +
+                    ", organizations_url='" + organizations_url + '\'' +
+                    ", repos_url='" + repos_url + '\'' +
+                    ", events_url='" + events_url + '\'' +
+                    ", received_events_url='" + received_events_url + '\'' +
+                    ", type='" + type + '\'' +
+                    ", site_admin=" + site_admin +
+                    '}';
+        }
     }
-  }
 
-  public interface GitHub {
-    @GET("/repos/{owner}/{repo}/contributors")
-    Call<List<Contributor>> contributors(
-        @Path("owner") String owner,
-        @Path("repo") String repo);
-  }
+    public interface GitHub {
+        @GET("/repos/{owner}/{repo}/contributors")
+        Call<List<Contributor>> contributors(
+                @Path("owner") String owner,
+                @Path("repo") String repo);
+    }
 
-  public static void main(String... args) throws IOException {
-    // Create a very simple REST adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(API_URL)
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
+    public static void main(String... args) throws IOException {
+        // Create a very simple REST adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(API_URL)
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
 
-    // Create an instance of our GitHub API interface.
-    GitHub github = retrofit.create(GitHub.class);
+        // Create an instance of our GitHub API interface.
+        // Create a call instance for looking up Retrofit contributors.
+        Call<List<Contributor>> call = retrofit.create(GitHub.class).contributors("square", "retrofit");
 
-    // Create a call instance for looking up Retrofit contributors.
-    Call<List<Contributor>> call = github.contributors("square", "retrofit");
+        // Fetch and print a list of the contributors to the library.
+        final Response<List<Contributor>> response = call.execute();
+        List<Contributor> contributors = response.body();
 
-    // Fetch and print a list of the contributors to the library.
-    List<Contributor> contributors = call.execute().body();
-    for (Contributor contributor : contributors) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        System.out.println(response.code() + "   " + response.message());
+        for (Contributor contributor : contributors) {
+            if (contributor.message != null && !contributor.message.isEmpty()) {
+                System.out.println("" + contributor.message);
+                return;
+            }
+            System.out.println(contributor.login + " (" + contributor.contributions + ")\n");
+        }
     }
-  }
 }
