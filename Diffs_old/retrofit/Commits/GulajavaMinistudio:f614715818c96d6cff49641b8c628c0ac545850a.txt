diff --git a/README.md b/README.md
index 2fa23ac51..89b315644 100644
--- a/README.md
+++ b/README.md
@@ -27,22 +27,13 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 Retrofit requires at minimum Java 7 or Android 2.3.
 
 
-ProGuard
---------
+R8 / ProGuard
+-------------
 
-If you are using ProGuard you need to add the following options:
-```
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
-# Retain service method parameters.
--keepclassmembers,allowshrinking,allowobfuscation interface * {
-    @retrofit2.http.* <methods>;
-}
-# Ignore annotation used for build tooling.
--dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-```
+If you are using R8 or ProGuard add the options from
+[this file](https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/rules.pro).
 
-You might also need rules for OkHttp and Okio which are dependencies.
+You might also need rules for OkHttp and Okio which are dependencies of this library.
 
 
 License
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 2f1ee2524..82371a4e4 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -143,10 +143,7 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            ServiceMethod<Object, Object> serviceMethod =
-                (ServiceMethod<Object, Object>) loadServiceMethod(method);
-            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.adapt(okHttpCall);
+            return loadServiceMethod(method).invoke(args);
           }
         });
   }
@@ -167,7 +164,7 @@ private void eagerlyValidateMethods(Class<?> service) {
     synchronized (serviceMethodCache) {
       result = serviceMethodCache.get(method);
       if (result == null) {
-        result = new ServiceMethod.Builder<>(this, method).build();
+        result = ServiceMethod.parseAnnotations(this, method);
         serviceMethodCache.put(method, result);
       }
     }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 9e718b604..d2c4288a8 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -57,17 +57,22 @@
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
-final class ServiceMethod<R, T> {
+final class ServiceMethod<ResponseT, ReturnT> {
+  static <ResponseT, ReturnT> ServiceMethod<ResponseT, ReturnT> parseAnnotations(Retrofit retrofit,
+      Method method) {
+    return new ServiceMethod.Builder<ResponseT, ReturnT>(retrofit, method).build();
+  }
+
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
   static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
 
   private final okhttp3.Call.Factory callFactory;
-  private final CallAdapter<R, T> callAdapter;
+  private final CallAdapter<ResponseT, ReturnT> callAdapter;
 
   private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, R> responseConverter;
+  private final Converter<ResponseBody, ResponseT> responseConverter;
   private final String httpMethod;
   private final String relativeUrl;
   private final Headers headers;
@@ -77,7 +82,7 @@
   private final boolean isMultipart;
   private final ParameterHandler<?>[] parameterHandlers;
 
-  ServiceMethod(Builder<R, T> builder) {
+  ServiceMethod(Builder<ResponseT, ReturnT> builder) {
     this.callFactory = builder.retrofit.callFactory();
     this.callAdapter = builder.callAdapter;
     this.baseUrl = builder.retrofit.baseUrl();
@@ -113,12 +118,12 @@
     return callFactory.newCall(requestBuilder.build());
   }
 
-  T adapt(Call<R> call) {
-    return callAdapter.adapt(call);
+  ReturnT invoke(@Nullable Object[] args) {
+    return callAdapter.adapt(new OkHttpCall<>(this, args));
   }
 
   /** Builds a method return value from an HTTP response body. */
-  R toResponse(ResponseBody body) throws IOException {
+  ResponseT toResponse(ResponseBody body) throws IOException {
     return responseConverter.convert(body);
   }
 
@@ -127,7 +132,7 @@ R toResponse(ResponseBody body) throws IOException {
    * requires potentially-expensive reflection so it is best to build each service method only once
    * and reuse it. Builders cannot be reused.
    */
-  static final class Builder<T, R> {
+  private static final class Builder<ResponseT, ReturnT> {
     final Retrofit retrofit;
     final Method method;
     final Annotation[] methodAnnotations;
@@ -150,8 +155,8 @@ R toResponse(ResponseBody body) throws IOException {
     MediaType contentType;
     Set<String> relativeUrlParamNames;
     ParameterHandler<?>[] parameterHandlers;
-    Converter<ResponseBody, T> responseConverter;
-    CallAdapter<T, R> callAdapter;
+    Converter<ResponseBody, ResponseT> responseConverter;
+    CallAdapter<ResponseT, ReturnT> callAdapter;
 
     Builder(Retrofit retrofit, Method method) {
       this.retrofit = retrofit;
@@ -161,7 +166,7 @@ R toResponse(ResponseBody body) throws IOException {
       this.parameterAnnotationsArray = method.getParameterAnnotations();
     }
 
-    public ServiceMethod build() {
+    ServiceMethod<ResponseT, ReturnT> build() {
       callAdapter = createCallAdapter();
       responseType = callAdapter.responseType();
       if (responseType == Response.class || responseType == okhttp3.Response.class) {
@@ -223,7 +228,7 @@ public ServiceMethod build() {
       return new ServiceMethod<>(this);
     }
 
-    private CallAdapter<T, R> createCallAdapter() {
+    private CallAdapter<ResponseT, ReturnT> createCallAdapter() {
       Type returnType = method.getGenericReturnType();
       if (Utils.hasUnresolvableType(returnType)) {
         throw methodError(
@@ -235,7 +240,7 @@ public ServiceMethod build() {
       Annotation[] annotations = method.getAnnotations();
       try {
         //noinspection unchecked
-        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
+        return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);
       } catch (RuntimeException e) { // Wide exception range because factories are user code.
         throw methodError(e, "Unable to create call adapter for %s", returnType);
       }
@@ -733,7 +738,7 @@ private void validatePathName(int p, String name) {
       }
     }
 
-    private Converter<ResponseBody, T> createResponseConverter() {
+    private Converter<ResponseBody, ResponseT> createResponseConverter() {
       Annotation[] annotations = method.getAnnotations();
       try {
         return retrofit.responseBodyConverter(responseType, annotations);
diff --git a/retrofit/src/main/resources/META-INF/proguard/rules.pro b/retrofit/src/main/resources/META-INF/proguard/rules.pro
new file mode 100644
index 000000000..dfc8dd06b
--- /dev/null
+++ b/retrofit/src/main/resources/META-INF/proguard/rules.pro
@@ -0,0 +1,10 @@
+# Retain generic type information for use by reflection by converters and adapters.
+-keepattributes Signature
+
+# Retain service method parameters.
+-keepclassmembers,allowshrinking,allowobfuscation interface * {
+    @retrofit2.http.* <methods>;
+}
+
+# Ignore annotation used for build tooling.
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 6b3634237..e4fb4f9ba 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -2701,10 +2701,7 @@ private static void assertBody(RequestBody body, String expected) {
 
     Method method = TestingUtils.onlyMethod(cls);
     //noinspection unchecked
-    ServiceMethod<T, Call<T>> serviceMethod =
-        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
-    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<T> call = serviceMethod.adapt(okHttpCall);
+    Call<T> call = (Call<T>) retrofit.loadServiceMethod(method).invoke(args);
     try {
       call.execute();
       throw new AssertionError();
diff --git a/website/index.html b/website/index.html
index 1b33a54b5..794838d75 100644
--- a/website/index.html
+++ b/website/index.html
@@ -173,19 +173,9 @@ <h4>Gradle</h4>
 </pre>
               <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-              <h4>ProGuard</h4>
-              <p>If you are using ProGuard in your project add the following lines to your configuration:</p>
-              <pre class="prettyprint">
-# Retain generic type information for use by reflection by converters and adapters.
--keepattributes Signature
-# Retain service method parameters.
--keepclassmembernames,allowobfuscation interface * {
-    @retrofit2.http.* <methods>;
-}
-# Ignore annotation used for build tooling.
--dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-</pre>
-            <p>Retrofit uses <a href="https://github.com/square/okio">Okio</a> under the hood, so you may want to look at its <a href="https://github.com/square/okio#proguard">ProGuard rules</a> as well.</p>
+              <h4>R8 / ProGuard</h4>
+              <p>If you are using R8 or ProGuard add the options from <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/resources/META-INF/proguard/rules.pro">this file</a>.</p>
+              <p>You might also need rules for OkHttp and Okio which are dependencies of this library.</p>
             </section>
 
             <section id="contributing">
