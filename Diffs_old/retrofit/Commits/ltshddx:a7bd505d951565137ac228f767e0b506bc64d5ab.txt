diff --git a/.travis.yml b/.travis.yml
index e6a844e22..79fe36a95 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,6 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
 after_success:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 80c420272..e2eb7feba 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,57 @@
 Change Log
 ==========
 
+Version 2.0.0-beta2 *(2015-09-28)*
+----------------------------------
+
+ * New: Using a response type of `Void` (e.g., `Call<Void>`) will ignore and discard the response body. This
+   can be used when there will be no response body (such as in a 201 response) or whenever the body is not
+   needed. `@Head` requests are now forced to use this as their response type.
+ * New: `validateEagerly()` method on `Retrofit.Builder` will verify the correctness of all service methods
+   on calls to `create()` instead of lazily validating on first use.
+ * New: `Converter` is now parameterized over both 'from' and 'to' types with a single `convert` method.
+   `Converter.Factory` is now an abstract class and has factory methods for both request body and response
+   body.
+ * New: `Converter.Factory` and `CallAdapter.Factory` now receive the method annotations when being created
+   for a return/response type and the parameter annotations when being created for a parameter type.
+ * New: `callAdapter()` method on `Retrofit` allows querying a `CallAdapter` for a given type. The
+   `nextCallAdapter()` method allows delegating to another `CallAdapter` from within a `CallAdapter.Factory`.
+   This is useful for composing call adapters to incrementally build up behavior.
+ * New: `requestConverter()` and `responseConverter()` methods on `Retrofit` allow querying a `Converter` for
+   a given type.
+ * New: `onResponse` method in `Callback` now receives the `Retrofit` instance. Combined with the
+   `responseConverter()` method on `Retrofit`, this provides a way of deserializing an error body on `Response`.
+   See the `DeserializeErrorBody` sample for an example.
+ * New: The `MoshiConverterFactory` has been updated for its v1.0.0.
+ * Fix: Using `ResponseBody` for the response type or `RequestBody` for a parameter type is now correctly
+   identified. Previously these types would erroneously be passed to the supplied converter.
+ * Fix: The encoding of `@Path` values has been corrected to conform to OkHttp's `HttpUrl`.
+ * Fix: Use form-data content disposition subtype for `@Multipart`.
+ * Fix: `Observable` and `Single`-based execution of requests now behave synchronously (and thus requires
+   `subscribeOn()` for running in the background).
+ * Fix: Correct `GsonConverterFactory` to honor the configuration of the `Gson` instances (such as not
+   serializing null values, the default).
+
+
+Version 2.0.0-beta1 *(2015-08-27)*
+----------------------------------
+
+ * New: `Call` encapsulates a single request/response HTTP call. A call can by run synchronously
+   via `execute()` or asynchronously via `enqueue()` and can be canceled with `cancel()`.
+ * New: `Response` is now parameterized and includes the deserialized body object.
+ * New: `@Url` parameter annotation allows passing a complete URL for an endpoint.
+ * New: OkHttp is now required as a dependency. Types like `TypedInput` and `TypedOutput` (and its
+   implementations), `Request`, and `Header` have been replaced with OkHttp types like `RequestBody`,
+   `ResponseBody`, and `Headers`.
+ * New: `CallAdapter` (and `Factory`) provides extension point for supporting multiple execution
+   mechanisms. An RxJava implementation is provided by a sibling module.
+ * New: `Converter` (and `Factory`) provides extension point for supporting multiple serialization
+   mechanisms. Gson, Jackson, Moshi, Protobuf, Wire, and SimpleXml implementations are provided by sibling
+   modules.
+ * Fix: A lot of things.
+ * Hello Droidcon NYC 2015!
+
+
 Version 1.9.0 *(2015-01-07)*
 ----------------------------
 
diff --git a/README.md b/README.md
index c101a0078..5bbcdc582 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 Retrofit
 ========
 
-Type-safe REST client for Android and Java by Square, Inc.
+Type-safe HTTP client for Android and Java by Square, Inc.
 
 For more information please see [the website][1].
 
@@ -14,17 +14,17 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>retrofit</artifactId>
-  <version>1.9.0</version>
+  <version>2.0.0-beta2</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:1.9.0'
+compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
-Retrofit requires at minimum Java 6 or Android 2.3.
+Retrofit requires at minimum Java 7 or Android 2.3.
 
 
 
diff --git a/checkstyle.xml b/checkstyle.xml
index de5302db0..1ab50fb72 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -119,5 +119,8 @@
         <!--module name="FinalParameters"/-->
         <!--module name="TodoComment"/-->
         <module name="UpperEll"/>
+        <module name="Indentation">
+          <property name="basicOffset" value="2"/>
+        </module>
     </module>
 </module>
diff --git a/deploy_website.sh b/deploy_website.sh
index 134675d3a..f7c8b370d 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -3,9 +3,6 @@
 set -ex
 
 REPO="git@github.com:square/retrofit.git"
-GROUP_ID="com.squareup.retrofit"
-ARTIFACT_ID="retrofit"
-
 DIR=temp-clone
 
 # Delete any existing temporary website clone
@@ -20,18 +17,12 @@ cd $DIR
 # Checkout and track the gh-pages branch
 git checkout -t origin/gh-pages
 
-# Delete everything
-rm -rf *
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
 
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
-rm javadoc.zip
-
 # Stage all files in git and create a commit
 git add .
 git add -u
diff --git a/pom.xml b/pom.xml
index 51f820329..b26fb4a24 100644
--- a/pom.xml
+++ b/pom.xml
@@ -29,7 +29,7 @@
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
-  <description>Type-safe REST client for Android and Java by Square, Inc.</description>
+  <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
   <url>http://github.com/square/retrofit/</url>
 
   <modules>
@@ -50,18 +50,19 @@
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <okhttp.version>2.5.0-SNAPSHOT</okhttp.version>
+    <okhttp.version>2.5.0</okhttp.version>
+    <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.10</rxjava.version>
+    <rxjava.version>1.0.14</rxjava.version>
 
     <!-- Converter Dependencies -->
-    <gson.version>2.3.1</gson.version>
+    <gson.version>2.4</gson.version>
     <protobuf.version>2.5.0</protobuf.version>
     <jackson.version>2.4.3</jackson.version>
-    <wire.version>1.7.0</wire.version>
+    <wire.version>2.0.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>0.9.0</moshi.version>
+    <moshi.version>1.0.0</moshi.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -101,6 +102,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-annotations</artifactId>
+        <version>${animal.sniffer.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.squareup.okhttp</groupId>
         <artifactId>okhttp</artifactId>
@@ -214,6 +220,27 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <executions>
+          <execution>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
+          </signature>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
new file mode 100644
index 000000000..054c5556a
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class RxJavaBehaviorAdapter implements NetworkBehavior.Adapter<Object> {
+  public static RxJavaBehaviorAdapter create() {
+    return new RxJavaBehaviorAdapter();
+  }
+
+  private RxJavaBehaviorAdapter() {
+  }
+
+  @Override public Object applyBehavior(NetworkBehavior behavior, Object value) {
+    if (value instanceof Observable) {
+      return applyObservableBehavior(behavior, (Observable<?>) value);
+    }
+    String name = value.getClass().getCanonicalName();
+    if ("rx.Single".equals(name)) {
+      // Apply behavior to the Single from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.applySingleBehavior(behavior, value);
+    }
+    throw new IllegalStateException("Unsupported type " + name);
+  }
+
+  public Observable<?> applyObservableBehavior(final NetworkBehavior behavior,
+      final Observable<?> value) {
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return value;
+          }
+        });
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
similarity index 74%
rename from retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
rename to retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
index 3fd67a6c8..d1c54214f 100644
--- a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
@@ -16,27 +16,24 @@
 package retrofit.mock;
 
 import rx.Observable;
+import rx.Single;
 import rx.functions.Func1;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-public final class ObservableBehaviorAdapter implements BehaviorAdapter<Observable<?>> {
-  public static ObservableBehaviorAdapter create() {
-    return new ObservableBehaviorAdapter();
-  }
-
-  private ObservableBehaviorAdapter() {
-  }
-
-  @Override public Observable<?> applyBehavior(final Behavior behavior, final Observable<?> value) {
+final class SingleHelper {
+  @SuppressWarnings("unchecked") // Caller must instanceof / getClass() verify 'value' is Single.
+  public static Object applySingleBehavior(final NetworkBehavior behavior, Object value) {
+    final Single<Object> single = (Single<Object>) value;
     return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
         .flatMap(new Func1<Long, Observable<?>>() {
           @Override public Observable<?> call(Long ignored) {
             if (behavior.calculateIsFailure()) {
               return Observable.error(behavior.failureException());
             }
-            return value;
+            return single.toObservable();
           }
-        });
+        })
+        .toSingle();
   }
 }
diff --git a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
similarity index 52%
rename from retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
rename to retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
index 6b2528f66..d256b84f0 100644
--- a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
+++ b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
@@ -23,6 +23,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import rx.Observable;
+import rx.Single;
 import rx.Subscriber;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -30,32 +31,99 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 
-public final class ObservableBehaviorAdapterTest {
+public final class RxJavaBehaviorAdapterTest {
   interface DoWorkService {
-    Observable<String> response();
+    Observable<String> observableResponse();
+    Single<String> singleResponse();
   }
 
-  private final Behavior behavior = Behavior.create(new Random(2847));
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
   private DoWorkService service;
 
   @Before public void setUp() {
     DoWorkService mockService = new DoWorkService() {
-      @Override public Observable<String> response() {
+      @Override public Observable<String> observableResponse() {
         return Observable.just("Hi!");
       }
+
+      @Override public Single<String> singleResponse() {
+        return Single.just("Hi!");
+      }
     };
 
-    BehaviorAdapter<?> adapter = ObservableBehaviorAdapter.create();
-    MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
+    NetworkBehavior.Adapter<?> adapter = RxJavaBehaviorAdapter.create();
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
     service = mockRetrofit.create(DoWorkService.class, mockService);
   }
 
-  @Test public void failureAfterDelay() throws InterruptedException {
+  @Test public void observableFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void observableSuccessAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void singleFailureAfterDelay() throws InterruptedException {
     behavior.setDelay(100, MILLISECONDS);
     behavior.setVariancePercent(0);
     behavior.setFailurePercent(100);
 
-    Observable<String> observable = service.response();
+    Single<String> observable = service.singleResponse();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -81,12 +149,12 @@
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
   }
 
-  @Test public void successAfterDelay() throws InterruptedException {
+  @Test public void singleSuccessAfterDelay() throws InterruptedException {
     behavior.setDelay(100, MILLISECONDS);
     behavior.setVariancePercent(0);
     behavior.setFailurePercent(0);
 
-    Observable<String> observable = service.response();
+    Single<String> observable = service.singleResponse();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java
new file mode 100644
index 000000000..77076a642
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java
@@ -0,0 +1,32 @@
+package retrofit;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
similarity index 55%
rename from retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
index dbb90b745..6583a19f1 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
@@ -15,11 +15,12 @@
  */
 package retrofit;
 
-import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import rx.Observable;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.subscriptions.Subscriptions;
@@ -27,40 +28,49 @@
 /**
  * TODO docs
  */
-public final class ObservableCallAdapterFactory implements CallAdapter.Factory {
+public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
   /**
    * TODO
    */
-  public static ObservableCallAdapterFactory create() {
-    return new ObservableCallAdapterFactory();
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory();
   }
 
-  private ObservableCallAdapterFactory() {
+  private RxJavaCallAdapterFactory() {
   }
 
-  @Override public String toString() {
-    return getClass().getSimpleName();
-  }
-
-  @Override public CallAdapter<?> get(Type returnType) {
-    if (Utils.getRawType(returnType) != Observable.class) {
+  @Override
+  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    Class<?> rawType = Utils.getRawType(returnType);
+    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
+    if (rawType != Observable.class && !isSingle) {
       return null;
     }
     if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Observable return type must be parameterized"
-          + " as Observable<Foo> or Observable<? extends Foo>");
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
 
-    Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
-    Class<?> rawObservableType = Utils.getRawType(observableType);
+    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType);
+    if (isSingle) {
+      // Add Single-converter wrapper from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.makeSingle(callAdapter);
+    }
+    return callAdapter;
+  }
 
+  private CallAdapter<Observable<?>> getCallAdapter(Type returnType) {
+    Type observableType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
+    Class<?> rawObservableType = Utils.getRawType(observableType);
     if (rawObservableType == Response.class) {
       if (!(observableType instanceof ParameterizedType)) {
         throw new IllegalStateException("Response must be parameterized"
             + " as Response<Foo> or Response<? extends Foo>");
       }
-      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
-      return new ResponseCallAdapter<>(responseType);
+      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
+      return new ResponseCallAdapter(responseType);
     }
 
     if (rawObservableType == Result.class) {
@@ -68,8 +78,8 @@ private ObservableCallAdapterFactory() {
         throw new IllegalStateException("Result must be parameterized"
             + " as Result<Foo> or Result<? extends Foo>");
       }
-      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
-      return new ResultCallAdapter<>(responseType);
+      Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) observableType);
+      return new ResultCallAdapter(responseType);
     }
 
     return new SimpleCallAdapter(observableType);
@@ -93,31 +103,26 @@ private CallOnSubscribe(Call<T> originalCall) {
         }
       }));
 
-      call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Response<T> response) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
-          try {
-            subscriber.onNext(response);
-          } catch (Throwable t) {
-            subscriber.onError(t);
-            return;
-          }
-          subscriber.onCompleted();
+      try {
+        Response<T> response = call.execute();
+        if (!subscriber.isUnsubscribed()) {
+          subscriber.onNext(response);
         }
-
-        @Override public void onFailure(Throwable t) {
-          if (subscriber.isUnsubscribed()) {
-            return;
-          }
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        if (!subscriber.isUnsubscribed()) {
           subscriber.onError(t);
         }
-      });
+        return;
+      }
+
+      if (!subscriber.isUnsubscribed()) {
+        subscriber.onCompleted();
+      }
     }
   }
 
-  static final class ResponseCallAdapter<T> implements CallAdapter<T> {
+  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
 
     ResponseCallAdapter(Type responseType) {
@@ -128,12 +133,12 @@ private CallOnSubscribe(Call<T> originalCall) {
       return responseType;
     }
 
-    @Override public Observable<Response<T>> adapt(Call<T> call) {
+    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
       return Observable.create(new CallOnSubscribe<>(call));
     }
   }
 
-  static final class SimpleCallAdapter<T> implements CallAdapter<T> {
+  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
 
     SimpleCallAdapter(Type responseType) {
@@ -144,20 +149,20 @@ private CallOnSubscribe(Call<T> originalCall) {
       return responseType;
     }
 
-    @Override public Observable<T> adapt(Call<T> call) {
+    @Override public <R> Observable<R> adapt(Call<R> call) {
       return Observable.create(new CallOnSubscribe<>(call)) //
-          .flatMap(new Func1<Response<T>, Observable<T>>() {
-            @Override public Observable<T> call(Response<T> response) {
+          .flatMap(new Func1<Response<R>, Observable<R>>() {
+            @Override public Observable<R> call(Response<R> response) {
               if (response.isSuccess()) {
                 return Observable.just(response.body());
               }
-              return Observable.error(new IOException()); // TODO non-suck message.
+              return Observable.error(new HttpException(response));
             }
           });
     }
   }
 
-  static final class ResultCallAdapter<T> implements CallAdapter<T> {
+  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
     private final Type responseType;
 
     ResultCallAdapter(Type responseType) {
@@ -168,15 +173,15 @@ private CallOnSubscribe(Call<T> originalCall) {
       return responseType;
     }
 
-    @Override public Observable<Result<T>> adapt(Call<T> call) {
+    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
       return Observable.create(new CallOnSubscribe<>(call)) //
-          .map(new Func1<Response<T>, Result<T>>() {
-            @Override public Result<T> call(Response<T> response) {
+          .map(new Func1<Response<R>, Result<R>>() {
+            @Override public Result<R> call(Response<R> response) {
               return Result.response(response);
             }
           })
-          .onErrorReturn(new Func1<Throwable, Result<T>>() {
-            @Override public Result<T> call(Throwable throwable) {
+          .onErrorReturn(new Func1<Throwable, Result<R>>() {
+            @Override public Result<R> call(Throwable throwable) {
               return Result.error(throwable);
             }
           });
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
similarity index 53%
rename from retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
index 5dde8b58f..9d3c28ef1 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/BehaviorAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
@@ -13,8 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit.mock;
+package retrofit;
 
-public interface BehaviorAdapter<T> {
-  T applyBehavior(Behavior behavior, T value);
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Single;
+
+final class SingleHelper {
+  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
+    return new CallAdapter<Single<?>>() {
+      @Override public Type responseType() {
+        return callAdapter.responseType();
+      }
+
+      @Override public <R> Single<?> adapt(Call<R> call) {
+        Observable<?> observable = callAdapter.adapt(call);
+        return observable.toSingle();
+      }
+    };
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
similarity index 52%
rename from retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
index 87eedb119..ac0d36105 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import org.junit.Before;
@@ -29,28 +30,36 @@
 import org.junit.Test;
 import retrofit.http.GET;
 import rx.Observable;
+import rx.Single;
 import rx.observables.BlockingObservable;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public final class ObservableCallAdapterFactoryTest {
+public final class RxJavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
+    @GET("/") Observable<String> observableBody();
+    @GET("/") Observable<Response<String>> observableResponse();
+    @GET("/") Observable<Result<String>> observableResult();
+    @GET("/") Single<String> singleBody();
+    @GET("/") Single<Response<String>> singleResponse();
+    @GET("/") Single<Result<String>> singleResult();
   }
 
+  private Retrofit retrofit;
   private Service service;
 
   @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
+    retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new StringConverterFactory())
-        .callAdapterFactory(ObservableCallAdapterFactory.create())
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -58,26 +67,27 @@
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     assertThat(o.first()).isEqualTo("Hi");
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     try {
       o.first();
       fail();
     } catch (RuntimeException e) {
-      // TODO assert on some indicator of 404.
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 OK");
     }
   }
 
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.body().toBlocking();
+    BlockingObservable<String> o = service.observableBody().toBlocking();
     try {
       o.first();
       fail();
@@ -89,7 +99,7 @@
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
@@ -98,7 +108,7 @@
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo("Hi");
@@ -107,7 +117,7 @@
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
     try {
       o.first();
       fail();
@@ -119,7 +129,7 @@
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -130,7 +140,7 @@
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -141,49 +151,67 @@
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   @Test public void responseType() {
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType).responseType()) //
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
     Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(responseType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(resultType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
   }
 
   @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
-    CallAdapter<?> adapter = factory.get(String.class);
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
     assertThat(adapter).isNull();
   }
 
   @Test public void rawTypeThrows() {
-    Type type = new TypeToken<Observable>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
     }
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
   }
 
-  @Test public void rawResponseTypeThrows() {
-    Type type = new TypeToken<Observable<Response>>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+  @Test public void rawObservableResponseTypeThrows() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
@@ -191,24 +219,45 @@
   }
 
   @Test public void rawResultTypeThrows() {
-    Type type = new TypeToken<Observable<Result>>() {}.getType();
-    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
     try {
-      factory.get(type);
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
     }
   }
 
-  static class StringConverterFactory implements Converter.Factory {
-    @Override public Converter<?> get(Type type) {
-      return new Converter<String>() {
-        @Override public String fromBody(ResponseBody body) throws IOException {
-          return body.string();
+  @Test public void single() {
+    // TODO Better tests here. Why is there no toBlocking() on Single?
+    assertNotNull(service.singleBody());
+    assertNotNull(service.singleResponse());
+    assertNotNull(service.singleResult());
+  }
+
+  static class StringConverterFactory extends Converter.Factory {
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
         }
+      };
+    }
 
-        @Override public RequestBody toBody(String value) {
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] annotations, Retrofit retrofit) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
           return RequestBody.create(MediaType.parse("text/plain"), value);
         }
       };
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
index adc79d39e..27bf7d8d1 100644
--- a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
@@ -18,10 +18,20 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Gson for JSON. */
-public final class GsonConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
+ * <p>
+ * Because Gson is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class GsonConverterFactory extends Converter.Factory {
   /**
    * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
@@ -45,8 +55,17 @@ private GsonConverterFactory(Gson gson) {
     this.gson = gson;
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonResponseBodyConverter<>(adapter);
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonConverter<>(adapter);
+    return new GsonRequestBodyConverter<>(gson, adapter);
   }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
similarity index 66%
rename from retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
index 95189be9e..651b02973 100644
--- a/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,45 +15,36 @@
  */
 package retrofit;
 
+import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonWriter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
-import java.io.Reader;
 import java.io.Writer;
 import java.nio.charset.Charset;
 import okio.Buffer;
 
-final class GsonConverter<T> implements Converter<T> {
+final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
   private static final Charset UTF_8 = Charset.forName("UTF-8");
 
-  private final TypeAdapter<T> typeAdapter;
+  private final Gson gson;
+  private final TypeAdapter<T> adapter;
 
-  GsonConverter(TypeAdapter<T> typeAdapter) {
-    this.typeAdapter = typeAdapter;
+  GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
+    this.adapter = adapter;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    Reader in = body.charStream();
-    try {
-      return typeAdapter.fromJson(in);
-    } finally {
-      try {
-        in.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
+  @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
     Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    JsonWriter jsonWriter = gson.newJsonWriter(writer);
     try {
-      typeAdapter.toJson(writer, value);
-      writer.flush();
+      adapter.write(jsonWriter, value);
+      jsonWriter.flush();
     } catch (IOException e) {
       throw new AssertionError(e); // Writing to Buffer does no I/O.
     }
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
similarity index 52%
rename from retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
rename to retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
index 3538c789b..fe568f891 100644
--- a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
@@ -15,33 +15,29 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.RequestBody;
+import com.google.gson.TypeAdapter;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.io.Reader;
 
-import static retrofit.Utils.closeQuietly;
+final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final TypeAdapter<T> adapter;
 
-final class OkHttpResponseBodyConverter implements Converter<ResponseBody> {
-  private final boolean isStreaming;
-
-  OkHttpResponseBodyConverter(boolean isStreaming) {
-    this.isStreaming = isStreaming;
+  GsonResponseBodyConverter(TypeAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
-  @Override public ResponseBody fromBody(ResponseBody body) throws IOException {
-    if (isStreaming) {
-      return body;
-    }
-
-    // Buffer the entire body to avoid future I/O.
+  @Override public T convert(ResponseBody value) throws IOException {
+    Reader reader = value.charStream();
     try {
-      return Utils.readBodyToBytesIfNecessary(body);
+      return adapter.fromJson(reader);
     } finally {
-      closeQuietly(body);
+      if (reader != null) {
+        try {
+          reader.close();
+        } catch (IOException ignored) {
+        }
+      }
     }
   }
-
-  @Override public RequestBody toBody(ResponseBody value) {
-    throw new UnsupportedOperationException();
-  }
 }
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
index 8d58997dc..3d4b6e4f0 100644
--- a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
@@ -89,7 +89,7 @@
         .create();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(GsonConverterFactory.create(gson))
+        .addConverterFactory(GsonConverterFactory.create(gson))
         .build();
     service = retrofit.create(Service.class);
   }
@@ -118,6 +118,15 @@
     RecordedRequest request = server.takeRequest();
     assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
     assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void serializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    service.anImplementation(new AnImplementation(null)).execute();
 
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
deleted file mode 100644
index d63eeea6f..000000000
--- a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.ObjectReader;
-import com.fasterxml.jackson.databind.ObjectWriter;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-
-final class JacksonConverter<T> implements Converter<T> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-
-  private final ObjectWriter writer;
-  private final ObjectReader reader;
-
-  JacksonConverter(ObjectWriter writer, ObjectReader reader) {
-    this.writer = writer;
-    this.reader = reader;
-  }
-
-
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream is = body.byteStream();
-    try {
-      return reader.readValue(is);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
-    try {
-      byte[] bytes = writer.writeValueAsBytes(value);
-      return RequestBody.create(MEDIA_TYPE, bytes);
-    } catch (JsonProcessingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
index 8f4efc0e8..0b05e9be1 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
@@ -19,10 +19,20 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Jackson. */
-public final class JacksonConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Jackson.
+ * <p>
+ * Because Jackson is so flexible in the types it supports, this converter assumes that it can
+ * handle all types. If you are mixing JSON serialization with something else (such as protocol
+ * buffers), you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this
+ * instance} last to allow the other converters a chance to see their types.
+ */
+public final class JacksonConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
   public static JacksonConverterFactory create() {
     return create(new ObjectMapper());
@@ -40,10 +50,19 @@ private JacksonConverterFactory(ObjectMapper mapper) {
     this.mapper = mapper;
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
     ObjectReader reader = mapper.reader(javaType);
-    return new JacksonConverter<>(writer, reader);
+    return new JacksonResponseBodyConverter<>(reader);
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectWriter writer = mapper.writerWithType(javaType);
+    return new JacksonRequestBodyConverter<>(writer);
   }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java
new file mode 100644
index 000000000..78edddee4
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+
+final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private final ObjectWriter adapter;
+
+  JacksonRequestBodyConverter(ObjectWriter adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = adapter.writeValueAsBytes(value);
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java
new file mode 100644
index 000000000..bead6c91b
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.Reader;
+
+final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final ObjectReader adapter;
+
+  JacksonResponseBodyConverter(ObjectReader adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    Reader reader = value.charStream();
+    try {
+      return adapter.readValue(reader);
+    } finally {
+      if (reader != null) {
+        try {
+          reader.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+  }
+}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
similarity index 98%
rename from retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
rename to retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
index 9df401a7b..83ba86fe6 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
@@ -38,7 +38,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class JacksonConverterTest {
+public class JacksonConverterFactoryTest {
   interface AnInterface {
     String getName();
   }
@@ -121,7 +121,7 @@
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(JacksonConverterFactory.create(mapper))
+        .addConverterFactory(JacksonConverterFactory.create(mapper))
         .build();
     service = retrofit.create(Service.class);
   }
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
index 492e42601..9968ccd38 100644
--- a/retrofit-converters/moshi/README.md
+++ b/retrofit-converters/moshi/README.md
@@ -3,8 +3,8 @@ Moshi Converter
 
 A `Converter` which uses [Moshi][1] for serialization to and from JSON.
 
-A default `Moshi` instance will be created or one can be configured and passed to the
-`MoshiConverter` construction to further control the serialization.
+A default `Moshi` instance will be created or one can be configured and passed to
+`MoshiConverterFactory.create()` to further control the serialization.
 
 
  [1]: https://github.com/square/moshi
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
index 75506f511..4721a423b 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
@@ -17,10 +17,20 @@
 
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.Moshi;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Moshi for JSON. */
-public final class MoshiConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
+ * <p>
+ * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class MoshiConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Moshi} instance for conversion. */
   public static MoshiConverterFactory create() {
     return create(new Moshi.Builder().build());
@@ -38,8 +48,17 @@ private MoshiConverterFactory(Moshi moshi) {
     this.moshi = moshi;
   }
 
-  @Override public Converter<?> get(Type type) {
-    JsonAdapter<Object> adapter = moshi.adapter(type);
-    return new MoshiConverter<>(adapter);
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    JsonAdapter<?> adapter = moshi.adapter(type);
+    return new MoshiResponseBodyConverter<>(adapter);
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    JsonAdapter<?> adapter = moshi.adapter(type);
+    return new MoshiRequestBodyConverter<>(adapter);
   }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
similarity index 62%
rename from retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
rename to retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
index de7c57add..f64109687 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
@@ -18,39 +18,25 @@
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.Buffer;
-import okio.BufferedSource;
 
-final class MoshiConverter<T> implements Converter<T> {
+final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
-  private JsonAdapter<T> adapter;
+  private final JsonAdapter<T> adapter;
 
-  MoshiConverter(JsonAdapter<T> adapter) {
+  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
     this.adapter = adapter;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    BufferedSource source = body.source();
-    try {
-      return adapter.fromJson(source);
-    } finally {
-      try {
-        source.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
+  @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
     try {
       adapter.toJson(buffer, value);
     } catch (IOException e) {
-      throw new AssertionError(e);
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
     }
-    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
 }
diff --git a/retrofit/src/main/java/retrofit/NoContentResponseBody.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
similarity index 53%
rename from retrofit/src/main/java/retrofit/NoContentResponseBody.java
rename to retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
index 098087653..3cfe106e1 100644
--- a/retrofit/src/main/java/retrofit/NoContentResponseBody.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
@@ -15,29 +15,29 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
+import com.squareup.moshi.JsonAdapter;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import okio.BufferedSource;
 
-final class NoContentResponseBody extends ResponseBody {
-  private final MediaType contentType;
-  private final long contentLength;
+final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final JsonAdapter<T> adapter;
 
-  NoContentResponseBody(MediaType contentType, long contentLength) {
-    this.contentType = contentType;
-    this.contentLength = contentLength;
+  MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
-  @Override public MediaType contentType() {
-    return contentType;
-  }
-
-  @Override public long contentLength() throws IOException {
-    return contentLength;
-  }
-
-  @Override public BufferedSource source() throws IOException {
-    throw new IllegalStateException("Cannot read raw response body of a converted body.");
+  @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = value.source();
+    try {
+      return adapter.fromJson(source);
+    } finally {
+      if (source != null) {
+        try {
+          source.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
   }
 }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
similarity index 97%
rename from retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
rename to retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
index f919b96f6..b14da4b7e 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
@@ -32,7 +32,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class MoshiConverterTest {
+public final class MoshiConverterFactoryTest {
   interface AnInterface {
     String getName();
   }
@@ -88,7 +88,7 @@
         .build();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(MoshiConverterFactory.create(moshi))
+        .addConverterFactory(MoshiConverterFactory.create(moshi))
         .build();
     service = retrofit.create(Service.class);
   }
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 4fe586b8e..f22f4abe3 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -20,6 +20,7 @@
     <module>jackson</module>
     <module>wire</module>
     <module>simplexml</module>
+    <module>scalars</module>
     <module>moshi</module>
   </modules>
 </project>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
index bcb9d2640..543c46ee7 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
@@ -17,22 +17,32 @@
 
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} which uses Protocol Buffers. */
-public final class ProtoConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
+ * <p>
+ * This converter only applies for types which extend from {@link MessageLite} (or one of its
+ * subclasses).
+ */
+public final class ProtoConverterFactory extends Converter.Factory {
   public static ProtoConverterFactory create() {
     return new ProtoConverterFactory();
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
+      return null;
     }
     Class<?> c = (Class<?>) type;
     if (!MessageLite.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
+      return null;
     }
 
     Parser<MessageLite> parser;
@@ -42,9 +52,20 @@ public static ProtoConverterFactory create() {
       parser = (Parser<MessageLite>) field.get(null);
     } catch (NoSuchFieldException | IllegalAccessException e) {
       throw new IllegalArgumentException(
-          "Expected a protobuf message but " + c.getName() + " had no PARSER field.");
+          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
     }
+    return new ProtoResponseBodyConverter<>(parser);
+  }
 
-    return new ProtoConverter<>(parser);
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
+      return null;
+    }
+    return new ProtoRequestBodyConverter<>();
   }
 }
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
similarity index 62%
rename from retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
index ad2434e47..e88a6ad73 100644
--- a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
@@ -15,16 +15,16 @@
  */
 package retrofit;
 
+import com.google.protobuf.MessageLite;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 
-final class OkHttpRequestBodyConverter implements Converter<RequestBody> {
-  @Override public RequestBody fromBody(ResponseBody body) throws IOException {
-    throw new UnsupportedOperationException();
-  }
+final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public RequestBody toBody(RequestBody value) {
-    return value;
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = value.toByteArray();
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
similarity index 60%
rename from retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
rename to retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
index 2dcd35ac9..78bb14f60 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
@@ -18,37 +18,31 @@
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
 
-final class ProtoConverter<T extends MessageLite> implements Converter<T> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+final class ProtoResponseBodyConverter<T extends MessageLite>
+    implements Converter<ResponseBody, T> {
+  private final Parser<T> parser;
 
-  private Parser<T> parser;
-
-  ProtoConverter(Parser<T> parser) {
+  ProtoResponseBodyConverter(Parser<T> parser) {
     this.parser = parser;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream is = body.byteStream();
+  @Override public T convert(ResponseBody value) throws IOException {
+    InputStream is = value.byteStream();
     try {
       return parser.parseFrom(is);
     } catch (InvalidProtocolBufferException e) {
-      throw new RuntimeException(e);
+      throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
     } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException ignored) {
+        }
       }
     }
   }
-
-  @Override public RequestBody toBody(T value) {
-    byte[] bytes = value.toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
similarity index 81%
rename from retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
rename to retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
index ed5caa207..238ec6931 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
@@ -34,7 +34,7 @@
 import static org.junit.Assert.fail;
 import static retrofit.PhoneProtos.Phone;
 
-public final class ProtoConverterTest {
+public final class ProtoConverterFactoryTest {
   interface Service {
     @GET("/") Call<Phone> get();
     @POST("/") Call<Phone> post(@Body Phone impl);
@@ -49,7 +49,7 @@
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(ProtoConverterFactory.create())
+        .addConverterFactory(ProtoConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -85,7 +85,12 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method Service.wrongClass");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.ProtoConverterFactory");
     }
   }
 
@@ -97,7 +102,12 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+          + "    for method Service.wrongType");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.ProtoConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/scalars/README.md b/retrofit-converters/scalars/README.md
new file mode 100644
index 000000000..e3edef925
--- /dev/null
+++ b/retrofit-converters/scalars/README.md
@@ -0,0 +1,5 @@
+Java Scalars Converter
+======================
+
+A `Converter` which supports converting strings and both primitives and their boxed types to
+`text/plain` bodies.
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
new file mode 100644
index 000000000..48bf8ee28
--- /dev/null
+++ b/retrofit-converters/scalars/pom.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-scalars</artifactId>
+  <name>Converter: Java Scalars</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit/ScalarRequestBodyConverter.java
new file mode 100644
index 000000000..91bd4e8e2
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit/ScalarRequestBodyConverter.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+
+final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
+  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+
+  private ScalarRequestBodyConverter() {
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
+  }
+}
diff --git a/retrofit-converters/scalars/src/main/java/retrofit/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit/ScalarsConverterFactory.java
new file mode 100644
index 000000000..30a8a9162
--- /dev/null
+++ b/retrofit-converters/scalars/src/main/java/retrofit/ScalarsConverterFactory.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A {@linkplain Converter.Factory converter} for strings and both primitives and their boxed types
+ * to {@code text/plain} bodies.
+ */
+public final class ScalarsConverterFactory extends Converter.Factory {
+  public static ScalarsConverterFactory create() {
+    return new ScalarsConverterFactory();
+  }
+
+  private ScalarsConverterFactory() {
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (type == String.class
+        || type == boolean.class
+        || type == Boolean.class
+        || type == byte.class
+        || type == Byte.class
+        || type == char.class
+        || type == Character.class
+        || type == double.class
+        || type == Double.class
+        || type == float.class
+        || type == Float.class
+        || type == int.class
+        || type == Integer.class
+        || type == long.class
+        || type == Long.class
+        || type == short.class
+        || type == Short.class) {
+      return ScalarRequestBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+}
diff --git a/retrofit-converters/scalars/src/test/java/retrofit/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit/ScalarsConverterFactoryTest.java
new file mode 100644
index 000000000..61d9e7b47
--- /dev/null
+++ b/retrofit-converters/scalars/src/test/java/retrofit/ScalarsConverterFactoryTest.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ScalarsConverterFactoryTest {
+  interface Service {
+      @POST("/") Call<ResponseBody> object(@Body Object body);
+
+      @POST("/") Call<ResponseBody> stringObject(@Body String body);
+      @POST("/") Call<ResponseBody> booleanPrimitive(@Body boolean body);
+      @POST("/") Call<ResponseBody> booleanObject(@Body Boolean body);
+      @POST("/") Call<ResponseBody> bytePrimitive(@Body byte body);
+      @POST("/") Call<ResponseBody> byteObject(@Body Byte body);
+      @POST("/") Call<ResponseBody> charPrimitive(@Body char body);
+      @POST("/") Call<ResponseBody> charObject(@Body Character body);
+      @POST("/") Call<ResponseBody> doublePrimitive(@Body double body);
+      @POST("/") Call<ResponseBody> doubleObject(@Body Double body);
+      @POST("/") Call<ResponseBody> floatPrimitive(@Body float body);
+      @POST("/") Call<ResponseBody> floatObject(@Body Float body);
+      @POST("/") Call<ResponseBody> integerPrimitive(@Body int body);
+      @POST("/") Call<ResponseBody> integerObject(@Body Integer body);
+      @POST("/") Call<ResponseBody> longPrimitive(@Body long body);
+      @POST("/") Call<ResponseBody> longObject(@Body Long body);
+      @POST("/") Call<ResponseBody> shortPrimitive(@Body short body);
+      @POST("/") Call<ResponseBody> shortObject(@Body Short body);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ScalarsConverterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void unsupportedTypesNotMatched() {
+    try {
+      service.object(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
+              + "    for method Service.object");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate RequestBody converter for class java.lang.Object. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.ScalarsConverterFactory");
+    }
+  }
+
+  @Test public void supportedTypes() throws IOException, InterruptedException {
+    RecordedRequest request;
+
+    server.enqueue(new MockResponse());
+    service.stringObject("string").execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("6");
+    assertThat(request.getBody().readUtf8()).isEqualTo("string");
+
+    server.enqueue(new MockResponse());
+    service.booleanPrimitive(true).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("4");
+    assertThat(request.getBody().readUtf8()).isEqualTo("true");
+
+    server.enqueue(new MockResponse());
+    service.booleanObject(false).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("5");
+    assertThat(request.getBody().readUtf8()).isEqualTo("false");
+
+    server.enqueue(new MockResponse());
+    service.bytePrimitive((byte) 0).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("0");
+
+    server.enqueue(new MockResponse());
+    service.byteObject((byte) 1).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("1");
+
+    server.enqueue(new MockResponse());
+    service.charPrimitive('a').execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("a");
+
+    server.enqueue(new MockResponse());
+    service.charObject('b').execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("b");
+
+    server.enqueue(new MockResponse());
+    service.doublePrimitive(2.2d).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(request.getBody().readUtf8()).isEqualTo("2.2");
+
+    server.enqueue(new MockResponse());
+    service.doubleObject(3.3d).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(request.getBody().readUtf8()).isEqualTo("3.3");
+
+    server.enqueue(new MockResponse());
+    service.floatPrimitive(4.4f).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(request.getBody().readUtf8()).isEqualTo("4.4");
+
+    server.enqueue(new MockResponse());
+    service.floatObject(5.5f).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(request.getBody().readUtf8()).isEqualTo("5.5");
+
+    server.enqueue(new MockResponse());
+    service.integerPrimitive(6).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("6");
+
+    server.enqueue(new MockResponse());
+    service.integerObject(7).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("7");
+
+    server.enqueue(new MockResponse());
+    service.longPrimitive(8L).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("8");
+
+    server.enqueue(new MockResponse());
+    service.longObject(9L).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+    assertThat(request.getBody().readUtf8()).isEqualTo("9");
+
+    server.enqueue(new MockResponse());
+    service.shortPrimitive((short) 10).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("2");
+    assertThat(request.getBody().readUtf8()).isEqualTo("10");
+
+    server.enqueue(new MockResponse());
+    service.shortObject((short) 11).execute();
+    request = server.takeRequest();
+    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+    assertThat(request.getHeader("Content-Length")).isEqualTo("2");
+    assertThat(request.getBody().readUtf8()).isEqualTo("11");
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
index 8f394c2c4..98ccbf6d8 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
@@ -15,12 +15,20 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
 
-/** A {@linkplain Converter.Factory converter} which uses Simple Framework for XML. */
-public final class SimpleXmlConverterFactory implements Converter.Factory {
+/**
+ * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
+ * <p>
+ * This converter only applies for class types. Parameterized types (e.g., {@code List<Foo>}) are
+ * not handled.
+ */
+public final class SimpleXmlConverterFactory extends Converter.Factory {
   /** Create an instance using a default {@link Persister} instance for conversion. */
   public static SimpleXmlConverterFactory create() {
     return create(new Persister());
@@ -54,11 +62,22 @@ public boolean isStrict() {
     return strict;
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     if (!(type instanceof Class)) {
-      throw new IllegalArgumentException("Expected a raw class but was " + type);
+      return null;
     }
     Class<?> cls = (Class<?>) type;
-    return new SimpleXmlConverter<>(cls, serializer, strict);
+    return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (!(type instanceof Class)) {
+      return null;
+    }
+    return new SimpleXmlRequestBodyConverter<>(serializer);
   }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java
new file mode 100644
index 000000000..f81c6b177
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import okio.Buffer;
+import org.simpleframework.xml.Serializer;
+
+final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final String CHARSET = "UTF-8";
+
+  private final Serializer serializer;
+
+  SimpleXmlRequestBodyConverter(Serializer serializer) {
+    this.serializer = serializer;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    try {
+      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+      serializer.write(value, osw);
+      osw.flush();
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
similarity index 60%
rename from retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
rename to retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
index 1170cba00..6d4e37247 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
@@ -15,32 +15,24 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStreamWriter;
-import okio.Buffer;
 import org.simpleframework.xml.Serializer;
 
-final class SimpleXmlConverter<T> implements Converter<T> {
-  private static final String CHARSET = "UTF-8";
-  private static final MediaType MEDIA_TYPE =
-      MediaType.parse("application/xml; charset=" + CHARSET);
-
+final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
   private final Class<T> cls;
   private final Serializer serializer;
   private final boolean strict;
 
-  SimpleXmlConverter(Class<T> cls, Serializer serializer, boolean strict) {
+  SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
     this.cls = cls;
     this.serializer = serializer;
     this.strict = strict;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream is = body.byteStream();
+  @Override public T convert(ResponseBody value) throws IOException {
+    InputStream is = value.byteStream();
     try {
       T read = serializer.read(cls, is, strict);
       if (read == null) {
@@ -58,16 +50,4 @@
       }
     }
   }
-
-  @Override public RequestBody toBody(T value) {
-    Buffer buffer = new Buffer();
-    try {
-      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(value, osw);
-      osw.flush();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
similarity index 96%
rename from retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
rename to retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
index 20df7596f..d0c6421ef 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
@@ -34,7 +34,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public class SimpleXmlConverterTest {
+public class SimpleXmlConverterFactoryTest {
   interface Service {
     @GET("/") Call<MyObject> get();
     @POST("/") Call<MyObject> post(@Body MyObject impl);
@@ -50,7 +50,7 @@
     Persister persister = new Persister(format);
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(SimpleXmlConverterFactory.create(persister))
+        .addConverterFactory(SimpleXmlConverterFactory.create(persister))
         .build();
     service = retrofit.create(Service.class);
   }
diff --git a/retrofit-converters/wire/README.md b/retrofit-converters/wire/README.md
index 88069b48f..9c82b143e 100644
--- a/retrofit-converters/wire/README.md
+++ b/retrofit-converters/wire/README.md
@@ -3,8 +3,5 @@ Wire Converter
 
 A `Converter` which uses [Wire][1] for protocol buffer-compatible serialization.
 
-A default `Wire` instance will be created or one can be configured and passed to the
-`WireConverter` construction to further control the serialization.
-
 
  [1]: https://github.com/square/wire
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
index 135e50d61..71ab98849 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
@@ -15,39 +15,53 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
+import com.squareup.wire.ProtoAdapter;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers. */
-public final class WireConverterFactory implements Converter.Factory {
-  /** Create an instance using a default {@link Wire} instance for conversion. */
+/**
+ * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
+ * <p>
+ * This converter only applies for types which extend from {@link Message}.
+ */
+public final class WireConverterFactory extends Converter.Factory {
   public static WireConverterFactory create() {
-    return create(new Wire());
+    return new WireConverterFactory();
   }
 
-  /** Create an instance using {@code wire} for conversion. */
-  public static WireConverterFactory create(Wire wire) {
-    return new WireConverterFactory(wire);
+  private WireConverterFactory() {
   }
 
-  private final Wire wire;
-
-  /** Create a converter using the supplied {@link Wire} instance. */
-  private WireConverterFactory(Wire wire) {
-    if (wire == null) throw new NullPointerException("wire == null");
-    this.wire = wire;
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    Class<?> c = (Class<?>) type;
+    if (!Message.class.isAssignableFrom(c)) {
+      return null;
+    }
+    //noinspection unchecked
+    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+    return new WireResponseBodyConverter<>(adapter);
   }
 
-  @Override public Converter<?> get(Type type) {
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
+      return null;
     }
     Class<?> c = (Class<?>) type;
     if (!Message.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
+      return null;
     }
     //noinspection unchecked
-    return new WireConverter<>(wire, (Class<Message>) c);
+    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+    return new WireRequestBodyConverter<>(adapter);
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
similarity index 52%
rename from retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
rename to retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
index c2a997f64..9f90062ea 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,37 +17,23 @@
 
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
+import com.squareup.wire.ProtoAdapter;
 import java.io.IOException;
-import java.io.InputStream;
+import okio.Buffer;
 
-final class WireConverter<T extends Message> implements Converter<T> {
+final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  private final Wire wire;
-  private final Class<T> cls;
+  private final ProtoAdapter<T> adapter;
 
-  public WireConverter(Wire wire, Class<T> cls) {
-    this.wire = wire;
-    this.cls = cls;
+  WireRequestBodyConverter(ProtoAdapter<T> adapter) {
+    this.adapter = adapter;
   }
 
-  @Override public T fromBody(ResponseBody body) throws IOException {
-    InputStream in = body.byteStream();
-    try {
-      return wire.parseFrom(in, cls);
-    } finally {
-      try {
-        in.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(T value) {
-    byte[] bytes = value.toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    adapter.encode(buffer, value);
+    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
   }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
new file mode 100644
index 000000000..4d11a1732
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoAdapter;
+import java.io.IOException;
+import okio.BufferedSource;
+
+final class WireResponseBodyConverter<T extends Message<T, ?>>
+    implements Converter<ResponseBody, T> {
+  private final ProtoAdapter<T> adapter;
+
+  WireResponseBodyConverter(ProtoAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = null;
+    try {
+      source = value.source();
+      return adapter.decode(source);
+    } finally {
+      if (source != null) {
+        try {
+          source.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/Phone.java b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
index e8a47989d..ab0a73683 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
@@ -1,27 +1,80 @@
 // Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: ../wire-runtime/src/test/proto/person.proto
+// Source file: test.proto at 2:1
 package retrofit;
 
+import com.squareup.wire.FieldEncoding;
 import com.squareup.wire.Message;
-import com.squareup.wire.ProtoField;
+import com.squareup.wire.ProtoAdapter;
+import com.squareup.wire.ProtoReader;
+import com.squareup.wire.ProtoWriter;
+import java.io.IOException;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.StringBuilder;
+import okio.ByteString;
 
-import static com.squareup.wire.Message.Datatype.STRING;
-import static com.squareup.wire.Message.Label.OPTIONAL;
+public final class Phone extends Message<Phone, Phone.Builder> {
+  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter<Phone>(FieldEncoding.LENGTH_DELIMITED, Phone.class) {
+    @Override
+    public int encodedSize(Phone value) {
+      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+          + value.unknownFields().size();
+    }
+
+    @Override
+    public void encode(ProtoWriter writer, Phone value) throws IOException {
+      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+      writer.writeBytes(value.unknownFields());
+    }
+
+    @Override
+    public Phone decode(ProtoReader reader) throws IOException {
+      Builder builder = new Builder();
+      long token = reader.beginMessage();
+      for (int tag; (tag = reader.nextTag()) != -1;) {
+        switch (tag) {
+          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
+          default: {
+            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+            builder.addUnknownField(tag, fieldEncoding, value);
+          }
+        }
+      }
+      reader.endMessage(token);
+      return builder.build();
+    }
+
+    @Override
+    public Phone redact(Phone value) {
+      Builder builder = value.newBuilder();
+      builder.clearUnknownFields();
+      return builder.build();
+    }
+  };
 
-public final class Phone extends Message {
+  private static final long serialVersionUID = 0L;
 
-  public static final String DEFAULT_PHONE = "";
+  public static final String DEFAULT_NUMBER = "";
 
-  @ProtoField(tag = 1, type = STRING, label = OPTIONAL)
   public final String number;
 
   public Phone(String number) {
+    this(number, ByteString.EMPTY);
+  }
+
+  public Phone(String number, ByteString unknownFields) {
+    super(unknownFields);
     this.number = number;
   }
 
-  private Phone(Builder builder) {
-    this(builder.number);
-    setBuilder(builder);
+  @Override
+  public Builder newBuilder() {
+    Builder builder = new Builder();
+    builder.number = number;
+    builder.addUnknownFields(unknownFields());
+    return builder;
   }
 
   @Override
@@ -29,41 +82,42 @@ public boolean equals(Object other) {
     if (other == this) return true;
     if (!(other instanceof Phone)) return false;
     Phone o = (Phone) other;
-    return equals(number, o.number);
+    return equals(unknownFields(), o.unknownFields())
+        && equals(number, o.number);
   }
 
   @Override
   public int hashCode() {
-    int result = hashCode;
+    int result = super.hashCode;
     if (result == 0) {
-      result = number != null ? number.hashCode() : 0;
-      hashCode = result;
+      result = unknownFields().hashCode();
+      result = result * 37 + (number != null ? number.hashCode() : 0);
+      super.hashCode = result;
     }
     return result;
   }
 
-  public static final class Builder extends Message.Builder<Phone> {
+  @Override
+  public String toString() {
+    StringBuilder builder = new StringBuilder();
+    if (number != null) builder.append(", number=").append(number);
+    return builder.replace(0, 2, "Phone{").append('}').toString();
+  }
 
+  public static final class Builder extends com.squareup.wire.Message.Builder<Phone, Builder> {
     public String number;
 
     public Builder() {
     }
 
-    public Builder(Phone message) {
-      super(message);
-      if (message == null) return;
-      this.number = message.number;
-    }
-
-    public Builder number(String name) {
-      this.number = name;
+    public Builder number(String number) {
+      this.number = number;
       return this;
     }
 
     @Override
     public Phone build() {
-      checkRequiredFields();
-      return new Phone(this);
+      return new Phone(number, buildUnknownFields());
     }
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
similarity index 80%
rename from retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
rename to retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
index 9b395f93d..e3c27b535 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
@@ -33,7 +33,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public final class WireConverterTest {
+public final class WireConverterFactoryTest {
   interface Service {
     @GET("/") Call<Phone> get();
     @POST("/") Call<Phone> post(@Body Phone impl);
@@ -48,7 +48,7 @@
   @Before public void setUp() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(WireConverterFactory.create())
+        .addConverterFactory(WireConverterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -84,7 +84,12 @@
       service.wrongClass();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method Service.wrongClass");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.WireConverterFactory");
     }
   }
 
@@ -96,7 +101,12 @@
       service.wrongType();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+          + "    for method Service.wrongType");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.WireConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
index 2e3bce2a1..8edf72fab 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -29,7 +29,7 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 final class BehaviorCall<T> implements Call<T> {
-  private final Behavior behavior;
+  private final NetworkBehavior behavior;
   private final ExecutorService backgroundExecutor;
   private final Executor callbackExecutor;
   private final Call<T> delegate;
@@ -38,8 +38,8 @@
   private volatile boolean canceled;
   private volatile boolean executed;
 
-  BehaviorCall(Behavior behavior, ExecutorService backgroundExecutor, Executor callbackExecutor,
-      Call<T> delegate) {
+  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor,
+      Executor callbackExecutor, Call<T> delegate) {
     if (callbackExecutor == null) {
       callbackExecutor = new Executor() {
         @Override public void execute(Runnable command) {
@@ -119,6 +119,10 @@ private void callFailure(final Throwable throwable) {
     });
   }
 
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
   @Override public Response<T> execute() throws IOException {
     final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
@@ -154,4 +158,8 @@ private void callFailure(final Throwable throwable) {
       task.cancel(true);
     }
   }
+
+  @Override public boolean isCanceled() {
+    return canceled;
+  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
index e580d1076..551f706f0 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
@@ -20,7 +20,7 @@
 import retrofit.Call;
 import retrofit.Retrofit;
 
-public final class CallBehaviorAdapter implements BehaviorAdapter<Call<?>> {
+public final class CallBehaviorAdapter implements NetworkBehavior.Adapter<Call<?>> {
   private final Executor callbackExecutor;
   private final ExecutorService backgroundExecutor;
 
@@ -34,7 +34,7 @@ public CallBehaviorAdapter(Retrofit retrofit, ExecutorService backgroundExecutor
     this.backgroundExecutor = backgroundExecutor;
   }
 
-  @Override public Call<?> applyBehavior(Behavior behavior, Call<?> value) {
+  @Override public Call<?> applyBehavior(NetworkBehavior behavior, Call<?> value) {
     return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, value);
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Calls.java b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
index e1d0e7e4f..21343074c 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
@@ -36,9 +36,17 @@
         callback.onResponse(response);
       }
 
+      @Override public boolean isExecuted() {
+        return false;
+      }
+
       @Override public void cancel() {
       }
 
+      @Override public boolean isCanceled() {
+        return false;
+      }
+
       @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
       @Override public Call<T> clone() {
         return this;
@@ -56,9 +64,17 @@
         callback.onFailure(failure);
       }
 
+      @Override public boolean isExecuted() {
+        return false;
+      }
+
       @Override public void cancel() {
       }
 
+      @Override public boolean isCanceled() {
+        return false;
+      }
+
       @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
       @Override public Call<T> clone() {
         return this;
diff --git a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
index dcd966c13..71aaaca6d 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
@@ -20,12 +20,12 @@
 import java.lang.reflect.Proxy;
 
 public final class MockRetrofit {
-  private final BehaviorAdapter<Object> adapter;
-  private final Behavior behavior;
+  private final NetworkBehavior behavior;
+  private final NetworkBehavior.Adapter<Object> adapter;
 
   @SuppressWarnings("unchecked") //
-  public MockRetrofit(BehaviorAdapter<?> adapter, Behavior behavior) {
-    this.adapter = (BehaviorAdapter<Object>) adapter;
+  public MockRetrofit(NetworkBehavior behavior, NetworkBehavior.Adapter<?> adapter) {
+    this.adapter = (NetworkBehavior.Adapter<Object>) adapter;
     this.behavior = behavior;
   }
 
@@ -39,7 +39,9 @@ public MockRetrofit(BehaviorAdapter<?> adapter, Behavior behavior) {
               return method.invoke(this, args);
             }
             method.setAccessible(true); // Just In Case™
-            return adapter.applyBehavior(behavior, method.invoke(instance, args));
+
+            Object value = method.invoke(instance, args);
+            return adapter.applyBehavior(behavior, value);
           }
         });
   }
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Behavior.java b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
similarity index 67%
rename from retrofit-mock/src/main/java/retrofit/mock/Behavior.java
rename to retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
index 713561c5c..f3fdffb77 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/Behavior.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
@@ -21,17 +21,47 @@
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-public final class Behavior {
+/**
+ * A simple emulation of the behavior of network calls.
+ * <p>
+ * This class models three properties of a network:
+ * <ul>
+ * <li>Delay – the time it takes before a response is received (successful or otherwise).</li>
+ * <li>Variance – the amount of fluctuation of the delay to be faster or slower.</li>
+ * <li>Failure - the percentage of operations which fail (such as {@link IOException}).</li>
+ * </ul>
+ * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
+ * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
+ * <p>
+ * By default, instances of this class will use a 2 second delay with 40% variance and failures
+ * will occur 3% of the time.
+ */
+public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
 
-  public static Behavior create() {
-    return new Behavior(new Random());
+  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
+  public interface Adapter<T> {
+    /**
+     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+     * traits when interacted with.
+     */
+    T applyBehavior(NetworkBehavior behavior, T value);
+  }
+
+  /** Create an instance with default behavior. */
+  public static NetworkBehavior create() {
+    return new NetworkBehavior(new Random());
   }
 
-  public static Behavior create(Random random) {
-    return new Behavior(random);
+  /**
+   * Create an instance with default behavior which uses {@code random} to control variance and
+   * failure calculation.
+   */
+  public static NetworkBehavior create(Random random) {
+    if (random == null) throw new NullPointerException("random == null");
+    return new NetworkBehavior(random);
   }
 
   private final Random random;
@@ -39,9 +69,9 @@ public static Behavior create(Random random) {
   private volatile long delayMs = DEFAULT_DELAY_MS;
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile IOException failureException = new IOException("Mock failure!");
+  private volatile Throwable failureException = new IOException("Mock failure!");
 
-  private Behavior(Random random) {
+  private NetworkBehavior(Random random) {
     this.random = random;
   }
 
@@ -85,15 +115,15 @@ public int failurePercent() {
   }
 
   /** Set the exception to be used when a failure is triggered. */
-  public void setFailureException(IOException exception) {
-    if (exception == null) {
-      throw new NullPointerException("exception == null");
+  public void setFailureException(Throwable t) {
+    if (t == null) {
+      throw new NullPointerException("t == null");
     }
-    this.failureException = exception;
+    this.failureException = t;
   }
 
   /** The exception to be used when a failure is triggered. */
-  public IOException failureException() {
+  public Throwable failureException() {
     return failureException;
   }
 
diff --git a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit/mock/MockRetrofitTest.java
similarity index 95%
rename from retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
rename to retrofit-mock/src/test/java/retrofit/mock/MockRetrofitTest.java
index f1f2d8cdc..4778bebb5 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit/mock/MockRetrofitTest.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package retrofit;
+package retrofit.mock;
 
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -25,11 +25,14 @@
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.mock.Behavior;
-import retrofit.mock.BehaviorAdapter;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+import retrofit.Retrofit;
 import retrofit.mock.CallBehaviorAdapter;
 import retrofit.mock.Calls;
 import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
 
 import static java.util.concurrent.Executors.newSingleThreadExecutor;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -45,7 +48,7 @@
   }
 
   private final IOException mockFailure = new IOException("Timeout!");
-  private final Behavior behavior = Behavior.create(new Random(2847));
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
   private DoWorkService service;
 
   @Before public void setUp() {
@@ -63,8 +66,9 @@
       }
     };
 
-    BehaviorAdapter<?> adapter = new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
-    MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
+    NetworkBehavior.Adapter<?> adapter =
+        new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
     service = mockRetrofit.create(DoWorkService.class, mockService);
   }
 
diff --git a/retrofit-mock/src/test/java/retrofit/BehaviorTest.java b/retrofit-mock/src/test/java/retrofit/mock/NetworkBehaviorTest.java
similarity index 94%
rename from retrofit-mock/src/test/java/retrofit/BehaviorTest.java
rename to retrofit-mock/src/test/java/retrofit/mock/NetworkBehaviorTest.java
index 46b75be17..2a86f3869 100644
--- a/retrofit-mock/src/test/java/retrofit/BehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit/mock/NetworkBehaviorTest.java
@@ -13,19 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit;
+package retrofit.mock;
 
 import java.util.Random;
 import org.junit.Test;
-import retrofit.mock.Behavior;
+import retrofit.mock.NetworkBehavior;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-public final class BehaviorTest {
-  private final Behavior behavior = Behavior.create(new Random(2847));
+public final class NetworkBehaviorTest {
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
   @Test public void delayMustBePositive() {
     try {
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index b4e355270..a6d9f5496 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -25,6 +25,12 @@
       <optional>true</optional>
     </dependency>
 
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <optional>true</optional>
+    </dependency>
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/retrofit/src/main/java/retrofit/BuiltInConverters.java b/retrofit/src/main/java/retrofit/BuiltInConverters.java
new file mode 100644
index 000000000..8f7cf4ae8
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/BuiltInConverters.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit.http.Streaming;
+
+final class BuiltInConverters extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (type == ResponseBody.class) {
+      if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
+        return StreamingResponseBodyConverter.INSTANCE;
+      }
+      return BufferingResponseBodyConverter.INSTANCE;
+    }
+    if (type == Void.class) {
+      return VoidResponseBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+      return RequestBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+    if (type == String.class) {
+      return StringConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  static final class StringConverter implements Converter<String, String> {
+    static final StringConverter INSTANCE = new StringConverter();
+
+    @Override public String convert(String value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
+    static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
+
+    @Override public Void convert(ResponseBody value) throws IOException {
+      value.close();
+      return null;
+    }
+  }
+
+  static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
+    static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
+
+    @Override public RequestBody convert(RequestBody value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class StreamingResponseBodyConverter
+      implements Converter<ResponseBody, ResponseBody> {
+    static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
+
+    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class BufferingResponseBodyConverter
+      implements Converter<ResponseBody, ResponseBody> {
+    static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
+
+    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+      try {
+        // Buffer the entire body to avoid future I/O.
+        return Utils.readBodyToBytesIfNecessary(value);
+      } finally {
+        Utils.closeQuietly(value);
+      }
+    }
+  }
+
+  static final class ToStringConverter implements Converter<Object, String> {
+    static final ToStringConverter INSTANCE = new ToStringConverter();
+
+    @Override public String convert(Object value) {
+      return value.toString();
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index 9e96e45c5..968aba8b4 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -27,10 +27,43 @@
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
  * working as designed.
+ *
+ * @param <T> Successful response body type.
  */
 public interface Call<T> extends Cloneable {
+  /**
+   * Synchronously send the request and return its response.
+   *
+   * @throws IOException if a problem occurred talking to the server.
+   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+   * or decoding the response.
+   */
   Response<T> execute() throws IOException;
+
+  /**
+   * Asynchronously send the request and notify {@code callback} of its response or if an error
+   * occurred talking to the server, creating the request, or processing the response.
+   */
   void enqueue(Callback<T> callback);
+
+  /**
+   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+   */
+  boolean isExecuted();
+
+  /**
+   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+   * yet been executed it never will be.
+   */
   void cancel();
+
+  /** True if {@link #cancel()} was called. */
+  boolean isCanceled();
+
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
   Call<T> clone();
 }
diff --git a/retrofit/src/main/java/retrofit/CallAdapter.java b/retrofit/src/main/java/retrofit/CallAdapter.java
index ee77630dd..38c099d71 100644
--- a/retrofit/src/main/java/retrofit/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -15,8 +15,10 @@
  */
 package retrofit;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
+/** Adapts a {@link Call} into the type of {@code T}. */
 public interface CallAdapter<T> {
   /**
    * Returns the value type that this adapter uses when converting the HTTP response body to a Java
@@ -28,18 +30,15 @@
    */
   Type responseType();
 
-  /**
-   * Returns an instance of the {@code returnType}, the same type originally passed to {@link
-   * Factory#get} used to create this instance.
-   */
-  Object adapt(Call<T> call);
+  /** Returns an instance of the {@code T} which adapts the execution of {@code call}. */
+  <R> T adapt(Call<R> call);
 
+  /** Creates {@link CallAdapter} instances based on a desired type. */
   interface Factory {
-
     /**
-     * Returns a call adapter for calls that return {@code returnType}, or null if this factory
-     * doesn't adapt that type.
+     * Returns a call adapter for interface methods that return {@code returnType}, or null if it
+     * cannot be handled by this factory.
      */
-    CallAdapter<?> get(Type returnType);
+    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 6841a2dd3..e6d48dcaf 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -26,12 +26,20 @@
  * <li>JVM: Callbacks are executed on the background thread which performed the request.</li>
  * </ul>
  *
- * @param <T> expected response type
+ * @param <T> Successful response body type.
  */
 public interface Callback<T> {
-  /** Successful HTTP response. */
+  /**
+   * Invoked for a received HTTP response.
+   * <p>
+   * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
+   * Call {@link Response#isSuccess()} to determine if the response indicates success.
+   */
   void onResponse(Response<T> response);
 
-  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
+  /**
+   * Invoked when a network exception occurred talking to the server or when an unexpected
+   * exception occurred creating the request or processing the response.
+   */
   void onFailure(Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
index 7405a9898..41aab20ab 100644
--- a/retrofit/src/main/java/retrofit/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -18,17 +18,58 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import retrofit.http.Body;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.Header;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
 
-/** Convert objects to and from their representation as HTTP bodies. */
-public interface Converter<T> {
-  /** Convert an HTTP response body to a concrete object of the specified type. */
-  T fromBody(ResponseBody body) throws IOException;
+/**
+ * Convert objects to and from their representation in HTTP. Register a converter with Retrofit
+ * using {@link Retrofit.Builder#addConverterFactory(Factory)}.
+ */
+public interface Converter<F, T> {
+  T convert(F value) throws IOException;
+
+  /** Creates {@link Converter} instances based on a type and target usage. */
+  abstract class Factory {
+    /**
+     * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
+     * {@code type} cannot be handled by this factory. This is used to create converters for
+     * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
+     * declaration.
+     */
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      return null;
+    }
 
-  /** Convert an object to an appropriate representation for HTTP transport. */
-  RequestBody toBody(T value);
+    /**
+     * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
+     * {@code type} cannot be handled by this factory. This is used to create converters for types
+     * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
+     * values.
+     */
+    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      return null;
+    }
 
-  interface Factory {
-    Converter<?> get(Type type);
+    /**
+     * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
+     * {@code type} cannot be handled by this factory. This is used to create converters for types
+     * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
+     * {@link Header @Header}, {@link Path @Path}, {@link Query @Query}, and
+     * {@link QueryMap @QueryMap} values.
+     */
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+      return null;
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
index 00e9b524b..64f9bf913 100644
--- a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
@@ -15,6 +15,7 @@
  */
 package retrofit;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
 /**
@@ -22,18 +23,15 @@
  * synchronous calls this is the application thread making the request; for asynchronous calls this
  * is a thread provided by OkHttp's dispatcher.
  */
-final class DefaultCallAdapter<T> implements CallAdapter<T> {
-  public static final Factory FACTORY = new Factory() {
-    @Override public CallAdapter<?> get(Type returnType) {
+final class DefaultCallAdapter implements CallAdapter<Call<?>> {
+  static final Factory FACTORY = new Factory() {
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (Utils.getRawType(returnType) != Call.class) {
         return null;
       }
       Type responseType = Utils.getCallResponseType(returnType);
-      return new DefaultCallAdapter<>(responseType);
-    }
-
-    @Override public String toString() {
-      return "Default";
+      return new DefaultCallAdapter(responseType);
     }
   };
 
@@ -47,7 +45,7 @@
     return responseType;
   }
 
-  @Override public Call<T> adapt(Call<T> call) {
+  @Override public <R> Call<R> adapt(Call<R> call) {
     return call;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
deleted file mode 100644
index 52d0e819c..000000000
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-
-final class ExceptionCatchingRequestBody extends ResponseBody {
-  private final ResponseBody delegate;
-  private IOException thrownException;
-
-  ExceptionCatchingRequestBody(ResponseBody delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() throws IOException {
-    try {
-      return delegate.contentLength();
-    } catch (IOException e) {
-      thrownException = e;
-      throw e;
-    }
-  }
-
-  @Override public BufferedSource source() throws IOException {
-    BufferedSource delegateSource;
-    try {
-      delegateSource = delegate.source();
-    } catch (IOException e) {
-      thrownException = e;
-      throw e;
-    }
-    return Okio.buffer(new ForwardingSource(delegateSource) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        try {
-          return super.read(sink, byteCount);
-        } catch (IOException e) {
-          thrownException = e;
-          throw e;
-        }
-      }
-    });
-  }
-
-  @Override public void close() throws IOException {
-    delegate.close();
-  }
-
-  void throwIfCaught() throws IOException {
-    if (thrownException != null) {
-      throw thrownException;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
index d9af81ca4..15ed08770 100644
--- a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -16,6 +16,7 @@
 package retrofit;
 
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
 
@@ -26,21 +27,18 @@
     this.callbackExecutor = callbackExecutor;
   }
 
-  @Override public String toString() {
-    return "ExecutorCallAdapterFactory[" + callbackExecutor + ']';
-  }
-
-  @Override public CallAdapter<?> get(Type returnType) {
+  @Override
+  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (Utils.getRawType(returnType) != Call.class) {
       return null;
     }
     final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object>() {
+    return new CallAdapter<Call<?>>() {
       @Override public Type responseType() {
         return responseType;
       }
 
-      @Override public Call<Object> adapt(Call<Object> call) {
+      @Override public <R> Call<R> adapt(Call<R> call) {
         return new ExecutorCallbackCall<>(callbackExecutor, call);
       }
     };
@@ -55,8 +53,33 @@
       this.delegate = delegate;
     }
 
-    @Override public void enqueue(Callback<T> callback) {
-      delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback));
+    @Override public void enqueue(final Callback<T> callback) {
+      delegate.enqueue(new Callback<T>() {
+        @Override public void onResponse(final Response<T> response) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              if (delegate.isCanceled()) {
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancelation
+                callback.onFailure(new IOException("Canceled"));
+              } else {
+                callback.onResponse(response);
+              }
+            }
+          });
+        }
+
+        @Override public void onFailure(final Throwable t) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              callback.onFailure(t);
+            }
+          });
+        }
+      });
+    }
+
+    @Override public boolean isExecuted() {
+      return delegate.isExecuted();
     }
 
     @Override public Response<T> execute() throws IOException {
@@ -67,35 +90,13 @@
       delegate.cancel();
     }
 
+    @Override public boolean isCanceled() {
+      return delegate.isCanceled();
+    }
+
     @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
     @Override public Call<T> clone() {
       return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
     }
   }
-
-  static final class ExecutorCallback<T> implements Callback<T> {
-    private final Executor callbackExecutor;
-    private final Callback<T> delegate;
-
-    ExecutorCallback(Executor callbackExecutor, Callback<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
-    }
-
-    @Override public void onResponse(final Response<T> response) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          delegate.onResponse(response);
-        }
-      });
-    }
-
-    @Override public void onFailure(final Throwable t) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          delegate.onFailure(t);
-        }
-      });
-    }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
index f0231aef8..2b3814700 100644
--- a/retrofit/src/main/java/retrofit/MethodHandler.java
+++ b/retrofit/src/main/java/retrofit/MethodHandler.java
@@ -17,74 +17,55 @@
 
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import retrofit.http.Streaming;
-
-import static retrofit.Utils.methodError;
 
 final class MethodHandler<T> {
   @SuppressWarnings("unchecked")
-  static MethodHandler<?> create(Method method, OkHttpClient client, BaseUrl baseUrl,
-      CallAdapter.Factory callAdapterFactory, Converter.Factory converterFactory) {
-    CallAdapter<Object> callAdapter =
-        (CallAdapter<Object>) createCallAdapter(method, callAdapterFactory);
-    Converter<Object> responseConverter =
-        (Converter<Object>) createResponseConverter(method, callAdapter.responseType(),
-            converterFactory);
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactory);
-    return new MethodHandler<>(client, requestFactory, callAdapter, responseConverter);
+  static MethodHandler<?> create(Retrofit retrofit, Method method) {
+    CallAdapter<Object> callAdapter = (CallAdapter<Object>) createCallAdapter(method, retrofit);
+    Type responseType = callAdapter.responseType();
+    Converter<ResponseBody, Object> responseConverter =
+        (Converter<ResponseBody, Object>) createResponseConverter(method, retrofit, responseType);
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
+    return new MethodHandler<>(retrofit.client(), requestFactory, callAdapter, responseConverter);
   }
 
-  private static CallAdapter<?> createCallAdapter(Method method,
-      CallAdapter.Factory adapterFactory) {
+  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
-      throw methodError(method,
+      throw Utils.methodError(method,
           "Method return type must not include a type variable or wildcard: %s", returnType);
     }
-
     if (returnType == void.class) {
-      throw methodError(method, "Service methods cannot return void.");
+      throw Utils.methodError(method, "Service methods cannot return void.");
     }
-
-    CallAdapter<?> adapter = adapterFactory.get(returnType);
-    if (adapter == null) {
-      throw methodError(method, "Call adapter factory '%s' was unable to handle return type %s",
-          adapterFactory, returnType);
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.callAdapter(returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
     }
-    return adapter;
   }
 
-  private static Converter<?> createResponseConverter(Method method, Type responseType,
-      Converter.Factory converterFactory) {
-    if (responseType == ResponseBody.class) {
-      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
-      return new OkHttpResponseBodyConverter(isStreaming);
-    }
-
-    if (converterFactory == null) {
-      throw methodError(method, "Method response type is "
-          + responseType
-          + " but no converter factory registered. "
-          + "Either add a converter factory to the Retrofit instance or use ResponseBody.");
-    }
-
-    Converter<?> converter = converterFactory.get(responseType);
-    if (converter == null) {
-      throw methodError(method, "Converter factory '%s' was unable to handle response type %s",
-          converterFactory, responseType);
+  private static Converter<ResponseBody, ?> createResponseConverter(Method method,
+      Retrofit retrofit, Type responseType) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return retrofit.responseBodyConverter(responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw Utils.methodError(e, method, "Unable to create converter for %s", responseType);
     }
-    return converter;
   }
 
   private final OkHttpClient client;
   private final RequestFactory requestFactory;
   private final CallAdapter<T> callAdapter;
-  private final Converter<T> responseConverter;
+  private final Converter<ResponseBody, T> responseConverter;
 
   private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
-      CallAdapter<T> callAdapter, Converter<T> responseConverter) {
+      CallAdapter<T> callAdapter, Converter<ResponseBody, T> responseConverter) {
     this.client = client;
     this.requestFactory = requestFactory;
     this.callAdapter = callAdapter;
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index 28af644c6..70cef8315 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -15,25 +15,30 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
 
 import static retrofit.Utils.closeQuietly;
 
 final class OkHttpCall<T> implements Call<T> {
   private final OkHttpClient client;
   private final RequestFactory requestFactory;
-  private final Converter<T> responseConverter;
+  private final Converter<ResponseBody, T> responseConverter;
   private final Object[] args;
 
   private volatile com.squareup.okhttp.Call rawCall;
   private boolean executed; // Guarded by this.
   private volatile boolean canceled;
 
-  OkHttpCall(OkHttpClient client, RequestFactory requestFactory, Converter<T> responseConverter,
-      Object[] args) {
+  OkHttpCall(OkHttpClient client, RequestFactory requestFactory,
+      Converter<ResponseBody, T> responseConverter, Object[] args) {
     this.client = client;
     this.requestFactory = requestFactory;
     this.responseConverter = responseConverter;
@@ -45,7 +50,7 @@
     return new OkHttpCall<>(client, requestFactory, responseConverter, args);
   }
 
-  public void enqueue(final Callback<T> callback) {
+  @Override public void enqueue(final Callback<T> callback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
       executed = true;
@@ -97,6 +102,10 @@ private void callSuccess(Response<T> response) {
     });
   }
 
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
   public Response<T> execute() throws IOException {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
@@ -112,7 +121,7 @@ private void callSuccess(Response<T> response) {
     return parseResponse(rawCall.execute());
   }
 
-  private com.squareup.okhttp.Call createRawCall() {
+  private com.squareup.okhttp.Call createRawCall() throws IOException {
     return client.newCall(requestFactory.create(args));
   }
 
@@ -141,7 +150,7 @@ private void callSuccess(Response<T> response) {
 
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
-      T body = responseConverter.fromBody(catchingBody);
+      T body = responseConverter.convert(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
@@ -158,4 +167,82 @@ public void cancel() {
       rawCall.cancel();
     }
   }
+
+  @Override public boolean isCanceled() {
+    return canceled;
+  }
+
+  static final class NoContentResponseBody extends ResponseBody {
+    private final MediaType contentType;
+    private final long contentLength;
+
+    NoContentResponseBody(MediaType contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public long contentLength() throws IOException {
+      return contentLength;
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      throw new IllegalStateException("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  static final class ExceptionCatchingRequestBody extends ResponseBody {
+    private final ResponseBody delegate;
+    private IOException thrownException;
+
+    ExceptionCatchingRequestBody(ResponseBody delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public MediaType contentType() {
+      return delegate.contentType();
+    }
+
+    @Override public long contentLength() throws IOException {
+      try {
+        return delegate.contentLength();
+      } catch (IOException e) {
+        thrownException = e;
+        throw e;
+      }
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      BufferedSource delegateSource;
+      try {
+        delegateSource = delegate.source();
+      } catch (IOException e) {
+        thrownException = e;
+        throw e;
+      }
+      return Okio.buffer(new ForwardingSource(delegateSource) {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          try {
+            return super.read(sink, byteCount);
+          } catch (IOException e) {
+            thrownException = e;
+            throw e;
+          }
+        }
+      });
+    }
+
+    @Override public void close() throws IOException {
+      delegate.close();
+    }
+
+    void throwIfCaught() throws IOException {
+      if (thrownException != null) {
+        throw thrownException;
+      }
+    }
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 845b61c47..b28337158 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -18,9 +18,10 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import com.squareup.okhttp.OkHttpClient;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -37,7 +38,11 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-
+    try {
+      Class.forName("java.util.Optional");
+      return new Java8();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
@@ -48,15 +53,31 @@ private static Platform findPlatform() {
     return DefaultCallAdapter.FACTORY;
   }
 
-  OkHttpClient defaultClient() {
-    OkHttpClient client = new OkHttpClient();
-    client.setConnectTimeout(15, TimeUnit.SECONDS);
-    client.setReadTimeout(15, TimeUnit.SECONDS);
-    client.setWriteTimeout(15, TimeUnit.SECONDS);
-    return client;
+  boolean isDefaultMethod(Method method) {
+    return false;
+  }
+
+  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+      throws Throwable {
+    throw new UnsupportedOperationException();
+  }
+
+  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+  static class Java8 extends Platform {
+    @Override boolean isDefaultMethod(Method method) {
+      return method.isDefault();
+    }
+
+    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+        Object... args) throws Throwable {
+      return MethodHandles.lookup()
+          .in(declaringClass)
+          .unreflectSpecial(method, declaringClass)
+          .bindTo(object)
+          .invokeWithArguments(args);
+    }
   }
 
-  /** Provides sane defaults for operation on Android. */
   static class Android extends Platform {
     @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
       if (callbackExecutor == null) {
@@ -71,10 +92,6 @@ OkHttpClient defaultClient() {
       @Override public void execute(Runnable r) {
         handler.post(r);
       }
-
-      @Override public String toString() {
-        return "MainThreadExecutor";
-      }
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestAction.java b/retrofit/src/main/java/retrofit/RequestAction.java
new file mode 100644
index 000000000..157de3906
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestAction.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.lang.reflect.Array;
+import java.util.Map;
+
+import static retrofit.Utils.checkNotNull;
+
+abstract class RequestAction<T> {
+  abstract void perform(RequestBuilder builder, T value) throws IOException;
+
+  final RequestAction<Iterable<T>> iterable() {
+    return new RequestAction<Iterable<T>>() {
+      @Override void perform(RequestBuilder builder, Iterable<T> values) throws IOException {
+        if (values == null) return; // Skip null values.
+
+        for (T value : values) {
+          RequestAction.this.perform(builder, value);
+        }
+      }
+    };
+  }
+
+  final RequestAction<Object> array() {
+    return new RequestAction<Object>() {
+      @Override void perform(RequestBuilder builder, Object values) throws IOException {
+        if (values == null) return; // Skip null values.
+
+        for (int i = 0, size = Array.getLength(values); i < size; i++) {
+          //noinspection unchecked
+          RequestAction.this.perform(builder, (T) Array.get(values, i));
+        }
+      }
+    };
+  }
+
+  static final class Url extends RequestAction<String> {
+    @Override void perform(RequestBuilder builder, String value) {
+      builder.setRelativeUrl(value);
+    }
+  }
+
+  static final class Header<T> extends RequestAction<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+
+    Header(String name, Converter<T, String> valueConverter) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void perform(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addHeader(name, valueConverter.convert(value));
+    }
+  }
+
+  static final class Path<T> extends RequestAction<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, T value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
+      }
+      builder.addPathParam(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class Query<T> extends RequestAction<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class QueryMap<T> extends RequestAction<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) return; // Skip null values.
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Query map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Field<T> extends RequestAction<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addFormField(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class FieldMap<T> extends RequestAction<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) return; // Skip null values.
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Field map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Part<T> extends RequestAction<T> {
+    private final Headers headers;
+    private final Converter<T, RequestBody> converter;
+
+    Part(Headers headers, Converter<T, RequestBody> converter) {
+      this.headers = headers;
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, T value) {
+      if (value == null) return; // Skip null values.
+
+      RequestBody body;
+      try {
+        body = converter.convert(value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+      }
+      builder.addPart(headers, body);
+    }
+  }
+
+  static final class PartMap<T> extends RequestAction<Map<String, T>> {
+    private final Converter<T, RequestBody> valueConverter;
+    private final String transferEncoding;
+
+    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+      this.valueConverter = valueConverter;
+      this.transferEncoding = transferEncoding;
+    }
+
+    @Override void perform(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) return; // Skip null values.
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Part map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          continue; // Skip null values.
+        }
+
+        Headers headers = Headers.of(
+            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+            "Content-Transfer-Encoding", transferEncoding);
+
+        builder.addPart(headers, valueConverter.convert(entryValue));
+      }
+    }
+  }
+
+  static final class Body<T> extends RequestAction<T> {
+    private final Converter<T, RequestBody> converter;
+
+    Body(Converter<T, RequestBody> converter) {
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, T value) {
+      if (value == null) {
+        throw new IllegalArgumentException("Body parameter value must not be null.");
+      }
+      RequestBody body;
+      try {
+        body = converter.convert(value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+      }
+      builder.setBody(body);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index b620f3aad..65eed2c1a 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -23,11 +23,14 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
+import okio.Buffer;
 import okio.BufferedSink;
 
 final class RequestBuilder {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  private static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+
   private final String method;
 
   private final HttpUrl baseUrl;
@@ -35,7 +38,7 @@
   private HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
-  private MediaType mediaType;
+  private MediaType contentType;
 
   private final boolean hasBody;
   private MultipartBuilder multipartBuilder;
@@ -43,20 +46,17 @@
   private RequestBody body;
 
   RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
-
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
+    this.requestBuilder = new Request.Builder();
+    this.contentType = contentType;
+    this.hasBody = hasBody;
 
-    Request.Builder requestBuilder = new Request.Builder();
     if (headers != null) {
       requestBuilder.headers(headers);
     }
-    this.requestBuilder = requestBuilder;
-    this.mediaType = mediaType;
-
-    this.hasBody = hasBody;
 
     if (isFormEncoded) {
       // Will be set to 'body' in 'build'.
@@ -64,6 +64,7 @@
     } else if (isMultipart) {
       // Will be set to 'body' in 'build'.
       multipartBuilder = new MultipartBuilder();
+      multipartBuilder.type(MultipartBuilder.FORM);
     }
   }
 
@@ -73,7 +74,7 @@ void setRelativeUrl(String relativeUrl) {
 
   void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      mediaType = MediaType.parse(value);
+      contentType = MediaType.parse(value);
     } else {
       requestBuilder.addHeader(name, value);
     }
@@ -84,20 +85,55 @@ void addPathParam(String name, String value, boolean encoded) {
       // The relative URL is cleared when the first query parameter is set.
       throw new AssertionError();
     }
-    try {
-      if (!encoded) {
-        String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
-        // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
-        // encode spaces rather than +. Query encoding difference specified in HTML spec.
-        // Any remaining plus signs represent spaces as already URLEncoded.
-        encodedValue = encodedValue.replace("+", "%20");
-        relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalize(value, encoded));
+  }
+
+  static String canonicalize(String input, boolean alreadyEncoded) {
+    int codePoint;
+    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, 0, i);
+        canonicalize(out, input, i, limit, alreadyEncoded);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters required encoding.
+    return input;
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit, boolean alreadyEncoded) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || PATH_SEGMENT_ENCODE_SET.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
       } else {
-        relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
       }
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert path parameter \"" + name + "\" value to UTF-8:" + value, e);
     }
   }
 
@@ -154,12 +190,12 @@ Request build() {
       }
     }
 
-    MediaType mediaType = this.mediaType;
-    if (mediaType != null) {
+    MediaType contentType = this.contentType;
+    if (contentType != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, mediaType);
+        body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        requestBuilder.addHeader("Content-Type", mediaType.toString());
+        requestBuilder.addHeader("Content-Type", contentType.toString());
       }
     }
 
@@ -169,17 +205,17 @@ Request build() {
         .build();
   }
 
-  private static class MediaTypeOverridingRequestBody extends RequestBody {
+  private static class ContentTypeOverridingRequestBody extends RequestBody {
     private final RequestBody delegate;
-    private final MediaType mediaType;
+    private final MediaType contentType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, MediaType mediaType) {
+    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
       this.delegate = delegate;
-      this.mediaType = mediaType;
+      this.contentType = contentType;
     }
 
     @Override public MediaType contentType() {
-      return mediaType;
+      return contentType;
     }
 
     @Override public long contentLength() throws IOException {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
deleted file mode 100644
index bc8b1a472..000000000
--- a/retrofit/src/main/java/retrofit/RequestBuilderAction.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Headers;
-import java.lang.reflect.Array;
-import java.util.Map;
-
-import static retrofit.Utils.checkNotNull;
-
-abstract class RequestBuilderAction {
-  abstract void perform(RequestBuilder builder, Object value);
-
-  static final class Url extends RequestBuilderAction {
-    @Override void perform(RequestBuilder builder, Object value) {
-      builder.setRelativeUrl((String) value);
-    }
-  }
-
-  static final class Header extends RequestBuilderAction {
-    private final String name;
-
-    Header(String name) {
-      this.name = checkNotNull(name, "name == null");
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addHeader(name, iterableValue.toString());
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addHeader(name, arrayValue.toString());
-          }
-        }
-      } else {
-        builder.addHeader(name, value.toString());
-      }
-    }
-  }
-
-  static final class Path extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Path(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, value.toString(), encoded);
-    }
-  }
-
-  static final class Query extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Query(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addQueryParam(name, iterableValue.toString(), encoded);
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addQueryParam(name, arrayValue.toString(), encoded);
-          }
-        }
-      } else {
-        builder.addQueryParam(name, value.toString(), encoded);
-      }
-    }
-  }
-
-  static final class QueryMap extends RequestBuilderAction {
-    private final boolean encoded;
-
-    QueryMap(boolean encoded) {
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
-        }
-      }
-    }
-  }
-
-  static final class Field extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Field(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addFormField(name, iterableValue.toString(), encoded);
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addFormField(name, arrayValue.toString(), encoded);
-          }
-        }
-      } else {
-        builder.addFormField(name, value.toString(), encoded);
-      }
-    }
-  }
-
-  static final class FieldMap extends RequestBuilderAction {
-    private final boolean encoded;
-
-    FieldMap(boolean encoded) {
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
-        }
-      }
-    }
-  }
-
-  static final class Part<T> extends RequestBuilderAction {
-    private final Headers headers;
-    private final Converter<T> converter;
-
-    Part(Headers headers, Converter<T> converter) {
-      this.headers = headers;
-      this.converter = converter;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      //noinspection unchecked
-      builder.addPart(headers, converter.toBody((T) value));
-    }
-  }
-
-  static final class PartMap extends RequestBuilderAction {
-    private final Converter.Factory converterFactory;
-    private final String transferEncoding;
-
-    PartMap(Converter.Factory converterFactory, String transferEncoding) {
-      this.converterFactory = converterFactory;
-      this.transferEncoding = transferEncoding;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue == null) {
-          continue; // Skip null values.
-        }
-
-        Headers headers = Headers.of(
-            "Content-Disposition", "name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-        //noinspection unchecked
-        Converter<Object> converter =
-            (Converter<Object>) converterFactory.get(entryValue.getClass());
-        builder.addPart(headers, converter.toBody(entryValue));
-      }
-    }
-  }
-
-  static final class Body<T> extends RequestBuilderAction {
-    private final Converter<T> converter;
-
-    Body(Converter<T> converter) {
-      this.converter = converter;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      //noinspection unchecked
-      builder.setBody(converter.toBody((T) value));
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
index 63527aabe..6a92b1467 100644
--- a/retrofit/src/main/java/retrofit/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit/RequestFactory.java
@@ -18,39 +18,40 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
+import java.io.IOException;
 
 final class RequestFactory {
   private final String method;
   private final BaseUrl baseUrl;
   private final String relativeUrl;
   private final Headers headers;
-  private final MediaType mediaType;
+  private final MediaType contentType;
   private final boolean hasBody;
   private final boolean isFormEncoded;
   private final boolean isMultipart;
-  private final RequestBuilderAction[] requestBuilderActions;
+  private final RequestAction[] requestActions;
 
   RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
-      RequestBuilderAction[] requestBuilderActions) {
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
+      RequestAction[] requestActions) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
     this.headers = headers;
-    this.mediaType = mediaType;
+    this.contentType = contentType;
     this.hasBody = hasBody;
     this.isFormEncoded = isFormEncoded;
     this.isMultipart = isMultipart;
-    this.requestBuilderActions = requestBuilderActions;
+    this.requestActions = requestActions;
   }
 
-  Request create(Object... args) {
+  Request create(Object... args) throws IOException {
     RequestBuilder requestBuilder =
-        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, mediaType, hasBody,
+        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
             isFormEncoded, isMultipart);
 
     if (args != null) {
-      RequestBuilderAction[] actions = requestBuilderActions;
+      RequestAction[] actions = requestActions;
       if (actions.length != args.length) {
         throw new IllegalArgumentException("Argument count ("
             + args.length
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
index 79337ee2c..79422eeaf 100644
--- a/retrofit/src/main/java/retrofit/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -19,6 +19,7 @@
 import com.squareup.okhttp.RequestBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.LinkedHashSet;
 import java.util.Map;
@@ -36,6 +37,7 @@
 import retrofit.http.Header;
 import retrofit.http.Headers;
 import retrofit.http.Multipart;
+import retrofit.http.OPTIONS;
 import retrofit.http.PATCH;
 import retrofit.http.POST;
 import retrofit.http.PUT;
@@ -54,11 +56,11 @@
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-  static RequestFactory parse(Method method, BaseUrl baseUrl, Converter.Factory converterFactory) {
+  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
     RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations();
-    parser.parseParameters(converterFactory);
-    return parser.toRequestFactory(baseUrl);
+    parser.parseMethodAnnotations(responseType);
+    parser.parseParameters(retrofit);
+    return parser.toRequestFactory(retrofit.baseUrl());
   }
 
   private final Method method;
@@ -69,8 +71,8 @@ static RequestFactory parse(Method method, BaseUrl baseUrl, Converter.Factory co
   private boolean isMultipart;
   private String relativeUrl;
   private com.squareup.okhttp.Headers headers;
-  private MediaType mediaType;
-  private RequestBuilderAction[] requestBuilderActions;
+  private MediaType contentType;
+  private RequestAction[] requestActions;
 
   private Set<String> relativeUrlParamNames;
 
@@ -79,15 +81,20 @@ private RequestFactoryParser(Method method) {
   }
 
   private RequestFactory toRequestFactory(BaseUrl baseUrl) {
-    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, mediaType, hasBody,
-        isFormEncoded, isMultipart, requestBuilderActions);
+    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
+        isFormEncoded, isMultipart, requestActions);
+  }
+
+  private RuntimeException parameterError(Throwable cause, int index, String message,
+      Object... args) {
+    return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
   }
 
   private RuntimeException parameterError(int index, String message, Object... args) {
     return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
   }
 
-  private void parseMethodAnnotations() {
+  private void parseMethodAnnotations(Type responseType) {
     for (Annotation annotation : method.getAnnotations()) {
       if (annotation instanceof DELETE) {
         parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
@@ -95,12 +102,17 @@ private void parseMethodAnnotations() {
         parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
       } else if (annotation instanceof HEAD) {
         parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+        if (!Void.class.equals(responseType)) {
+          throw methodError(method, "HEAD method must use Void as response type.");
+        }
       } else if (annotation instanceof PATCH) {
         parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
       } else if (annotation instanceof POST) {
         parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
       } else if (annotation instanceof PUT) {
         parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof OPTIONS) {
+        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
       } else if (annotation instanceof HTTP) {
         HTTP http = (HTTP) annotation;
         parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
@@ -178,7 +190,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
       if ("Content-Type".equalsIgnoreCase(headerName)) {
-        mediaType = MediaType.parse(headerValue);
+        contentType = MediaType.parse(headerValue);
       } else {
         builder.add(headerName, headerValue);
       }
@@ -186,7 +198,7 @@ private void parseHttpMethodAndPath(String httpMethod, String value, boolean has
     return builder.build();
   }
 
-  private void parseParameters(Converter.Factory converterFactory) {
+  private void parseParameters(Retrofit retrofit) {
     Type[] methodParameterTypes = method.getGenericParameterTypes();
     Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
 
@@ -198,13 +210,18 @@ private void parseParameters(Converter.Factory converterFactory) {
     boolean gotUrl = false;
 
     int count = methodParameterAnnotationArrays.length;
-    RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
+    RequestAction[] requestActions = new RequestAction[count];
     for (int i = 0; i < count; i++) {
       Type methodParameterType = methodParameterTypes[i];
+      if (Utils.hasUnresolvableType(methodParameterType)) {
+        throw parameterError(i, "Parameter type must not include a type variable or wildcard: %s",
+            methodParameterType);
+      }
+
       Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
       if (methodParameterAnnotations != null) {
         for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          RequestBuilderAction action = null;
+          RequestAction action = null;
           if (methodParameterAnnotation instanceof Url) {
             if (gotUrl) {
               throw parameterError(i, "Multiple @Url method annotations found.");
@@ -222,7 +239,7 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
             }
             gotUrl = true;
-            action = new RequestBuilderAction.Url();
+            action = new RequestAction.Url();
 
           } else if (methodParameterAnnotation instanceof Path) {
             if (gotQuery) {
@@ -240,30 +257,121 @@ private void parseParameters(Converter.Factory converterFactory) {
             Path path = (Path) methodParameterAnnotation;
             String name = path.value();
             validatePathName(i, name);
-            action = new RequestBuilderAction.Path(name, path.encoded());
+
+            Converter<?, String> valueConverter =
+                retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
+            action = new RequestAction.Path<>(name, valueConverter, path.encoded());
 
           } else if (methodParameterAnnotation instanceof Query) {
             Query query = (Query) methodParameterAnnotation;
-            action = new RequestBuilderAction.Query(query.value(), query.encoded());
+            String name = query.value();
+            boolean encoded = query.encoded();
+
+            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            if (Iterable.class.isAssignableFrom(rawParameterType)) {
+              if (!(methodParameterType instanceof ParameterizedType)) {
+                throw parameterError(i, rawParameterType.getSimpleName()
+                    + " must include generic type (e.g., "
+                    + rawParameterType.getSimpleName()
+                    + "<String>)");
+              }
+              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
+              action = new RequestAction.Query<>(name, valueConverter, encoded).iterable();
+            } else if (rawParameterType.isArray()) {
+              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
+              action = new RequestAction.Query<>(name, valueConverter, encoded).array();
+            } else {
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
+              action = new RequestAction.Query<>(name, valueConverter, encoded);
+            }
+
             gotQuery = true;
 
           } else if (methodParameterAnnotation instanceof QueryMap) {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@QueryMap parameter type must be Map.");
             }
+            if (!(methodParameterType instanceof ParameterizedType)) {
+              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (String.class != keyType) {
+              throw parameterError(i, "@QueryMap keys must be of type String: " + keyType);
+            }
+            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+            Converter<?, String> valueConverter =
+                retrofit.stringConverter(valueType, methodParameterAnnotations);
+
             QueryMap queryMap = (QueryMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.QueryMap(queryMap.encoded());
+            action = new RequestAction.QueryMap<>(valueConverter, queryMap.encoded());
 
           } else if (methodParameterAnnotation instanceof Header) {
             Header header = (Header) methodParameterAnnotation;
-            action = new RequestBuilderAction.Header(header.value());
+            String name = header.value();
+
+            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            if (Iterable.class.isAssignableFrom(rawParameterType)) {
+              if (!(methodParameterType instanceof ParameterizedType)) {
+                throw parameterError(i, rawParameterType.getSimpleName()
+                    + " must include generic type (e.g., "
+                    + rawParameterType.getSimpleName()
+                    + "<String>)");
+              }
+              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
+              action = new RequestAction.Header<>(name, valueConverter).iterable();
+            } else if (rawParameterType.isArray()) {
+              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
+              action = new RequestAction.Header<>(name, valueConverter).array();
+            } else {
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
+              action = new RequestAction.Header<>(name, valueConverter);
+            }
 
           } else if (methodParameterAnnotation instanceof Field) {
             if (!isFormEncoded) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
             Field field = (Field) methodParameterAnnotation;
-            action = new RequestBuilderAction.Field(field.value(), field.encoded());
+            String name = field.value();
+            boolean encoded = field.encoded();
+
+            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            if (Iterable.class.isAssignableFrom(rawParameterType)) {
+              if (!(methodParameterType instanceof ParameterizedType)) {
+                throw parameterError(i, rawParameterType.getSimpleName()
+                    + " must include generic type (e.g., "
+                    + rawParameterType.getSimpleName()
+                    + "<String>)");
+              }
+              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(iterableType, methodParameterAnnotations);
+              action = new RequestAction.Field<>(name, valueConverter, encoded).iterable();
+            } else if (rawParameterType.isArray()) {
+              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(arrayComponentType, methodParameterAnnotations);
+              action = new RequestAction.Field<>(name, valueConverter, encoded).array();
+            } else {
+              Converter<?, String> valueConverter =
+                  retrofit.stringConverter(methodParameterType, methodParameterAnnotations);
+              action = new RequestAction.Field<>(name, valueConverter, encoded);
+            }
+
             gotField = true;
 
           } else if (methodParameterAnnotation instanceof FieldMap) {
@@ -273,8 +381,20 @@ private void parseParameters(Converter.Factory converterFactory) {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@FieldMap parameter type must be Map.");
             }
+            if (!(methodParameterType instanceof ParameterizedType)) {
+              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (String.class != keyType) {
+              throw parameterError(i, "@FieldMap keys must be of type String: " + keyType);
+            }
+            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+            Converter<?, String> valueConverter =
+                retrofit.stringConverter(valueType, methodParameterAnnotations);
+
             FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.FieldMap(fieldMap.encoded());
+            action = new RequestAction.FieldMap<>(valueConverter, fieldMap.encoded());
             gotField = true;
 
           } else if (methodParameterAnnotation instanceof Part) {
@@ -283,21 +403,33 @@ private void parseParameters(Converter.Factory converterFactory) {
             }
             Part part = (Part) methodParameterAnnotation;
             com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "name=\"" + part.value() + "\"",
+                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
                 "Content-Transfer-Encoding", part.encoding());
-            Converter<?> converter;
-            if (methodParameterType == RequestBody.class) {
-              converter = new OkHttpRequestBodyConverter();
-            } else {
-              if (converterFactory == null) {
-                throw parameterError(i, "@Part parameter is %s"
-                    + " but no converter factory registered. Either add a converter factory"
-                    + " to the Retrofit instance or use RequestBody.",
-                    methodParameterType);
+
+            Class<?> rawParameterType = Utils.getRawType(methodParameterType);
+            if (Iterable.class.isAssignableFrom(rawParameterType)) {
+              if (!(methodParameterType instanceof ParameterizedType)) {
+                throw parameterError(i, rawParameterType.getSimpleName()
+                    + " must include generic type (e.g., "
+                    + rawParameterType.getSimpleName()
+                    + "<String>)");
               }
-              converter = converterFactory.get(methodParameterType);
+              ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+              Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+              Converter<?, RequestBody> valueConverter =
+                  retrofit.requestBodyConverter(iterableType, methodParameterAnnotations);
+              action = new RequestAction.Part<>(headers, valueConverter).iterable();
+            } else if (rawParameterType.isArray()) {
+              Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+              Converter<?, RequestBody> valueConverter =
+                  retrofit.requestBodyConverter(arrayComponentType, methodParameterAnnotations);
+              action = new RequestAction.Part<>(headers, valueConverter).array();
+            } else {
+              Converter<?, RequestBody> valueConverter =
+                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
+              action = new RequestAction.Part<>(headers, valueConverter);
             }
-            action = new RequestBuilderAction.Part<>(headers, converter);
+
             gotPart = true;
 
           } else if (methodParameterAnnotation instanceof PartMap) {
@@ -308,8 +440,20 @@ private void parseParameters(Converter.Factory converterFactory) {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
+            if (!(methodParameterType instanceof ParameterizedType)) {
+              throw parameterError(i, "Map must include generic types (e.g., Map<String, String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) methodParameterType;
+            Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (String.class != keyType) {
+              throw parameterError(i, "@PartMap keys must be of type String: " + keyType);
+            }
+            Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+            Converter<?, RequestBody> valueConverter =
+                retrofit.requestBodyConverter(valueType, methodParameterAnnotations);
+
             PartMap partMap = (PartMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.PartMap(converterFactory, partMap.encoding());
+            action = new RequestAction.PartMap<>(valueConverter, partMap.encoding());
             gotPart = true;
 
           } else if (methodParameterAnnotation instanceof Body) {
@@ -321,33 +465,28 @@ private void parseParameters(Converter.Factory converterFactory) {
               throw parameterError(i, "Multiple @Body method annotations found.");
             }
 
-            Converter<?> converter;
-            if (methodParameterType == RequestBody.class) {
-              converter = new OkHttpRequestBodyConverter();
-            } else {
-              if (converterFactory == null) {
-                throw parameterError(i, "@Body parameter is %s"
-                        + " but no converter factory registered. Either add a converter factory"
-                        + " to the Retrofit instance or use RequestBody.",
-                    methodParameterType);
-              }
-              converter = converterFactory.get(methodParameterType);
+            Converter<?, RequestBody> converter;
+            try {
+              converter =
+                  retrofit.requestBodyConverter(methodParameterType, methodParameterAnnotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+              throw parameterError(e, i, "Unable to create @Body converter for %s",
+                  methodParameterType);
             }
-
-            action = new RequestBuilderAction.Body<>(converter);
+            action = new RequestAction.Body<>(converter);
             gotBody = true;
           }
 
           if (action != null) {
-            if (requestBuilderActions[i] != null) {
+            if (requestActions[i] != null) {
               throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
             }
-            requestBuilderActions[i] = action;
+            requestActions[i] = action;
           }
         }
       }
 
-      if (requestBuilderActions[i] == null) {
+      if (requestActions[i] == null) {
         throw parameterError(i, "No Retrofit annotation found.");
       }
     }
@@ -365,7 +504,7 @@ private void parseParameters(Converter.Factory converterFactory) {
       throw methodError(method, "Multipart method must contain at least one @Part.");
     }
 
-    this.requestBuilderActions = requestBuilderActions;
+    this.requestActions = requestActions;
   }
 
   private void validatePathName(int index, String name) {
@@ -391,4 +530,16 @@ private void validatePathName(int index, String name) {
     }
     return patterns;
   }
+
+  static Class<?> boxIfPrimitive(Class<?> type) {
+    if (boolean.class == type) return Boolean.class;
+    if (byte.class == type) return Byte.class;
+    if (char.class == type) return Character.class;
+    if (double.class == type) return Double.class;
+    if (float.class == type) return Float.class;
+    if (int.class == type) return Integer.class;
+    if (long.class == type) return Long.class;
+    if (short.class == type) return Short.class;
+    return type;
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
index dab90ff09..d53f075c0 100644
--- a/retrofit/src/main/java/retrofit/Response.java
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -16,51 +16,53 @@
 package retrofit;
 
 import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.ResponseBody;
 
-import static retrofit.Utils.checkNotNull;
-
-/**
- * TODO
- */
+/** An HTTP response. */
 public final class Response<T> {
-  /**
-   * TODO
-   */
+  /** Create a synthetic successful response with {@code body} as the deserialized body. */
   public static <T> Response<T> success(T body) {
     return success(body, new com.squareup.okhttp.Response.Builder() //
         .code(200)
+        .message("OK")
         .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
-            .build())
+        .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
         .build());
   }
 
   /**
-   * TODO
+   * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
+   * body.
    */
   public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
+    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    if (!rawResponse.isSuccessful()) {
+      throw new IllegalArgumentException("rawResponse must be successful response");
+    }
     return new Response<>(rawResponse, body, null);
   }
 
   /**
-   * TODO
+   * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
+   * as the error body.
    */
   public static <T> Response<T> error(int code, ResponseBody body) {
+    if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
     return error(body, new com.squareup.okhttp.Response.Builder() //
         .code(code)
         .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
-            .build())
+        .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
         .build());
   }
 
-  /**
-   * TODO
-   */
+  /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
   public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
+    if (body == null) throw new NullPointerException("body == null");
+    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    if (rawResponse.isSuccessful()) {
+      throw new IllegalArgumentException("rawResponse should not be successful response");
+    }
     return new Response<>(rawResponse, null, body);
   }
 
@@ -69,7 +71,7 @@
   private final ResponseBody errorBody;
 
   private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
-    this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
+    this.rawResponse = rawResponse;
     this.body = body;
     this.errorBody = errorBody;
   }
@@ -84,6 +86,12 @@ public int code() {
     return rawResponse.code();
   }
 
+  /** HTTP status message or null if unknown. */
+  public String message() {
+    return rawResponse.message();
+  }
+
+  /** HTTP headers. */
   public Headers headers() {
     return rawResponse.headers();
   }
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index 418b23c00..081eaeea5 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -19,12 +19,18 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
+import retrofit.http.GET;
 import retrofit.http.HTTP;
 import retrofit.http.Header;
 
@@ -39,8 +45,8 @@
  * The relative path for a given method is obtained from an annotation on the method describing
  * the request type. The built-in methods are {@link retrofit.http.GET GET},
  * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.PATCH
- * PATCH}, {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a
- * custom HTTP method with {@link HTTP @HTTP}.
+ * PATCH}, {@link retrofit.http.HEAD HEAD}, {@link retrofit.http.DELETE DELETE} and
+ * {@link retrofit.http.OPTIONS OPTIONS}. You can use a custom HTTP method with {@link HTTP @HTTP}.
  * <p>
  * Method parameters can be used to replace parts of the URL by annotating them with
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
@@ -48,17 +54,15 @@
  * {@link retrofit.http.Query @Query}.
  * <p>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
- * will be converted to request representation by a call to
- * {@link Converter#toBody(Object) toBody}
- * on the supplied {@link Converter} for this instance. A {@link RequestBody} can also be used
- * which will not use the {@code Converter}.
+ * will be converted to request representation by one of the {@link Converter.Factory} instances.
+ * A {@link RequestBody} can also be used for a raw representation.
  * <p>
  * Alternative request body formats are supported by method annotations and corresponding parameter
  * annotations:
  * <ul>
  * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
  * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
- * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
+ * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with parts
  * specified by the {@link retrofit.http.Part @Part} parameter annotation.
  * </ul>
  * <p>
@@ -67,9 +71,9 @@
  * annotate a parameter with {@link Header @Header}.
  * <p>
  * By default, methods return a {@link Call} which represents the HTTP request. The generic
- * parameter of the call is the response body type and will be converted by a call to
- * {@link Converter#fromBody(ResponseBody) fromBody} on the supplied {@link Converter} for
- * this instance. {@link ResponseBody} can also be used which will not use the {@code Converter}.
+ * parameter of the call is the response body type and will be converted by one of the
+ * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+ * representation. {@link Void} can be used if you do not care about the body contents.
  * <p>
  * For example:
  * <pre>
@@ -90,43 +94,62 @@
 
   private final OkHttpClient client;
   private final BaseUrl baseUrl;
-  private final Converter.Factory converterFactory;
-  private final CallAdapter.Factory adapterFactory;
+  private final List<Converter.Factory> converterFactories;
+  private final List<CallAdapter.Factory> adapterFactories;
   private final Executor callbackExecutor;
+  private final boolean validateEagerly;
 
-  private Retrofit(OkHttpClient client, BaseUrl baseUrl, Converter.Factory converterFactory,
-      CallAdapter.Factory adapterFactory, Executor callbackExecutor) {
+  private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
+      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
+      boolean validateEagerly) {
     this.client = client;
     this.baseUrl = baseUrl;
-    this.converterFactory = converterFactory;
-    this.adapterFactory = adapterFactory;
+    this.converterFactories = converterFactories;
+    this.adapterFactories = adapterFactories;
     this.callbackExecutor = callbackExecutor;
+    this.validateEagerly = validateEagerly;
   }
 
   /** Create an implementation of the API defined by the {@code service} interface. */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
+  public <T> T create(final Class<T> service) {
+    Utils.validateServiceInterface(service);
+    if (validateEagerly) {
+      eagerlyValidateMethods(service);
+    }
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        handler);
+        new InvocationHandler() {
+          private final Platform platform = Platform.get();
+
+          @Override public Object invoke(Object proxy, Method method, Object... args)
+              throws Throwable {
+            // If the method is a method from Object then defer to normal invocation.
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            if (platform.isDefaultMethod(method)) {
+              return platform.invokeDefaultMethod(method, service, proxy, args);
+            }
+            return loadMethodHandler(method).invoke(args);
+          }
+        });
   }
 
-  private final InvocationHandler handler = new InvocationHandler() {
-    @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
+  private void eagerlyValidateMethods(Class<?> service) {
+    Platform platform = Platform.get();
+    for (Method method : service.getDeclaredMethods()) {
+      if (!platform.isDefaultMethod(method)) {
+        loadMethodHandler(method);
       }
-      return loadMethodHandler(method).invoke(args);
     }
-  };
+  }
 
   MethodHandler<?> loadMethodHandler(Method method) {
     MethodHandler<?> handler;
     synchronized (methodHandlerCache) {
       handler = methodHandlerCache.get(method);
       if (handler == null) {
-        handler = MethodHandler.create(method, client, baseUrl, adapterFactory, converterFactory);
+        handler = MethodHandler.create(this, method);
         methodHandlerCache.put(method, handler);
       }
     }
@@ -141,17 +164,173 @@ public BaseUrl baseUrl() {
     return baseUrl;
   }
 
+  public List<CallAdapter.Factory> callAdapterFactories() {
+    return Collections.unmodifiableList(adapterFactories);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories}.
+   *
+   * @throws IllegalArgumentException if no call adapter available for {@code type}.
+   */
+  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+    return nextCallAdapter(null, returnType, annotations);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories} except {@code skipPast}.
+   *
+   * @throws IllegalArgumentException if no call adapter available for {@code type}.
+   */
+  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+      Annotation[] annotations) {
+    checkNotNull(returnType, "returnType == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = adapterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      if (adapter != null) {
+        return adapter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+        .append(returnType)
+        .append(". Tried:");
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+    }
+    if (skipPast != null) {
+      builder.append("\nSkipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+      }
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
   /**
    * TODO
-   * <p>
-   * May be null.
    */
-  public Converter.Factory converterFactory() {
-    return converterFactory;
+  public List<Converter.Factory> converterFactories() {
+    return Collections.unmodifiableList(converterFactories);
+  }
+
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+   * {@linkplain #converterFactories() factories}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<T, RequestBody> requestBodyConverter(Type type, Annotation[] annotations) {
+    return nextRequestBodyConverter(null, type, annotations);
+  }
+
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+   * {@linkplain #converterFactories() factories} except {@code skipPast}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
+      Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = converterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter<?, RequestBody> converter =
+          converterFactories.get(i).requestBodyConverter(type, annotations, this);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<T, RequestBody>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+        .append(type)
+        .append(". Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
+    }
+    if (skipPast != null) {
+      builder.append("\nSkipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+      }
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+   * {@linkplain #converterFactories() factories}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+    return nextResponseBodyConverter(null, type, annotations);
   }
 
-  public CallAdapter.Factory callAdapterFactory() {
-    return adapterFactory;
+  /**
+   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+   * {@linkplain #converterFactories() factories} except {@code skipPast}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
+      Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = converterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter<ResponseBody, ?> converter =
+          converterFactories.get(i).responseBodyConverter(type, annotations, this);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<ResponseBody, T>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+        .append(type)
+        .append(". Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n * ").append(converterFactories.get(i).getClass().getName());
+    }
+    if (skipPast != null) {
+      builder.append("\nSkipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+      }
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link String} from the available
+   * {@linkplain #converterFactories() factories}.
+   */
+  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<?, String> converter =
+          converterFactories.get(i).stringConverter(type, annotations);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<T, String>) converter;
+      }
+    }
+
+    // Nothing matched. Resort to default converter which just calls toString().
+    //noinspection unchecked
+    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
   }
 
   public Executor callbackExecutor() {
@@ -167,9 +346,16 @@ public Executor callbackExecutor() {
   public static final class Builder {
     private OkHttpClient client;
     private BaseUrl baseUrl;
-    private Converter.Factory converterFactory;
-    private CallAdapter.Factory adapterFactory;
+    private List<Converter.Factory> converterFactories = new ArrayList<>();
+    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
     private Executor callbackExecutor;
+    private boolean validateEagerly;
+
+    public Builder() {
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverters());
+    }
 
     /** The HTTP client used for requests. */
     public Builder client(OkHttpClient client) {
@@ -177,7 +363,11 @@ public Builder client(OkHttpClient client) {
       return this;
     }
 
-    /** API base URL. */
+    /**
+     * Set a fixed API base URL.
+     *
+     * @see #baseUrl(HttpUrl)
+     */
     public Builder baseUrl(String baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
       HttpUrl httpUrl = HttpUrl.parse(baseUrl);
@@ -187,9 +377,62 @@ public Builder baseUrl(String baseUrl) {
       return baseUrl(httpUrl);
     }
 
-    /** API base URL. */
+    /**
+     * Set a fixed API base URL.
+     * <p>
+     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+     * {@code <a href="">} link on a website resolving on the current URL.
+     * <p>
+     * <b>Base URLs should always end in {@code /}.</b>
+     * <p>
+     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+     * append themselves to a base which has path components.
+     * <p>
+     * <b>Correct:</b><br>
+     * Base URL: http://example.com/api/<br>
+     * Endpoint: foo/bar/<br>
+     * Result: http://example.com/api/foo/bar/
+     * <p>
+     * <b>Incorrect:</b><br>
+     * Base URL: http://example.com/api<br>
+     * Endpoint: foo/bar/<br>
+     * Result: http://example.com/foo/bar/
+     * <p>
+     * This method enforces that {@code baseUrl} has a trailing {@code /}.
+     * <p>
+     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+     * <p>
+     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+     * components.
+     * <p>
+     * Base URL: http://example.com/api/<br>
+     * Endpoint: /foo/bar/<br>
+     * Result: http://example.com/foo/bar/
+     * <p>
+     * Base URL: http://example.com/<br>
+     * Endpoint: /foo/bar/<br>
+     * Result: http://example.com/foo/bar/
+     * <p>
+     * <b>Endpoint values may be a full URL.</b>
+     * <p>
+     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+     * replace the scheme of {@code baseUrl}.
+     * <p>
+     * Base URL: http://example.com/<br>
+     * Endpoint: https://github.com/square/retrofit/<br>
+     * Result: https://github.com/square/retrofit/
+     * <p>
+     * Base URL: http://example.com<br>
+     * Endpoint: //github.com/square/retrofit/<br>
+     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     */
     public Builder baseUrl(final HttpUrl baseUrl) {
       checkNotNull(baseUrl, "baseUrl == null");
+      List<String> pathSegments = baseUrl.pathSegments();
+      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+      }
       return baseUrl(new BaseUrl() {
         @Override public HttpUrl url() {
           return baseUrl;
@@ -197,23 +440,27 @@ public Builder baseUrl(final HttpUrl baseUrl) {
       });
     }
 
-    /** API base URL. */
+    /**
+     * Set an API base URL which can change over time.
+     *
+     * @see #baseUrl(HttpUrl)
+     */
     public Builder baseUrl(BaseUrl baseUrl) {
       this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
       return this;
     }
 
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder converterFactory(Converter.Factory converterFactory) {
-      this.converterFactory = checkNotNull(converterFactory, "converterFactory == null");
+    /** Add converter factory for serialization and deserialization of objects. */
+    public Builder addConverterFactory(Converter.Factory converterFactory) {
+      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
       return this;
     }
 
     /**
      * TODO
      */
-    public Builder callAdapterFactory(CallAdapter.Factory factory) {
-      this.adapterFactory = checkNotNull(factory, "factory == null");
+    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+      adapterFactories.add(checkNotNull(factory, "factory == null"));
       return this;
     }
 
@@ -226,21 +473,35 @@ public Builder callbackExecutor(Executor callbackExecutor) {
       return this;
     }
 
+    /**
+     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+     * the configuration of all methods in the supplied interface.
+     */
+    public Builder validateEagerly(boolean validateEagerly) {
+      this.validateEagerly = validateEagerly;
+      return this;
+    }
+
     /** Create the {@link Retrofit} instances. */
     public Retrofit build() {
       if (baseUrl == null) {
         throw new IllegalStateException("Base URL required.");
       }
 
-      // Set any platform-appropriate defaults for unspecified components.
+      OkHttpClient client = this.client;
       if (client == null) {
-        client = Platform.get().defaultClient();
-      }
-      if (adapterFactory == null) {
-        adapterFactory = Platform.get().defaultCallAdapterFactory(callbackExecutor);
+        client = new OkHttpClient();
       }
 
-      return new Retrofit(client, baseUrl, converterFactory, adapterFactory, callbackExecutor);
+      // Make a defensive copy of the adapters and add the default Call adapter.
+      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+
+      // Make a defensive copy of the converters.
+      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
+          validateEagerly);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index e90cd3c73..a81d379a1 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.ResponseBody;
 import java.io.Closeable;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
@@ -48,6 +49,17 @@ static void closeQuietly(Closeable closeable) {
     }
   }
 
+  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
+  static boolean isAnnotationPresent(Annotation[] annotations,
+      Class<? extends Annotation> cls) {
+    for (Annotation annotation : annotations) {
+      if (cls.isInstance(annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Replace a {@link Response} with an identical copy whose body is backed by a
    * {@link Buffer} rather than a {@link Source}.
@@ -58,32 +70,32 @@ static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws I
     }
 
     BufferedSource source = body.source();
-    final Buffer buffer = new Buffer();
+    Buffer buffer = new Buffer();
     buffer.writeAll(source);
     source.close();
 
     return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  static <T> void validateServiceClass(Class<T> service) {
+  static <T> void validateServiceInterface(Class<T> service) {
     if (!service.isInterface()) {
-      throw new IllegalArgumentException("Only interface baseUrl definitions are supported.");
+      throw new IllegalArgumentException("API declarations must be interfaces.");
     }
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
     // the recommended pattern.
     if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");
+      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
     }
   }
 
-  public static Type getSingleParameterUpperBound(ParameterizedType type) {
+  public static Type getParameterUpperBound(int index, ParameterizedType type) {
     Type[] types = type.getActualTypeArguments();
-    if (types.length != 1) {
+    if (types.length <= index) {
       throw new IllegalArgumentException(
-          "Expected one type argument but got: " + Arrays.toString(types));
+          "Expected at least " + index + " type argument(s) but got: " + Arrays.toString(types));
     }
-    Type paramType = types[0];
+    Type paramType = types[index];
     if (paramType instanceof WildcardType) {
       return ((WildcardType) paramType).getUpperBounds()[0];
     }
@@ -152,12 +164,20 @@ public static boolean hasUnresolvableType(Type type) {
   }
 
   static RuntimeException methodError(Method method, String message, Object... args) {
+    return methodError(null, method, message, args);
+  }
+
+  static RuntimeException methodError(Throwable cause, Method method, String message,
+      Object... args) {
     message = String.format(message, args);
-    return new IllegalArgumentException(message
+    IllegalArgumentException e = new IllegalArgumentException(message
         + "\n    for method "
         + method.getDeclaringClass().getSimpleName()
         + "."
         + method.getName());
+    e.initCause(cause);
+    return e;
+
   }
 
   static Type getCallResponseType(Type returnType) {
@@ -165,7 +185,7 @@ static Type getCallResponseType(Type returnType) {
       throw new IllegalArgumentException(
           "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
     }
-    final Type responseType = getSingleParameterUpperBound((ParameterizedType) returnType);
+    final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
     // Ensure the Call response type is not Response, we automatically deliver the Response object.
     if (getRawType(responseType) == retrofit.Response.class) {
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index 1f7dbdc5b..19ddbc861 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,10 +23,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a DELETE request to a REST path relative to base URL. */
+/** Make a DELETE request. */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index b2dd2a4cf..03ff0e49f 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,10 +23,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a GET request to a REST path relative to base URL. */
+/** Make a GET request. */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface GET {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index 9ae6f7adc..ea17778ed 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,10 +23,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a HEAD request to a REST path relative to base URL. */
+/** Make a HEAD request. */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HEAD {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/HTTP.java b/retrofit/src/main/java/retrofit/http/HTTP.java
index f699bbe7d..7c0dcde77 100644
--- a/retrofit/src/main/java/retrofit/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,11 +23,34 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+/**
+ * Use a custom HTTP verb for a request.
+ * <pre>{@code
+ * interface Service {
+ *   &#064;HTTP(method = "CUSTOM", path = "custom/endpoint/")
+ *   Call<ResponseBody> customEndpoint();
+ * }
+ * }</pre>
+ * This annotation can also used for sending {@code DELETE} with a request body:
+ * <pre>{@code
+ * interface Service {
+ *   &#064;HTTP(method = "DELETE", path = "remove/", hasBody = true)
+ *   Call<ResponseBody> deleteObject(@Body RequestBody object);
+ * }
+ * }</pre>
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HTTP {
   String method();
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String path() default "";
   boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/OPTIONS.java b/retrofit/src/main/java/retrofit/http/OPTIONS.java
new file mode 100644
index 000000000..d887b5996
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/OPTIONS.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make an OPTIONS request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface OPTIONS {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit/src/main/java/retrofit/http/PATCH.java b/retrofit/src/main/java/retrofit/http/PATCH.java
index 2788ee8f0..a9a074616 100644
--- a/retrofit/src/main/java/retrofit/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit/http/PATCH.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,10 +23,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a PATCH request to a REST path relative to base URL. */
+/** Make a PATCH request. */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PATCH {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index 0d39b2d1a..1a0c4ab71 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,10 +23,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a POST request to a REST path relative to base URL. */
+/** Make a POST request. */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface POST {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index 5c382e33d..f0e14dcb7 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -22,10 +23,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a PUT request to a REST path relative to base URL. */
+/** Make a PUT request. */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PUT {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
   String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 154af6086..b06cad953 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -18,7 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Retrofit;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -26,12 +26,12 @@
 /**
  * Denotes a single part of a multi-part request.
  * <p>
- * The parameter type on which this annotation exists will be processed in one of three ways:
+ * The parameter type on which this annotation exists will be processed in one of two ways:
  * <ul>
- * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
- * content type.</li>
+ * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
+ * directly with its content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
- * {@linkplain Retrofit#converterFactory() a converter}.</li>
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
@@ -39,10 +39,9 @@
  * <pre>
  * &#64;Multipart
  * &#64;POST("/")
- * void example(&#64;Part("description") String description,
- *              &#64;Part("image") TypedFile image,
- *              ...
- * );
+ * Call&lt;<ResponseBody> example(
+ *     &#64;Part("description") String description,
+ *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
  * </pre>
  * <p>
  * Part parameters may not be {@code null}.
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index 512f3545f..a3026ce30 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -18,26 +18,28 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Retrofit;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Denotes name and value parts of a multi-part request
+ * Denotes name and value parts of a multi-part request.
  * <p>
- * Values of the map on which this annotation exists will be processed in one of three ways:
+ * Values of the map on which this annotation exists will be processed in one of two ways:
  * <ul>
- * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
- * content type.</li>
+ * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
+ * directly with its content type.</li>
  * <li>Other object types will be converted to an appropriate representation by using
- * {@linkplain Retrofit#converterFactory() a converter}.</li>
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * <pre>
  * &#64;Multipart
  * &#64;POST("/upload")
- * void upload(&#64;Part("file") TypedFile file, &#64;PartMap Map&lt;String, String&gt; params);
+ * Call&lt;ResponseBody> upload(
+ *     &#64;Part("file") RequestBody file,
+ *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
  * </pre>
  *
  * @see Multipart
@@ -47,6 +49,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of this part. */
+  /** The {@code Content-Transfer-Encoding} of the parts. */
   String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Url.java b/retrofit/src/main/java/retrofit/http/Url.java
index b953a3060..a7d27bf11 100644
--- a/retrofit/src/main/java/retrofit/http/Url.java
+++ b/retrofit/src/main/java/retrofit/http/Url.java
@@ -15,6 +15,7 @@
  */
 package retrofit.http;
 
+import com.squareup.okhttp.HttpUrl;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -24,11 +25,14 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Relative URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
+ * URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
  * <pre>
  * &#64;GET
  * void list(@Url String url);
  * </pre>
+ * <p>
+ * See {@linkplain retrofit.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+ * the value will be resolved against a base URL to create the full endpoint URL.
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
index a0796cf07..994fa95b3 100644
--- a/retrofit/src/test/java/retrofit/CallTest.java
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -23,6 +23,7 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
@@ -58,7 +59,7 @@
   @Test public void http200Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -72,7 +73,7 @@
   @Test public void http200Async() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -100,7 +101,7 @@
   @Test public void http404Sync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -115,7 +116,7 @@
   @Test public void http404Async() throws InterruptedException, IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -144,7 +145,7 @@
   @Test public void transportProblemSync() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -161,7 +162,7 @@
   @Test public void transportProblemAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -188,10 +189,12 @@
   @Test public void conversionProblemOutgoingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public RequestBody toBody(Object value) {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+              Retrofit retrofit) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -212,10 +215,12 @@
   @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public RequestBody toBody(Object value) {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+              Retrofit retrofit) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -245,10 +250,12 @@
   @Test public void conversionProblemIncomingSync() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public String fromBody(ResponseBody body) throws IOException {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -288,12 +295,14 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .client(client)
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public String fromBody(ResponseBody body) throws IOException {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
                 try {
-                  return super.fromBody(body);
+                  return value.string();
                 } catch (IOException e) {
                   // Some serialization libraries mask transport problems in runtime exceptions. Bad!
                   throw new RuntimeException("wrapper", e);
@@ -319,10 +328,12 @@
   @Test public void conversionProblemIncomingAsync() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter<?> get(Type type) {
-            return new StringConverter() {
-              @Override public String fromBody(ResponseBody body) throws IOException {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
                 throw new UnsupportedOperationException("I am broken!");
               }
             };
@@ -352,11 +363,17 @@
   }
 
   @Test public void http204SkipsConverter() throws IOException {
-    final Converter converter = spy(new ToStringConverterFactory.StringConverter());
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter get(Type type) {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
             return converter;
           }
         })
@@ -372,11 +389,17 @@
   }
 
   @Test public void http205SkipsConverter() throws IOException {
-    final Converter converter = spy(new ToStringConverterFactory.StringConverter());
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory() {
-          @Override public Converter get(Type type) {
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
             return converter;
           }
         })
@@ -394,7 +417,7 @@
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -407,7 +430,7 @@
   @Test public void responseBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -420,7 +443,7 @@
   @Test public void responseBodyBuffers() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -441,7 +464,7 @@
   @Test public void responseBodyStreams() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -464,7 +487,7 @@
   @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -486,7 +509,7 @@
   @Test public void emptyResponse() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service example = retrofit.create(Service.class);
 
@@ -499,15 +522,51 @@
     assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
   }
 
+  @Test public void reportsExecutedSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    assertThat(call.isExecuted()).isFalse();
+
+    call.execute();
+    assertThat(call.isExecuted()).isTrue();
+  }
+
+  @Test public void reportsExecutedAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    assertThat(call.isExecuted()).isFalse();
+
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {}
+      @Override public void onFailure(Throwable t) {}
+    });
+    assertThat(call.isExecuted()).isTrue();
+  }
+
   @Test public void cancelBeforeExecute() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
     Call<String> call = service.getString();
 
     call.cancel();
+    assertThat(call.isCanceled()).isTrue();
 
     try {
       call.execute();
@@ -520,12 +579,13 @@
   @Test public void cancelBeforeEnqueue() throws Exception {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
     Call<String> call = service.getString();
 
     call.cancel();
+    assertThat(call.isCanceled()).isTrue();
 
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
@@ -546,7 +606,7 @@
   @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
 
@@ -563,7 +623,7 @@
   @Test public void cancelRequest() throws InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
     Service service = retrofit.create(Service.class);
 
@@ -585,6 +645,7 @@
     });
 
     call.cancel();
+    assertThat(call.isCanceled()).isTrue();
 
     assertTrue(latch.await(2, SECONDS));
     assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
diff --git a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
index ca089e3a9..474b882db 100644
--- a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.reflect.TypeToken;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
@@ -32,6 +33,11 @@
 
 @SuppressWarnings("unchecked")
 public final class ExecutorCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final Retrofit retrofit = new Retrofit.Builder()
+      .baseUrl("http://localhost:1")
+      .build();
   private final Callback<String> callback = mock(Callback.class);
   private final Executor callbackExecutor = spy(new Executor() {
     @Override public void execute(Runnable runnable) {
@@ -42,7 +48,7 @@
 
   @Test public void rawTypeThrows() {
     try {
-      factory.get(Call.class);
+      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
@@ -52,7 +58,7 @@
   @Test public void responseThrows() {
     Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
     try {
-      factory.get(returnType);
+      factory.get(returnType, NO_ANNOTATIONS, retrofit);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
@@ -62,17 +68,20 @@
 
   @Test public void responseType() {
     Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
     Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType).responseType()) //
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
         .isEqualTo(new TypeToken<List<String>>() {}.getType());
   }
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public Response<String> execute() throws IOException {
@@ -84,7 +93,8 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Response<String> response = Response.success("Hi");
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
@@ -98,7 +108,8 @@
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     final Throwable throwable = new IOException();
     Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
       @Override public void enqueue(Callback<String> callback) {
@@ -114,7 +125,8 @@
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
     Call<String> call = (Call<String>) adapter.adapt(delegate);
     Call<String> cloned = call.clone();
@@ -125,7 +137,8 @@
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter<Call<?>> adapter =
+        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
     Call<String> delegate = mock(Call.class);
     Call<String> call = (Call<String>) adapter.adapt(delegate);
     call.cancel();
@@ -138,6 +151,10 @@
       throw new UnsupportedOperationException();
     }
 
+    @Override public boolean isExecuted() {
+      return false;
+    }
+
     @Override public Response<String> execute() throws IOException {
       throw new UnsupportedOperationException();
     }
@@ -146,6 +163,10 @@
       throw new UnsupportedOperationException();
     }
 
+    @Override public boolean isCanceled() {
+      return false;
+    }
+
     @Override public Call<String> clone() {
       throw new UnsupportedOperationException();
     }
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 6fc52cb7d..ac0dffbb9 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -1,10 +1,13 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
@@ -13,6 +16,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -27,6 +31,7 @@
 import retrofit.http.Header;
 import retrofit.http.Headers;
 import retrofit.http.Multipart;
+import retrofit.http.OPTIONS;
 import retrofit.http.PATCH;
 import retrofit.http.POST;
 import retrofit.http.PUT;
@@ -48,7 +53,7 @@
   @Test public void customMethodNoBody() {
     class Example {
       @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -63,7 +68,7 @@
   @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -80,7 +85,7 @@
       @Multipart //
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -98,7 +103,7 @@
       @FormUrlEncoded //
       @Multipart //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -114,7 +119,7 @@
   @Test public void invalidPathParam() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Path("hey!") String thing) {
+      Call<ResponseBody> method(@Path("hey!") String thing) {
         return null;
       }
     }
@@ -132,7 +137,7 @@
   @Test public void pathParamNotAllowedInQuery() throws Exception {
     class Example {
       @GET("/foo?bar={bar}") //
-      Call<Object> method(@Path("bar") String thing) {
+      Call<ResponseBody> method(@Path("bar") String thing) {
         return null;
       }
     }
@@ -149,7 +154,7 @@
   @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Body @Query("nope") Object o) {
+      Call<ResponseBody> method(@Body @Query("nope") String o) {
         return null;
       }
     }
@@ -167,7 +172,7 @@
   @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
     class Example {
       @GET("/") //
-      Call<Object> method(@Query("maybe") @NonNull Object o) {
+      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
         return null;
       }
     }
@@ -179,7 +184,7 @@
     class Example {
       @PATCH("/foo") //
       @POST("/foo") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -195,7 +200,7 @@
 
   @Test public void lackingMethod() {
     class Example {
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -211,7 +216,7 @@
   @Test public void implicitMultipartForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Part("a") int a) {
+      Call<ResponseBody> method(@Part("a") int a) {
         return null;
       }
     }
@@ -227,7 +232,7 @@
   @Test public void implicitMultipartWithPartMapForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@PartMap Map<String, String> params) {
+      Call<ResponseBody> method(@PartMap Map<String, String> params) {
         return null;
       }
     }
@@ -244,7 +249,7 @@
     class Example {
       @Multipart //
       @GET("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -261,7 +266,7 @@
     class Example {
       @Multipart //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -277,7 +282,7 @@
   @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Field("a") int a) {
+      Call<ResponseBody> method(@Field("a") int a) {
         return null;
       }
     }
@@ -293,7 +298,7 @@
   @Test public void implicitFormEncodingByFieldMapForbidden() {
     class Example {
       @POST("/") //
-      Call<Object> method(@FieldMap Map<String, String> a) {
+      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
         return null;
       }
     }
@@ -310,7 +315,7 @@
     class Example {
       @FormUrlEncoded //
       @GET("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -327,7 +332,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -343,7 +348,7 @@
     class Example {
       @GET("/") //
       @Headers({}) //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -359,7 +364,7 @@
     class Example {
       @GET("/") //
       @Headers("Malformed") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -375,7 +380,7 @@
   @Test public void pathParamNonPathParamAndTypedBytes() {
     class Example {
       @PUT("/{a}") //
-      Call<Object> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
         return null;
       }
     }
@@ -391,7 +396,7 @@
   @Test public void parameterWithoutAnnotation() {
     class Example {
       @GET("/") //
-      Call<Object> method(String a) {
+      Call<ResponseBody> method(String a) {
         return null;
       }
     }
@@ -407,7 +412,7 @@
   @Test public void nonBodyHttpMethodWithSingleEntity() {
     class Example {
       @GET("/") //
-      Call<Object> method(@Body Object o) {
+      Call<ResponseBody> method(@Body String o) {
         return null;
       }
     }
@@ -423,7 +428,7 @@
   @Test public void queryMapMustBeAMap() {
     class Example {
       @GET("/") //
-      Call<Object> method(@QueryMap List<String> a) {
+      Call<ResponseBody> method(@QueryMap List<String> a) {
         return null;
       }
     }
@@ -439,7 +444,7 @@
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
-      Call<Object> method(@QueryMap Map<String, String> a) {
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
         return null;
       }
     }
@@ -459,7 +464,7 @@
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
-      Call<Object> method(@Body int o1, @Body int o2) {
+      Call<ResponseBody> method(@Body String o1, @Body String o2) {
         return null;
       }
     }
@@ -476,7 +481,7 @@
     class Example {
       @Multipart //
       @PUT("/") //
-      Call<Object> method(@Part("one") int o1, @Body int o2) {
+      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
         return null;
       }
     }
@@ -492,7 +497,7 @@
   @Test public void get() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -506,7 +511,7 @@
   @Test public void delete() {
     class Example {
       @DELETE("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -520,7 +525,7 @@
   @Test public void head() {
     class Example {
       @HEAD("/foo/bar/") //
-      Call<Object> method() {
+      Call<Void> method() {
         return null;
       }
     }
@@ -531,10 +536,25 @@
     assertThat(request.body()).isNull();
   }
 
+  @Test public void headWithoutVoidThrows() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "HEAD method must use Void as response type.\n    for method Example.method");
+    }
+  }
+
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -549,7 +569,7 @@
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -564,7 +584,7 @@
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -576,10 +596,24 @@
     assertBody(request.body(), "hi");
   }
 
+  @Test public void options() {
+    class Example {
+      @OPTIONS("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("OPTIONS");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
   @Test public void getWithPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -593,7 +627,7 @@
   @Test public void getWithUnusedAndInvalidNamedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -607,7 +641,7 @@
   @Test public void getWithEncodedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path(value = "ping", encoded = true) String ping) {
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
         return null;
       }
     }
@@ -621,7 +655,7 @@
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping) {
+      Call<ResponseBody> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -636,7 +670,7 @@
   @Test public void getWithQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -650,7 +684,7 @@
   @Test public void getWithEncodedQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
         return null;
       }
     }
@@ -664,7 +698,7 @@
   @Test public void queryParamOptionalOmitsQuery() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -675,7 +709,7 @@
   @Test public void queryParamOptional() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("foo") String foo, @Query("ping") String ping,
+      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
           @Query("kit") String kit) {
         return null;
       }
@@ -687,7 +721,7 @@
   @Test public void getWithQueryUrlAndParam() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Call<Object> method(@Query("ping") String ping) {
+      Call<ResponseBody> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -701,7 +735,7 @@
   @Test public void getWithQuery() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -715,7 +749,7 @@
   @Test public void getWithPathAndQueryParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit,
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
           @Query("riff") String riff) {
         return null;
       }
@@ -731,7 +765,7 @@
   @Test public void getWithQueryThenPathThrows() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Query("kit") String kit, @Path("ping") String ping) {
+      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
         return null;
       }
     }
@@ -748,7 +782,7 @@
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -763,7 +797,7 @@
   @Test public void getWithPathAndQueryAmpersandParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -771,14 +805,14 @@
     Request request = buildRequest(Example.class, "pong&", "kat&");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
     assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryHashParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -793,7 +827,7 @@
   @Test public void getWithQueryParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") List<Object> keys) {
+      Call<ResponseBody> method(@Query("key") List<Object> keys) {
         return null;
       }
     }
@@ -809,7 +843,7 @@
   @Test public void getWithQueryParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") Object[] keys) {
+      Call<ResponseBody> method(@Query("key") Object[] keys) {
         return null;
       }
     }
@@ -825,7 +859,7 @@
   @Test public void getWithQueryParamPrimitiveArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Query("key") int[] keys) {
+      Call<ResponseBody> method(@Query("key") int[] keys) {
         return null;
       }
     }
@@ -841,7 +875,7 @@
   @Test public void getWithQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@QueryMap Map<String, Object> query) {
+      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
         return null;
       }
     }
@@ -861,7 +895,7 @@
   @Test public void getWithEncodedQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@QueryMap(encoded = true) Map<String, Object> query) {
+      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
         return null;
       }
     }
@@ -881,7 +915,7 @@
   @Test public void getWithUrl() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -896,7 +930,7 @@
   @Test public void getAbsoluteUrl() {
     class Example {
       @GET("http://example2.com/foo/bar/")
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -911,7 +945,7 @@
   @Test public void getWithUrlAbsolute() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -926,7 +960,7 @@
   @Test public void getWithUrlAbsoluteSameHost() {
     class Example {
       @GET
-      Call<Object> method(@Url String url) {
+      Call<ResponseBody> method(@Url String url) {
         return null;
       }
     }
@@ -941,7 +975,7 @@
   @Test public void getWithNonStringUrlThrows() {
     class Example {
       @GET
-      Call<Object> method(@Url Object url) {
+      Call<ResponseBody> method(@Url Object url) {
         return null;
       }
     }
@@ -958,7 +992,7 @@
   @Test public void getUrlAndUrlParamThrows() {
     class Example {
       @GET("foo/bar")
-      Call<Object> method(@Url Object url) {
+      Call<ResponseBody> method(@Url Object url) {
         return null;
       }
     }
@@ -975,7 +1009,7 @@
   @Test public void getWithoutUrlThrows() {
     class Example {
       @GET
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -992,7 +1026,7 @@
   @Test public void getWithUrlThenPathThrows() {
     class Example {
       @GET
-      Call<Object> method(@Url String url, @Path("hey") String hey) {
+      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
         return null;
       }
     }
@@ -1009,7 +1043,7 @@
   @Test public void getWithPathThenUrlThrows() {
     class Example {
       @GET
-      Call<Object> method(@Path("hey") String hey, @Url Object url) {
+      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
         return null;
       }
     }
@@ -1026,7 +1060,7 @@
   @Test public void getWithQueryThenUrlThrows() {
     class Example {
       @GET("foo/bar")
-      Call<Object> method(@Query("hey") String hey, @Url Object url) {
+      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
         return null;
       }
     }
@@ -1043,7 +1077,7 @@
   @Test public void getWithUrlThenQuery() {
     class Example {
       @GET
-      Call<Object> method(@Url String url, @Query("hey") String hey) {
+      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
         return null;
       }
     }
@@ -1057,7 +1091,7 @@
   @Test public void postWithUrl() {
     class Example {
       @POST
-      Call<Object> method(@Url String url, @Body RequestBody body) {
+      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
         return null;
       }
     }
@@ -1072,7 +1106,7 @@
   @Test public void normalPostWithPathParam() {
     class Example {
       @POST("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
         return null;
       }
     }
@@ -1087,7 +1121,7 @@
   @Test public void emptyBody() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1102,7 +1136,7 @@
   @Test public void customMethodEmptyBody() {
     class Example {
       @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1116,7 +1150,7 @@
   @Test public void bodyResponseBody() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1131,7 +1165,7 @@
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1146,7 +1180,7 @@
   @Test public void bodyWithPathParams() {
     class Example {
       @POST("/foo/bar/{ping}/{kit}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
         return null;
       }
     }
@@ -1162,7 +1196,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
         return null;
       }
     }
@@ -1179,19 +1213,82 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"\r\n")
         .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
   }
 
+  @Test public void multipartArray() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") String[] ping) {
+        return null;
+      }
+    }
+
+    Request request =
+        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong1\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"")
+        .contains("\r\npong2\r\n--");
+  }
+
+  @Test public void multipartIterable() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<String> ping) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong1\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"")
+        .contains("\r\npong2\r\n--");
+  }
+
   @Test public void multipartWithEncoding() throws IOException {
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
+      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
           @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
         return null;
       }
@@ -1208,11 +1305,15 @@
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
-    assertThat(bodyString).contains("name=\"ping\"\r\n")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\npong\r\n--");
 
-    assertThat(bodyString).contains("name=\"kit\"")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 7-bit")
         .contains("\r\nkat\r\n--");
   }
@@ -1221,15 +1322,15 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("ping", "pong");
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
     params.put("foo", null); // Should be skipped.
-    params.put("kit", "kat");
+    params.put("kit", RequestBody.create(null, "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
@@ -1242,10 +1343,12 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"\r\n")
         .contains("\r\npong\r\n--");
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"kit\"")
         .contains("\r\nkat\r\n--");
 
@@ -1256,15 +1359,15 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("ping", "pong");
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
     params.put("foo", null); // Should be skipped.
-    params.put("kit", "kat");
+    params.put("kit", RequestBody.create(null, "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
@@ -1276,11 +1379,15 @@
     body.writeTo(buffer);
     String bodyString = buffer.readUtf8();
 
-    assertThat(bodyString).contains("name=\"ping\"\r\n")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\npong\r\n--");
 
-    assertThat(bodyString).contains("name=\"kit\"")
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
         .contains("Content-Transfer-Encoding: 8-bit")
         .contains("\r\nkat\r\n--");
 
@@ -1291,14 +1398,14 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap Map<String, Object> parts) {
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("ping", "pong");
-    params.put(null, "kat");
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put(null, RequestBody.create(null, "kat"));
 
     try {
       buildRequest(Example.class, params);
@@ -1312,7 +1419,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@PartMap List<Object> parts) {
+      Call<ResponseBody> method(@PartMap List<Object> parts) {
         return null;
       }
     }
@@ -1330,7 +1437,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
         return null;
       }
     }
@@ -1345,6 +1452,7 @@
     String bodyString = buffer.readUtf8();
 
     assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
         .contains("name=\"ping\"")
         .contains("\r\npong\r\n--");
   }
@@ -1353,7 +1461,7 @@
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") RequestBody ping) {
+      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
         return null;
       }
     }
@@ -1369,7 +1477,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping) {
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
         return null;
       }
     }
@@ -1381,7 +1489,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field(value = "na%20me", encoded = true) String foo) {
+      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
         return null;
       }
     }
@@ -1393,7 +1501,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping,
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
           @Field("kit") String kit) {
         return null;
       }
@@ -1406,7 +1514,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1420,7 +1528,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1434,7 +1542,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
         return null;
       }
     }
@@ -1448,7 +1556,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
         return null;
       }
     }
@@ -1465,7 +1573,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/foo") //
-      Call<Object> method(@FieldMap Map<String, Object> fieldMap) {
+      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
         return null;
       }
     }
@@ -1483,7 +1591,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method(@FieldMap Map<String, Object> a) {
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
         return null;
       }
     }
@@ -1505,7 +1613,7 @@
     class Example {
       @FormUrlEncoded //
       @POST("/") //
-      Call<Object> method(@FieldMap List<String> a) {
+      Call<ResponseBody> method(@FieldMap List<String> a) {
         return null;
       }
     }
@@ -1525,7 +1633,7 @@
           "ping: pong",
           "kit: kat"
       })
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1542,7 +1650,7 @@
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("kit") BigInteger kit) {
+      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
@@ -1559,7 +1667,7 @@
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Call<Object> method(@Header("kit") String kit) {
+      Call<ResponseBody> method(@Header("kit") String kit) {
         return null;
       }
     }
@@ -1576,7 +1684,7 @@
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("foo") List<String> kit) {
+      Call<ResponseBody> method(@Header("foo") List<String> kit) {
         return null;
       }
     }
@@ -1592,7 +1700,7 @@
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Call<Object> method(@Header("foo") String[] kit) {
+      Call<ResponseBody> method(@Header("foo") String[] kit) {
         return null;
       }
     }
@@ -1609,7 +1717,7 @@
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Call<Object> method(@Body RequestBody body) {
+      Call<ResponseBody> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1622,7 +1730,7 @@
     class Example {
       @DELETE("/") //
       @Headers("Content-Type: text/not-plain") //
-      Call<Object> method() {
+      Call<ResponseBody> method() {
         return null;
       }
     }
@@ -1633,7 +1741,7 @@
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Call<Object> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
@@ -1654,16 +1762,34 @@ private static void assertBody(RequestBody body, String expected) {
   }
 
   private Request buildRequest(Class<?> cls, Object... args) {
-    Method method = TestingUtils.onlyMethod(cls);
+    OkHttpClient client = new OkHttpClient();
 
-    BaseUrl baseUrl = new BaseUrl() {
-      @Override public HttpUrl url() {
-        return HttpUrl.parse("http://example.com/");
+    final AtomicReference<Request> requestRef = new AtomicReference<>();
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        requestRef.set(chain.request());
+        throw new UnsupportedOperationException("Not implemented");
       }
-    };
-    Converter.Factory converterFactory = new ToStringConverterFactory();
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory())
+        .client(client)
+        .build();
 
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactory);
-    return requestFactory.create(args);
+    Method method = TestingUtils.onlyMethod(cls);
+    MethodHandler<?> handler = retrofit.loadMethodHandler(method);
+    Call<?> invoke = (Call<?>) handler.invoke(args);
+    try {
+      invoke.execute();
+      throw new AssertionError();
+    } catch (UnsupportedOperationException ignored) {
+      return requestRef.get();
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit/ResponseTest.java b/retrofit/src/test/java/retrofit/ResponseTest.java
new file mode 100644
index 000000000..4c0deb641
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/ResponseTest.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.ResponseBody;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResponseTest {
+  private final com.squareup.okhttp.Response successResponse =
+      new com.squareup.okhttp.Response.Builder() //
+          .code(200)
+          .message("OK")
+          .protocol(Protocol.HTTP_1_1)
+          .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
+          .build();
+  private final com.squareup.okhttp.Response errorResponse =
+      new com.squareup.okhttp.Response.Builder() //
+          .code(400)
+          .message("Broken!")
+          .protocol(Protocol.HTTP_1_1)
+          .request(new com.squareup.okhttp.Request.Builder().url("http://localhost").build())
+          .build();
+
+  @Test public void success() {
+    Object body = new Object();
+    Response<Object> response = Response.success(body);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successNullAllowed() {
+    Response<Object> response = Response.success(null);
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isNull();
+  }
+
+  @Test public void successWithRawResponse() {
+    Object body = new Object();
+    Response<Object> response = Response.success(body, successResponse);
+    assertThat(response.raw()).isSameAs(successResponse);
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successWithNullRawResponseThrows() {
+    try {
+      Response.success("", null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("rawResponse == null");
+    }
+  }
+
+  @Test public void successWithErrorRawResponseThrows() {
+    try {
+      Response.success("", errorResponse);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("rawResponse must be successful response");
+    }
+  }
+
+  @Test public void error() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    Response<?> response = Response.error(400, errorBody);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(400);
+    assertThat(response.message()).isNull();
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.body()).isNull();
+    assertThat(response.errorBody()).isSameAs(errorBody);
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Response.error(400, null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("body == null");
+    }
+  }
+
+  @Test public void errorWithSuccessCodeThrows() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    try {
+      Response.error(200, errorBody);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("code < 400: 200");
+    }
+  }
+
+  @Test public void errorWithRawResponse() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    Response<?> response = Response.error(errorBody, errorResponse);
+    assertThat(response.raw()).isSameAs(errorResponse);
+    assertThat(response.code()).isEqualTo(400);
+    assertThat(response.message()).isEqualTo("Broken!");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.body()).isNull();
+    assertThat(response.errorBody()).isSameAs(errorBody);
+  }
+
+  @Test public void nullErrorWithRawResponseThrows() {
+    try {
+      Response.error(null, errorResponse);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("body == null");
+    }
+  }
+
+  @Test public void errorWithNullRawResponseThrows() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    try {
+      Response.error(errorBody, null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("rawResponse == null");
+    }
+  }
+
+  @Test public void errorWithSuccessRawResponseThrows() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    try {
+      Response.error(errorBody, successResponse);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("rawResponse should not be successful response");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
index 27a1548d7..70f27a38f 100644
--- a/retrofit/src/test/java/retrofit/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -9,6 +9,8 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.List;
@@ -19,17 +21,21 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit.http.Body;
 import retrofit.http.GET;
 import retrofit.http.POST;
+import retrofit.http.Query;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
@@ -41,8 +47,11 @@
   interface CallMethod {
     @GET("/") Call<String> disallowed();
     @POST("/") Call<ResponseBody> disallowed(@Body String body);
-    @GET("/") Call<ResponseBody> allowed();
-    @POST("/") Call<ResponseBody> allowed(@Body RequestBody body);
+    @GET("/") Call<ResponseBody> getResponseBody();
+    @GET("/") Call<Void> getVoid();
+    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
+    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
+    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
   }
   interface FutureMethod {
     @GET("/") Future<String> method();
@@ -52,16 +61,31 @@
   interface StringService {
     @GET("/") String get();
   }
-  interface Unresolvable {
+  interface UnresolvableResponseType {
     @GET("/") <T> Call<T> typeVariable();
     @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
     @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
     @GET("/") Call<?> wildcard();
     @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
   }
+  interface UnresolvableParameterType {
+    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
+    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
+    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
+    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
+    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
+  }
   interface VoidService {
     @GET("/") void nope();
   }
+  interface Annotated {
+    @GET("/") @Foo Call<String> method();
+    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
+    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
+
+    @Retention(RUNTIME)
+    @interface Foo {}
+  }
 
   @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
   @Test public void objectMethodsStillWork() {
@@ -83,7 +107,7 @@
       retrofit.create(Extending.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
     }
   }
 
@@ -102,29 +126,64 @@
     }
   }
 
-  @Test public void callReturnTypeAdapterAddedByDefault() {
+  @Test public void validateEagerlyDisabledByDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    // Should not throw exception about incorrect configuration of the VoidService
+    retrofit.create(VoidService.class);
+  }
+
+  @Test public void validateEagerlyDisabledByUser() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .validateEagerly(false)
+        .build();
+
+    // Should not throw exception about incorrect configuration of the VoidService
+    retrofit.create(VoidService.class);
+  }
+
+  @Test public void validateEagerlyFailsAtCreation() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .validateEagerly(true)
+        .build();
+
+    try {
+      retrofit.create(VoidService.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
+  @Test public void callCallAdapterAddedByDefault() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.allowed()).isNotNull();
+    assertThat(example.getResponseBody()).isNotNull();
   }
 
-  @Test public void callReturnTypeCustomAdapter() {
+  @Test public void callCallCustomAdapter() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType) {
+      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         factoryCalled.set(true);
         if (Utils.getRawType(returnType) != Call.class) {
           return null;
         }
-        return new CallAdapter<Object>() {
+        return new CallAdapter<Call<?>>() {
           @Override public Type responseType() {
-            return Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+            return Utils.getParameterUpperBound(0, (ParameterizedType) returnType);
           }
 
-          @Override public Object adapt(Call<Object> call) {
+          @Override public <R> Call<R> adapt(Call<R> call) {
             adapterCalled.set(true);
             return call;
           }
@@ -134,26 +193,27 @@
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .callAdapterFactory(new MyCallAdapterFactory())
+        .addCallAdapterFactory(new MyCallAdapterFactory())
         .build();
     CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.allowed()).isNotNull();
+    assertThat(example.getResponseBody()).isNotNull();
     assertThat(factoryCalled.get()).isTrue();
     assertThat(adapterCalled.get()).isTrue();
   }
 
-  @Test public void customReturnTypeAdapter() {
+  @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory implements CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType) {
+      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
         if (Utils.getRawType(returnType) != String.class) {
           return null;
         }
-        return new CallAdapter<Object>() {
+        return new CallAdapter<String>() {
           @Override public Type responseType() {
             return String.class;
           }
 
-          @Override public String adapt(Call<Object> call) {
+          @Override public <R> String adapt(Call<R> call) {
             return "Hi!";
           }
         };
@@ -162,14 +222,35 @@
 
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
-        .callAdapterFactory(new GreetingCallAdapterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new GreetingCallAdapterFactory())
         .build();
     StringService example = retrofit.create(StringService.class);
     assertThat(example.get()).isEqualTo("Hi!");
   }
 
-  @Test public void customReturnTypeAdapterMissingThrows() {
+  @Test public void methodAnnotationsPassedToCallAdapter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+        return null;
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void customCallAdapterMissingThrows() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .build();
@@ -178,12 +259,115 @@
       example.method();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call adapter factory 'Default' was unable to"
-              + " handle return type java.util.concurrent.Future<java.lang.String>\n"
+      assertThat(e).hasMessage(
+          "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
               + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>. Tried:\n"
+              + " * retrofit.DefaultCallAdapter$1");
     }
   }
 
+  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void parameterAnnotationsPassedToRequestBodyConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().requestBodyConverter(type, annotations, retrofit);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.bodyParameter(null); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void parameterAnnotationsPassedToStringConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+        annotationsRef.set(annotations);
+
+        return new Converter<Object, String>() {
+          @Override public String convert(Object value) throws IOException {
+            return String.valueOf(value);
+          }
+        };
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.queryParameter(null); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void stringConverterNotCalledForString() {
+    class MyConverterFactory extends Converter.Factory {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+        throw new AssertionError();
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.queryString(null);
+    assertThat(call).isNotNull();
+    // We also implicitly assert the above factory was not called as it would have thrown.
+  }
+
+  @Test public void stringConverterReturningNullResultsInDefault() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
+    class MyConverterFactory extends Converter.Factory {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations) {
+        factoryCalled.set(true);
+        return null;
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.queryObject(null);
+    assertThat(call).isNotNull();
+    assertThat(factoryCalled.get()).isTrue();
+  }
+
   @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -194,9 +378,11 @@
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Body parameter is class java.lang.String but no converter factory registered. Either"
-              + " add a converter factory to the Retrofit instance or use RequestBody. (parameter #1)\n"
+          "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
               + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters");
     }
   }
 
@@ -212,25 +398,18 @@
       example.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Method response type is class java.lang.String but no converter factory registered. "
-              + "Either add a converter factory to the Retrofit instance or use ResponseBody.\n"
-              + "    for method CallMethod.disallowed");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters");
     }
   }
 
   @Test public void converterReturningNullThrows() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new Converter.Factory() {
-          @Override public Converter<?> get(Type type) {
-            return null;
-          }
-
-          @Override public String toString() {
-            return "Nully";
-          }
-        })
+        .addConverterFactory(new Converter.Factory() {})
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
 
@@ -238,9 +417,12 @@
       service.disallowed();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Converter factory 'Nully' was unable to handle response type class java.lang.String\n"
-              + "    for method CallMethod.disallowed");
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverters\n"
+              + " * retrofit.RetrofitTest$1");
     }
   }
 
@@ -252,10 +434,22 @@
 
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    Response<ResponseBody> response = example.allowed().execute();
+    Response<ResponseBody> response = example.getResponseBody().execute();
     assertThat(response.body().string()).isEqualTo("Hi");
   }
 
+  @Test public void voidOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Void> response = example.getVoid().execute();
+    assertThat(response.body()).isNull();
+  }
+
   @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
@@ -265,32 +459,32 @@
     server.enqueue(new MockResponse().setBody("Hi"));
 
     RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.allowed(body).execute();
+    Response<ResponseBody> response = example.postRequestBody(body).execute();
     assertThat(response.body().string()).isEqualTo("Hi");
 
     assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
   }
 
-  @Test public void unresolvableTypeThrows() {
+  @Test public void unresolvableResponseTypeThrows() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
-        .converterFactory(new ToStringConverterFactory())
+        .addConverterFactory(new ToStringConverterFactory())
         .build();
-    Unresolvable example = retrofit.create(Unresolvable.class);
+    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
 
     try {
       example.typeVariable();
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<T>\n    for method Unresolvable.typeVariable");
+          + "retrofit.Call<T>\n    for method UnresolvableResponseType.typeVariable");
     }
     try {
       example.typeVariableUpperBound();
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<T>\n    for method Unresolvable.typeVariableUpperBound");
+          + "retrofit.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
     }
     try {
       example.crazy();
@@ -298,14 +492,14 @@
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
           + "retrofit.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
-          + "    for method Unresolvable.crazy");
+          + "    for method UnresolvableResponseType.crazy");
     }
     try {
       example.wildcard();
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<?>\n    for method Unresolvable.wildcard");
+          + "retrofit.Call<?>\n    for method UnresolvableResponseType.wildcard");
     }
     try {
       example.wildcardUpperBound();
@@ -313,7 +507,53 @@
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
           + "retrofit.Call<? extends com.squareup.okhttp.ResponseBody>\n"
-          + "    for method Unresolvable.wildcardUpperBound");
+          + "    for method UnresolvableResponseType.wildcardUpperBound");
+    }
+  }
+
+  @Test public void unresolvableParameterTypeThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
+
+    try {
+      example.typeVariable(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
+    }
+    try {
+      example.typeVariableUpperBound(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
+    }
+    try {
+      example.crazy(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
+          + "    for method UnresolvableParameterType.crazy");
+    }
+    try {
+      example.wildcard(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
+    }
+    try {
+      example.wildcardUpperBound(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "java.util.List<? extends com.squareup.okhttp.RequestBody> (parameter #1)\n"
+          + "    for method UnresolvableParameterType.wildcardUpperBound");
     }
   }
 
@@ -356,6 +596,22 @@
     }
   }
 
+  @Test public void baseUrlNoTrailingSlashThrows() {
+    try {
+      new Retrofit.Builder().baseUrl("http://example.com/api");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+    }
+    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+    try {
+      new Retrofit.Builder().baseUrl(parsed);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+    }
+  }
+
   @Test public void baseUrlStringPropagated() {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
@@ -410,32 +666,153 @@
 
   @Test public void converterNullThrows() {
     try {
-      new Retrofit.Builder().converterFactory(null);
+      new Retrofit.Builder().addConverterFactory(null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("converterFactory == null");
     }
   }
 
-  @Test public void converterNoDefault() {
+  @Test public void converterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    List<Converter.Factory> converterFactories = retrofit.converterFactories();
+    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+  }
+
+  @Test public void requestConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, annotations, retrofit);
+
+    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).requestBodyConverter(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void requestConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter.Factory factory1 = spy(new Converter.Factory() {
+      @Override
+      public Converter<?, RequestBody> requestBodyConverter(Type returnType,
+          Annotation[] annotations, Retrofit retrofit) {
+        return null;
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.requestBodyConverter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate RequestBody converter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).requestBodyConverter(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+  }
+
+  @Test public void responseConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
         .build();
-    assertThat(retrofit.converterFactory()).isNull();
+
+    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
+
+    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).responseBodyConverter(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void responseConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter.Factory factory1 = spy(new Converter.Factory() {
+      @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type returnType,
+          Annotation[] annotations, Retrofit retrofit) {
+        return null;
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.responseBodyConverter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).responseBodyConverter(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+  }
+
+  @Test public void stringConverterFactoryQueried() {
+    Type type = Object.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<?, String> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations);
+
+    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).stringConverter(type, annotations);
+    verifyNoMoreInteractions(factory);
   }
 
   @Test public void converterFactoryPropagated() {
     Converter.Factory factory = mock(Converter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .converterFactory(factory)
+        .addConverterFactory(factory)
         .build();
-    assertThat(retrofit.converterFactory()).isSameAs(factory);
+    assertThat(retrofit.converterFactories()).contains(factory);
   }
 
   @Test public void callAdapterFactoryNullThrows() {
     try {
-      new Retrofit.Builder().callAdapterFactory(null);
+      new Retrofit.Builder().addCallAdapterFactory(null);
       fail();
     } catch (NullPointerException e) {
       assertThat(e).hasMessage("factory == null");
@@ -446,16 +823,158 @@
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
         .build();
-    assertThat(retrofit.callAdapterFactory()).isNotNull();
+    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
   }
 
   @Test public void callAdapterFactoryPropagated() {
     CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://example.com/")
-        .callAdapterFactory(factory)
+        .addCallAdapterFactory(factory)
         .build();
-    assertThat(retrofit.callAdapterFactory()).isSameAs(factory);
+    assertThat(retrofit.callAdapterFactories()).contains(factory);
+  }
+
+  @Test public void callAdapterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegate() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .build();
+
+    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .addCallAdapterFactory(factory3)
+        .build();
+
+    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+    verify(factory3).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory3);
+  }
+
+  @Test public void callAdapterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+
+    doReturn(null).when(factory).get(type, annotations, retrofit);
+
+    try {
+      retrofit.callAdapter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Could not locate call adapter for class java.lang.String. Tried:");
+    }
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .build();
+
+    try {
+      retrofit.callAdapter(type, annotations);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageContaining("Skipped:")
+          .hasMessageStartingWith(
+              "Could not locate call adapter for class java.lang.String. Tried:");
+    }
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
   }
 
   @Test public void callbackExecutorNullThrows() {
@@ -494,7 +1013,7 @@
         .callbackExecutor(executor)
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.allowed();
+    Call<ResponseBody> call = service.getResponseBody();
 
     server.enqueue(new MockResponse());
 
@@ -525,7 +1044,7 @@
         .callbackExecutor(executor)
         .build();
     CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.allowed();
+    Call<ResponseBody> call = service.getResponseBody();
 
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
diff --git a/retrofit/src/test/java/retrofit/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
index 291622d94..cbcef6a4b 100644
--- a/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
@@ -19,22 +19,34 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-class ToStringConverterFactory implements Converter.Factory {
+class ToStringConverterFactory extends Converter.Factory {
   private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
-  @Override public Converter get(Type type) {
-    return new StringConverter();
-  }
-
-  static class StringConverter implements Converter<Object> {
-    @Override public String fromBody(ResponseBody body) throws IOException {
-      return body.string();
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (String.class.equals(type)) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
+        }
+      };
     }
+    return null;
+  }
 
-    @Override public RequestBody toBody(Object value) {
-      return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] annotations, Retrofit retrofit) {
+    if (String.class.equals(type)) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
+          return RequestBody.create(MEDIA_TYPE, value);
+        }
+      };
     }
+    return null;
   }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index f80ad0afd..cedb3a385 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -24,6 +24,15 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>converter-gson</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
new file mode 100644
index 000000000..037ea553e
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import okio.BufferedSink;
+import retrofit.Call;
+import retrofit.Converter;
+import retrofit.GsonConverterFactory;
+import retrofit.Retrofit;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+public final class ChunkingConverter {
+  @Target(PARAMETER)
+  @Retention(RUNTIME)
+  @interface Chunked {
+  }
+
+  /**
+   * A converter which removes known content lengths to force chunking when {@code @Chunked} is
+   * present on {@code @Body} params.
+   */
+  static class ChunkingConverterFactory extends Converter.Factory {
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      boolean isBody = false;
+      boolean isChunked = false;
+      for (Annotation annotation : annotations) {
+        isBody |= annotation instanceof Body;
+        isChunked |= annotation instanceof Chunked;
+      }
+      if (!isBody || !isChunked) {
+        return null;
+      }
+
+      // Look up the real converter to delegate to.
+      final Converter<Object, RequestBody> delegate =
+          retrofit.nextRequestBodyConverter(this, type, annotations);
+      // Wrap it in a Converter which removes the content length from the delegate's body.
+      return new Converter<Object, RequestBody>() {
+        @Override public RequestBody convert(Object value) throws IOException {
+          final RequestBody realBody = delegate.convert(value);
+          return new RequestBody() {
+            @Override public MediaType contentType() {
+              return realBody.contentType();
+            }
+
+            @Override public void writeTo(BufferedSink sink) throws IOException {
+              realBody.writeTo(sink);
+            }
+          };
+        }
+      };
+    }
+  }
+
+  static class Repo {
+    final String owner;
+    final String name;
+
+    Repo(String owner, String name) {
+      this.owner = owner;
+      this.name = name;
+    }
+  }
+
+  interface Service {
+    @POST("/")
+    Call<ResponseBody> sendNormal(@Body Repo repo);
+    @POST("/")
+    Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
+  }
+
+  public static void main(String... args) throws IOException, InterruptedException {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+    server.start();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ChunkingConverterFactory())
+        .addConverterFactory(GsonConverterFactory.create())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Repo retrofitRepo = new Repo("square", "retrofit");
+
+    service.sendNormal(retrofitRepo).execute();
+    RecordedRequest normalRequest = server.takeRequest();
+    System.out.println(
+        "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
+
+    service.sendChunked(retrofitRepo).execute();
+    RecordedRequest chunkedRequest = server.takeRequest();
+    System.out.println(
+        "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
index 95ebb85da..92bb635ee 100644
--- a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -19,12 +19,15 @@
 import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import retrofit.Call;
 import retrofit.CallAdapter;
 import retrofit.Callback;
+import retrofit.GsonConverterFactory;
 import retrofit.Response;
 import retrofit.Retrofit;
 import retrofit.http.GET;
@@ -35,25 +38,24 @@
  */
 public final class CustomCallAdapter {
   public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
-    @Override public CallAdapter<?> get(Type returnType) {
+    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit) {
       TypeToken<?> token = TypeToken.of(returnType);
       if (token.getRawType() != ListenableFuture.class) {
         return null;
       }
-
-      TypeToken<?> componentType = token.getComponentType();
-      if (componentType == null) {
-        throw new IllegalStateException(); // TODO
+      if (!(returnType instanceof ParameterizedType)) {
+        throw new IllegalStateException(
+            "ListenableFuture must have generic type (e.g., ListenableFuture<ResponseBody>)");
       }
-      final Type responseType = componentType.getType();
-
-      return new CallAdapter<Object>() {
+      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
+      return new CallAdapter<ListenableFuture<?>>() {
         @Override public Type responseType() {
           return responseType;
         }
 
-        @Override public ListenableFuture<?> adapt(Call<Object> call) {
-          CallFuture<Object> future = new CallFuture<>(call);
+        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
+          CallFuture<R> future = new CallFuture<>(call);
           call.enqueue(future);
           return future;
         }
@@ -97,7 +99,8 @@ private CallFuture(Call<T> call) {
   public static void main(String... args) {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl("http://httpbin.org")
-        .callAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .addConverterFactory(GsonConverterFactory.create())
         .build();
 
     HttpBinService service = retrofit.create(HttpBinService.class);
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
new file mode 100644
index 000000000..d25f0d0b8
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import retrofit.Call;
+import retrofit.Converter;
+import retrofit.GsonConverterFactory;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+public final class DeserializeErrorBody {
+  interface Service {
+    @GET("/user") Call<User> getUser();
+  }
+
+  static class User {
+    // normal fields...
+  }
+
+  static class Error {
+    String message;
+  }
+
+  public static void main(String... args) throws IOException {
+    // Create a local web server which response with a 404 and JSON body.
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse()
+        .setResponseCode(404)
+        .setBody("{\"message\":\"Unable to locate resource\"}"));
+
+    // Create our Service instance with a Retrofit pointing at the local web server and Gson.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GsonConverterFactory.create())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Response<User> response = service.getUser().execute();
+
+    // Normally you would check response.isSuccess() here before doing the following, but we know
+    // this call will always fail. You could also use response.code() to determine whether to
+    // convert the error body and/or which type to use for conversion.
+
+    // Look up a converter for the Error type on the Retrofit instance.
+    Converter<ResponseBody, Error> errorConverter =
+        retrofit.responseBodyConverter(Error.class, new Annotation[0]);
+    // Convert the error body into our Error type.
+    Error error = errorConverter.convert(response.errorBody());
+    System.out.println("ERROR: " + error.message);
+
+    server.shutdown();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
new file mode 100644
index 000000000..12931b293
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.common.reflect.TypeToken;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import retrofit.Call;
+import retrofit.CallAdapter;
+import retrofit.Callback;
+import retrofit.GsonConverterFactory;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+/**
+ * A sample showing a custom {@link CallAdapter} which adapts the built-in {@link Call} to a custom
+ * version whose callback has more granular methods.
+ */
+public final class ErrorHandlingCallAdapter {
+  /** A callback which offers granular callbacks for various conditions. */
+  interface MyCallback<T> {
+    /** Called for [200, 300) responses. */
+    void success(Response<T> response);
+    /** Called for 401 responses. */
+    void unauthenticated(Response<?> response);
+    /** Called for [400, 500) responses, except 401. */
+    void clientError(Response<?> response);
+    /** Called for [500, 600) response. */
+    void serverError(Response<?> response);
+    /** Called for network errors while making the call. */
+    void networkError(IOException e);
+    /** Called for unexpected errors while making the call. */
+    void unexpectedError(Throwable t);
+  }
+
+  interface MyCall<T> {
+    void cancel();
+    void enqueue(MyCallback<T> callback);
+    MyCall<T> clone();
+
+    // Left as an exercise for the reader...
+    // TODO MyResponse<T> execute() throws MyHttpException;
+  }
+
+  public static class ErrorHandlingCallAdapterFactory implements CallAdapter.Factory {
+    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit) {
+      TypeToken<?> token = TypeToken.of(returnType);
+      if (token.getRawType() != MyCall.class) {
+        return null;
+      }
+      if (!(returnType instanceof ParameterizedType)) {
+        throw new IllegalStateException(
+            "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
+      }
+      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
+      return new CallAdapter<MyCall<?>>() {
+        @Override public Type responseType() {
+          return responseType;
+        }
+
+        @Override public <R> MyCall<R> adapt(Call<R> call) {
+          return new MyCallAdapter<>(call);
+        }
+      };
+    }
+  }
+
+  /** Adapts a {@link Call} to {@link MyCall}. */
+  static class MyCallAdapter<T> implements MyCall<T> {
+    private final Call<T> call;
+
+    MyCallAdapter(Call<T> call) {
+      this.call = call;
+    }
+
+    @Override public void cancel() {
+      call.cancel();
+    }
+
+    @Override public void enqueue(final MyCallback<T> callback) {
+      call.enqueue(new Callback<T>() {
+        @Override public void onResponse(Response<T> response) {
+          int code = response.code();
+          if (code >= 200 && code < 300) {
+            callback.success(response);
+          } else if (code == 401) {
+            callback.unauthenticated(response);
+          } else if (code >= 400 && code < 500) {
+            callback.clientError(response);
+          } else if (code >= 500 && code < 600) {
+            callback.serverError(response);
+          } else {
+            callback.unexpectedError(new RuntimeException("Unexpected response " + response));
+          }
+        }
+
+        @Override public void onFailure(Throwable t) {
+          if (t instanceof IOException) {
+            callback.networkError((IOException) t);
+          } else {
+            callback.unexpectedError(t);
+          }
+        }
+      });
+    }
+
+    @Override public MyCall<T> clone() {
+      return new MyCallAdapter<>(call.clone());
+    }
+  }
+
+  interface HttpBinService {
+    @GET("/ip")
+    MyCall<Ip> getIp();
+  }
+
+  static class Ip {
+    String origin;
+  }
+
+  public static void main(String... args) {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://httpbin.org")
+        .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
+        .addConverterFactory(GsonConverterFactory.create())
+        .build();
+
+    HttpBinService service = retrofit.create(HttpBinService.class);
+    MyCall<Ip> ip = service.getIp();
+    ip.enqueue(new MyCallback<Ip>() {
+      @Override public void success(Response<Ip> response) {
+        System.out.println("SUCCESS! " + response.body().origin);
+      }
+
+      @Override public void unauthenticated(Response<?> response) {
+        System.out.println("UNAUTHENTICATED");
+      }
+
+      @Override public void clientError(Response<?> response) {
+        System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
+      }
+
+      @Override public void serverError(Response<?> response) {
+        System.out.println("SERVER ERROR " + response.code() + " " + response.message());
+      }
+
+      @Override public void networkError(IOException e) {
+        System.err.println("NETOWRK ERROR " + e.getMessage());
+      }
+
+      @Override public void unexpectedError(Throwable t) {
+        System.err.println("FATAL ERROR " + t.getMessage());
+      }
+    });
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index b05f00844..a591e2be7 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -14,10 +14,10 @@
 import java.util.concurrent.Executors;
 import retrofit.Call;
 import retrofit.Retrofit;
-import retrofit.mock.Behavior;
 import retrofit.mock.CallBehaviorAdapter;
 import retrofit.mock.Calls;
 import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
 
 /**
  * An example of using {@link MockRetrofit} to create a mock service implementation with
@@ -73,14 +73,14 @@ public static void main(String... args) throws IOException {
         .build();
 
     // Create the Behavior object which manages the fake behavior and the background executor.
-    Behavior behavior = Behavior.create();
+    NetworkBehavior behavior = NetworkBehavior.create();
     ExecutorService bg = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
         .setNameFormat("mock-retrofit-%d")
         .setDaemon(true)
         .build());
 
     // Create the mock implementation and use MockRetrofit to apply the behavior to it.
-    MockRetrofit mockRetrofit = new MockRetrofit(new CallBehaviorAdapter(retrofit, bg), behavior);
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, new CallBehaviorAdapter(retrofit, bg));
     MockGitHub mockGitHub = new MockGitHub();
     GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index a57edb3ca..1fe28dc2a 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit.Call;
+import retrofit.GsonConverterFactory;
 import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
@@ -46,6 +47,7 @@ public static void main(String... args) throws IOException {
     // Create a very simple REST adapter which points the GitHub API.
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(API_URL)
+        .addConverterFactory(GsonConverterFactory.create())
         .build();
 
     // Create an instance of our GitHub API interface.
diff --git a/website/index.html b/website/index.html
index fbbda6a98..9dc7e6e3a 100644
--- a/website/index.html
+++ b/website/index.html
@@ -4,7 +4,7 @@
     <meta charset="utf-8">
     <title>Retrofit</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="A type-safe REST client for Android and Java">
+    <meta name="description" content="A type-safe HTTP client for Android and Java">
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
@@ -27,13 +27,14 @@ <h1>Retrofit</h1>
               </ul>
             </menu>
           </div>
+        </div>
       </div>
     </header>
     <section id="subtitle">
       <div class="container">
         <div class="row">
           <div class="span12">
-            <h2>A type-safe <strong>REST client</strong> for Android and Java</h2>
+            <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsung! --></h2>
           </div>
         </div>
       </div>
@@ -42,232 +43,146 @@ <h2>A type-safe <strong>REST client</strong> for Android and Java</h2>
       <div class="container">
         <div class="row">
           <div class="span9">
-            <h3 id="introduction">Introduction</h3>
-            <p>Retrofit turns your REST API into a Java interface.</p>
-            <pre class="prettyprint">public interface GitHubService {
+            <section id="introduction">
+              <h3>Introduction</h3>
+              <p>Retrofit turns your HTTP API into a Java interface.</p>
+              <pre class="prettyprint">public interface GitHubService {
   @GET("/users/{user}/repos")
-  List&lt;Repo> listRepos(@Path("user") String user);
+  Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
-            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.github.com")
+              <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+              <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.github.com")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
-            <pre class="prettyprint">List&lt;Repo> repos = service.listRepos("octocat");</pre>
-            <p>Use annotations to describe the HTTP request:</p>
-            <ul>
-              <li>URL parameter replacement and query parameter support</li>
-              <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
-              <li>Multipart request body and file upload</li>
-            </ul>
-
-            <h3 id="api-declaration">API Declaration</h3>
-            <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
-
-            <h4>Request Method</h4>
-            <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-            <pre class="prettyprint">@GET("/users/list")</pre>
-            <p>You can also specify query parameters in the URL.</p>
-            <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
-            </pre>
-
-            <h4>URL Manipulation</h4>
-            <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
+              <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
+              <p>Use annotations to describe the HTTP request:</p>
+              <ul>
+                <li>URL parameter replacement and query parameter support</li>
+                <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
+                <li>Multipart request body and file upload</li>
+              </ul>
+              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
+            </section>
+
+            <section id="api-declaration">
+              <h3>API Declaration</h3>
+              <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
+
+              <h4>Request Method</h4>
+              <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
+              <pre class="prettyprint">@GET("/users/list")</pre>
+              <p>You can also specify query parameters in the URL.</p>
+              <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
+
+              <h4>URL Manipulation</h4>
+              <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId);</pre>
-            <p>Query parameters can also be added.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>Query parameters can also be added.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
-            <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
-            <pre class="prettyprint">@GET("/group/{id}/users")
+              <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
+              <pre class="prettyprint">@GET("/group/{id}/users")
 List&lt;User> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
-            <h4>Request Body</h4>
-            <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
-            <pre class="prettyprint">@POST("/users/new")
-void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>Retrofit</code>'s converter.</p>
+              <h4>Request Body</h4>
+              <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
+              <pre class="prettyprint">@POST("/users/new")
+Call&lt;User> createUser(@Body User user);</pre>
+              <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
-            <h4>Form Encoded and Multipart</h4>
-            <p>Methods can also be declared to send form-encoded and multipart data.</p>
-            <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
-            <pre class="prettyprint">@FormUrlEncoded
+              <h4>Form Encoded and Multipart</h4>
+              <p>Methods can also be declared to send form-encoded and multipart data.</p>
+              <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
+              <pre class="prettyprint">@FormUrlEncoded
 @POST("/user/edit")
-User updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
-            <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
-            <pre class="prettyprint">@Multipart
+Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
+              <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
+              <pre class="prettyprint">@Multipart
 @PUT("/user/photo")
-User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description);</pre>
-            <p>Multipart parts use the <code>Retrofit</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
+              <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
 
-            <h4>Header Manipulation</h4>
-            <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
-            <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
+              <h4>Header Manipulation</h4>
+              <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
+              <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
 @GET("/widget/list")
-List&lt;Widget> widgetList();</pre>
-            <pre class="prettyprint">@Headers({
+Call&lt;List&lt;Widget>> widgetList();</pre>
+              <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
 @GET("/users/{username}")
-User getUser(@Path("username") String username);</pre>
-            <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
-            <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
-            <pre class="prettyprint">@GET("/user")
-void getUser(@Header("Authorization") String authorization, Callback&lt;User> callback)</pre>
-            <p>Headers that need to be added to every request can be specified using a <code>RequestInterceptor</code>. The following code creates a <code>RequestInterceptor</code> that will add a <code>User-Agent</code> header to every request.</p>
-            <pre class="prettyprint">RequestInterceptor requestInterceptor = new RequestInterceptor() {
-  @Override
-  public void intercept(RequestFacade request) {
-    request.addHeader("User-Agent", "Retrofit-Sample-App");
-  }
-};
-
-Retrofit retrofit = new Retrofit.Builder()
-  .setEndpoint("https://api.github.com")
-  .setRequestInterceptor(requestInterceptor)
-  .build();</pre>
-
-            <h4>Synchronous vs. Asynchronous vs. Observable</h4>
-            <p>Methods can be declared for either synchronous or asynchronous execution.</p>
-            <p>A method with a return type will be executed synchronously.</p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-Photo getUserPhoto(@Path("id") int id);</pre>
-            <p>Asynchronous execution requires the last parameter of the method be a <code>Callback</code>.</p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-void getUserPhoto(@Path("id") int id, Callback&lt;Photo> cb);</pre>
-            <p>On Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.</p>
-
-            <p>Retrofit also integrates <a href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-Observable&lt;Photo> getUserPhoto(@Path("id") int id);</pre>
-            <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
-
-            <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>Retrofit</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
-            <pre class="prettyprint">@GET("/users/list")
-List&lt;User> userList();
-
-@GET("/users/list")
-void userList(Callback&lt;List&lt;User>> cb);
-
-@GET("/users/list")
-Observable&lt;List&lt;User>> userList();</pre>
-            <p>For access to the raw HTTP response use the <code>Response</code> type.</p>
-            <pre class="prettyprint">@GET("/users/list")
-Response userList();
-
-@GET("/users/list")
-void userList(Callback&lt;Response> cb);
-
-@GET("/users/list")
-Observable&lt;Response> userList();</pre>
-
-            <h3 id="restadapter-configuration">Retrofit Configuration</h3>
-            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
-
-            <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>Retrofit</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
-            <h4>Custom Gson Converter Example</h4>
-            <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
-            <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
-            <pre class="prettyprint">Gson gson = new GsonBuilder()
-    .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
-    .registerTypeAdapter(Date.class, new DateTypeAdapter())
-    .create();
-
-Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.github.com")
-    .setConverter(new GsonConverter(gson))
-    .build();
-
-GitHubService service = retrofit.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>Retrofit</code>.</p>
-            <h4>Content format Agnostic</h4>
-            <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href="http://simple.sourceforge.net/">Simple</a>) and Protocol Buffers (using <a href="https://code.google.com/p/protobuf/">protobuf</a> or <a href="https://github.com/square/wire">Wire</a>). Please see the <a href="https://github.com/square/retrofit/tree/master/retrofit-converters">retrofit-converters</a> directory for the full listing of converters.</p>
-            <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.soundcloud.com")
-    .setConverter(new SimpleXMLConverter())
-    .build();
-
-SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
-            <h4>Custom Converters</h4>
-            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
-            <h4>Custom Error Handling</h4>
-            <p>If you need custom error handling for requests, you may provide your own <code>ErrorHandler</code>. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code</p>
-            <pre class="prettyprint">
-class MyErrorHandler implements ErrorHandler {
-  @Override public Throwable handleError(RetrofitError cause) {
-    Response r = cause.getResponse();
-    if (r != null && r.getStatus() == 401) {
-      return new UnauthorizedException(cause);
-    }
-    return cause;
-  }
-}
-
-Retrofit retrofit = new Retrofit.Builder()
-    .setEndpoint("https://api.github.com")
-    .setErrorHandler(new MyErrorHandler())
-    .build();</pre>
-            <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
-
-            <h4>Logging</h4>
-            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>Retrofit</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
-            <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
-            <pre class="prettyprint">
-Retrofit retrofit = new Retrofit.Builder()
-    .setLogLevel(Retrofit.LogLevel.FULL)
-    .setEndpoint("https://api.github.com")
-    .build();</pre>
-            <p>This logging can be added or changed at any point in the <code>Retrofit</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
-
-            <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
+Call&lt;User> getUser(@Path("username") String username);</pre>
+              <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
+              <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
+              <pre class="prettyprint">@GET("/user")
+Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
+              <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
+
+              <h4>Synchronous vs. Asynchronous</h4>
+              <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
+              <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
+            </section>
+
+            <section id="restadapter-configuration">
+              <h3>Retrofit Configuration</h3>
+              <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+
+              <h4>Converters</h4>
+              <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
+              <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
+              <ul>
+                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
+                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
+                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
+                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
+                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
+                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
+              </ul>
+              <h4>Custom Converters</h4>
+              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
+            </section>
+
+            <section id="download">
+              <h3>Download</h3>
+              <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+              <h4>Maven</h4>
+              <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit&lt;/groupId>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
-            <h4>Gradle</h4>
-            <pre class="prettyprint">
+              <h4>Gradle</h4>
+              <pre class="prettyprint">
 compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-            <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
+              <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-            <h4>Integration with OkHttp</h4>
-            <p>Retrofit will automatically use OkHttp (version 2.0 or newer) when it is present.</p>
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
-  &lt;artifactId>okhttp&lt;/artifactId>
-  &lt;version><span class="okhttpversion pln"><em>(insert latest version)</em></span>&lt;/version>
-&lt;/dependency>
-</pre>
-            <h4>Gradle</h4>
-<pre class="prettyprint">
-compile 'com.squareup.okhttp:okhttp:<span class="okhttpversion pln"><em>(insert latest version)</em></span>'
-</pre>
-            <h4>ProGuard</h4>
-            <p>If you are using Proguard in your project add the following lines to your configuration:</p>
-            <pre class="prettyprint">
+              <h4>ProGuard</h4>
+              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+              <pre class="prettyprint">
 -dontwarn retrofit.**
 -keep class retrofit.** { *; }
 -keepattributes Signature
 -keepattributes Exceptions
 </pre>
-            <h3 id="contributing">Contributing</h3>
-            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            </section>
+
+            <section id="contributing">
+              <h3>Contributing</h3>
+              <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
+              <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            </section>
 
-            <h3 id="license">License</h3>
-            <pre>Copyright 2013 Square, Inc.
+            <section id="license">
+              <h3>License</h3>
+              <pre>Copyright 2013 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -280,6 +195,7 @@ <h3 id="license">License</h3>
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</pre>
+            </section>
           </div>
           <div class="span3">
             <div class="content-nav" data-spy="affix" data-offset-top="80">
@@ -292,7 +208,7 @@ <h3 id="license">License</h3>
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="javadoc/index.html">Javadoc</a></li>
+                <li><a href="2.x/retrofit/">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
               </ul>
             </div>
@@ -338,9 +254,6 @@ <h3 id="license">License</h3>
           $('.version-tag').text('v' + version);
           $('.version-href').attr('href', url);
         });
-        $.fn.artifactVersion('com.squareup.okhttp', 'okhttp', function(version, url) {
-          $('.okhttpversion').text(version);
-        });
       });
 
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
