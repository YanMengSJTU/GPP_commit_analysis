diff --git a/README.md b/README.md
index b99e03dbb..95d3f43ea 100644
--- a/README.md
+++ b/README.md
@@ -47,6 +47,9 @@ onNetFailure(Call<T> call, Throwable t);
 
 handle Unexpected char  in header name and value
 
+7、OkHttpClientUtil.getTrustAllSSLClient
+
+TrustAllSSL
 
 中文：
 ---------
@@ -93,6 +96,11 @@ onNetFailure(Call<T> call, Throwable t);
 
 当okhttp header 有中文字符时 采用getHeaderValueEncoded 和 getHeaderNameEncoded 进行编码
 
+
+7、OkHttpClientUtil.getTrustAllSSLClient
+
+设置信任所有SSL正证书
+
 Usage
 --------
 for android
@@ -103,7 +111,7 @@ repositories {
     }
 }
 dependencies {
-	compile 'com.github.MasonLiuChn:RetrofitPlus:2.3.0.1'
+	compile 'com.github.MasonLiuChn:RetrofitPlus:2.3.0.3'
 	compile('com.squareup.retrofit2:converter-gson:2.3.0') {
         	//exclude module: 'retrofit' 如果不写 group 则生成 pom 不会 add exclusion
         	exclude group: 'com.squareup.retrofit2', module: 'retrofit'
diff --git a/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java b/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
index 8cf7cd955..3c2b2aa2f 100644
--- a/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
+++ b/retrofit/src/main/java/retrofit2/plus/OkHttpClientUtil.java
@@ -9,13 +9,19 @@
 import java.security.KeyStore;
 import java.security.SecureRandom;
 import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
 import java.util.Collection;
 import java.util.Iterator;
 
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
 
 import okhttp3.OkHttpClient;
 
@@ -26,6 +32,47 @@
     private OkHttpClientUtil() {
     }
 
+    public static OkHttpClient getTrustAllSSLClient(OkHttpClient client) {
+        try {
+            // Create a trust manager that does not validate certificate chains
+            final TrustManager[] trustAllCerts = new TrustManager[]{
+                    new X509TrustManager() {
+                        @Override
+                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
+                        }
+
+                        @Override
+                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
+                        }
+
+                        @Override
+                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                            return new java.security.cert.X509Certificate[]{};
+                        }
+                    }
+            };
+
+            // Install the all-trusting trust manager
+            final SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
+            // Create an ssl socket factory with our all-trusting manager
+            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+
+            OkHttpClient.Builder builder = client.newBuilder();
+            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);
+            builder.hostnameVerifier(new HostnameVerifier() {
+                @Override
+                public boolean verify(String hostname, SSLSession session) {
+                    return true;
+                }
+            });
+
+            return builder.build();
+        } catch (Exception e) {
+            return client;
+        }
+    }
+
     public static OkHttpClient getSSLClient(OkHttpClient client, Context context, String assetsSSLFileName) {
         InputStream inputStream = trustedCertificatesInputStream(context, assetsSSLFileName);
         return getSSLClientByInputStream(client, inputStream);
@@ -107,17 +154,18 @@ private static KeyStore newEmptyKeyStore(char[] password) {
 
     /**
      * 由于okhttp header 中的 value 不支持 null, \n 和 中文这样的特殊字符,所以encode字符串
+     *
      * @param value
      * @return
      */
-    public static  String getHeaderValueEncoded(String value) {
+    public static String getHeaderValueEncoded(String value) {
         if (TextUtils.isEmpty(value)) return " ";
         for (int i = 0, length = value.length(); i < length; i++) {
             char c = value.charAt(i);
             if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {//根据源码okhttp允许[0020-007E]+\t的字符
-                try{
+                try {
                     return URLEncoder.encode(value, "UTF-8");
-                }catch (Exception e){
+                } catch (Exception e) {
                     e.printStackTrace();
                     return " ";
                 }
@@ -129,14 +177,14 @@ public static  String getHeaderValueEncoded(String value) {
     /**
      * 由于okhttp header 中的 name 不支持 null,空格、\t、 \n 和 中文这样的特殊字符,所以encode字符串
      */
-    public static  String getHeaderNameEncoded(String name) {
+    public static String getHeaderNameEncoded(String name) {
         if (TextUtils.isEmpty(name)) return "null";
         for (int i = 0, length = name.length(); i < length; i++) {
             char c = name.charAt(i);
             if (c <= '\u0020' || c >= '\u007f') {//根据源码okhttp允许[0021-007E]的字符
-                try{
+                try {
                     return URLEncoder.encode(name, "UTF-8");
-                }catch (Exception e){
+                } catch (Exception e) {
                     e.printStackTrace();
                     return " ";
                 }
