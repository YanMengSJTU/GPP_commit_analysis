diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index becb9e3dc..2ba24011c 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -80,6 +80,7 @@
                   <exclude>org.json</exclude>
                   <exclude>com.squareup.okhttp3</exclude>
                   <exclude>com.squareup.okio</exclude>
+                  <!--<exclude>com.squareup.retrofit2</exclude>-->
                 </excludes>
               </artifactSet>
             </configuration>
diff --git a/retrofit-custom/dependency-reduced-pom.xml b/retrofit-custom/dependency-reduced-pom.xml
new file mode 100644
index 000000000..c81a4f572
--- /dev/null
+++ b/retrofit-custom/dependency-reduced-pom.xml
@@ -0,0 +1,122 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <parent>
+    <artifactId>parent</artifactId>
+    <groupId>com.squareup.retrofit2</groupId>
+    <version>2.2.0-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>retrofit</artifactId>
+  <name>Retrofit</name>
+  <dependencies>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.12</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <artifactId>hamcrest-core</artifactId>
+          <groupId>org.hamcrest</groupId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <version>1.7.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <version>1.9.5</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <artifactId>objenesis</artifactId>
+          <groupId>org.objenesis</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>hamcrest-core</artifactId>
+          <groupId>org.hamcrest</groupId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>19.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>3.6.0</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <artifactId>bcprov-jdk15on</artifactId>
+          <groupId>org.bouncycastle</groupId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>org.robolectric</groupId>
+      <artifactId>robolectric</artifactId>
+      <version>3.0</version>
+      <scope>test</scope>
+      <exclusions>
+        <exclusion>
+          <artifactId>robolectric-annotations</artifactId>
+          <groupId>org.robolectric</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>robolectric-resources</artifactId>
+          <groupId>org.robolectric</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>robolectric-utils</artifactId>
+          <groupId>org.robolectric</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>shadows-core</artifactId>
+          <groupId>org.robolectric</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>bcprov-jdk16</artifactId>
+          <groupId>org.bouncycastle</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>asm</artifactId>
+          <groupId>org.ow2.asm</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>asm-commons</artifactId>
+          <groupId>org.ow2.asm</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>asm-util</artifactId>
+          <groupId>org.ow2.asm</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>asm-analysis</artifactId>
+          <groupId>org.ow2.asm</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>vtd-xml</artifactId>
+          <groupId>com.ximpleware</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>maven-ant-tasks</artifactId>
+          <groupId>org.apache.maven</groupId>
+        </exclusion>
+        <exclusion>
+          <artifactId>ant</artifactId>
+          <groupId>org.apache.ant</groupId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+  </dependencies>
+</project>
+
diff --git a/retrofit-custom/pom.xml b/retrofit-custom/pom.xml
new file mode 100644
index 000000000..082e825ab
--- /dev/null
+++ b/retrofit-custom/pom.xml
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.2.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>retrofit</artifactId>
+  <name>Retrofit</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.robolectric</groupId>
+      <artifactId>robolectric</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-custom/src/main/java/retrofit2/BuiltInConverters.java b/retrofit-custom/src/main/java/retrofit2/BuiltInConverters.java
new file mode 100644
index 000000000..f729383a3
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/BuiltInConverters.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.Streaming;
+
+final class BuiltInConverters extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (type == ResponseBody.class) {
+      return Utils.isAnnotationPresent(annotations, Streaming.class)
+          ? StreamingResponseBodyConverter.INSTANCE
+          : BufferingResponseBodyConverter.INSTANCE;
+    }
+    if (type == Void.class) {
+      return VoidResponseBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+      return RequestBodyConverter.INSTANCE;
+    }
+    return null;
+  }
+
+  static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
+    static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
+
+    @Override public Void convert(ResponseBody value) throws IOException {
+      value.close();
+      return null;
+    }
+  }
+
+  static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
+    static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
+
+    @Override public RequestBody convert(RequestBody value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class StreamingResponseBodyConverter
+      implements Converter<ResponseBody, ResponseBody> {
+    static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
+
+    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+      return value;
+    }
+  }
+
+  static final class BufferingResponseBodyConverter
+      implements Converter<ResponseBody, ResponseBody> {
+    static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
+
+    @Override public ResponseBody convert(ResponseBody value) throws IOException {
+      try {
+        // Buffer the entire body to avoid future I/O.
+        return Utils.buffer(value);
+      } finally {
+        value.close();
+      }
+    }
+  }
+
+  static final class ToStringConverter implements Converter<Object, String> {
+    static final ToStringConverter INSTANCE = new ToStringConverter();
+
+    @Override public String convert(Object value) {
+      return value.toString();
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Call.java b/retrofit-custom/src/main/java/retrofit2/Call.java
new file mode 100644
index 000000000..171d9e0c4
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Call.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import okhttp3.Request;
+
+/**
+ * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
+ * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
+ * calls with the same parameters to the same webserver; this may be used to implement polling or
+ * to retry a failed call.
+ *
+ * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
+ * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
+ * is busy writing its request or reading its response may receive a {@link IOException}; this is
+ * working as designed.
+ *
+ * @param <T> Successful response body type.
+ */
+public interface Call<T> extends Cloneable {
+  /**
+   * Synchronously send the request and return its response.
+   *
+   * @throws IOException if a problem occurred talking to the server.
+   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+   * or decoding the response.
+   */
+  Response<T> execute() throws IOException;
+
+  /**
+   * Asynchronously send the request and notify {@code callback} of its response or if an error
+   * occurred talking to the server, creating the request, or processing the response.
+   */
+  void enqueue(Callback<T> callback);
+
+  /**
+   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+   */
+  boolean isExecuted();
+
+  /**
+   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+   * yet been executed it never will be.
+   */
+  void cancel();
+
+  /** True if {@link #cancel()} was called. */
+  boolean isCanceled();
+
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
+  Call<T> clone();
+
+  /** The original HTTP request. */
+  Request request();
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/CallAdapter.java b/retrofit-custom/src/main/java/retrofit2/CallAdapter.java
new file mode 100644
index 000000000..927540bf4
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/CallAdapter.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
+/**
+ * Adapts a {@link Call} with response type {@code R} into the type of {@code T}. Instances are
+ * created by {@linkplain Factory a factory} which is
+ * {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into the {@link Retrofit}
+ * instance.
+ */
+public interface CallAdapter<R, T> {
+  /**
+   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+   * is used to prepare the {@code call} passed to {@code #adapt}.
+   * <p>
+   * Note: This is typically not the same type as the {@code returnType} provided to this call
+   * adapter's factory.
+   */
+  Type responseType();
+
+  /**
+   * Returns an instance of {@code T} which delegates to {@code call}.
+   * <p>
+   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+   * return a new {@code Async<R>} which invoked {@code call} when run.
+   * <pre><code>
+   * &#64;Override
+   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
+   *     &#64;Override
+   *     public Response&lt;R&gt; call() throws Exception {
+   *       return call.execute();
+   *     }
+   *   });
+   * }
+   * </code></pre>
+   */
+  T adapt(Call<R> call);
+
+  /**
+   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+   * Retrofit#create(Class) the service interface} methods.
+   */
+  abstract class Factory {
+    /**
+     * Returns a call adapter for interface methods that return {@code returnType}, or null if it
+     * cannot be handled by this factory.
+     */
+    public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit);
+
+    /**
+     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     */
+    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+      return Utils.getParameterUpperBound(index, type);
+    }
+
+    /**
+     * Extract the raw class type from {@code type}. For example, the type representing
+     * {@code List<? extends Runnable>} returns {@code List.class}.
+     */
+    protected static Class<?> getRawType(Type type) {
+      return Utils.getRawType(type);
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Callback.java b/retrofit-custom/src/main/java/retrofit2/Callback.java
new file mode 100644
index 000000000..62c93a621
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Callback.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+/**
+ * Communicates responses from a server or offline requests. One and only one method will be
+ * invoked in response to a given request.
+ * <p>
+ * Callback methods are executed using the {@link Retrofit} callback executor. When none is
+ * specified, the following defaults are used:
+ * <ul>
+ * <li>Android: Callbacks are executed on the application's main (UI) thread.</li>
+ * <li>JVM: Callbacks are executed on the background thread which performed the request.</li>
+ * </ul>
+ *
+ * @param <T> Successful response body type.
+ */
+public interface Callback<T> {
+  /**
+   * Invoked for a received HTTP response.
+   * <p>
+   * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
+   * Call {@link Response#isSuccessful()} to determine if the response indicates success.
+   */
+  void onResponse(Call<T> call, Response<T> response);
+
+  /**
+   * Invoked when a network exception occurred talking to the server or when an unexpected
+   * exception occurred creating the request or processing the response.
+   */
+  void onFailure(Call<T> call, Throwable t);
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Converter.java b/retrofit-custom/src/main/java/retrofit2/Converter.java
new file mode 100644
index 000000000..880eea9b8
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Converter.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.Body;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+
+/**
+ * Convert objects to and from their representation in HTTP. Instances are created by {@linkplain
+ * Factory a factory} which is {@linkplain Retrofit.Builder#addConverterFactory(Factory) installed}
+ * into the {@link Retrofit} instance.
+ */
+public interface Converter<F, T> {
+  T convert(F value) throws IOException;
+
+  /** Creates {@link Converter} instances based on a type and target usage. */
+  abstract class Factory {
+    /**
+     * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
+     * {@code type} cannot be handled by this factory. This is used to create converters for
+     * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
+     * declaration.
+     */
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      return null;
+    }
+
+    /**
+     * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
+     * {@code type} cannot be handled by this factory. This is used to create converters for types
+     * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
+     * values.
+     */
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      return null;
+    }
+
+    /**
+     * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
+     * {@code type} cannot be handled by this factory. This is used to create converters for types
+     * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
+     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
+     */
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      return null;
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit-custom/src/main/java/retrofit2/DefaultCallAdapterFactory.java
new file mode 100644
index 000000000..c0f114cf3
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * Creates call adapters for that uses the same thread for both I/O and application-level
+ * callbacks. For synchronous calls this is the application thread making the request; for
+ * asynchronous calls this is a thread provided by OkHttp's dispatcher.
+ */
+final class DefaultCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
+      return null;
+    }
+
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Object, Call<?>>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<Object> adapt(Call<Object> call) {
+        return call;
+      }
+    };
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit-custom/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
new file mode 100644
index 000000000..a633d60e8
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+import okhttp3.Request;
+
+final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
+  final Executor callbackExecutor;
+
+  ExecutorCallAdapterFactory(Executor callbackExecutor) {
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != Call.class) {
+      return null;
+    }
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Object, Call<?>>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<Object> adapt(Call<Object> call) {
+        return new ExecutorCallbackCall<>(callbackExecutor, call);
+      }
+    };
+  }
+
+  static final class ExecutorCallbackCall<T> implements Call<T> {
+    final Executor callbackExecutor;
+    final Call<T> delegate;
+
+    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void enqueue(final Callback<T> callback) {
+      if (callback == null) throw new NullPointerException("callback == null");
+
+      delegate.enqueue(new Callback<T>() {
+        @Override public void onResponse(Call<T> call, final Response<T> response) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              if (delegate.isCanceled()) {
+                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+              } else {
+                callback.onResponse(ExecutorCallbackCall.this, response);
+              }
+            }
+          });
+        }
+
+        @Override public void onFailure(Call<T> call, final Throwable t) {
+          callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              callback.onFailure(ExecutorCallbackCall.this, t);
+            }
+          });
+        }
+      });
+    }
+
+    @Override public boolean isExecuted() {
+      return delegate.isExecuted();
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      return delegate.execute();
+    }
+
+    @Override public void cancel() {
+      delegate.cancel();
+    }
+
+    @Override public boolean isCanceled() {
+      return delegate.isCanceled();
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+    @Override public Call<T> clone() {
+      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+    }
+
+    @Override public Request request() {
+      return delegate.request();
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/OkHttpCall.java b/retrofit-custom/src/main/java/retrofit2/OkHttpCall.java
new file mode 100644
index 000000000..ccbfe1ab2
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/OkHttpCall.java
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+
+final class OkHttpCall<T> implements Call<T> {
+  private final ServiceMethod<T, ?> serviceMethod;
+  private final Object[] args;
+
+  private volatile boolean canceled;
+
+  // All guarded by this.
+  private okhttp3.Call rawCall;
+  private Throwable creationFailure; // Either a RuntimeException or IOException.
+  private boolean executed;
+
+  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
+    this.serviceMethod = serviceMethod;
+    this.args = args;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public OkHttpCall<T> clone() {
+    return new OkHttpCall<>(serviceMethod, args);
+  }
+
+  @Override public synchronized Request request() {
+    okhttp3.Call call = rawCall;
+    if (call != null) {
+      return call.request();
+    }
+    if (creationFailure != null) {
+      if (creationFailure instanceof IOException) {
+        throw new RuntimeException("Unable to create request.", creationFailure);
+      } else {
+        throw (RuntimeException) creationFailure;
+      }
+    }
+    try {
+      return (rawCall = createRawCall()).request();
+    } catch (RuntimeException e) {
+      creationFailure = e;
+      throw e;
+    } catch (IOException e) {
+      creationFailure = e;
+      throw new RuntimeException("Unable to create request.", e);
+    }
+  }
+
+  @Override public void enqueue(final Callback<T> callback) {
+    if (callback == null) throw new NullPointerException("callback == null");
+
+    okhttp3.Call call;
+    Throwable failure;
+
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed.");
+      executed = true;
+
+      call = rawCall;
+      failure = creationFailure;
+      if (call == null && failure == null) {
+        try {
+          call = rawCall = createRawCall();
+        } catch (Throwable t) {
+          failure = creationFailure = t;
+        }
+      }
+    }
+
+    if (failure != null) {
+      callback.onFailure(this, failure);
+      return;
+    }
+
+    if (canceled) {
+      call.cancel();
+    }
+
+    call.enqueue(new okhttp3.Callback() {
+      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
+          throws IOException {
+        Response<T> response;
+        try {
+          response = parseResponse(rawResponse);
+        } catch (Throwable e) {
+          callFailure(e);
+          return;
+        }
+        callSuccess(response);
+      }
+
+      @Override public void onFailure(okhttp3.Call call, IOException e) {
+        try {
+          callback.onFailure(OkHttpCall.this, e);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      private void callFailure(Throwable e) {
+        try {
+          callback.onFailure(OkHttpCall.this, e);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      private void callSuccess(Response<T> response) {
+        try {
+          callback.onResponse(OkHttpCall.this, response);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+    });
+  }
+
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
+  @Override public Response<T> execute() throws IOException {
+    okhttp3.Call call;
+
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed.");
+      executed = true;
+
+      if (creationFailure != null) {
+        if (creationFailure instanceof IOException) {
+          throw (IOException) creationFailure;
+        } else {
+          throw (RuntimeException) creationFailure;
+        }
+      }
+
+      call = rawCall;
+      if (call == null) {
+        try {
+          call = rawCall = createRawCall();
+        } catch (IOException | RuntimeException e) {
+          creationFailure = e;
+          throw e;
+        }
+      }
+    }
+
+    if (canceled) {
+      call.cancel();
+    }
+
+    return parseResponse(call.execute());
+  }
+
+  private okhttp3.Call createRawCall() throws IOException {
+    Request request = serviceMethod.toRequest(args);
+    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+    if (call == null) {
+      throw new NullPointerException("Call.Factory returned null.");
+    }
+    return call;
+  }
+
+  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+    ResponseBody rawBody = rawResponse.body();
+
+    // Remove the body's source (the only stateful object) so we can pass the response along.
+    rawResponse = rawResponse.newBuilder()
+        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+        .build();
+
+    int code = rawResponse.code();
+    if (code < 200 || code >= 300) {
+      try {
+        // Buffer the entire body to avoid future I/O.
+        ResponseBody bufferedBody = Utils.buffer(rawBody);
+        return Response.error(bufferedBody, rawResponse);
+      } finally {
+        rawBody.close();
+      }
+    }
+
+    if (code == 204 || code == 205) {
+      rawBody.close();
+      return Response.success(null, rawResponse);
+    }
+
+    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    try {
+      T body = serviceMethod.toResponse(catchingBody);
+      return Response.success(body, rawResponse);
+    } catch (RuntimeException e) {
+      // If the underlying source threw an exception, propagate that rather than indicating it was
+      // a runtime exception.
+      catchingBody.throwIfCaught();
+      throw e;
+    }
+  }
+
+  public void cancel() {
+    canceled = true;
+
+    okhttp3.Call call;
+    synchronized (this) {
+      call = rawCall;
+    }
+    if (call != null) {
+      call.cancel();
+    }
+  }
+
+  @Override public boolean isCanceled() {
+    if (canceled) {
+      return true;
+    }
+    synchronized (this) {
+      return rawCall != null && rawCall.isCanceled();
+    }
+  }
+
+  static final class NoContentResponseBody extends ResponseBody {
+    private final MediaType contentType;
+    private final long contentLength;
+
+    NoContentResponseBody(MediaType contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public long contentLength() {
+      return contentLength;
+    }
+
+    @Override public BufferedSource source() {
+      throw new IllegalStateException("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  static final class ExceptionCatchingRequestBody extends ResponseBody {
+    private final ResponseBody delegate;
+    IOException thrownException;
+
+    ExceptionCatchingRequestBody(ResponseBody delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public MediaType contentType() {
+      return delegate.contentType();
+    }
+
+    @Override public long contentLength() {
+      return delegate.contentLength();
+    }
+
+    @Override public BufferedSource source() {
+      return Okio.buffer(new ForwardingSource(delegate.source()) {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          try {
+            return super.read(sink, byteCount);
+          } catch (IOException e) {
+            thrownException = e;
+            throw e;
+          }
+        }
+      });
+    }
+
+    @Override public void close() {
+      delegate.close();
+    }
+
+    void throwIfCaught() throws IOException {
+      if (thrownException != null) {
+        throw thrownException;
+      }
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/ParameterHandler.java b/retrofit-custom/src/main/java/retrofit2/ParameterHandler.java
new file mode 100644
index 000000000..f0aa001d1
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/ParameterHandler.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.reflect.Array;
+import java.util.Map;
+import okhttp3.Headers;
+import okhttp3.MultipartBody;
+import okhttp3.RequestBody;
+
+import static retrofit2.Utils.checkNotNull;
+
+abstract class ParameterHandler<T> {
+  abstract void apply(RequestBuilder builder, T value) throws IOException;
+
+  final ParameterHandler<Iterable<T>> iterable() {
+    return new ParameterHandler<Iterable<T>>() {
+      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+        if (values == null) return; // Skip null values.
+
+        for (T value : values) {
+          ParameterHandler.this.apply(builder, value);
+        }
+      }
+    };
+  }
+
+  final ParameterHandler<Object> array() {
+    return new ParameterHandler<Object>() {
+      @Override void apply(RequestBuilder builder, Object values) throws IOException {
+        if (values == null) return; // Skip null values.
+
+        for (int i = 0, size = Array.getLength(values); i < size; i++) {
+          //noinspection unchecked
+          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
+        }
+      }
+    };
+  }
+
+  static final class RelativeUrl extends ParameterHandler<Object> {
+    @Override void apply(RequestBuilder builder, Object value) {
+      builder.setRelativeUrl(value);
+    }
+  }
+
+  static final class Header<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+
+    Header(String name, Converter<T, String> valueConverter) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addHeader(name, valueConverter.convert(value));
+    }
+  }
+
+  static final class Path<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
+      }
+      builder.addPathParam(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class Query<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class QueryName<T> extends ParameterHandler<T> {
+    private final Converter<T, String> nameConverter;
+    private final boolean encoded;
+
+    QueryName(Converter<T, String> nameConverter, boolean encoded) {
+      this.nameConverter = nameConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(nameConverter.convert(value), null, encoded);
+    }
+  }
+
+  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Query map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Query map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Query map contained null value for key '" + entryKey + "'.");
+        }
+        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+      }
+    }
+  }
+
+  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+
+    HeaderMap(Converter<T, String> valueConverter) {
+      this.valueConverter = valueConverter;
+    }
+
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Header map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String headerName = entry.getKey();
+        if (headerName == null) {
+          throw new IllegalArgumentException("Header map contained null key.");
+        }
+        T headerValue = entry.getValue();
+        if (headerValue == null) {
+          throw new IllegalArgumentException(
+              "Header map contained null value for key '" + headerName + "'.");
+        }
+        builder.addHeader(headerName, valueConverter.convert(headerValue));
+      }
+    }
+  }
+
+  static final class Field<T> extends ParameterHandler<T> {
+    private final String name;
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addFormField(name, valueConverter.convert(value), encoded);
+    }
+  }
+
+  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, String> valueConverter;
+    private final boolean encoded;
+
+    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+      this.valueConverter = valueConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Field map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Field map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Field map contained null value for key '" + entryKey + "'.");
+        }
+        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+      }
+    }
+  }
+
+  static final class Part<T> extends ParameterHandler<T> {
+    private final Headers headers;
+    private final Converter<T, RequestBody> converter;
+
+    Part(Headers headers, Converter<T, RequestBody> converter) {
+      this.headers = headers;
+      this.converter = converter;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) {
+      if (value == null) return; // Skip null values.
+
+      RequestBody body;
+      try {
+        body = converter.convert(value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+      }
+      builder.addPart(headers, body);
+    }
+  }
+
+  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+    static final RawPart INSTANCE = new RawPart();
+
+    private RawPart() {
+    }
+
+    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+      if (value != null) { // Skip null values.
+        builder.addPart(value);
+      }
+    }
+  }
+
+  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+    private final Converter<T, RequestBody> valueConverter;
+    private final String transferEncoding;
+
+    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+      this.valueConverter = valueConverter;
+      this.transferEncoding = transferEncoding;
+    }
+
+    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+      if (value == null) {
+        throw new IllegalArgumentException("Part map was null.");
+      }
+
+      for (Map.Entry<String, T> entry : value.entrySet()) {
+        String entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Part map contained null key.");
+        }
+        T entryValue = entry.getValue();
+        if (entryValue == null) {
+          throw new IllegalArgumentException(
+              "Part map contained null value for key '" + entryKey + "'.");
+        }
+
+        Headers headers = Headers.of(
+            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+            "Content-Transfer-Encoding", transferEncoding);
+
+        builder.addPart(headers, valueConverter.convert(entryValue));
+      }
+    }
+  }
+
+  static final class Body<T> extends ParameterHandler<T> {
+    private final Converter<T, RequestBody> converter;
+
+    Body(Converter<T, RequestBody> converter) {
+      this.converter = converter;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) {
+      if (value == null) {
+        throw new IllegalArgumentException("Body parameter value must not be null.");
+      }
+      RequestBody body;
+      try {
+        body = converter.convert(value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+      }
+      builder.setBody(body);
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Platform.java b/retrofit-custom/src/main/java/retrofit2/Platform.java
new file mode 100644
index 000000000..ad9cf533c
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Platform.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.concurrent.Executor;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+class Platform {
+  private static final Platform PLATFORM = findPlatform();
+
+  static Platform get() {
+    return PLATFORM;
+  }
+
+  private static Platform findPlatform() {
+    try {
+      Class.forName("android.os.Build");
+      if (Build.VERSION.SDK_INT != 0) {
+        return new Android();
+      }
+    } catch (ClassNotFoundException ignored) {
+    }
+    try {
+      Class.forName("java.util.Optional");
+      return new Java8();
+    } catch (ClassNotFoundException ignored) {
+    }
+    return new Platform();
+  }
+
+  Executor defaultCallbackExecutor() {
+    return null;
+  }
+
+  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+    if (callbackExecutor != null) {
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+    return DefaultCallAdapterFactory.INSTANCE;
+  }
+
+  boolean isDefaultMethod(Method method) {
+    return false;
+  }
+
+  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+      throws Throwable {
+    throw new UnsupportedOperationException();
+  }
+
+  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+  static class Java8 extends Platform {
+    @Override boolean isDefaultMethod(Method method) {
+      return method.isDefault();
+    }
+
+    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+        Object... args) throws Throwable {
+      // Because the service interface might not be public, we need to use a MethodHandle lookup
+      // that ignores the visibility of the declaringClass.
+      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+      constructor.setAccessible(true);
+      return constructor.newInstance(declaringClass, -1 /* trusted */)
+          .unreflectSpecial(method, declaringClass)
+          .bindTo(object)
+          .invokeWithArguments(args);
+    }
+  }
+
+  static class Android extends Platform {
+    @Override public Executor defaultCallbackExecutor() {
+      return new MainThreadExecutor();
+    }
+
+    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+
+    static class MainThreadExecutor implements Executor {
+      private final Handler handler = new Handler(Looper.getMainLooper());
+
+      @Override public void execute(Runnable r) {
+        handler.post(r);
+      }
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/RequestBuilder.java b/retrofit-custom/src/main/java/retrofit2/RequestBuilder.java
new file mode 100644
index 000000000..3a25b6f53
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/RequestBuilder.java
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import okhttp3.FormBody;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okio.Buffer;
+import okio.BufferedSink;
+
+final class RequestBuilder {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+
+  private final String method;
+
+  private final HttpUrl baseUrl;
+  private String relativeUrl;
+  private HttpUrl.Builder urlBuilder;
+
+  private final Request.Builder requestBuilder;
+  private MediaType contentType;
+
+  private final boolean hasBody;
+  private MultipartBody.Builder multipartBuilder;
+  private FormBody.Builder formBuilder;
+  private RequestBody body;
+
+  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+    this.method = method;
+    this.baseUrl = baseUrl;
+    this.relativeUrl = relativeUrl;
+    this.requestBuilder = new Request.Builder();
+    this.contentType = contentType;
+    this.hasBody = hasBody;
+
+    if (headers != null) {
+      requestBuilder.headers(headers);
+    }
+
+    if (isFormEncoded) {
+      // Will be set to 'body' in 'build'.
+      formBuilder = new FormBody.Builder();
+    } else if (isMultipart) {
+      // Will be set to 'body' in 'build'.
+      multipartBuilder = new MultipartBody.Builder();
+      multipartBuilder.setType(MultipartBody.FORM);
+    }
+  }
+
+  void setRelativeUrl(Object relativeUrl) {
+    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
+    this.relativeUrl = relativeUrl.toString();
+  }
+
+  void addHeader(String name, String value) {
+    if ("Content-Type".equalsIgnoreCase(name)) {
+      MediaType type = MediaType.parse(value);
+      if (type == null) {
+        throw new IllegalArgumentException("Malformed content type: " + value);
+      }
+      contentType = type;
+    } else {
+      requestBuilder.addHeader(name, value);
+    }
+  }
+
+  void addPathParam(String name, String value, boolean encoded) {
+    if (relativeUrl == null) {
+      // The relative URL is cleared when the first query parameter is set.
+      throw new AssertionError();
+    }
+    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
+  }
+
+  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+    int codePoint;
+    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, 0, i);
+        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters required encoding.
+    return input;
+  }
+
+  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+      boolean alreadyEncoded) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (codePoint < 0x20 || codePoint >= 0x7f
+          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
+      } else {
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
+      }
+    }
+  }
+
+  void addQueryParam(String name, String value, boolean encoded) {
+    if (relativeUrl != null) {
+      // Do a one-time combination of the built relative URL and the base URL.
+      urlBuilder = baseUrl.newBuilder(relativeUrl);
+      if (urlBuilder == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
+      relativeUrl = null;
+    }
+
+    if (encoded) {
+      urlBuilder.addEncodedQueryParameter(name, value);
+    } else {
+      urlBuilder.addQueryParameter(name, value);
+    }
+  }
+
+  void addFormField(String name, String value, boolean encoded) {
+    if (encoded) {
+      formBuilder.addEncoded(name, value);
+    } else {
+      formBuilder.add(name, value);
+    }
+  }
+
+  void addPart(Headers headers, RequestBody body) {
+    multipartBuilder.addPart(headers, body);
+  }
+
+  void addPart(MultipartBody.Part part) {
+    multipartBuilder.addPart(part);
+  }
+
+  void setBody(RequestBody body) {
+    this.body = body;
+  }
+
+  Request build() {
+    HttpUrl url;
+    HttpUrl.Builder urlBuilder = this.urlBuilder;
+    if (urlBuilder != null) {
+      url = urlBuilder.build();
+    } else {
+      // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      url = baseUrl.resolve(relativeUrl);
+      if (url == null) {
+        throw new IllegalArgumentException(
+            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+      }
+    }
+
+    RequestBody body = this.body;
+    if (body == null) {
+      // Try to pull from one of the builders.
+      if (formBuilder != null) {
+        body = formBuilder.build();
+      } else if (multipartBuilder != null) {
+        body = multipartBuilder.build();
+      } else if (hasBody) {
+        // Body is absent, make an empty body.
+        body = RequestBody.create(null, new byte[0]);
+      }
+    }
+
+    MediaType contentType = this.contentType;
+    if (contentType != null) {
+      if (body != null) {
+        body = new ContentTypeOverridingRequestBody(body, contentType);
+      } else {
+        requestBuilder.addHeader("Content-Type", contentType.toString());
+      }
+    }
+
+    return requestBuilder
+        .url(url)
+        .method(method, body)
+        .build();
+  }
+
+  private static class ContentTypeOverridingRequestBody extends RequestBody {
+    private final RequestBody delegate;
+    private final MediaType contentType;
+
+    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
+      this.delegate = delegate;
+      this.contentType = contentType;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public long contentLength() throws IOException {
+      return delegate.contentLength();
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      delegate.writeTo(sink);
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Response.java b/retrofit-custom/src/main/java/retrofit2/Response.java
new file mode 100644
index 000000000..a0efab014
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Response.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+
+/** An HTTP response. */
+public final class Response<T> {
+  /** Create a synthetic successful response with {@code body} as the deserialized body. */
+  public static <T> Response<T> success(T body) {
+    return success(body, new okhttp3.Response.Builder() //
+        .code(200)
+        .message("OK")
+        .protocol(Protocol.HTTP_1_1)
+        .request(new Request.Builder().url("http://localhost/").build())
+        .build());
+  }
+
+  /**
+   * Create a synthetic successful response using {@code headers} with {@code body} as the
+   * deserialized body.
+   */
+  public static <T> Response<T> success(T body, Headers headers) {
+    if (headers == null) throw new NullPointerException("headers == null");
+    return success(body, new okhttp3.Response.Builder() //
+        .code(200)
+        .message("OK")
+        .protocol(Protocol.HTTP_1_1)
+        .headers(headers)
+        .request(new Request.Builder().url("http://localhost/").build())
+        .build());
+  }
+
+  /**
+   * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
+   * body.
+   */
+  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
+    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    if (!rawResponse.isSuccessful()) {
+      throw new IllegalArgumentException("rawResponse must be successful response");
+    }
+    return new Response<>(rawResponse, body, null);
+  }
+
+  /**
+   * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
+   * as the error body.
+   */
+  public static <T> Response<T> error(int code, ResponseBody body) {
+    if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
+    return error(body, new okhttp3.Response.Builder() //
+        .code(code)
+        .protocol(Protocol.HTTP_1_1)
+        .request(new Request.Builder().url("http://localhost/").build())
+        .build());
+  }
+
+  /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
+  public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
+    if (body == null) throw new NullPointerException("body == null");
+    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    if (rawResponse.isSuccessful()) {
+      throw new IllegalArgumentException("rawResponse should not be successful response");
+    }
+    return new Response<>(rawResponse, null, body);
+  }
+
+  private final okhttp3.Response rawResponse;
+  private final T body;
+  private final ResponseBody errorBody;
+
+  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+    this.rawResponse = rawResponse;
+    this.body = body;
+    this.errorBody = errorBody;
+  }
+
+  /** The raw response from the HTTP client. */
+  public okhttp3.Response raw() {
+    return rawResponse;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return rawResponse.code();
+  }
+
+  /** HTTP status message or null if unknown. */
+  public String message() {
+    return rawResponse.message();
+  }
+
+  /** HTTP headers. */
+  public Headers headers() {
+    return rawResponse.headers();
+  }
+
+  /** Returns true if {@link #code()} is in the range [200..300). */
+  public boolean isSuccessful() {
+    return rawResponse.isSuccessful();
+  }
+
+  /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
+  public T body() {
+    return body;
+  }
+
+  /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
+  public ResponseBody errorBody() {
+    return errorBody;
+  }
+
+  @Override public String toString() {
+    return rawResponse.toString();
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Retrofit.java b/retrofit-custom/src/main/java/retrofit2/Retrofit.java
new file mode 100644
index 000000000..8633de4af
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Retrofit.java
@@ -0,0 +1,585 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executor;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.GET;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.Url;
+
+import static java.util.Collections.unmodifiableList;
+import static retrofit2.Utils.checkNotNull;
+
+/**
+ * Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to
+ * define how requests are made. Create instances using {@linkplain Builder
+ * the builder} and pass your interface to {@link #create} to generate an implementation.
+ * <p>
+ * For example,
+ * <pre><code>
+ * Retrofit retrofit = new Retrofit.Builder()
+ *     .baseUrl("https://api.example.com/")
+ *     .addConverterFactory(GsonConverterFactory.create())
+ *     .build();
+ *
+ * MyApi api = retrofit.create(MyApi.class);
+ * Response&lt;User&gt; user = api.getUser().execute();
+ * </code></pre>
+ *
+ * @author Bob Lee (bob@squareup.com)
+ * @author Jake Wharton (jw@squareup.com)
+ */
+public final class Retrofit {
+  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+
+  final okhttp3.Call.Factory callFactory;
+  final HttpUrl baseUrl;
+  final List<Converter.Factory> converterFactories;
+  final List<CallAdapter.Factory> adapterFactories;
+  final Executor callbackExecutor;
+  final boolean validateEagerly;
+
+  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+      Executor callbackExecutor, boolean validateEagerly) {
+    this.callFactory = callFactory;
+    this.baseUrl = baseUrl;
+    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
+    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
+    this.callbackExecutor = callbackExecutor;
+    this.validateEagerly = validateEagerly;
+  }
+
+  /**
+   * Create an implementation of the API endpoints defined by the {@code service} interface.
+   * <p>
+   * The relative path for a given method is obtained from an annotation on the method describing
+   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+   * parameter with {@link Url @Url}.
+   * <p>
+   * Method parameters can be used to replace parts of the URL by annotating them with
+   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+   * {@link retrofit2.http.Query @Query}.
+   * <p>
+   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+   * object will be converted to request representation by one of the {@link Converter.Factory}
+   * instances. A {@link RequestBody} can also be used for a raw representation.
+   * <p>
+   * Alternative request body formats are supported by method annotations and corresponding
+   * parameter annotations:
+   * <ul>
+   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+   * </ul>
+   * <p>
+   * Additional static headers can be added for an endpoint using the
+   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+   * header annotate a parameter with {@link Header @Header}.
+   * <p>
+   * By default, methods return a {@link Call} which represents the HTTP request. The generic
+   * parameter of the call is the response body type and will be converted by one of the
+   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+   * representation. {@link Void} can be used if you do not care about the body contents.
+   * <p>
+   * For example:
+   * <pre>
+   * public interface CategoryService {
+   *   &#64;POST("category/{cat}/")
+   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+   * }
+   * </pre>
+   */
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  public <T> T create(final Class<T> service) {
+    Utils.validateServiceInterface(service);
+    if (validateEagerly) {
+      eagerlyValidateMethods(service);
+    }
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
+        new InvocationHandler() {
+          private final Platform platform = Platform.get();
+
+          @Override public Object invoke(Object proxy, Method method, Object... args)
+              throws Throwable {
+            // If the method is a method from Object then defer to normal invocation.
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            if (platform.isDefaultMethod(method)) {
+              return platform.invokeDefaultMethod(method, service, proxy, args);
+            }
+            ServiceMethod<Object, Object> serviceMethod =
+                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+            return serviceMethod.callAdapter.adapt(okHttpCall);
+          }
+        });
+  }
+
+  private void eagerlyValidateMethods(Class<?> service) {
+    Platform platform = Platform.get();
+    for (Method method : service.getDeclaredMethods()) {
+      if (!platform.isDefaultMethod(method)) {
+        loadServiceMethod(method);
+      }
+    }
+  }
+
+  ServiceMethod<?, ?> loadServiceMethod(Method method) {
+    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+    if (result != null) return result;
+
+    synchronized (serviceMethodCache) {
+      result = serviceMethodCache.get(method);
+      if (result == null) {
+        result = new ServiceMethod.Builder<>(this, method).build();
+        serviceMethodCache.put(method, result);
+      }
+    }
+    return result;
+  }
+
+  /**
+   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+   * Typically an instance of {@link OkHttpClient}.
+   */
+  public okhttp3.Call.Factory callFactory() {
+    return callFactory;
+  }
+
+  /** The API base URL. */
+  public HttpUrl baseUrl() {
+    return baseUrl;
+  }
+
+  /**
+   * Returns a list of the factories tried when creating a
+   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+   */
+  public List<CallAdapter.Factory> callAdapterFactories() {
+    return adapterFactories;
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories}.
+   *
+   * @throws IllegalArgumentException if no call adapter available for {@code type}.
+   */
+  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
+    return nextCallAdapter(null, returnType, annotations);
+  }
+
+  /**
+   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+   * #callAdapterFactories() factories} except {@code skipPast}.
+   *
+   * @throws IllegalArgumentException if no call adapter available for {@code type}.
+   */
+  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+      Annotation[] annotations) {
+    checkNotNull(returnType, "returnType == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = adapterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+      if (adapter != null) {
+        return adapter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+        .append(returnType)
+        .append(".\n");
+    if (skipPast != null) {
+      builder.append("  Skipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+      }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = adapterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a list of the factories tried when creating a
+   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
+   */
+  public List<Converter.Factory> converterFactories() {
+    return converterFactories;
+  }
+
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+   * {@linkplain #converterFactories() factories}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
+  }
+
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+   * {@linkplain #converterFactories() factories} except {@code skipPast}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
+      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+    checkNotNull(methodAnnotations, "methodAnnotations == null");
+
+    int start = converterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter.Factory factory = converterFactories.get(i);
+      Converter<?, RequestBody> converter =
+          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<T, RequestBody>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+        .append(type)
+        .append(".\n");
+    if (skipPast != null) {
+      builder.append("  Skipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+      }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+   * {@linkplain #converterFactories() factories}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+    return nextResponseBodyConverter(null, type, annotations);
+  }
+
+  /**
+   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+   * {@linkplain #converterFactories() factories} except {@code skipPast}.
+   *
+   * @throws IllegalArgumentException if no converter available for {@code type}.
+   */
+  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
+      Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    int start = converterFactories.indexOf(skipPast) + 1;
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      Converter<ResponseBody, ?> converter =
+          converterFactories.get(i).responseBodyConverter(type, annotations, this);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<ResponseBody, T>) converter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+        .append(type)
+        .append(".\n");
+    if (skipPast != null) {
+      builder.append("  Skipped:");
+      for (int i = 0; i < start; i++) {
+        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+      }
+      builder.append('\n');
+    }
+    builder.append("  Tried:");
+    for (int i = start, count = converterFactories.size(); i < count; i++) {
+      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  /**
+   * Returns a {@link Converter} for {@code type} to {@link String} from the available
+   * {@linkplain #converterFactories() factories}.
+   */
+  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+    checkNotNull(type, "type == null");
+    checkNotNull(annotations, "annotations == null");
+
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<?, String> converter =
+          converterFactories.get(i).stringConverter(type, annotations, this);
+      if (converter != null) {
+        //noinspection unchecked
+        return (Converter<T, String>) converter;
+      }
+    }
+
+    // Nothing matched. Resort to default converter which just calls toString().
+    //noinspection unchecked
+    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
+  }
+
+  /**
+   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+   * in which case callbacks should be made synchronously on the background thread.
+   */
+  public Executor callbackExecutor() {
+    return callbackExecutor;
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  /**
+   * Build a new {@link Retrofit}.
+   * <p>
+   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+   * are optional.
+   */
+  public static final class Builder {
+    private final Platform platform;
+    private okhttp3.Call.Factory callFactory;
+    private HttpUrl baseUrl;
+    private final List<Converter.Factory> converterFactories = new ArrayList<>();
+    private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+    private Executor callbackExecutor;
+    private boolean validateEagerly;
+
+    Builder(Platform platform) {
+      this.platform = platform;
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverters());
+    }
+
+    public Builder() {
+      this(Platform.get());
+    }
+
+    Builder(Retrofit retrofit) {
+      platform = Platform.get();
+      callFactory = retrofit.callFactory;
+      baseUrl = retrofit.baseUrl;
+      converterFactories.addAll(retrofit.converterFactories);
+      adapterFactories.addAll(retrofit.adapterFactories);
+      // Remove the default, platform-aware call adapter added by build().
+      adapterFactories.remove(adapterFactories.size() - 1);
+      callbackExecutor = retrofit.callbackExecutor;
+      validateEagerly = retrofit.validateEagerly;
+    }
+
+    /**
+     * The HTTP client used for requests.
+     * <p>
+     * This is a convenience method for calling {@link #callFactory}.
+     */
+    public Builder client(OkHttpClient client) {
+      return callFactory(checkNotNull(client, "client == null"));
+    }
+
+    /**
+     * Specify a custom call factory for creating {@link Call} instances.
+     * <p>
+     * Note: Calling {@link #client} automatically sets this value.
+     */
+    public Builder callFactory(okhttp3.Call.Factory factory) {
+      this.callFactory = checkNotNull(factory, "factory == null");
+      return this;
+    }
+
+    /**
+     * Set the API base URL.
+     *
+     * @see #baseUrl(HttpUrl)
+     */
+    public Builder baseUrl(String baseUrl) {
+      checkNotNull(baseUrl, "baseUrl == null");
+      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+      if (httpUrl == null) {
+        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+      }
+      return baseUrl(httpUrl);
+    }
+
+    /**
+     * Set the API base URL.
+     * <p>
+     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+     * {@code <a href="">} link on a website resolving on the current URL.
+     * <p>
+     * <b>Base URLs should always end in {@code /}.</b>
+     * <p>
+     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+     * append themselves to a base which has path components.
+     * <p>
+     * <b>Correct:</b><br>
+     * Base URL: http://example.com/api/<br>
+     * Endpoint: foo/bar/<br>
+     * Result: http://example.com/api/foo/bar/
+     * <p>
+     * <b>Incorrect:</b><br>
+     * Base URL: http://example.com/api<br>
+     * Endpoint: foo/bar/<br>
+     * Result: http://example.com/foo/bar/
+     * <p>
+     * This method enforces that {@code baseUrl} has a trailing {@code /}.
+     * <p>
+     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+     * <p>
+     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+     * components.
+     * <p>
+     * Base URL: http://example.com/api/<br>
+     * Endpoint: /foo/bar/<br>
+     * Result: http://example.com/foo/bar/
+     * <p>
+     * Base URL: http://example.com/<br>
+     * Endpoint: /foo/bar/<br>
+     * Result: http://example.com/foo/bar/
+     * <p>
+     * <b>Endpoint values may be a full URL.</b>
+     * <p>
+     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+     * replace the scheme of {@code baseUrl}.
+     * <p>
+     * Base URL: http://example.com/<br>
+     * Endpoint: https://github.com/square/retrofit/<br>
+     * Result: https://github.com/square/retrofit/
+     * <p>
+     * Base URL: http://example.com<br>
+     * Endpoint: //github.com/square/retrofit/<br>
+     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     */
+    public Builder baseUrl(HttpUrl baseUrl) {
+      checkNotNull(baseUrl, "baseUrl == null");
+      List<String> pathSegments = baseUrl.pathSegments();
+      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+      }
+      this.baseUrl = baseUrl;
+      return this;
+    }
+
+    /** Add converter factory for serialization and deserialization of objects. */
+    public Builder addConverterFactory(Converter.Factory factory) {
+      converterFactories.add(checkNotNull(factory, "factory == null"));
+      return this;
+    }
+
+    /**
+     * Add a call adapter factory for supporting service method return types other than {@link
+     * Call}.
+     */
+    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+      adapterFactories.add(checkNotNull(factory, "factory == null"));
+      return this;
+    }
+
+    /**
+     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+     * your service method.
+     * <p>
+     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+     * return types}.
+     */
+    public Builder callbackExecutor(Executor executor) {
+      this.callbackExecutor = checkNotNull(executor, "executor == null");
+      return this;
+    }
+
+    /**
+     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+     * the configuration of all methods in the supplied interface.
+     */
+    public Builder validateEagerly(boolean validateEagerly) {
+      this.validateEagerly = validateEagerly;
+      return this;
+    }
+
+    /**
+     * Create the {@link Retrofit} instance using the configured values.
+     * <p>
+     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+     * OkHttpClient} will be created and used.
+     */
+    public Retrofit build() {
+      if (baseUrl == null) {
+        throw new IllegalStateException("Base URL required.");
+      }
+
+      okhttp3.Call.Factory callFactory = this.callFactory;
+      if (callFactory == null) {
+        callFactory = new OkHttpClient();
+      }
+
+      Executor callbackExecutor = this.callbackExecutor;
+      if (callbackExecutor == null) {
+        callbackExecutor = platform.defaultCallbackExecutor();
+      }
+
+      // Make a defensive copy of the adapters and add the default Call adapter.
+      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+
+      // Make a defensive copy of the converters.
+      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
+          callbackExecutor, validateEagerly);
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/ServiceMethod.java b/retrofit-custom/src/main/java/retrofit2/ServiceMethod.java
new file mode 100644
index 000000000..a32f8101a
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/ServiceMethod.java
@@ -0,0 +1,788 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.http.Body;
+import retrofit2.http.DELETE;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.HEAD;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Multipart;
+import retrofit2.http.OPTIONS;
+import retrofit2.http.PATCH;
+import retrofit2.http.POST;
+import retrofit2.http.PUT;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
+import retrofit2.http.Url;
+
+/** Adapts an invocation of an interface method into an HTTP call. */
+final class ServiceMethod<R, T> {
+  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+  final okhttp3.Call.Factory callFactory;
+  final CallAdapter<R, T> callAdapter;
+
+  private final HttpUrl baseUrl;
+  private final Converter<ResponseBody, R> responseConverter;
+  private final String httpMethod;
+  private final String relativeUrl;
+  private final Headers headers;
+  private final MediaType contentType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final ParameterHandler<?>[] parameterHandlers;
+
+  ServiceMethod(Builder<R, T> builder) {
+    this.callFactory = builder.retrofit.callFactory();
+    this.callAdapter = builder.callAdapter;
+    this.baseUrl = builder.retrofit.baseUrl();
+    this.responseConverter = builder.responseConverter;
+    this.httpMethod = builder.httpMethod;
+    this.relativeUrl = builder.relativeUrl;
+    this.headers = builder.headers;
+    this.contentType = builder.contentType;
+    this.hasBody = builder.hasBody;
+    this.isFormEncoded = builder.isFormEncoded;
+    this.isMultipart = builder.isMultipart;
+    this.parameterHandlers = builder.parameterHandlers;
+  }
+
+  /** Builds an HTTP request from method arguments. */
+  Request toRequest(Object... args) throws IOException {
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+        contentType, hasBody, isFormEncoded, isMultipart);
+
+    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
+
+    int argumentCount = args != null ? args.length : 0;
+    if (argumentCount != handlers.length) {
+      throw new IllegalArgumentException("Argument count (" + argumentCount
+          + ") doesn't match expected count (" + handlers.length + ")");
+    }
+
+    for (int p = 0; p < argumentCount; p++) {
+      handlers[p].apply(requestBuilder, args[p]);
+    }
+
+    return requestBuilder.build();
+  }
+
+  /** Builds a method return value from an HTTP response body. */
+  R toResponse(ResponseBody body) throws IOException {
+    return responseConverter.convert(body);
+  }
+
+  /**
+   * Inspects the annotations on an interface method to construct a reusable service method. This
+   * requires potentially-expensive reflection so it is best to build each service method only once
+   * and reuse it. Builders cannot be reused.
+   */
+  static final class Builder<T, R> {
+    final Retrofit retrofit;
+    final Method method;
+    final Annotation[] methodAnnotations;
+    final Annotation[][] parameterAnnotationsArray;
+    final Type[] parameterTypes;
+
+    Type responseType;
+    boolean gotField;
+    boolean gotPart;
+    boolean gotBody;
+    boolean gotPath;
+    boolean gotQuery;
+    boolean gotUrl;
+    String httpMethod;
+    boolean hasBody;
+    boolean isFormEncoded;
+    boolean isMultipart;
+    String relativeUrl;
+    Headers headers;
+    MediaType contentType;
+    Set<String> relativeUrlParamNames;
+    ParameterHandler<?>[] parameterHandlers;
+    Converter<ResponseBody, T> responseConverter;
+    CallAdapter<T, R> callAdapter;
+
+    Builder(Retrofit retrofit, Method method) {
+      this.retrofit = retrofit;
+      this.method = method;
+      this.methodAnnotations = method.getAnnotations();
+      this.parameterTypes = method.getGenericParameterTypes();
+      this.parameterAnnotationsArray = method.getParameterAnnotations();
+    }
+
+    public ServiceMethod build() {
+      callAdapter = createCallAdapter();
+      responseType = callAdapter.responseType();
+      if (responseType == Response.class || responseType == okhttp3.Response.class) {
+        throw methodError("'"
+            + Utils.getRawType(responseType).getName()
+            + "' is not a valid response body type. Did you mean ResponseBody?");
+      }
+      responseConverter = createResponseConverter();
+
+      for (Annotation annotation : methodAnnotations) {
+        parseMethodAnnotation(annotation);
+      }
+
+      if (httpMethod == null) {
+        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+      }
+
+      if (!hasBody) {
+        if (isMultipart) {
+          throw methodError(
+              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+        }
+        if (isFormEncoded) {
+          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+              + "request body (e.g., @POST).");
+        }
+      }
+
+      int parameterCount = parameterAnnotationsArray.length;
+      parameterHandlers = new ParameterHandler<?>[parameterCount];
+      for (int p = 0; p < parameterCount; p++) {
+        Type parameterType = parameterTypes[p];
+        if (Utils.hasUnresolvableType(parameterType)) {
+          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+              parameterType);
+        }
+
+        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+        if (parameterAnnotations == null) {
+          throw parameterError(p, "No Retrofit annotation found.");
+        }
+
+        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+      }
+
+      if (relativeUrl == null && !gotUrl) {
+        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+      }
+      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+        throw methodError("Non-body HTTP method cannot contain @Body.");
+      }
+      if (isFormEncoded && !gotField) {
+        throw methodError("Form-encoded method must contain at least one @Field.");
+      }
+      if (isMultipart && !gotPart) {
+        throw methodError("Multipart method must contain at least one @Part.");
+      }
+
+      return new ServiceMethod<>(this);
+    }
+
+    private CallAdapter<T, R> createCallAdapter() {
+      Type returnType = method.getGenericReturnType();
+      if (Utils.hasUnresolvableType(returnType)) {
+        throw methodError(
+            "Method return type must not include a type variable or wildcard: %s", returnType);
+      }
+      if (returnType == void.class) {
+        throw methodError("Service methods cannot return void.");
+      }
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        //noinspection unchecked
+        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, "Unable to create call adapter for %s", returnType);
+      }
+    }
+
+    private void parseMethodAnnotation(Annotation annotation) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+        if (!Void.class.equals(responseType)) {
+          throw methodError("HEAD method must use Void as response type.");
+        }
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof OPTIONS) {
+        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof retrofit2.http.Headers) {
+        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError("@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError("Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError("Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+      if (this.httpMethod != null) {
+        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+            this.httpMethod, httpMethod);
+      }
+      this.httpMethod = httpMethod;
+      this.hasBody = hasBody;
+
+      if (value.isEmpty()) {
+        return;
+      }
+
+      // Get the relative URL path and existing query string, if present.
+      int question = value.indexOf('?');
+      if (question != -1 && question < value.length() - 1) {
+        // Ensure the query string does not have any named parameters.
+        String queryParams = value.substring(question + 1);
+        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+        if (queryParamMatcher.find()) {
+          throw methodError("URL query string \"%s\" must not have replace block. "
+              + "For dynamic query parameters use @Query.", queryParams);
+        }
+      }
+
+      this.relativeUrl = value;
+      this.relativeUrlParamNames = parsePathParameters(value);
+    }
+
+    private Headers parseHeaders(String[] headers) {
+      Headers.Builder builder = new Headers.Builder();
+      for (String header : headers) {
+        int colon = header.indexOf(':');
+        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+          throw methodError(
+              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        }
+        String headerName = header.substring(0, colon);
+        String headerValue = header.substring(colon + 1).trim();
+        if ("Content-Type".equalsIgnoreCase(headerName)) {
+          MediaType type = MediaType.parse(headerValue);
+          if (type == null) {
+            throw methodError("Malformed content type: %s", headerValue);
+          }
+          contentType = type;
+        } else {
+          builder.add(headerName, headerValue);
+        }
+      }
+      return builder.build();
+    }
+
+    private ParameterHandler<?> parseParameter(
+        int p, Type parameterType, Annotation[] annotations) {
+      ParameterHandler<?> result = null;
+      for (Annotation annotation : annotations) {
+        ParameterHandler<?> annotationAction = parseParameterAnnotation(
+            p, parameterType, annotations, annotation);
+
+        if (annotationAction == null) {
+          continue;
+        }
+
+        if (result != null) {
+          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+        }
+
+        result = annotationAction;
+      }
+
+      if (result == null) {
+        throw parameterError(p, "No Retrofit annotation found.");
+      }
+
+      return result;
+    }
+
+    private ParameterHandler<?> parseParameterAnnotation(
+        int p, Type type, Annotation[] annotations, Annotation annotation) {
+      if (annotation instanceof Url) {
+        if (gotUrl) {
+          throw parameterError(p, "Multiple @Url method annotations found.");
+        }
+        if (gotPath) {
+          throw parameterError(p, "@Path parameters may not be used with @Url.");
+        }
+        if (gotQuery) {
+          throw parameterError(p, "A @Url parameter must not come after a @Query");
+        }
+        if (relativeUrl != null) {
+          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+        }
+
+        gotUrl = true;
+
+        if (type == HttpUrl.class
+            || type == String.class
+            || type == URI.class
+            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+          return new ParameterHandler.RelativeUrl();
+        } else {
+          throw parameterError(p,
+              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        }
+
+      } else if (annotation instanceof Path) {
+        if (gotQuery) {
+          throw parameterError(p, "A @Path parameter must not come after a @Query.");
+        }
+        if (gotUrl) {
+          throw parameterError(p, "@Path parameters may not be used with @Url.");
+        }
+        if (relativeUrl == null) {
+          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+        }
+        gotPath = true;
+
+        Path path = (Path) annotation;
+        String name = path.value();
+        validatePathName(p, name);
+
+        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+        return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+      } else if (annotation instanceof Query) {
+        Query query = (Query) annotation;
+        String name = query.value();
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Query<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryName) {
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
+      } else if (annotation instanceof QueryMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@QueryMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+      } else if (annotation instanceof Header) {
+        Header header = (Header) annotation;
+        String name = header.value();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Header<>(name, converter).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Header<>(name, converter).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Header<>(name, converter);
+        }
+
+      } else if (annotation instanceof HeaderMap) {
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@HeaderMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        return new ParameterHandler.HeaderMap<>(valueConverter);
+
+      } else if (annotation instanceof Field) {
+        if (!isFormEncoded) {
+          throw parameterError(p, "@Field parameters can only be used with form encoding.");
+        }
+        Field field = (Field) annotation;
+        String name = field.value();
+        boolean encoded = field.encoded();
+
+        gotField = true;
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.Field<>(name, converter, encoded);
+        }
+
+      } else if (annotation instanceof FieldMap) {
+        if (!isFormEncoded) {
+          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+        }
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@FieldMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p,
+              "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+        }
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        Converter<?, String> valueConverter =
+            retrofit.stringConverter(valueType, annotations);
+
+        gotField = true;
+        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+      } else if (annotation instanceof Part) {
+        if (!isMultipart) {
+          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+        }
+        Part part = (Part) annotation;
+        gotPart = true;
+
+        String partName = part.value();
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (partName.isEmpty()) {
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = rawParameterType.getComponentType();
+            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(p,
+                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+            }
+            return ParameterHandler.RawPart.INSTANCE.array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            return ParameterHandler.RawPart.INSTANCE;
+          } else {
+            throw parameterError(p,
+                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+          }
+        } else {
+          Headers headers =
+              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                  "Content-Transfer-Encoding", part.encoding());
+
+          if (Iterable.class.isAssignableFrom(rawParameterType)) {
+            if (!(type instanceof ParameterizedType)) {
+              throw parameterError(p, rawParameterType.getSimpleName()
+                  + " must include generic type (e.g., "
+                  + rawParameterType.getSimpleName()
+                  + "<String>)");
+            }
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                  + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).iterable();
+          } else if (rawParameterType.isArray()) {
+            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                  + "include a part name in the annotation.");
+            }
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter).array();
+          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                + "include a part name in the annotation.");
+          } else {
+            Converter<?, RequestBody> converter =
+                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+            return new ParameterHandler.Part<>(headers, converter);
+          }
+        }
+
+      } else if (annotation instanceof PartMap) {
+        if (!isMultipart) {
+          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+        }
+        gotPart = true;
+        Class<?> rawParameterType = Utils.getRawType(type);
+        if (!Map.class.isAssignableFrom(rawParameterType)) {
+          throw parameterError(p, "@PartMap parameter type must be Map.");
+        }
+        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+        if (!(mapType instanceof ParameterizedType)) {
+          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        }
+        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+        if (String.class != keyType) {
+          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+        }
+
+        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+              + "Use @Part List<Part> or a different value type instead.");
+        }
+
+        Converter<?, RequestBody> valueConverter =
+            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+        PartMap partMap = (PartMap) annotation;
+        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+      } else if (annotation instanceof Body) {
+        if (isFormEncoded || isMultipart) {
+          throw parameterError(p,
+              "@Body parameters cannot be used with form or multi-part encoding.");
+        }
+        if (gotBody) {
+          throw parameterError(p, "Multiple @Body method annotations found.");
+        }
+
+        Converter<?, RequestBody> converter;
+        try {
+          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+        } catch (RuntimeException e) {
+          // Wide exception range because factories are user code.
+          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+        }
+        gotBody = true;
+        return new ParameterHandler.Body<>(converter);
+      }
+
+      return null; // Not a Retrofit annotation.
+    }
+
+    private void validatePathName(int p, String name) {
+      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+            PARAM_URL_REGEX.pattern(), name);
+      }
+      // Verify URL replacement name is actually present in the URL path.
+      if (!relativeUrlParamNames.contains(name)) {
+        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+      }
+    }
+
+    private Converter<ResponseBody, T> createResponseConverter() {
+      Annotation[] annotations = method.getAnnotations();
+      try {
+        return retrofit.responseBodyConverter(responseType, annotations);
+      } catch (RuntimeException e) { // Wide exception range because factories are user code.
+        throw methodError(e, "Unable to create converter for %s", responseType);
+      }
+    }
+
+    private RuntimeException methodError(String message, Object... args) {
+      return methodError(null, message, args);
+    }
+
+    private RuntimeException methodError(Throwable cause, String message, Object... args) {
+      message = String.format(message, args);
+      return new IllegalArgumentException(message
+          + "\n    for method "
+          + method.getDeclaringClass().getSimpleName()
+          + "."
+          + method.getName(), cause);
+    }
+
+    private RuntimeException parameterError(
+        Throwable cause, int p, String message, Object... args) {
+      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
+    }
+
+    private RuntimeException parameterError(int p, String message, Object... args) {
+      return methodError(message + " (parameter #" + (p + 1) + ")", args);
+    }
+  }
+
+  /**
+   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+   * in the URI, it will only show up once in the set.
+   */
+  static Set<String> parsePathParameters(String path) {
+    Matcher m = PARAM_URL_REGEX.matcher(path);
+    Set<String> patterns = new LinkedHashSet<>();
+    while (m.find()) {
+      patterns.add(m.group(1));
+    }
+    return patterns;
+  }
+
+  static Class<?> boxIfPrimitive(Class<?> type) {
+    if (boolean.class == type) return Boolean.class;
+    if (byte.class == type) return Byte.class;
+    if (char.class == type) return Character.class;
+    if (double.class == type) return Double.class;
+    if (float.class == type) return Float.class;
+    if (int.class == type) return Integer.class;
+    if (long.class == type) return Long.class;
+    if (short.class == type) return Short.class;
+    return type;
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/Utils.java b/retrofit-custom/src/main/java/retrofit2/Utils.java
new file mode 100644
index 000000000..cae93701e
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/Utils.java
@@ -0,0 +1,496 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.GenericDeclaration;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import java.util.NoSuchElementException;
+import okhttp3.ResponseBody;
+import okio.Buffer;
+
+final class Utils {
+  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+
+  private Utils() {
+    // No instances.
+  }
+
+  static Class<?> getRawType(Type type) {
+    if (type == null) throw new NullPointerException("type == null");
+
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+    }
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+    }
+    if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+    }
+    if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+    }
+    if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+    }
+
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+  }
+
+  /** Returns true if {@code a} and {@code b} are equal. */
+  static boolean equals(Type a, Type b) {
+    if (a == b) {
+      return true; // Also handles (a == null && b == null).
+
+    } else if (a instanceof Class) {
+      return a.equals(b); // Class already specifies equals().
+
+    } else if (a instanceof ParameterizedType) {
+      if (!(b instanceof ParameterizedType)) return false;
+      ParameterizedType pa = (ParameterizedType) a;
+      ParameterizedType pb = (ParameterizedType) b;
+      return equal(pa.getOwnerType(), pb.getOwnerType())
+          && pa.getRawType().equals(pb.getRawType())
+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+    } else if (a instanceof GenericArrayType) {
+      if (!(b instanceof GenericArrayType)) return false;
+      GenericArrayType ga = (GenericArrayType) a;
+      GenericArrayType gb = (GenericArrayType) b;
+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+    } else if (a instanceof WildcardType) {
+      if (!(b instanceof WildcardType)) return false;
+      WildcardType wa = (WildcardType) a;
+      WildcardType wb = (WildcardType) b;
+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+    } else if (a instanceof TypeVariable) {
+      if (!(b instanceof TypeVariable)) return false;
+      TypeVariable<?> va = (TypeVariable<?>) a;
+      TypeVariable<?> vb = (TypeVariable<?>) b;
+      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+          && va.getName().equals(vb.getName());
+
+    } else {
+      return false; // This isn't a type we support!
+    }
+  }
+
+  /**
+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   */
+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+    if (toResolve == rawType) return context;
+
+    // We skip searching through interfaces if unknown is an interface.
+    if (toResolve.isInterface()) {
+      Class<?>[] interfaces = rawType.getInterfaces();
+      for (int i = 0, length = interfaces.length; i < length; i++) {
+        if (interfaces[i] == toResolve) {
+          return rawType.getGenericInterfaces()[i];
+        } else if (toResolve.isAssignableFrom(interfaces[i])) {
+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+        }
+      }
+    }
+
+    // Check our supertypes.
+    if (!rawType.isInterface()) {
+      while (rawType != Object.class) {
+        Class<?> rawSupertype = rawType.getSuperclass();
+        if (rawSupertype == toResolve) {
+          return rawType.getGenericSuperclass();
+        } else if (toResolve.isAssignableFrom(rawSupertype)) {
+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+        }
+        rawType = rawSupertype;
+      }
+    }
+
+    // We can't resolve this further.
+    return toResolve;
+  }
+
+  private static int indexOf(Object[] array, Object toFind) {
+    for (int i = 0; i < array.length; i++) {
+      if (toFind.equals(array[i])) return i;
+    }
+    throw new NoSuchElementException();
+  }
+
+  private static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  static int hashCodeOrZero(Object o) {
+    return o != null ? o.hashCode() : 0;
+  }
+
+  static String typeToString(Type type) {
+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+  }
+
+  /**
+   * Returns the generic form of {@code supertype}. For example, if this is {@code
+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+   * Iterable.class}.
+   *
+   * @param supertype a superclass of, or interface implemented by, this.
+   */
+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+    return resolve(context, contextRawType,
+        getGenericSupertype(context, contextRawType, supertype));
+  }
+
+  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    // This implementation is made a little more complicated in an attempt to avoid object-creation.
+    while (true) {
+      if (toResolve instanceof TypeVariable) {
+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+        if (toResolve == typeVariable) {
+          return toResolve;
+        }
+
+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+        Class<?> original = (Class<?>) toResolve;
+        Type componentType = original.getComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof GenericArrayType) {
+        GenericArrayType original = (GenericArrayType) toResolve;
+        Type componentType = original.getGenericComponentType();
+        Type newComponentType = resolve(context, contextRawType, componentType);
+        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+            newComponentType);
+
+      } else if (toResolve instanceof ParameterizedType) {
+        ParameterizedType original = (ParameterizedType) toResolve;
+        Type ownerType = original.getOwnerType();
+        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        boolean changed = newOwnerType != ownerType;
+
+        Type[] args = original.getActualTypeArguments();
+        for (int t = 0, length = args.length; t < length; t++) {
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          if (resolvedTypeArgument != args[t]) {
+            if (!changed) {
+              args = args.clone();
+              changed = true;
+            }
+            args[t] = resolvedTypeArgument;
+          }
+        }
+
+        return changed
+            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+            : original;
+
+      } else if (toResolve instanceof WildcardType) {
+        WildcardType original = (WildcardType) toResolve;
+        Type[] originalLowerBound = original.getLowerBounds();
+        Type[] originalUpperBound = original.getUpperBounds();
+
+        if (originalLowerBound.length == 1) {
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          if (lowerBound != originalLowerBound[0]) {
+            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
+          }
+        } else if (originalUpperBound.length == 1) {
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          if (upperBound != originalUpperBound[0]) {
+            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
+          }
+        }
+        return original;
+
+      } else {
+        return toResolve;
+      }
+    }
+  }
+
+  private static Type resolveTypeVariable(
+      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+    Class<?> declaredByRaw = declaringClassOf(unknown);
+
+    // We can't reduce this further.
+    if (declaredByRaw == null) return unknown;
+
+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+    if (declaredBy instanceof ParameterizedType) {
+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    }
+
+    return unknown;
+  }
+
+  /**
+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+   * a class.
+   */
+  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
+  }
+
+  static void checkNotPrimitive(Type type) {
+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  static <T> T checkNotNull(T object, String message) {
+    if (object == null) {
+      throw new NullPointerException(message);
+    }
+    return object;
+  }
+
+  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
+  static boolean isAnnotationPresent(Annotation[] annotations,
+      Class<? extends Annotation> cls) {
+    for (Annotation annotation : annotations) {
+      if (cls.isInstance(annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static ResponseBody buffer(final ResponseBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.source().readAll(buffer);
+    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
+  }
+
+  static <T> void validateServiceInterface(Class<T> service) {
+    if (!service.isInterface()) {
+      throw new IllegalArgumentException("API declarations must be interfaces.");
+    }
+    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+    // the recommended pattern.
+    if (service.getInterfaces().length > 0) {
+      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+    }
+  }
+
+  static Type getParameterUpperBound(int index, ParameterizedType type) {
+    Type[] types = type.getActualTypeArguments();
+    if (index < 0 || index >= types.length) {
+      throw new IllegalArgumentException(
+          "Index " + index + " not in range [0," + types.length + ") for " + type);
+    }
+    Type paramType = types[index];
+    if (paramType instanceof WildcardType) {
+      return ((WildcardType) paramType).getUpperBounds()[0];
+    }
+    return paramType;
+  }
+
+  static boolean hasUnresolvableType(Type type) {
+    if (type instanceof Class<?>) {
+      return false;
+    }
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+        if (hasUnresolvableType(typeArgument)) {
+          return true;
+        }
+      }
+      return false;
+    }
+    if (type instanceof GenericArrayType) {
+      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+    }
+    if (type instanceof TypeVariable) {
+      return true;
+    }
+    if (type instanceof WildcardType) {
+      return true;
+    }
+    String className = type == null ? "null" : type.getClass().getName();
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+        + "GenericArrayType, but <" + type + "> is of type " + className);
+  }
+
+  static Type getCallResponseType(Type returnType) {
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    return getParameterUpperBound(0, (ParameterizedType) returnType);
+  }
+
+  private static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final Type ownerType;
+    private final Type rawType;
+    private final Type[] typeArguments;
+
+    ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>
+          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+        throw new IllegalArgumentException();
+      }
+
+      this.ownerType = ownerType;
+      this.rawType = rawType;
+      this.typeArguments = typeArguments.clone();
+
+      for (Type typeArgument : this.typeArguments) {
+        if (typeArgument == null) throw new NullPointerException();
+        checkNotPrimitive(typeArgument);
+      }
+    }
+
+    @Override public Type[] getActualTypeArguments() {
+      return typeArguments.clone();
+    }
+
+    @Override public Type getRawType() {
+      return rawType;
+    }
+
+    @Override public Type getOwnerType() {
+      return ownerType;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    }
+
+    @Override public int hashCode() {
+      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+      result.append(typeToString(rawType));
+      if (typeArguments.length == 0) return result.toString();
+      result.append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < typeArguments.length; i++) {
+        result.append(", ").append(typeToString(typeArguments[i]));
+      }
+      return result.append(">").toString();
+    }
+  }
+
+  private static final class GenericArrayTypeImpl implements GenericArrayType {
+    private final Type componentType;
+
+    GenericArrayTypeImpl(Type componentType) {
+      this.componentType = componentType;
+    }
+
+    @Override public Type getGenericComponentType() {
+      return componentType;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof GenericArrayType
+          && Utils.equals(this, (GenericArrayType) o);
+    }
+
+    @Override public int hashCode() {
+      return componentType.hashCode();
+    }
+
+    @Override public String toString() {
+      return typeToString(componentType) + "[]";
+    }
+  }
+
+  /**
+   * The WildcardType interface supports multiple upper bounds and multiple
+   * lower bounds. We only support what the Java 6 language needs - at most one
+   * bound. If a lower bound is set, the upper bound must be Object.class.
+   */
+  private static final class WildcardTypeImpl implements WildcardType {
+    private final Type upperBound;
+    private final Type lowerBound;
+
+    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+      if (lowerBounds.length > 1) throw new IllegalArgumentException();
+      if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+      if (lowerBounds.length == 1) {
+        if (lowerBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(lowerBounds[0]);
+        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+        this.lowerBound = lowerBounds[0];
+        this.upperBound = Object.class;
+      } else {
+        if (upperBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(upperBounds[0]);
+        this.lowerBound = null;
+        this.upperBound = upperBounds[0];
+      }
+    }
+
+    @Override public Type[] getUpperBounds() {
+      return new Type[] { upperBound };
+    }
+
+    @Override public Type[] getLowerBounds() {
+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+    }
+
+    @Override public int hashCode() {
+      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    }
+
+    @Override public String toString() {
+      if (lowerBound != null) return "? super " + typeToString(lowerBound);
+      if (upperBound == Object.class) return "?";
+      return "? extends " + typeToString(upperBound);
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
new file mode 100644
index 000000000..e6c702705
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
+ * <p>
+ * Because Gson is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class GsonConverterFactory extends Converter.Factory {
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create() {
+    return create(new Gson());
+  }
+
+  /**
+   * Create an instance using {@code gson} for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create(Gson gson) {
+    return new GsonConverterFactory(gson);
+  }
+
+  private final Gson gson;
+
+  private GsonConverterFactory(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
+    this.gson = gson;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonResponseBodyConverter<>(gson, adapter);
+  }
+
+  @Override
+  public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonRequestBodyConverter<>(gson, adapter);
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
new file mode 100644
index 000000000..2e30a4478
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.nio.charset.Charset;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.Buffer;
+import retrofit2.Converter;
+
+final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private final Gson gson;
+  private final TypeAdapter<T> adapter;
+
+  GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
+    this.adapter = adapter;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    JsonWriter jsonWriter = gson.newJsonWriter(writer);
+    adapter.write(jsonWriter, value);
+    jsonWriter.close();
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java b/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
new file mode 100644
index 000000000..bd9509a18
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import java.io.IOException;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+
+final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final Gson gson;
+  private final TypeAdapter<T> adapter;
+
+  GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+    this.gson = gson;
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    JsonReader jsonReader = gson.newJsonReader(value.charStream());
+    try {
+      return adapter.read(jsonReader);
+    } finally {
+      value.close();
+    }
+  }
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Body.java b/retrofit-custom/src/main/java/retrofit2/http/Body.java
new file mode 100644
index 000000000..98d1d8684
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Body.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2011 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Use this annotation on a service method param when you want to directly control the request body
+ * of a POST/PUT request (instead of sending in as request parameters or form-style request
+ * body). The object will be serialized using the {@link Retrofit Retrofit} instance
+ * {@link Converter Converter} and the result will be set directly as the
+ * request body.
+ * <p>
+ * Body parameters may not be {@code null}.
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Body {
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/DELETE.java b/retrofit-custom/src/main/java/retrofit2/http/DELETE.java
new file mode 100644
index 000000000..4a2b3e519
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/DELETE.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a DELETE request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface DELETE {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Field.java b/retrofit-custom/src/main/java/retrofit2/http/Field.java
new file mode 100644
index 000000000..4dbd1bf11
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Field.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Named pair for a form-encoded request.
+ * <p>
+ * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * field pair for each non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;FormUrlEncoded
+ * &#64;POST("/")
+ * Call&lt;ResponseBody&gt; example(
+ *     &#64;Field("name") String name,
+ *     &#64;Field("occupation") String occupation);
+ * </code></pre>
+ * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
+ * {@code name=Bob+Smith&occupation=President}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;FormUrlEncoded
+ * &#64;POST("/list")
+ * Call&lt;ResponseBody&gt; example(@Field("name") String... names);
+ * </code></pre>
+ * Calling with {@code foo.example("Bob Smith", "Jane Doe")} yields a request body of
+ * {@code name=Bob+Smith&name=Jane+Doe}.
+ *
+ * @see FormUrlEncoded
+ * @see FieldMap
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Field {
+  String value();
+
+  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
+  boolean encoded() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/FieldMap.java b/retrofit-custom/src/main/java/retrofit2/http/FieldMap.java
new file mode 100644
index 000000000..a7eb1ee86
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/FieldMap.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Named key/value pairs for a form-encoded request.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;FormUrlEncoded
+ * &#64;POST("/things")
+ * Call&lt;ResponseBody&gt; things(@FieldMap Map&lt;String, String&gt; fields);
+ * </code></pre>
+ * Calling with {@code foo.things(ImmutableMap.of("foo", "bar", "kit", "kat")} yields a request
+ * body of {@code foo=bar&kit=kat}.
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
+ *
+ * @see FormUrlEncoded
+ * @see Field
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface FieldMap {
+  /** Specifies whether the names and values are already URL encoded. */
+  boolean encoded() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/FormUrlEncoded.java b/retrofit-custom/src/main/java/retrofit2/http/FormUrlEncoded.java
new file mode 100644
index 000000000..cb00931d0
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/FormUrlEncoded.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes that the request body will use form URL encoding. Fields should be declared as
+ * parameters and annotated with {@link Field @Field}.
+ * <p>
+ * Requests made with this annotation will have {@code application/x-www-form-urlencoded} MIME
+ * type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to
+ * <a href="http://tools.ietf.org/html/rfc3986">RFC-3986</a>.
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface FormUrlEncoded {
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/GET.java b/retrofit-custom/src/main/java/retrofit2/http/GET.java
new file mode 100644
index 000000000..deca1820d
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/GET.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a GET request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface GET {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/HEAD.java b/retrofit-custom/src/main/java/retrofit2/http/HEAD.java
new file mode 100644
index 000000000..077787d4f
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/HEAD.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a HEAD request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface HEAD {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/HTTP.java b/retrofit-custom/src/main/java/retrofit2/http/HTTP.java
new file mode 100644
index 000000000..101eecf3b
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/HTTP.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Use a custom HTTP verb for a request.
+ * <pre><code>
+ * interface Service {
+ *   &#064;HTTP(method = "CUSTOM", path = "custom/endpoint/")
+ *   Call&lt;ResponseBody&gt; customEndpoint();
+ * }
+ * </code></pre>
+ * This annotation can also used for sending {@code DELETE} with a request body:
+ * <pre><code>
+ * interface Service {
+ *   &#064;HTTP(method = "DELETE", path = "remove/", hasBody = true)
+ *   Call&lt;ResponseBody&gt; deleteObject(@Body RequestBody object);
+ * }
+ * </code></pre>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface HTTP {
+  String method();
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String path() default "";
+  boolean hasBody() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Header.java b/retrofit-custom/src/main/java/retrofit2/http/Header.java
new file mode 100644
index 000000000..b8f7a70ea
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Header.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Replaces the header with the value of its target.
+ * <pre><code>
+ * &#64;GET("/")
+ * Call&lt;ResponseBody&gt; foo(@Header("Accept-Language") String lang);
+ * </code></pre>
+ * Header parameters may be {@code null} which will omit them from the request. Passing a
+ * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
+ * <p>
+ * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
+ * be included in the request.
+ *
+ * @see Headers
+ * @see HeaderMap
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(PARAMETER)
+public @interface Header {
+  String value();
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/HeaderMap.java b/retrofit-custom/src/main/java/retrofit2/http/HeaderMap.java
new file mode 100644
index 000000000..aa1facd39
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/HeaderMap.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.util.Map;
+
+/**
+ * Adds headers specified in the {@link Map}.
+ * <p>
+ * Values are converted to strings using {@link String#valueOf(Object)}.
+ * <p>
+ * Simple Example:
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@HeaderMap Map&lt;String, String&gt; headers);
+ *
+ * ...
+ *
+ * // The following call yields /search with headers
+ * // Accept: text/plain and Accept-Charset: utf-8
+ * foo.list(ImmutableMap.of("Accept", "text/plain", "Accept-Charset", "utf-8"));
+ * </pre>
+ *
+ * @see Header
+ * @see Headers
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface HeaderMap {
+
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Headers.java b/retrofit-custom/src/main/java/retrofit2/http/Headers.java
new file mode 100644
index 000000000..b360f3ec3
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Headers.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Adds headers literally supplied in the {@code value}.
+ * <pre><code>
+ * &#64;Headers("Cache-Control: max-age=640000")
+ * &#64;GET("/")
+ * ...
+ *
+ * &#64;Headers({
+ *   "X-Foo: Bar",
+ *   "X-Ping: Pong"
+ * })
+ * &#64;GET("/")
+ * ...
+ * </code></pre>
+ * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
+ * be included in the request.
+ *
+ * @see Header
+ * @see HeaderMap
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface Headers {
+  String[] value();
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Multipart.java b/retrofit-custom/src/main/java/retrofit2/http/Multipart.java
new file mode 100644
index 000000000..2e88926bc
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Multipart.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes that the request body is multi-part. Parts should be declared as parameters and
+ * annotated with {@link Part @Part}.
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface Multipart {
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/OPTIONS.java b/retrofit-custom/src/main/java/retrofit2/http/OPTIONS.java
new file mode 100644
index 000000000..17dc085e3
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/OPTIONS.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make an OPTIONS request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface OPTIONS {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/PATCH.java b/retrofit-custom/src/main/java/retrofit2/http/PATCH.java
new file mode 100644
index 000000000..035276982
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/PATCH.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a PATCH request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface PATCH {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/POST.java b/retrofit-custom/src/main/java/retrofit2/http/POST.java
new file mode 100644
index 000000000..34352cd34
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/POST.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a POST request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface POST {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/PUT.java b/retrofit-custom/src/main/java/retrofit2/http/PUT.java
new file mode 100644
index 000000000..0d4437f86
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/PUT.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/** Make a PUT request. */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface PUT {
+  /**
+   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+   * parameter of the method is annotated with {@link Url @Url}.
+   * <p>
+   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+   * this is resolved against a base URL to create the full endpoint URL.
+   */
+  String value() default "";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Part.java b/retrofit-custom/src/main/java/retrofit2/http/Part.java
new file mode 100644
index 000000000..f320c088f
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Part.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import retrofit2.Converter;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes a single part of a multi-part request.
+ * <p>
+ * The parameter type on which this annotation exists will be processed in one of three ways:
+ * <ul>
+ * <li>If the type is {@link okhttp3.MultipartBody.Part} the contents will be used directly. Omit
+ * the name from the annotation (i.e., {@code @Part MultipartBody.Part part}).</li>
+ * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
+ * directly with its content type. Supply the part name in the annotation (e.g.,
+ * {@code @Part("foo") RequestBody foo}).</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Converter a converter}. Supply the part name in the annotation (e.g.,
+ * {@code @Part("foo") Image photo}).</li>
+ * </ul>
+ * <p>
+ * Values may be {@code null} which will omit them from the request body.
+ * <p>
+ * <pre><code>
+ * &#64;Multipart
+ * &#64;POST("/")
+ * Call&lt;ResponseBody&gt; example(
+ *     &#64;Part("description") String description,
+ *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
+ * </code></pre>
+ * <p>
+ * Part parameters may not be {@code null}.
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Part {
+  /**
+   * The name of the part. Required for all parameter types except
+   * {@link okhttp3.MultipartBody.Part}.
+   */
+  String value() default "";
+  /** The {@code Content-Transfer-Encoding} of this part. */
+  String encoding() default "binary";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/PartMap.java b/retrofit-custom/src/main/java/retrofit2/http/PartMap.java
new file mode 100644
index 000000000..79eae2147
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/PartMap.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import retrofit2.Converter;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Denotes name and value parts of a multi-part request.
+ * <p>
+ * Values of the map on which this annotation exists will be processed in one of two ways:
+ * <ul>
+ * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
+ * directly with its content type.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Converter a converter}.</li>
+ * </ul>
+ * <p>
+ * <pre><code>
+ * &#64;Multipart
+ * &#64;POST("/upload")
+ * Call&lt;ResponseBody&gt; upload(
+ *     &#64;Part("file") RequestBody file,
+ *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
+ * </code></pre>
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
+ *
+ * @see Multipart
+ * @see Part
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface PartMap {
+  /** The {@code Content-Transfer-Encoding} of the parts. */
+  String encoding() default "binary";
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Path.java b/retrofit-custom/src/main/java/retrofit2/http/Path.java
new file mode 100644
index 000000000..4d8c6f054
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Path.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Named replacement in a URL path segment. Values are converted to string using
+ * {@link String#valueOf(Object)} and URL encoded.
+ * <p>
+ * Simple example:
+ * <pre><code>
+ * &#64;GET("/image/{id}")
+ * Call&lt;ResponseBody&gt; example(@Path("id") int id);
+ * </code></pre>
+ * Calling with {@code foo.example(1)} yields {@code /image/1}.
+ * <p>
+ * Values are URL encoded by default. Disable with {@code encoded=true}.
+ * <pre><code>
+ * &#64;GET("/user/{name}")
+ * Call&lt;ResponseBody&gt; encoded(@Path("name") String name);
+ *
+ * &#64;GET("/user/{name}")
+ * Call&lt;ResponseBody&gt; notEncoded(@Path(value="name", encoded=true) String name);
+ * </code></pre>
+ * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
+ * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
+ * <p>
+ * Path parameters may not be {@code null}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(PARAMETER)
+public @interface Path {
+  String value();
+
+  /**
+   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Query.java b/retrofit-custom/src/main/java/retrofit2/http/Query.java
new file mode 100644
index 000000000..614795009
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Query.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL.
+ * <p>
+ * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
+ * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
+ * query parameter for each non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("page") int page);
+ * </code></pre>
+ * Calling with {@code foo.friends(1)} yields {@code /friends?page=1}.
+ * <p>
+ * Example with {@code null}:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String group);
+ * </code></pre>
+ * Calling with {@code foo.friends(null)} yields {@code /friends}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String... groups);
+ * </code></pre>
+ * Calling with {@code foo.friends("coworker", "bowling")} yields
+ * {@code /friends?group=coworker&group=bowling}.
+ * <p>
+ * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
+ * to change this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query(value="group", encoded=true) String group);
+ * </code></pre>
+ * Calling with {@code foo.friends("foo+bar"))} yields {@code /friends?group=foo+bar}.
+ *
+ * @see QueryMap
+ * @see QueryName
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Query {
+  /** The query parameter name. */
+  String value();
+
+  /**
+   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/QueryMap.java b/retrofit-custom/src/main/java/retrofit2/http/QueryMap.java
new file mode 100644
index 000000000..119a59381
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/QueryMap.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter keys and values appended to the URL.
+ * <p>
+ * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.friends(ImmutableMap.of("group", "coworker", "age", "42"))} yields
+ * {@code /friends?group=coworker&age=42}.
+ * <p>
+ * Map keys and values representing parameter values are URL encoded by default. Specify
+ * {@link #encoded() encoded=true} to change this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * </code></pre>
+ * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
+ * {@code /search?group=coworker+bowling}.
+ * <p>
+ * A {@code null} value for the map, as a key, or as a value is not allowed.
+ *
+ * @see Query
+ * @see QueryName
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryMap {
+  /** Specifies whether parameter names and values are already URL encoded. */
+  boolean encoded() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/QueryName.java b/retrofit-custom/src/main/java/retrofit2/http/QueryName.java
new file mode 100644
index 000000000..5d6f0e948
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/QueryName.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL that has no value.
+ * <p>
+ * Passing a {@link java.util.List List} or array will result in a query parameter for each
+ * non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)")} yields {@code /friends?contains(Bob)}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String... filters);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)", "age(42)")} yields
+ * {@code /friends?contains(Bob)&age(42)}.
+ * <p>
+ * Parameter names are URL encoded by default. Specify {@link #encoded() encoded=true} to change
+ * this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName(encoded=true) String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("name+age"))} yields {@code /friends?name+age}.
+ *
+ * @see Query
+ * @see QueryMap
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryName {
+  /**
+   * Specifies whether the parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Streaming.java b/retrofit-custom/src/main/java/retrofit2/http/Streaming.java
new file mode 100644
index 000000000..4a87591df
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Streaming.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
+ * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface Streaming {
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/Url.java b/retrofit-custom/src/main/java/retrofit2/http/Url.java
new file mode 100644
index 000000000..31187ca3d
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/Url.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import okhttp3.HttpUrl;
+import retrofit2.Retrofit;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
+ * <pre><code>
+ * &#64;GET
+ * Call&lt;ResponseBody&gt; list(@Url String url);
+ * </code></pre>
+ * <p>
+ * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+ * the value will be resolved against a base URL to create the full endpoint URL.
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Url {
+}
diff --git a/retrofit-custom/src/main/java/retrofit2/http/package-info.java b/retrofit-custom/src/main/java/retrofit2/http/package-info.java
new file mode 100644
index 000000000..2777d51b7
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/http/package-info.java
@@ -0,0 +1,4 @@
+// Copyright 2014 Square, Inc.
+
+/** Annotations for interface methods to control the HTTP request behavior. */
+package retrofit2.http;
diff --git a/retrofit-custom/src/main/java/retrofit2/package-info.java b/retrofit-custom/src/main/java/retrofit2/package-info.java
new file mode 100644
index 000000000..44f5b357a
--- /dev/null
+++ b/retrofit-custom/src/main/java/retrofit2/package-info.java
@@ -0,0 +1,12 @@
+// Copyright 2014 Square, Inc.
+
+/**
+ * Retrofit turns your REST API into a Java interface.
+ * <pre>
+ * public interface GitHubService {
+ *   &#64;GET("/users/{user}/repos")
+ *   List&lt;Repo&gt; listRepos(@Path("user") String user);
+ * }
+ * </pre>
+ */
+package retrofit2;
diff --git a/retrofit-custom/src/test/java/retrofit2/CallAdapterTest.java b/retrofit-custom/src/test/java/retrofit2/CallAdapterTest.java
new file mode 100644
index 000000000..d1ed83480
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/CallAdapterTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static retrofit2.CallAdapter.Factory.getParameterUpperBound;
+import static retrofit2.CallAdapter.Factory.getRawType;
+
+public final class CallAdapterTest {
+  @Test public void parameterizedTypeInvalidIndex() {
+    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
+    try {
+      getParameterUpperBound(-1, listOfString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+    }
+    try {
+      getParameterUpperBound(1, listOfString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+    }
+  }
+
+  @Test public void parameterizedTypes() {
+    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
+    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
+
+    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
+    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
+    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
+
+    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+    }.getType();
+    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
+  }
+
+  @Test public void rawTypeThrowsOnNull() {
+    try {
+      getRawType(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("type == null");
+    }
+  }
+
+  @Test public void rawTypes() throws NoSuchMethodException {
+    assertThat(getRawType(String.class)).isSameAs(String.class);
+
+    Type listOfString = new TypeToken<List<String>>() {}.getType();
+    assertThat(getRawType(listOfString)).isSameAs(List.class);
+
+    Type stringArray = new TypeToken<String[]>() {}.getType();
+    assertThat(getRawType(stringArray)).isSameAs(String[].class);
+
+    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+    }.getType()).getActualTypeArguments()[0];
+    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
+
+    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
+    }.getType()).getActualTypeArguments()[0];
+    assertThat(getRawType(wildParam)).isSameAs(List.class);
+
+    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
+    assertThat(getRawType(typeVar)).isSameAs(Object.class);
+  }
+
+  @SuppressWarnings("unused") // Used reflectively.
+  static class A<T> {
+    T method() {
+      return null;
+    }
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/CallTest.java b/retrofit-custom/src/test/java/retrofit2/CallTest.java
new file mode 100644
index 000000000..fffd43c1f
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/CallTest.java
@@ -0,0 +1,981 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.Body;
+import retrofit2.http.GET;
+import retrofit2.http.POST;
+import retrofit2.http.Path;
+import retrofit2.http.Streaming;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class CallTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Call<String> getString();
+    @GET("/") Call<ResponseBody> getBody();
+    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
+    @POST("/") Call<String> postString(@Body String body);
+    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
+  }
+
+  @Test public void http200Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http200Async() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Async() throws InterruptedException, IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void transportProblemSync() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    Call<String> call = example.getString();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void transportProblemAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    Throwable failure = failureRef.get();
+    assertThat(failure).isInstanceOf(IOException.class);
+  }
+
+  @Test public void conversionProblemOutgoingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+              Retrofit retrofit) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    Call<String> call = example.postString("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> requestBodyConverter(Type type,
+              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+              Retrofit retrofit) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postString("Hi").enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void conversionProblemIncomingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.postString("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
+    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
+    OkHttpClient client = new OkHttpClient.Builder() //
+        .addInterceptor(new Interceptor() {
+          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
+            okhttp3.Response response = chain.proceed(chain.request());
+            ResponseBody body = response.body();
+            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+              @Override public long read(Buffer sink, long byteCount) throws IOException {
+                throw new IOException("cause");
+              }
+            });
+            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+            return response.newBuilder().body(body).build();
+          }
+        }).build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .client(client)
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                try {
+                  return value.string();
+                } catch (IOException e) {
+                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                  throw new RuntimeException("wrapper", e);
+                }
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("cause");
+    }
+  }
+
+  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postString("Hi").enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void http204SkipsConverter() throws IOException {
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return converter;
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.code()).isEqualTo(204);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void http205SkipsConverter() throws IOException {
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            return converter;
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.code()).isEqualTo(205);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void executeCallOnce() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+    server.enqueue(new MockResponse());
+    Call<String> call = example.getString();
+    call.execute();
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed.");
+    }
+  }
+
+  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("1234"));
+
+    Response<ResponseBody> response = example.getBody().execute();
+    assertThat(response.body().string()).isEqualTo("1234");
+  }
+
+  @Test public void responseBodyBuffers() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call<ResponseBody> buffered = example.getBody();
+    // When buffering we will detect all socket problems before returning the Response.
+    try {
+      buffered.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
+  }
+
+  @Test public void responseBodyStreams() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+    Response<ResponseBody> response = example.getStreamingBody().execute();
+
+    ResponseBody streamedBody = response.body();
+    // When streaming we only detect socket problems as the ResponseBody is read.
+    try {
+      streamedBody.string();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
+  }
+
+  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+    ResponseBody rawBody = response.raw().body();
+    assertThat(rawBody.contentLength()).isEqualTo(2);
+    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
+    try {
+      rawBody.source();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("");
+    ResponseBody rawBody = response.raw().body();
+    assertThat(rawBody.contentLength()).isEqualTo(0);
+    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
+  }
+
+  @Test public void reportsExecutedSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    assertThat(call.isExecuted()).isFalse();
+
+    call.execute();
+    assertThat(call.isExecuted()).isTrue();
+  }
+
+  @Test public void reportsExecutedAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    assertThat(call.isExecuted()).isFalse();
+
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {}
+      @Override public void onFailure(Call<String> call, Throwable t) {}
+    });
+    assertThat(call.isExecuted()).isTrue();
+  }
+
+  @Test public void cancelBeforeExecute() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+    Call<String> call = service.getString();
+
+    call.cancel();
+    assertThat(call.isCanceled()).isTrue();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Canceled");
+    }
+  }
+
+  @Test public void cancelBeforeEnqueue() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+    Call<String> call = service.getString();
+
+    call.cancel();
+    assertThat(call.isCanceled()).isTrue();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+    assertThat(failureRef.get()).hasMessage("Canceled");
+  }
+
+  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hello"));
+
+    Call<String> call = service.getString();
+    assertThat(call.execute().body()).isEqualTo("Hi");
+
+    Call<String> cloned = call.clone();
+    assertThat(cloned.execute().body()).isEqualTo("Hello");
+  }
+
+  @Test public void cancelRequest() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    Call<String> call = service.getString();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    call.cancel();
+    assertThat(call.isCanceled()).isTrue();
+
+    assertTrue(latch.await(10, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+  }
+
+  @Test public void cancelOkHttpRequest() throws InterruptedException {
+    OkHttpClient client = new OkHttpClient();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .client(client)
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    Call<String> call = service.getString();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // Cancel the underlying HTTP Call. Should be reflected accurately back in the Retrofit Call.
+    client.dispatcher().cancelAll();
+    assertThat(call.isCanceled()).isTrue();
+
+    assertTrue(latch.await(10, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+  }
+
+  @Test public void requestBeforeExecuteCreates() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    call.execute();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.execute();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
+      throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+  }
+
+  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        return "Hello";
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    call.request();
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+
+  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
+      InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse());
+
+    final AtomicInteger writeCount = new AtomicInteger();
+    Object a = new Object() {
+      @Override public String toString() {
+        writeCount.incrementAndGet();
+        throw new RuntimeException("Broken!");
+      }
+    };
+    Call<String> call = service.postRequestBody(a);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+        assertThat(writeCount.get()).isEqualTo(1);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(10, SECONDS));
+
+    try {
+      call.request();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Broken!");
+    }
+    assertThat(writeCount.get()).isEqualTo(1);
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit-custom/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
new file mode 100644
index 000000000..6f1480d23
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.Executor;
+import okhttp3.Request;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@SuppressWarnings("unchecked")
+public final class ExecutorCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final Retrofit retrofit = new Retrofit.Builder()
+      .baseUrl("http://localhost:1")
+      .build();
+  private final Callback<String> callback = mock(Callback.class);
+  private final Executor callbackExecutor = spy(new Executor() {
+    @Override public void execute(Runnable runnable) {
+      runnable.run();
+    }
+  });
+  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
+
+  @Test public void rawTypeThrows() {
+    try {
+      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+  }
+
+  @Test public void responseType() {
+    Type classType = new TypeToken<Call<String>>() {}.getType();
+    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+  }
+
+  @Test public void adaptedCallExecute() throws IOException {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    final Response<String> response = Response.success("Hi");
+    Call<String> call = adapter.adapt(new EmptyCall() {
+      @Override public Response<String> execute() throws IOException {
+        return response;
+      }
+    });
+    assertThat(call.execute()).isSameAs(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    final Response<String> response = Response.success("Hi");
+    EmptyCall originalCall = new EmptyCall() {
+      @Override public void enqueue(Callback<String> callback) {
+        callback.onResponse(this, response);
+      }
+    };
+    Call<String> call = adapter.adapt(originalCall);
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verify(callback).onResponse(call, response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    final Throwable throwable = new IOException();
+    EmptyCall originalCall = new EmptyCall() {
+      @Override public void enqueue(Callback<String> callback) {
+        callback.onFailure(this, throwable);
+      }
+    };
+    Call<String> call = adapter.adapt(originalCall);
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(callbackExecutor);
+    verify(callback).onFailure(call, throwable);
+    verifyNoMoreInteractions(callback);
+  }
+
+  @Test public void adaptedCallCloneDeepCopy() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    Call<String> delegate = mock(Call.class);
+    Call<String> call = adapter.adapt(delegate);
+    Call<String> cloned = call.clone();
+    assertThat(cloned).isNotSameAs(call);
+    verify(delegate).clone();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  @Test public void adaptedCallCancel() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String, Call<String>> adapter =
+        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+    Call<String> delegate = mock(Call.class);
+    Call<String> call = adapter.adapt(delegate);
+    call.cancel();
+    verify(delegate).cancel();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  static class EmptyCall implements Call<String> {
+    @Override public void enqueue(Callback<String> callback) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isExecuted() {
+      return false;
+    }
+
+    @Override public Response<String> execute() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public void cancel() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isCanceled() {
+      return false;
+    }
+
+    @Override public Call<String> clone() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Request request() {
+      throw new UnsupportedOperationException();
+    }
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit-custom/src/test/java/retrofit2/Java8DefaultMethodsTest.java
new file mode 100644
index 000000000..8333969c6
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+// TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
+public final class Java8DefaultMethodsTest {
+  //@Rule public final MockWebServer server = new MockWebServer();
+  //
+  //interface Example {
+  //  @GET("/") Call<String> user(@Query("name") String name);
+  //
+  //  default Call<String> user() {
+  //    return user("hey");
+  //  }
+  //}
+  //
+  //@Test public void test() throws IOException {
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //  server.enqueue(new MockResponse().setBody("Hi"));
+  //
+  //  Retrofit retrofit = new Retrofit.Builder()
+  //      .baseUrl(server.url("/"))
+  //      .addConverterFactory(new ToStringConverterFactory())
+  //      .build();
+  //  Example example = retrofit.create(Example.class);
+  //
+  //  Response<String> response = example.user().execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //  Response<String> response = example.user("hi").execute();
+  //  assertThat(response.body()).isEqualTo("Hi");
+  //}
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit-custom/src/test/java/retrofit2/RequestBuilderAndroidTest.java
new file mode 100644
index 000000000..63fa57b6c
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/RequestBuilderAndroidTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import android.net.Uri;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static retrofit2.RequestBuilderTest.buildRequest;
+
+@RunWith(RobolectricTestRunner.class)
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderAndroidTest {
+  @Test public void getWithAndroidUriUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Uri url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithAndroidUriUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Uri url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit-custom/src/test/java/retrofit2/RequestBuilderTest.java
new file mode 100644
index 000000000..a2ef1376b
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/RequestBuilderTest.java
@@ -0,0 +1,2624 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.math.BigInteger;
+import java.net.URI;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okio.Buffer;
+import org.junit.Ignore;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.Body;
+import retrofit2.http.DELETE;
+import retrofit2.http.Field;
+import retrofit2.http.FieldMap;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.HEAD;
+import retrofit2.http.HTTP;
+import retrofit2.http.Header;
+import retrofit2.http.HeaderMap;
+import retrofit2.http.Headers;
+import retrofit2.http.Multipart;
+import retrofit2.http.OPTIONS;
+import retrofit2.http.PATCH;
+import retrofit2.http.POST;
+import retrofit2.http.PUT;
+import retrofit2.http.Part;
+import retrofit2.http.PartMap;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
+import retrofit2.http.Url;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderTest {
+  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+
+  @Test public void customMethodNoBody() {
+    class Example {
+      @HTTP(method = "CUSTOM1", path = "/foo")
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("CUSTOM1");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+    assertThat(request.body()).isNull();
+  }
+
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodWithBody() {
+    class Example {
+      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("CUSTOM2");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
+    class Example {
+      @Multipart //
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Only one encoding annotation is allowed.\n    for method Example.method");
+    }
+  }
+
+  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+    class Example {
+      @FormUrlEncoded //
+      @Multipart //
+      @POST("/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Only one encoding annotation is allowed.\n    for method Example.method");
+    }
+  }
+
+  @Test public void invalidPathParam() throws Exception {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@Path("hey!") String thing) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+              + " Found: hey! (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void pathParamNotAllowedInQuery() throws Exception {
+    class Example {
+      @GET("/foo?bar={bar}") //
+      Call<ResponseBody> method(@Path("bar") String thing) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "URL query string \"bar={bar}\" must not have replace block."
+              + " For dynamic query parameters use @Query.\n    for method Example.method");
+    }
+  }
+
+  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@Body @Query("nope") String o) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @interface NonNull {}
+
+  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "yep");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
+  }
+
+  @Test public void twoMethodsFail() {
+    class Example {
+      @PATCH("/foo") //
+      @POST("/foo") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+        assertThat(e.getMessage())
+            .isIn("Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method",
+                  "Only one HTTP method is allowed. Found: POST and PATCH.\n    for method Example.method");
+    }
+  }
+
+  @Test public void lackingMethod() {
+    class Example {
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
+    }
+  }
+
+  @Test public void implicitMultipartForbidden() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@Part("a") int a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void implicitMultipartWithPartMapForbidden() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@PartMap Map<String, String> params) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void multipartFailsOnNonBodyMethod() {
+    class Example {
+      @Multipart //
+      @GET("/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+    }
+  }
+
+  @Test public void multipartFailsWithNoParts() {
+    class Example {
+      @Multipart //
+      @POST("/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Multipart method must contain at least one @Part.\n    for method Example.method");
+    }
+  }
+
+  @Test public void implicitFormEncodingByFieldForbidden() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@Field("a") int a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void implicitFormEncodingByFieldMapForbidden() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void formEncodingFailsOnNonBodyMethod() {
+    class Example {
+      @FormUrlEncoded //
+      @GET("/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+    }
+  }
+
+  @Test public void formEncodingFailsWithNoParts() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+    }
+  }
+
+  @Test public void headersFailWhenEmptyOnMethod() {
+    class Example {
+      @GET("/") //
+      @Headers({}) //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
+    }
+  }
+
+  @Test public void headersFailWhenMalformed() {
+    class Example {
+      @GET("/") //
+      @Headers("Malformed") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
+    }
+  }
+
+  @Test public void pathParamNonPathParamAndTypedBytes() {
+    class Example {
+      @PUT("/{a}") //
+      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
+    }
+  }
+
+  @Test public void parameterWithoutAnnotation() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(String a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void nonBodyHttpMethodWithSingleEntity() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@Body String o) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
+    }
+  }
+
+  @Test public void queryMapMustBeAMap() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap List<String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void queryMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+  }
+
+  @Test public void queryMapRejectsNull() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map was null.");
+    }
+  }
+
+  @Test public void queryMapRejectsNullKeys() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<>();
+    queryParams.put("ping", "pong");
+    queryParams.put(null, "kat");
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map contained null key.");
+    }
+  }
+
+  @Test public void queryMapRejectsNullValues() {
+    class Example {
+      @GET("/") //
+      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+        return null;
+      }
+    }
+
+    Map<String, String> queryParams = new LinkedHashMap<>();
+    queryParams.put("ping", "pong");
+    queryParams.put("kit", null);
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+    }
+  }
+
+  @Test public void getWithHeaderMap() {
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+        return null;
+      }
+    }
+
+    Map<String, Object> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", "utf-8");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isEqualTo(2);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+  }
+
+  @Test public void headerMapMustBeAMap() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap List<String> headers) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void headerMapSupportsSubclasses() {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @GET("/search")
+      Call<ResponseBody> method(@HeaderMap Foo headers) {
+        return null;
+      }
+    }
+
+    Foo headers = new Foo();
+    headers.put("Accept", "text/plain");
+
+    Request request = buildRequest(Example.class, headers);
+    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+    assertThat(request.headers().size()).isEqualTo(1);
+    assertThat(request.header("Accept")).isEqualTo("text/plain");
+  }
+
+  @Test public void headerMapRejectsNull() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (Map<String, String>) null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map was null.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullKeys() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put(null, "utf-8");
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null key.");
+    }
+  }
+
+  @Test public void headerMapRejectsNullValues() {
+    class Example {
+      @GET("/")
+      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+        return null;
+      }
+    }
+
+    Map<String, String> headers = new LinkedHashMap<>();
+    headers.put("Accept", "text/plain");
+    headers.put("Accept-Charset", null);
+
+    try {
+      buildRequest(Example.class, headers);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+    }
+  }
+
+  @Test public void twoBodies() {
+    class Example {
+      @PUT("/") //
+      Call<ResponseBody> method(@Body String o1, @Body String o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+    }
+  }
+
+  @Test public void bodyInNonBodyRequest() {
+    class Example {
+      @Multipart //
+      @PUT("/") //
+      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+    }
+  }
+
+  @Test public void get() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void delete() {
+    class Example {
+      @DELETE("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("DELETE");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertNull(request.body());
+  }
+
+  @Test public void head() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Call<Void> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("HEAD");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headWithoutVoidThrows() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "HEAD method must use Void as response type.\n    for method Example.method");
+    }
+  }
+
+  @Test public void post() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void put() {
+    class Example {
+      @PUT("/foo/bar/") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void patch() {
+    class Example {
+      @PATCH("/foo/bar/") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PATCH");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void options() {
+    class Example {
+      @OPTIONS("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("OPTIONS");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "po ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUnusedAndInvalidNamedPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/{kit,kat}/") //
+      Call<ResponseBody> method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "po%20ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathSegments() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/pong/more");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "baz/\r\npong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void pathParamRequired() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+    }
+  }
+
+  @Test public void getWithQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void queryParamOptionalOmitsQuery() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new Object[] { null });
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+  }
+
+  @Test public void queryParamOptional() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
+          @Query("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+  }
+
+  @Test public void getWithQueryUrlAndParam() {
+    class Example {
+      @GET("/foo/bar/?hi=mom") //
+      Call<ResponseBody> method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQuery() {
+    class Example {
+      @GET("/foo/bar/?hi=mom") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
+          @Query("riff") String riff) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", "kat", "raff");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "kat", "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithPathAndQueryQuestionMarkParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong?", "kat?");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryAmpersandParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong&", "kat&");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryHashParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong#", "kat#");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query("key") List<Object> keys) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
+    Request request = buildRequest(Example.class, values);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query("key") Object[] keys) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three", "1" };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamPrimitiveArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Query("key") int[] keys) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3, 1 };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3&key=1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryNameParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName(encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?p%20o%20n%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void queryNameParamOptionalOmitsQuery() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new Object[] { null });
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+  }
+
+  @Test public void getWithQueryNameParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName List<Object> keys) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
+    Request request = buildRequest(Example.class, values);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName Object[] keys) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three", "1" };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParamPrimitiveArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName int[] keys) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3, 1 };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&3&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("kit", "kat");
+    params.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("kit", "k%20t");
+    params.put("pi%20ng", "p%20g");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getAbsoluteUrl() {
+    class Example {
+      @GET("http://example2.com/foo/bar/")
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithStringUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url String url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithJavaUriUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url URI url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithStringUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url String url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithJavaUriUrlAbsolute() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url URI url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithUrlAbsoluteSameHost() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url String url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithHttpUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url HttpUrl url) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithNullUrl() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url HttpUrl url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, (HttpUrl) null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("@Url parameter is null.");
+    }
+  }
+
+  @Test public void getWithNonStringUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+              + " (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void getUrlAndUrlParamThrows() {
+    class Example {
+      @GET("foo/bar")
+      Call<ResponseBody> method(@Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithoutUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithUrlThenPathThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithPathThenUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryThenUrlThrows() {
+    class Example {
+      @GET("foo/bar")
+      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "hey", "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithUrlThenQuery() {
+    class Example {
+      @GET
+      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+  }
+
+  @Test public void postWithUrl() {
+    class Example {
+      @POST
+      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void normalPostWithPathParam() {
+    class Example {
+      @POST("/foo/bar/{ping}/") //
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void emptyBody() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "");
+  }
+
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodEmptyBody() {
+    class Example {
+      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("CUSTOM");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "");
+  }
+
+  @Test public void bodyRequired() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+    }
+  }
+
+  @Test public void bodyWithPathParams() {
+    class Example {
+      @POST("/foo/bar/{ping}/{kit}/") //
+      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body, "kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void simpleMultipart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartArray() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") String[] ping) {
+        return null;
+      }
+    }
+
+    Request request =
+        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong1\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"")
+        .contains("\r\npong2\r\n--");
+  }
+
+  @Test public void multipartRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part RequestBody part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartIterableRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<RequestBody> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayRequiresName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part RequestBody[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartOkHttpPartForbidsName() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartOkHttpPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, part);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpIterablePart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"foo\"\r\n")
+        .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpArrayPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+    Request request =
+        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"foo\"\r\n")
+        .contains("\r\nbar\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartOkHttpPartWithFilename() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part MultipartBody.Part part) {
+        return null;
+      }
+    }
+
+    MultipartBody.Part part =
+        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+    Request request = buildRequest(Example.class, part);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartIterable() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<String> ping) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong1\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"")
+        .contains("\r\npong2\r\n--");
+  }
+
+  @Test public void multipartIterableOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartArrayOkHttpPart() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
+          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 7-bit")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMap() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put("kit", RequestBody.create(null, "kat"));
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMapWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put("kit", RequestBody.create(null, "kat"));
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMapRejectsNonStringKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsOkHttpPartValues() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+              + "    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsNull() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map was null.");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsNullKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put(null, RequestBody.create(null, "kat"));
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map contained null key.");
+    }
+  }
+
+  @Test public void multipartPartMapRejectsNullValues() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+        return null;
+      }
+    }
+
+    Map<String, RequestBody> params = new LinkedHashMap<>();
+    params.put("ping", RequestBody.create(null, "pong"));
+    params.put("kit", null);
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+    }
+  }
+
+  @Test public void multipartPartMapMustBeMap() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap List<Object> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.emptyList());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@PartMap Foo parts) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8())
+        .contains("name=\"hello\"")
+        .contains("\r\n\r\nworld\r\n--");
+  }
+
+  @Test public void multipartNullRemovesPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong", null);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("Content-Disposition: form-data;")
+        .contains("name=\"ping\"")
+        .contains("\r\npong\r\n--");
+  }
+
+  @Test public void multipartPartOptional() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+    }
+  }
+
+  @Test public void simpleFormEncoded() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", "pong");
+    assertBody(request.body(), "foo=bar&ping=pong");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParam() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "ba%20r");
+    assertBody(request.body(), "na%20me=ba%20r");
+  }
+
+  @Test public void formEncodedFieldOptional() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
+          @Field("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertBody(request.body(), "foo=bar&kit=kat");
+  }
+
+  @Test public void formEncodedFieldList() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedFieldArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three" };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  }
+
+  @Test public void formEncodedFieldPrimitiveArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3 };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParamMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("k%20it", "k%20at");
+    fieldMap.put("pin%20g", "po%20ng");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+  }
+
+  @Test public void formEncodedFieldMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "kit=kat&ping=pong");
+  }
+
+  @Test public void fieldMapRejectsNull() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map was null.");
+    }
+  }
+
+  @Test public void fieldMapRejectsNullKeys() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put(null, "pong");
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map contained null key.");
+    }
+  }
+
+  @Test public void fieldMapRejectsNullValues() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+    }
+  }
+
+  @Test public void fieldMapMustBeAMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap List<String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void fieldMapSupportsSubclasses() throws IOException {
+    class Foo extends HashMap<String, String> {
+    }
+
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<ResponseBody> method(@FieldMap Foo a) {
+        return null;
+      }
+    }
+
+    Foo foo = new Foo();
+    foo.put("hello", "world");
+
+    Request request = buildRequest(Example.class, foo);
+    Buffer buffer = new Buffer();
+    request.body().writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+  }
+
+  @Test public void simpleHeaders() {
+    class Example {
+      @GET("/foo/bar/")
+      @Headers({
+          "ping: pong",
+          "kit: kat"
+      })
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    okhttp3.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamToString() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new BigInteger("1234"));
+    assertThat(request.method()).isEqualTo("GET");
+    okhttp3.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(1);
+    assertThat(headers.get("kit")).isEqualTo("1234");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      @Headers("ping: pong") //
+      Call<ResponseBody> method(@Header("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "kat");
+    assertThat(request.method()).isEqualTo("GET");
+    okhttp3.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Header("foo") List<String> kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+    assertThat(request.method()).isEqualTo("GET");
+    okhttp3.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.values("foo")).containsExactly("bar", "baz");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@Header("foo") String[] kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
+    assertThat(request.method()).isEqualTo("GET");
+    okhttp3.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.values("foo")).containsExactly("bar", "baz");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void contentTypeAnnotationHeaderOverrides() {
+    class Example {
+      @POST("/") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
+  @Test public void malformedContentTypeHeaderThrows() {
+    class Example {
+      @POST("/") //
+      @Headers("Content-Type: hello, world!") //
+      Call<ResponseBody> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    try {
+      buildRequest(Example.class, body);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Malformed content type: hello, world!\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
+    class Example {
+      @DELETE("/") //
+      @Headers("Content-Type: text/not-plain") //
+      Call<ResponseBody> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+  }
+
+  @Test public void contentTypeParameterHeaderOverrides() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    Request request = buildRequest(Example.class, "text/not-plain", body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
+  @Test public void malformedContentTypeParameterThrows() {
+    class Example {
+      @POST("/") //
+      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    try {
+      buildRequest(Example.class, "hello, world!", body);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Malformed content type: hello, world!");
+    }
+  }
+
+  @Test public void malformedAnnotationRelativeUrlThrows() {
+    class Example {
+      @GET("ftp://example.org")
+      Call<ResponseBody> get() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void malformedParameterRelativeUrlThrows() {
+    class Example {
+      @GET
+      Call<ResponseBody> get(@Url String relativeUrl) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, "ftp://example.org");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+    }
+  }
+
+  @Test public void multipartPartsShouldBeInOrder() throws IOException {
+    class Example {
+      @Multipart
+      @POST("/foo")
+      Call<ResponseBody> get(@Part("first") String data, @Part("second") String dataTwo, @Part("third") String dataThree) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "firstParam", "secondParam", "thirdParam");
+    MultipartBody body = (MultipartBody) request.body();
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String readBody = buffer.readUtf8();
+
+    assertThat(readBody.indexOf("firstParam")).isLessThan(readBody.indexOf("secondParam"));
+    assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
+  }
+
+  private static void assertBody(RequestBody body, String expected) {
+    assertThat(body).isNotNull();
+    Buffer buffer = new Buffer();
+    try {
+      body.writeTo(buffer);
+      assertThat(buffer.readUtf8()).isEqualTo(expected);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  static <T> Request buildRequest(Class<T> cls, Object... args) {
+    final AtomicReference<Request> requestRef = new AtomicReference<>();
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        requestRef.set(request);
+        throw new UnsupportedOperationException("Not implemented");
+      }
+    };
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(new ToStringConverterFactory())
+        .callFactory(callFactory)
+        .build();
+
+    Method method = TestingUtils.onlyMethod(cls);
+    //noinspection unchecked
+    ServiceMethod<T, Call<T>> serviceMethod =
+        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
+    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+    Call<T> call = serviceMethod.callAdapter.adapt(okHttpCall);
+    try {
+      call.execute();
+      throw new AssertionError();
+    } catch (UnsupportedOperationException ignored) {
+      return requestRef.get();
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/ResponseTest.java b/retrofit-custom/src/test/java/retrofit2/ResponseTest.java
new file mode 100644
index 000000000..3d059b8ad
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/ResponseTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResponseTest {
+  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
+      .code(200)
+      .message("OK")
+      .protocol(Protocol.HTTP_1_1)
+      .request(new okhttp3.Request.Builder().url("http://localhost").build())
+      .build();
+  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
+      .code(400)
+      .message("Broken!")
+      .protocol(Protocol.HTTP_1_1)
+      .request(new okhttp3.Request.Builder().url("http://localhost").build())
+      .build();
+
+  @Test public void success() {
+    Object body = new Object();
+    Response<Object> response = Response.success(body);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successNullAllowed() {
+    Response<Object> response = Response.success(null);
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isNull();
+  }
+
+  @Test public void successWithHeaders() {
+    Object body = new Object();
+    Headers headers = Headers.of("foo", "bar");
+    Response<Object> response = Response.success(body, headers);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successWithNullHeadersThrows() {
+    try {
+      Response.success("", (okhttp3.Headers) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("headers == null");
+    }
+  }
+
+  @Test public void successWithRawResponse() {
+    Object body = new Object();
+    Response<Object> response = Response.success(body, successResponse);
+    assertThat(response.raw()).isSameAs(successResponse);
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(body);
+    assertThat(response.errorBody()).isNull();
+  }
+
+  @Test public void successWithNullRawResponseThrows() {
+    try {
+      Response.success("", (okhttp3.Response) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("rawResponse == null");
+    }
+  }
+
+  @Test public void successWithErrorRawResponseThrows() {
+    try {
+      Response.success("", errorResponse);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("rawResponse must be successful response");
+    }
+  }
+
+  @Test public void error() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    Response<?> response = Response.error(400, errorBody);
+    assertThat(response.raw()).isNotNull();
+    assertThat(response.code()).isEqualTo(400);
+    assertThat(response.message()).isNull();
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.body()).isNull();
+    assertThat(response.errorBody()).isSameAs(errorBody);
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Response.error(400, null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("body == null");
+    }
+  }
+
+  @Test public void errorWithSuccessCodeThrows() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    try {
+      Response.error(200, errorBody);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("code < 400: 200");
+    }
+  }
+
+  @Test public void errorWithRawResponse() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    Response<?> response = Response.error(errorBody, errorResponse);
+    assertThat(response.raw()).isSameAs(errorResponse);
+    assertThat(response.code()).isEqualTo(400);
+    assertThat(response.message()).isEqualTo("Broken!");
+    assertThat(response.headers().size()).isZero();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.body()).isNull();
+    assertThat(response.errorBody()).isSameAs(errorBody);
+  }
+
+  @Test public void nullErrorWithRawResponseThrows() {
+    try {
+      Response.error(null, errorResponse);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("body == null");
+    }
+  }
+
+  @Test public void errorWithNullRawResponseThrows() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    try {
+      Response.error(errorBody, null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("rawResponse == null");
+    }
+  }
+
+  @Test public void errorWithSuccessRawResponseThrows() {
+    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+    try {
+      Response.error(errorBody, successResponse);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("rawResponse should not be successful response");
+    }
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/RetrofitTest.java b/retrofit-custom/src/test/java/retrofit2/RetrofitTest.java
new file mode 100644
index 000000000..92dfb74ca
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/RetrofitTest.java
@@ -0,0 +1,1335 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.DelegatingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingCallAdapterFactory;
+import retrofit2.helpers.NonMatchingConverterFactory;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.Body;
+import retrofit2.http.GET;
+import retrofit2.http.POST;
+import retrofit2.http.Query;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class RetrofitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface CallMethod {
+    @GET("/") Call<String> disallowed();
+    @POST("/") Call<ResponseBody> disallowed(@Body String body);
+
+    @GET("/") Call<retrofit2.Response> badType1();
+    @GET("/") Call<okhttp3.Response> badType2();
+
+    @GET("/") Call<ResponseBody> getResponseBody();
+    @GET("/") Call<Void> getVoid();
+    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
+    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
+    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
+  }
+  interface FutureMethod {
+    @GET("/") Future<String> method();
+  }
+  interface Extending extends CallMethod {
+  }
+  interface StringService {
+    @GET("/") String get();
+  }
+  interface UnresolvableResponseType {
+    @GET("/") <T> Call<T> typeVariable();
+    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
+    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
+    @GET("/") Call<?> wildcard();
+    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
+  }
+  interface UnresolvableParameterType {
+    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
+    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
+    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
+    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
+    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
+  }
+  interface VoidService {
+    @GET("/") void nope();
+  }
+  interface Annotated {
+    @GET("/") @Foo Call<String> method();
+    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
+    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
+
+    @Retention(RUNTIME)
+    @interface Foo {}
+  }
+  interface MutableParameters {
+    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
+  }
+
+  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+  @Test public void objectMethodsStillWork() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    assertThat(example.hashCode()).isNotZero();
+    assertThat(example.equals(this)).isFalse();
+    assertThat(example.toString()).isNotEmpty();
+  }
+
+  @Test public void interfaceWithExtendIsNotSupported() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    try {
+      retrofit.create(Extending.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
+    }
+  }
+
+  @Test public void cloneSharesStatefulInstances() {
+    CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
+    Converter.Factory converter = mock(Converter.Factory.class);
+    HttpUrl baseUrl = server.url("/");
+    Executor executor = mock(Executor.class);
+    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+
+    Retrofit one = new Retrofit.Builder()
+        .addCallAdapterFactory(callAdapter)
+        .addConverterFactory(converter)
+        .baseUrl(baseUrl)
+        .callbackExecutor(executor)
+        .callFactory(callFactory)
+        .build();
+
+    CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
+    Converter.Factory converter2 = mock(Converter.Factory.class);
+    Retrofit two = one.newBuilder()
+        .addCallAdapterFactory(callAdapter2)
+        .addConverterFactory(converter2)
+        .build();
+    assertEquals(one.callAdapterFactories().size() + 1, two.callAdapterFactories().size());
+    assertThat(two.callAdapterFactories()).contains(callAdapter, callAdapter2);
+    assertEquals(one.converterFactories().size() + 1, two.converterFactories().size());
+    assertThat(two.converterFactories()).contains(converter, converter2);
+    assertSame(baseUrl, two.baseUrl());
+    assertSame(executor, two.callbackExecutor());
+    assertSame(callFactory, two.callFactory());
+  }
+
+  @Test public void responseTypeCannotBeRetrofitResponse() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    try {
+      service.badType1();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+              + "    for method CallMethod.badType1");
+    }
+  }
+
+  @Test public void responseTypeCannotBeOkHttpResponse() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    try {
+      service.badType2();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+              + "    for method CallMethod.badType2");
+    }
+  }
+
+  @Test public void voidReturnTypeNotAllowed() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    VoidService service = retrofit.create(VoidService.class);
+
+    try {
+      service.nope();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
+  @Test public void validateEagerlyDisabledByDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+
+    // Should not throw exception about incorrect configuration of the VoidService
+    retrofit.create(VoidService.class);
+  }
+
+  @Test public void validateEagerlyDisabledByUser() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .validateEagerly(false)
+        .build();
+
+    // Should not throw exception about incorrect configuration of the VoidService
+    retrofit.create(VoidService.class);
+  }
+
+  @Test public void validateEagerlyFailsAtCreation() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .validateEagerly(true)
+        .build();
+
+    try {
+      retrofit.create(VoidService.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
+  @Test public void callCallAdapterAddedByDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    assertThat(example.getResponseBody()).isNotNull();
+  }
+
+  @Test public void callCallCustomAdapter() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
+    final AtomicBoolean adapterCalled = new AtomicBoolean();
+    class MyCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
+        factoryCalled.set(true);
+        if (getRawType(returnType) != Call.class) {
+          return null;
+        }
+        return new CallAdapter<Object, Call<?>>() {
+          @Override public Type responseType() {
+            return getParameterUpperBound(0, (ParameterizedType) returnType);
+          }
+
+          @Override public Call<Object> adapt(Call<Object> call) {
+            adapterCalled.set(true);
+            return call;
+          }
+        };
+      }
+    }
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    assertThat(example.getResponseBody()).isNotNull();
+    assertThat(factoryCalled.get()).isTrue();
+    assertThat(adapterCalled.get()).isTrue();
+  }
+
+  @Test public void customCallAdapter() {
+    class GreetingCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
+        if (getRawType(returnType) != String.class) {
+          return null;
+        }
+        return new CallAdapter<Object, String>() {
+          @Override public Type responseType() {
+            return String.class;
+          }
+
+          @Override public String adapt(Call<Object> call) {
+            return "Hi!";
+          }
+        };
+      }
+    }
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new GreetingCallAdapterFactory())
+        .build();
+    StringService example = retrofit.create(StringService.class);
+    assertThat(example.get()).isEqualTo("Hi!");
+  }
+
+  @Test public void methodAnnotationsPassedToCallAdapter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyCallAdapterFactory extends CallAdapter.Factory {
+      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+        return null;
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void customCallAdapterMissingThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    FutureMethod example = retrofit.create(FutureMethod.class);
+    try {
+      example.method();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+          + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
+    }
+  }
+
+  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<?, RequestBody> requestBodyConverter(Type type,
+          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        parameterAnnotationsRef.set(parameterAnnotations);
+        methodAnnotationsRef.set(methodAnnotations);
+        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+            methodAnnotations, retrofit);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.bodyParameter(null); // Trigger internal setup.
+
+    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
+  }
+
+  @Test public void parameterAnnotationsPassedToStringConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        annotationsRef.set(annotations);
+
+        return new Converter<Object, String>() {
+          @Override public String convert(Object value) throws IOException {
+            return String.valueOf(value);
+          }
+        };
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.queryParameter(null); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void stringConverterCalledForString() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
+    class MyConverterFactory extends Converter.Factory {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        factoryCalled.set(true);
+        return null;
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.queryString(null);
+    assertThat(call).isNotNull();
+    assertThat(factoryCalled.get()).isTrue();
+  }
+
+  @Test public void stringConverterReturningNullResultsInDefault() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
+    class MyConverterFactory extends Converter.Factory {
+      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+          Retrofit retrofit) {
+        factoryCalled.set(true);
+        return null;
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.queryObject(null);
+    assertThat(call).isNotNull();
+    assertThat(factoryCalled.get()).isTrue();
+  }
+
+  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    try {
+      example.disallowed("Hi!");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
+    }
+  }
+
+  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    try {
+      example.disallowed();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters");
+    }
+  }
+
+  @Test public void requestBodyOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<ResponseBody> response = example.getResponseBody().execute();
+    assertThat(response.body().string()).isEqualTo("Hi");
+  }
+
+  @Test public void voidOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Void> response = example.getVoid().execute();
+    assertThat(response.body()).isNull();
+  }
+
+  @Test public void voidResponsesArePooled() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    example.getVoid().execute();
+    example.getVoid().execute();
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    Response<ResponseBody> response = example.postRequestBody(body).execute();
+    assertThat(response.body().string()).isEqualTo("Hi");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+  }
+
+  @Test public void unresolvableResponseTypeThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
+
+    try {
+      example.typeVariable();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
+    }
+    try {
+      example.typeVariableUpperBound();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
+    }
+    try {
+      example.crazy();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
+          + "    for method UnresolvableResponseType.crazy");
+    }
+    try {
+      example.wildcard();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
+    }
+    try {
+      example.wildcardUpperBound();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
+          + "    for method UnresolvableResponseType.wildcardUpperBound");
+    }
+  }
+
+  @Test public void unresolvableParameterTypeThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
+
+    try {
+      example.typeVariable(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
+    }
+    try {
+      example.typeVariableUpperBound(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
+    }
+    try {
+      example.crazy(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
+          + "    for method UnresolvableParameterType.crazy");
+    }
+    try {
+      example.wildcard(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
+    }
+    try {
+      example.wildcardUpperBound(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
+          + "    for method UnresolvableParameterType.wildcardUpperBound");
+    }
+  }
+
+  @Test public void baseUrlRequired() {
+    try {
+      new Retrofit.Builder().build();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Base URL required.");
+    }
+  }
+
+  @Test public void baseUrlNullThrows() {
+    try {
+      new Retrofit.Builder().baseUrl((String) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+    try {
+      new Retrofit.Builder().baseUrl((HttpUrl) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+  }
+
+  @Test public void baseUrlInvalidThrows() {
+    try {
+      new Retrofit.Builder().baseUrl("ftp://foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    }
+  }
+
+  @Test public void baseUrlNoTrailingSlashThrows() {
+    try {
+      new Retrofit.Builder().baseUrl("http://example.com/api");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+    }
+    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+    try {
+      new Retrofit.Builder().baseUrl(parsed);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+    }
+  }
+
+  @Test public void baseUrlStringPropagated() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    HttpUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+  }
+
+  @Test public void baseHttpUrlPropagated() {
+    HttpUrl url = HttpUrl.parse("http://example.com/");
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(url)
+        .build();
+    assertThat(retrofit.baseUrl()).isSameAs(url);
+  }
+
+  @Test public void clientNullThrows() {
+    try {
+      new Retrofit.Builder().client(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("client == null");
+    }
+  }
+
+  @Test public void callFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
+    assertThat(retrofit.callFactory()).isNotNull();
+  }
+
+  @Test public void callFactoryPropagated() {
+    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(callFactory)
+        .build();
+    assertThat(retrofit.callFactory()).isSameAs(callFactory);
+  }
+
+  @Test public void callFactoryClientPropagated() {
+    OkHttpClient client = new OkHttpClient();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .client(client)
+        .build();
+    assertThat(retrofit.callFactory()).isSameAs(client);
+  }
+
+  @Test public void callFactoryUsed() throws IOException {
+    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        return new OkHttpClient().newCall(request);
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callFactory(callFactory)
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    CallMethod service = retrofit.create(CallMethod.class);
+    service.getResponseBody().execute();
+    verify(callFactory).newCall(any(Request.class));
+    verifyNoMoreInteractions(callFactory);
+  }
+
+  @Test public void callFactoryReturningNullThrows() throws IOException {
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        return null;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(callFactory)
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+    try {
+      call.execute();
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("Call.Factory returned null.");
+    }
+  }
+
+  @Test public void callFactoryThrowingPropagates() {
+    final RuntimeException cause = new RuntimeException("Broken!");
+    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+      @Override public okhttp3.Call newCall(Request request) {
+        throw cause;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(callFactory)
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+    try {
+      call.execute();
+      fail();
+    } catch (Exception e) {
+      assertThat(e).isSameAs(cause);
+    }
+  }
+
+  @Test public void converterNullThrows() {
+    try {
+      new Retrofit.Builder().addConverterFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("factory == null");
+    }
+  }
+
+  @Test public void converterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    List<Converter.Factory> converterFactories = retrofit.converterFactories();
+    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+  }
+
+  @Test public void requestConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] parameterAnnotations = new Annotation[0];
+    Annotation[] methodAnnotations = new Annotation[1];
+
+    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+        methodAnnotations, retrofit);
+
+    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+        parameterAnnotations, methodAnnotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void requestConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory)
+        .build();
+
+    try {
+      retrofit.requestBodyConverter(type, annotations, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void requestConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate RequestBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
+  }
+
+  @Test public void responseConverterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
+
+    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).responseBodyConverter(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void responseConverterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory)
+        .build();
+
+    try {
+      retrofit.responseBodyConverter(type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void responseConverterFactorySkippedNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(nonMatchingFactory1)
+        .addConverterFactory(nonMatchingFactory2)
+        .build();
+
+    try {
+      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate ResponseBody converter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+    }
+
+    assertThat(nonMatchingFactory1.called).isFalse();
+    assertThat(nonMatchingFactory2.called).isTrue();
+  }
+
+  @Test public void stringConverterFactoryQueried() {
+    Type type = Object.class;
+    Annotation[] annotations = new Annotation[0];
+
+    Converter<?, String> expectedAdapter = mock(Converter.class);
+    Converter.Factory factory = mock(Converter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
+
+    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).stringConverter(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void converterFactoryPropagated() {
+    Converter.Factory factory = mock(Converter.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+    assertThat(retrofit.converterFactories()).contains(factory);
+  }
+
+  @Test public void callAdapterFactoryNullThrows() {
+    try {
+      new Retrofit.Builder().addCallAdapterFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("factory == null");
+    }
+  }
+
+  @Test public void callAdapterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
+  }
+
+  @Test public void callAdapterFactoryPropagated() {
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+    assertThat(retrofit.callAdapterFactories()).contains(factory);
+  }
+
+  @Test public void callAdapterFactoryQueried() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+
+    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegate() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .build();
+
+    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+  }
+
+  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
+    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+      @Override
+      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory1)
+        .addCallAdapterFactory(factory2)
+        .addCallAdapterFactory(factory3)
+        .build();
+
+    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+    assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+    verify(factory1).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory1);
+    verify(factory2).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory2);
+    verify(factory3).get(type, annotations, retrofit);
+    verifyNoMoreInteractions(factory3);
+  }
+
+  @Test public void callAdapterFactoryNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(nonMatchingFactory)
+        .build();
+
+    try {
+      retrofit.callAdapter(type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
+    }
+
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
+    Type type = String.class;
+    Annotation[] annotations = new Annotation[0];
+
+    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(delegatingFactory1)
+        .addCallAdapterFactory(delegatingFactory2)
+        .addCallAdapterFactory(nonMatchingFactory)
+        .build();
+
+    try {
+      retrofit.callAdapter(type, annotations);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(""
+          + "Could not locate call adapter for class java.lang.String.\n"
+          + "  Skipped:\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+          + "  Tried:\n"
+          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.DefaultCallAdapterFactory");
+    }
+
+    assertThat(delegatingFactory1.called).isTrue();
+    assertThat(delegatingFactory2.called).isTrue();
+    assertThat(nonMatchingFactory.called).isTrue();
+  }
+
+  @Test public void callbackExecutorNullThrows() {
+    try {
+      new Retrofit.Builder().callbackExecutor(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("executor == null");
+    }
+  }
+
+  @Test public void callbackExecutorPropagatesDefaultJvm() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isNull();
+  }
+
+  @Test public void callbackExecutorPropagatesDefaultAndroid() {
+    final Executor executor = Executors.newSingleThreadExecutor();
+    Platform platform = new Platform() {
+      @Override Executor defaultCallbackExecutor() {
+        return executor;
+      }
+    };
+    Retrofit retrofit = new Retrofit.Builder(platform)
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
+  @Test public void callbackExecutorPropagated() {
+    Executor executor = mock(Executor.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callbackExecutor(executor)
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
+  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
+    Executor executor = spy(new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+    verify(executor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(executor);
+  }
+
+  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
+    Executor executor = spy(new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+    verify(executor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(executor);
+  }
+
+  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
+  @Test public void argumentCapture() throws Exception {
+    AtomicInteger i = new AtomicInteger();
+
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
+
+    i.set(100);
+    Call<String> call1 = mutableParameters.method(i);
+
+    i.set(101);
+    Response<String> response1 = call1.execute();
+
+    i.set(102);
+    assertEquals("a", response1.body());
+    assertEquals("/?i=101", server.takeRequest().getPath());
+
+    i.set(200);
+    Call<String> call2 = call1.clone();
+
+    i.set(201);
+    Response<String> response2 = call2.execute();
+
+    i.set(202);
+    assertEquals("b", response2.body());
+
+    assertEquals("/?i=201", server.takeRequest().getPath());
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit-custom/src/test/java/retrofit2/ServiceMethodTest.java
new file mode 100644
index 000000000..c9c48f31e
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/ServiceMethodTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.util.Set;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ServiceMethodTest {
+  @Test public void pathParameterParsing() throws Exception {
+    expectParams("/");
+    expectParams("/foo");
+    expectParams("/foo/bar");
+    expectParams("/foo/bar/{}");
+    expectParams("/foo/bar/{taco}", "taco");
+    expectParams("/foo/bar/{t}", "t");
+    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+    expectParams("/foo/bar/{}/{taco}", "taco");
+    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("/foo/bar/{taco-shell}", "taco-shell");
+    expectParams("/foo/bar/{taco_shell}", "taco_shell");
+    expectParams("/foo/bar/{sha256}", "sha256");
+    expectParams("/foo/bar/{TACO}", "TACO");
+    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+  }
+
+  private static void expectParams(String path, String... expected) {
+    Set<String> calculated = ServiceMethod.parsePathParameters(path);
+    assertThat(calculated).containsExactly(expected);
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/TestingUtils.java b/retrofit-custom/src/test/java/retrofit2/TestingUtils.java
new file mode 100644
index 000000000..3847509ea
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/TestingUtils.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+
+public final class TestingUtils {
+  public static Method onlyMethod(Class c) {
+    Method[] declaredMethods = c.getDeclaredMethods();
+    if (declaredMethods.length == 1) {
+      return declaredMethods[0];
+    }
+    throw new IllegalArgumentException("More than one method declared.");
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java b/retrofit-custom/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
new file mode 100644
index 000000000..5f584ec85
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.converter.gson;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.Body;
+import retrofit2.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GsonConverterFactoryTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
+    @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @Override public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.peek() != JsonToken.END_OBJECT) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .setLenient()
+        .create();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GsonConverterFactory.create(gson))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void serializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{}"));
+
+    service.anImplementation(new AnImplementation(null)).execute();
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void deserializeUsesConfiguration() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
+
+    Response<AnImplementation> response =
+        service.anImplementation(new AnImplementation("value")).execute();
+    assertThat(response.body().getName()).isNull();
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit-custom/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
new file mode 100644
index 000000000..6ce48efe2
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+
+public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return retrofit.nextCallAdapter(this, returnType, annotations);
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit-custom/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
new file mode 100644
index 000000000..3f44ddff8
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit2.CallAdapter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
+  public boolean called;
+
+  @Override
+  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit-custom/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
new file mode 100644
index 000000000..343839944
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public final class NonMatchingConverterFactory extends Converter.Factory {
+  public boolean called;
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+
+  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    called = true;
+    return null;
+  }
+}
diff --git a/retrofit-custom/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit-custom/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
new file mode 100644
index 000000000..0a70e3ddb
--- /dev/null
+++ b/retrofit-custom/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.helpers;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+
+public class ToStringConverterFactory extends Converter.Factory {
+  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+
+  @Override
+  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+      Retrofit retrofit) {
+    if (String.class.equals(type)) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
+        }
+      };
+    }
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+    if (String.class.equals(type)) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
+          return RequestBody.create(MEDIA_TYPE, value);
+        }
+      };
+    }
+    return null;
+  }
+}
