diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
index 91f444b22..eeedbf9eb 100644
--- a/.buildscript/settings.xml
+++ b/.buildscript/settings.xml
@@ -1,9 +1,9 @@
 <settings>
-  <servers>
-    <server>
-      <id>sonatype-nexus-snapshots</id>
-      <username>${env.CI_DEPLOY_USERNAME}</username>
-      <password>${env.CI_DEPLOY_PASSWORD}</password>
-    </server>
-  </servers>
+    <servers>
+        <server>
+            <id>sonatype-nexus-snapshots</id>
+            <username>${env.CI_DEPLOY_USERNAME}</username>
+            <password>${env.CI_DEPLOY_PASSWORD}</password>
+        </server>
+    </servers>
 </settings>
diff --git a/checkstyle.xml b/checkstyle.xml
index a729c26a7..acc86fd56 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,5 +1,4 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
+<?xml version="1.0"?><!DOCTYPE module PUBLIC
     "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
     "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
 
@@ -7,17 +6,17 @@
     <module name="NewlineAtEndOfFile">
         <property name="lineSeparator" value="lf" />
     </module>
-    <module name="FileLength"/>
-    <module name="FileTabCharacter"/>
+    <module name="FileLength" />
+    <module name="FileTabCharacter" />
 
     <!-- Trailing spaces -->
     <module name="RegexpSingleline">
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
+        <property name="format" value="\s+$" />
+        <property name="message" value="Line has trailing spaces." />
     </module>
 
     <module name="TreeWalker">
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+        <property name="cacheFile" value="${checkstyle.cache.file}" />
 
         <!-- Checks for Javadoc comments.                     -->
         <!-- See http://checkstyle.sf.net/config_javadoc.html -->
@@ -29,31 +28,31 @@
 
         <!-- Checks for Naming Conventions.                  -->
         <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <module name="ConstantName"/>
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
+        <module name="ConstantName" />
+        <module name="LocalFinalVariableName" />
+        <module name="LocalVariableName" />
+        <module name="MemberName" />
+        <module name="MethodName" />
         <!--<module name="PackageName"/>-->
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
+        <module name="ParameterName" />
+        <module name="StaticVariableName" />
+        <module name="TypeName" />
 
 
         <!-- Checks for imports                              -->
         <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
+        <module name="AvoidStarImport" />
+        <module name="IllegalImport" /> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport" />
         <module name="UnusedImports">
-          <property name="processJavadoc" value="true"/>
+            <property name="processJavadoc" value="true" />
         </module>
 
 
         <!-- Checks for Size Violations.                    -->
         <!-- See http://checkstyle.sf.net/config_sizes.html -->
         <module name="LineLength">
-            <property name="max" value="100"/>
+            <property name="max" value="100" />
         </module>
         <!--<module name="MethodLength"/>-->
         <!--module name="ParameterNumber"/-->
@@ -61,68 +60,68 @@
 
         <!-- Checks for whitespace                               -->
         <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
+        <module name="GenericWhitespace" />
+        <module name="EmptyForIteratorPad" />
+        <module name="MethodParamPad" />
         <module name="NoWhitespaceAfter">
-          <property name="tokens" value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS"/>
+            <property name="tokens" value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS" />
         </module>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround"/>
+        <module name="NoWhitespaceBefore" />
+        <module name="OperatorWrap" />
+        <module name="ParenPad" />
+        <module name="TypecastParenPad" />
+        <module name="WhitespaceAfter" />
+        <module name="WhitespaceAround" />
 
 
         <!-- Modifier Checks                                    -->
         <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <module name="ModifierOrder"/>
-        <module name="RedundantModifier"/>
+        <module name="ModifierOrder" />
+        <module name="RedundantModifier" />
 
 
         <!-- Checks for blocks. You know, those {}'s         -->
         <!-- See http://checkstyle.sf.net/config_blocks.html -->
         <!--module name="AvoidNestedBlocks"/-->
         <!--module name="EmptyBlock"/-->
-        <module name="LeftCurly"/>
+        <module name="LeftCurly" />
         <!--module name="NeedBraces"/-->
-        <module name="RightCurly"/>
+        <module name="RightCurly" />
 
 
         <!-- Checks for common coding problems               -->
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
-        <module name="CovariantEquals"/>
-        <module name="EmptyStatement"/>
-        <module name="EqualsAvoidNull"/>
-        <module name="EqualsHashCode"/>
+        <module name="CovariantEquals" />
+        <module name="EmptyStatement" />
+        <module name="EqualsAvoidNull" />
+        <module name="EqualsHashCode" />
         <!--module name="HiddenField"/-->
-        <module name="IllegalInstantiation"/>
+        <module name="IllegalInstantiation" />
         <!--module name="InnerAssignment"/-->
         <!--module name="MagicNumber"/-->
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
+        <module name="MissingSwitchDefault" />
+        <module name="RedundantThrows" />
+        <module name="SimplifyBooleanExpression" />
+        <module name="SimplifyBooleanReturn" />
 
         <!-- Checks for class design                         -->
         <!-- See http://checkstyle.sf.net/config_design.html -->
         <!--module name="DesignForExtension"/-->
         <!--module name="FinalClass"/-->
         <!--module name="HideUtilityClassConstructor"/-->
-        <module name="InterfaceIsType"/>
+        <module name="InterfaceIsType" />
         <!--module name="VisibilityModifier"/-->
 
 
         <!-- Miscellaneous other checks.                   -->
         <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <module name="ArrayTypeStyle"/>
+        <module name="ArrayTypeStyle" />
         <!--module name="FinalParameters"/-->
         <!--module name="TodoComment"/-->
-        <module name="UpperEll"/>
+        <module name="UpperEll" />
         <module name="Indentation">
-          <property name="basicOffset" value="2"/>
+            <property name="basicOffset" value="2" />
         </module>
     </module>
 </module>
diff --git a/pom.xml b/pom.xml
index b99efb76b..a55d377cb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,5 +1,4 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
+<?xml version="1.0" encoding="UTF-8"?><!--
  Copyright (C) 2012 Square, Inc.
 
   Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,256 +13,258 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
+    <parent>
+        <groupId>org.sonatype.oss</groupId>
+        <artifactId>oss-parent</artifactId>
+        <version>7</version>
+    </parent>
 
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>parent</artifactId>
-  <version>2.0.3-SNAPSHOT</version>
-  <packaging>pom</packaging>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.3-SNAPSHOT</version>
+    <packaging>pom</packaging>
 
-  <name>Retrofit (Parent)</name>
-  <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
-  <url>http://github.com/square/retrofit/</url>
+    <name>Retrofit (Parent)</name>
+    <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
+    <url>http://github.com/square/retrofit/</url>
 
-  <modules>
-    <module>retrofit</module>
-    <module>retrofit-adapters</module>
-    <module>retrofit-converters</module>
-    <module>retrofit-mock</module>
-    <module>samples</module>
-  </modules>
+    <modules>
+        <module>retrofit</module>
+        <module>retrofit-adapters</module>
+        <module>retrofit-converters</module>
+        <module>retrofit-mock</module>
+        <module>samples</module>
+    </modules>
 
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
-    <!-- Compilation -->
-    <java.version>1.7</java.version>
+        <!-- Compilation -->
+        <java.version>1.7</java.version>
 
-    <!-- Dependencies -->
-    <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.2.0</okhttp.version>
-    <animal.sniffer.version>1.14</animal.sniffer.version>
+        <!-- Dependencies -->
+        <android.version>4.1.1.4</android.version>
+        <okhttp.version>3.2.0</okhttp.version>
+        <animal.sniffer.version>1.14</animal.sniffer.version>
 
-    <!-- Adapter Dependencies -->
-    <rxjava.version>1.1.1</rxjava.version>
+        <!-- Adapter Dependencies -->
+        <rxjava.version>1.1.1</rxjava.version>
 
-    <!-- Converter Dependencies -->
-    <gson.version>2.6.1</gson.version>
-    <protobuf.version>2.6.1</protobuf.version>
-    <jackson.version>2.7.2</jackson.version>
-    <wire.version>2.1.1</wire.version>
-    <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.1.0</moshi.version>
+        <!-- Converter Dependencies -->
+        <gson.version>2.6.1</gson.version>
+        <protobuf.version>2.6.1</protobuf.version>
+        <jackson.version>2.7.2</jackson.version>
+        <wire.version>2.1.1</wire.version>
+        <simplexml.version>2.7.1</simplexml.version>
+        <moshi.version>1.1.0</moshi.version>
 
-    <!-- Sample Dependencies -->
-    <jsoup.version>1.7.3</jsoup.version>
+        <!-- Sample Dependencies -->
+        <jsoup.version>1.7.3</jsoup.version>
 
-    <!-- Test Dependencies -->
-    <junit.version>4.12</junit.version>
-    <assertj.version>1.7.0</assertj.version>
-    <mockito.version>1.9.5</mockito.version>
-    <guava.version>19.0</guava.version>
-    <robolectric.version>3.0</robolectric.version>
-  </properties>
+        <!-- Test Dependencies -->
+        <junit.version>4.12</junit.version>
+        <assertj.version>1.7.0</assertj.version>
+        <mockito.version>1.9.5</mockito.version>
+        <guava.version>19.0</guava.version>
+        <robolectric.version>3.0</robolectric.version>
+    </properties>
 
-  <scm>
-    <url>http://github.com/square/retrofit</url>
-    <connection>scm:git:git://github.com/square/retrofit.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
+    <scm>
+        <url>http://github.com/square/retrofit</url>
+        <connection>scm:git:git://github.com/square/retrofit.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
+        <tag>HEAD</tag>
+    </scm>
 
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>http://github.com/square/retrofit/issues</url>
-  </issueManagement>
+    <issueManagement>
+        <system>GitHub Issues</system>
+        <url>http://github.com/square/retrofit/issues</url>
+    </issueManagement>
 
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
+    <licenses>
+        <license>
+            <name>Apache 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+        </license>
+    </licenses>
 
-  <organization>
-    <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
-  </organization>
+    <organization>
+        <name>Square, Inc.</name>
+        <url>http://squareup.com</url>
+    </organization>
 
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-annotations</artifactId>
-        <version>${animal.sniffer.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp3</groupId>
-        <artifactId>okhttp</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.reactivex</groupId>
-        <artifactId>rxjava</artifactId>
-        <version>${rxjava.version}</version>
-      </dependency>
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>com.google.android</groupId>
+                <artifactId>android</artifactId>
+                <version>${android.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-annotations</artifactId>
+                <version>${animal.sniffer.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.okhttp3</groupId>
+                <artifactId>okhttp</artifactId>
+                <version>${okhttp.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.code.gson</groupId>
+                <artifactId>gson</artifactId>
+                <version>${gson.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>io.reactivex</groupId>
+                <artifactId>rxjava</artifactId>
+                <version>${rxjava.version}</version>
+            </dependency>
 
-      <dependency>
-        <groupId>com.google.protobuf</groupId>
-        <artifactId>protobuf-java</artifactId>
-        <version>${protobuf.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.fasterxml.jackson.core</groupId>
-        <artifactId>jackson-databind</artifactId>
-        <version>${jackson.version}</version>
-     </dependency>
-      <dependency>
-        <groupId>com.squareup.wire</groupId>
-        <artifactId>wire-runtime</artifactId>
-        <version>${wire.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.simpleframework</groupId>
-        <artifactId>simple-xml</artifactId>
-        <version>${simplexml.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.moshi</groupId>
-        <artifactId>moshi</artifactId>
-        <version>${moshi.version}</version>
-      </dependency>
+            <dependency>
+                <groupId>com.google.protobuf</groupId>
+                <artifactId>protobuf-java</artifactId>
+                <version>${protobuf.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.fasterxml.jackson.core</groupId>
+                <artifactId>jackson-databind</artifactId>
+                <version>${jackson.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.wire</groupId>
+                <artifactId>wire-runtime</artifactId>
+                <version>${wire.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.simpleframework</groupId>
+                <artifactId>simple-xml</artifactId>
+                <version>${simplexml.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.moshi</groupId>
+                <artifactId>moshi</artifactId>
+                <version>${moshi.version}</version>
+            </dependency>
 
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.assertj</groupId>
-        <artifactId>assertj-core</artifactId>
-        <version>${assertj.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.mockito</groupId>
-        <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp3</groupId>
-        <artifactId>mockwebserver</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.robolectric</groupId>
-        <artifactId>robolectric</artifactId>
-        <version>${robolectric.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
+            <dependency>
+                <groupId>junit</groupId>
+                <artifactId>junit</artifactId>
+                <version>${junit.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.assertj</groupId>
+                <artifactId>assertj-core</artifactId>
+                <version>${assertj.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.mockito</groupId>
+                <artifactId>mockito-core</artifactId>
+                <version>${mockito.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+                <version>${guava.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.okhttp3</groupId>
+                <artifactId>mockwebserver</artifactId>
+                <version>${okhttp.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.robolectric</groupId>
+                <artifactId>robolectric</artifactId>
+                <version>${robolectric.version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
 
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
-          <configuration>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
+    <build>
+        <pluginManagement>
+            <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-compiler-plugin</artifactId>
+                    <version>3.0</version>
+                    <configuration>
+                        <source>${java.version}</source>
+                        <target>${java.version}</target>
+                    </configuration>
+                </plugin>
+            </plugins>
+        </pluginManagement>
 
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5</version>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-release-plugin</artifactId>
+                <version>2.5</version>
+                <configuration>
+                    <autoVersionSubmodules>true</autoVersionSubmodules>
+                </configuration>
+            </plugin>
 
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.15</version>
-        <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>verify</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-checkstyle-plugin</artifactId>
+                <version>2.15</version>
+                <configuration>
+                    <failsOnError>true</failsOnError>
+                    <configLocation>checkstyle.xml</configLocation>
+                    <consoleOutput>true</consoleOutput>
+                </configuration>
+                <executions>
+                    <execution>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>checkstyle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
 
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.3</version>
-        <executions>
-          <execution>
-            <id>attach-javadocs</id>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <version>2.10.3</version>
+                <executions>
+                    <execution>
+                        <id>attach-javadocs</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
 
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <executions>
-          <execution>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.1</version>
-          </signature>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-maven-plugin</artifactId>
+                <version>${animal.sniffer.version}</version>
+                <executions>
+                    <execution>
+                        <phase>test</phase>
+                        <goals>
+                            <goal>check</goal>
+                        </goals>
+                    </execution>
+                </executions>
+                <configuration>
+                    <signature>
+                        <groupId>org.codehaus.mojo.signature</groupId>
+                        <artifactId>java16</artifactId>
+                        <version>1.1</version>
+                    </signature>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index a6c744536..8a98a9dca 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -1,43 +1,45 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-guava</artifactId>
-  <name>Adapter: Guava</name>
+    <artifactId>adapter-guava</artifactId>
+    <name>Adapter: Guava</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index df40799c5..2aa089d01 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -17,10 +17,12 @@
 
 import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -29,7 +31,7 @@
 
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which creates Guava futures.
- * <p>
+ * <p/>
  * Adding this class to {@link Retrofit} allows you to return {@link ListenableFuture} from service
  * methods.
  * <pre><code>
@@ -49,103 +51,113 @@
  * </ul>
  */
 public final class GuavaCallAdapterFactory extends CallAdapter.Factory {
-  public static GuavaCallAdapterFactory create() {
-    return new GuavaCallAdapterFactory();
-  }
-
-  private GuavaCallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != ListenableFuture.class) {
-      return null;
-    }
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("ListenableFuture return type must be parameterized"
-          + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    public static GuavaCallAdapterFactory create() {
+        return new GuavaCallAdapterFactory();
     }
-    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    if (getRawType(innerType) != Response.class) {
-      // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+    private GuavaCallAdapterFactory() {
     }
 
-    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
-    if (!(innerType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Response must be parameterized"
-          + " as Response<Foo> or Response<? extends Foo>");
-    }
-    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != ListenableFuture.class) {
+            return null;
+        }
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalStateException("ListenableFuture return type must be parameterized"
+                    + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+        }
+        Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-  private static class BodyCallAdapter implements CallAdapter<ListenableFuture<?>> {
-    private final Type responseType;
+        if (getRawType(innerType) != Response.class) {
+            // Generic type is not Response<T>. Use it for body-only adapter.
+            return new BodyCallAdapter(innerType);
+        }
 
-    BodyCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+        if (!(innerType instanceof ParameterizedType)) {
+            throw new IllegalStateException("Response must be parameterized"
+                    + " as Response<Foo> or Response<? extends Foo>");
+        }
+        Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+        return new ResponseCallAdapter(responseType);
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static class BodyCallAdapter implements CallAdapter<ListenableFuture<?>> {
+        private final Type responseType;
 
-    @Override public <R> ListenableFuture<R> adapt(final Call<R> call) {
-      return new AbstractFuture<R>() {
-        {
-          call.enqueue(new Callback<R>() {
-            @Override public void onResponse(Call<R> call, Response<R> response) {
-              if (response.isSuccessful()) {
-                set(response.body());
-              } else {
-                setException(new HttpException(response));
-              }
-            }
-
-            @Override public void onFailure(Call<R> call, Throwable t) {
-              setException(t);
-            }
-          });
+        BodyCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
 
-        @Override protected void interruptTask() {
-          call.cancel();
+        @Override
+        public Type responseType() {
+            return responseType;
         }
-      };
-    }
-  }
-
-  private static class ResponseCallAdapter implements CallAdapter<ListenableFuture<?>> {
-    private final Type responseType;
 
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        @Override
+        public <R> ListenableFuture<R> adapt(final Call<R> call) {
+            return new AbstractFuture<R>() {
+                {
+                    call.enqueue(new Callback<R>() {
+                        @Override
+                        public void onResponse(Call<R> call, Response<R> response) {
+                            if (response.isSuccessful()) {
+                                set(response.body());
+                            } else {
+                                setException(new HttpException(response));
+                            }
+                        }
+
+                        @Override
+                        public void onFailure(Call<R> call, Throwable t) {
+                            setException(t);
+                        }
+                    });
+                }
+
+                @Override
+                protected void interruptTask() {
+                    call.cancel();
+                }
+            };
+        }
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static class ResponseCallAdapter implements CallAdapter<ListenableFuture<?>> {
+        private final Type responseType;
+
+        ResponseCallAdapter(Type responseType) {
+            this.responseType = responseType;
+        }
 
-    @Override public <R> ListenableFuture<Response<R>> adapt(final Call<R> call) {
-      return new AbstractFuture<Response<R>>() {
-        {
-          call.enqueue(new Callback<R>() {
-            @Override public void onResponse(Call<R> call, Response<R> response) {
-              set(response);
-            }
-
-            @Override public void onFailure(Call<R> call, Throwable t) {
-              setException(t);
-            }
-          });
+        @Override
+        public Type responseType() {
+            return responseType;
         }
 
-        @Override protected void interruptTask() {
-          call.cancel();
+        @Override
+        public <R> ListenableFuture<Response<R>> adapt(final Call<R> call) {
+            return new AbstractFuture<Response<R>>() {
+                {
+                    call.enqueue(new Callback<R>() {
+                        @Override
+                        public void onResponse(Call<R> call, Response<R> response) {
+                            set(response);
+                        }
+
+                        @Override
+                        public void onFailure(Call<R> call, Throwable t) {
+                            setException(t);
+                        }
+                    });
+                }
+
+                @Override
+                protected void interruptTask() {
+                    call.cancel();
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
index f18a81955..1685b3d60 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -17,33 +17,39 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
+/**
+ * Exception for an unexpected, non-2xx HTTP response.
+ */
 public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super("HTTP " + response.code() + " " + response.message());
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /**
+     * HTTP status code.
+     */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /**
+     * HTTP status message.
+     */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
index 62d449eb9..a5dcd9c02 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -17,13 +17,17 @@
 
 import com.google.common.reflect.TypeToken;
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
+
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -32,69 +36,85 @@
 import static org.junit.Assert.fail;
 
 public final class GuavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
-  @Rule public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-  private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
-  private Retrofit retrofit;
+    private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
+    private Retrofit retrofit;
 
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
+    @Before
+    public void setUp() {
+        retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(factory)
+                .build();
+    }
 
-  @Test public void responseType() {
-    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}.getType();
-    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {}.getType();
-    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {}.getType();
-    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
+    @Test
+    public void responseType() {
+        Type bodyClass = new TypeToken<ListenableFuture<String>>() {
+        }.getType();
+        assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+        Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+    }
 
-  @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
+    @Test
+    public void nonListenableFutureReturnsNull() {
+        CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+        assertThat(adapter).isNull();
+    }
 
-  @Test public void rawTypeThrows() {
-    Type observableType = new TypeToken<ListenableFuture>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    @Test
+    public void rawTypeThrows() {
+        Type observableType = new TypeToken<ListenableFuture>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+        }
     }
-  }
 
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<ListenableFuture<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    @Test
+    public void rawResponseTypeThrows() {
+        Type observableType = new TypeToken<ListenableFuture<Response>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
index fb3ccb3da..57fedd7ab 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -16,13 +16,17 @@
 package retrofit2.adapter.guava;
 
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,83 +36,94 @@
 import static org.junit.Assert.fail;
 
 public final class ListenableFutureTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") ListenableFuture<String> body();
-    @GET("/") ListenableFuture<Response<String>> response();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(GuavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    ListenableFuture<String> future = service.body();
-    assertThat(future.get()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    ListenableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
-          .hasMessage("HTTP 404 Client Error");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        ListenableFuture<String> body();
+
+        @GET("/")
+        ListenableFuture<Response<String>> response();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        ListenableFuture<String> future = service.body();
+        assertThat(future.get()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void bodySuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        ListenableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(HttpException.class)
+                    .hasMessage("HTTP 404 Client Error");
+        }
+    }
+
+    @Test
+    public void bodyFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        ListenableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 
-  @Test public void bodyFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    @Test
+    public void responseSuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    ListenableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+        ListenableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
     }
-  }
-
-  @Test public void responseSuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    ListenableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    ListenableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    ListenableFuture<Response<String>> future = service.response();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+
+    @Test
+    public void responseSuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        ListenableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        ListenableFuture<Response<String>> future = service.response();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
index bb9ccf189..f0bc6dc19 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 9b3051eb0..17b5e6bc5 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -1,65 +1,67 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-java8</artifactId>
-  <name>Adapter: Java 8</name>
+    <artifactId>adapter-java8</artifactId>
+    <name>Adapter: Java 8</name>
 
-  <properties>
-    <java.version>1.8</java.version>
-  </properties>
+    <properties>
+        <java.version>1.8</java.version>
+    </properties>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <configuration>
-          <signature>
-            <groupId>org.kaazing.mojo.signature</groupId>
-            <artifactId>java18</artifactId>
-            <version>1.0</version>
-          </signature>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-maven-plugin</artifactId>
+                <version>${animal.sniffer.version}</version>
+                <configuration>
+                    <signature>
+                        <groupId>org.kaazing.mojo.signature</groupId>
+                        <artifactId>java18</artifactId>
+                        <version>1.0</version>
+                    </signature>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
index 022fa9848..918d0d462 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -17,33 +17,39 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
+/**
+ * Exception for an unexpected, non-2xx HTTP response.
+ */
 public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super("HTTP " + response.code() + " " + response.message());
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /**
+     * HTTP status code.
+     */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /**
+     * HTTP status message.
+     */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index b0bd0efb0..4be2d49d0 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.CompletableFuture;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -28,7 +29,7 @@
 
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
- * <p>
+ * <p/>
  * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
  * service methods.
  * <pre><code>
@@ -48,109 +49,119 @@
  * </ul>
  */
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
-  public static Java8CallAdapterFactory create() {
-    return new Java8CallAdapterFactory();
-  }
-
-  private Java8CallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != CompletableFuture.class) {
-      return null;
+    public static Java8CallAdapterFactory create() {
+        return new Java8CallAdapterFactory();
     }
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("CompletableFuture return type must be parameterized"
-          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
-    }
-    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    if (getRawType(innerType) != Response.class) {
-      // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
+    private Java8CallAdapterFactory() {
     }
 
-    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
-    if (!(innerType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Response must be parameterized"
-          + " as Response<Foo> or Response<? extends Foo>");
-    }
-    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter(responseType);
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != CompletableFuture.class) {
+            return null;
+        }
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalStateException("CompletableFuture return type must be parameterized"
+                    + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+        }
+        Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-  private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
-    private final Type responseType;
+        if (getRawType(innerType) != Response.class) {
+            // Generic type is not Response<T>. Use it for body-only adapter.
+            return new BodyCallAdapter(innerType);
+        }
 
-    BodyCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+        if (!(innerType instanceof ParameterizedType)) {
+            throw new IllegalStateException("Response must be parameterized"
+                    + " as Response<Foo> or Response<? extends Foo>");
+        }
+        Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+        return new ResponseCallAdapter(responseType);
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static class BodyCallAdapter implements CallAdapter<CompletableFuture<?>> {
+        private final Type responseType;
 
-    @Override public <R> CompletableFuture<R> adapt(final Call<R> call) {
-      final CompletableFuture<R> future = new CompletableFuture<R>() {
-        @Override public boolean cancel(boolean mayInterruptIfRunning) {
-          if (mayInterruptIfRunning) {
-            call.cancel();
-          }
-          return super.cancel(mayInterruptIfRunning);
-        }
-      };
-
-      call.enqueue(new Callback<R>() {
-        @Override public void onResponse(Call<R> call, Response<R> response) {
-          if (response.isSuccessful()) {
-            future.complete(response.body());
-          } else {
-            future.completeExceptionally(new HttpException(response));
-          }
+        BodyCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
 
-        @Override public void onFailure(Call<R> call, Throwable t) {
-          future.completeExceptionally(t);
+        @Override
+        public Type responseType() {
+            return responseType;
         }
-      });
-
-      return future;
-    }
-  }
 
-  private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
-    private final Type responseType;
-
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        @Override
+        public <R> CompletableFuture<R> adapt(final Call<R> call) {
+            final CompletableFuture<R> future = new CompletableFuture<R>() {
+                @Override
+                public boolean cancel(boolean mayInterruptIfRunning) {
+                    if (mayInterruptIfRunning) {
+                        call.cancel();
+                    }
+                    return super.cancel(mayInterruptIfRunning);
+                }
+            };
+
+            call.enqueue(new Callback<R>() {
+                @Override
+                public void onResponse(Call<R> call, Response<R> response) {
+                    if (response.isSuccessful()) {
+                        future.complete(response.body());
+                    } else {
+                        future.completeExceptionally(new HttpException(response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<R> call, Throwable t) {
+                    future.completeExceptionally(t);
+                }
+            });
+
+            return future;
+        }
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static class ResponseCallAdapter implements CallAdapter<CompletableFuture<?>> {
+        private final Type responseType;
 
-    @Override public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
-      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
-        @Override public boolean cancel(boolean mayInterruptIfRunning) {
-          if (mayInterruptIfRunning) {
-            call.cancel();
-          }
-          return super.cancel(mayInterruptIfRunning);
+        ResponseCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
-      };
 
-      call.enqueue(new Callback<R>() {
-        @Override public void onResponse(Call<R> call, Response<R> response) {
-          future.complete(response);
+        @Override
+        public Type responseType() {
+            return responseType;
         }
 
-        @Override public void onFailure(Call<R> call, Throwable t) {
-          future.completeExceptionally(t);
+        @Override
+        public <R> CompletableFuture<Response<R>> adapt(final Call<R> call) {
+            final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+                @Override
+                public boolean cancel(boolean mayInterruptIfRunning) {
+                    if (mayInterruptIfRunning) {
+                        call.cancel();
+                    }
+                    return super.cancel(mayInterruptIfRunning);
+                }
+            };
+
+            call.enqueue(new Callback<R>() {
+                @Override
+                public void onResponse(Call<R> call, Response<R> response) {
+                    future.complete(response);
+                }
+
+                @Override
+                public void onFailure(Call<R> call, Throwable t) {
+                    future.completeExceptionally(t);
+                }
+            });
+
+            return future;
         }
-      });
-
-      return future;
     }
-  }
 }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
index d4a00a1dc..b90a16a8d 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -18,11 +18,14 @@
 import java.io.IOException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,83 +35,94 @@
 import static org.junit.Assert.fail;
 
 public final class CompletableFutureTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") CompletableFuture<String> body();
-    @GET("/") CompletableFuture<Response<String>> response();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(Java8CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    CompletableFuture<String> future = service.body();
-    assertThat(future.get()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    CompletableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
-          .hasMessage("HTTP 404 Client Error");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        CompletableFuture<String> body();
+
+        @GET("/")
+        CompletableFuture<Response<String>> response();
     }
-  }
 
-  @Test public void bodyFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(Java8CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        CompletableFuture<String> future = service.body();
+        assertThat(future.get()).isEqualTo("Hi");
+    }
 
-    CompletableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    @Test
+    public void bodySuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        CompletableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(HttpException.class)
+                    .hasMessage("HTTP 404 Client Error");
+        }
     }
-  }
-
-  @Test public void responseSuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    CompletableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    CompletableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    CompletableFuture<Response<String>> future = service.response();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+
+    @Test
+    public void bodyFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        CompletableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
+    }
+
+    @Test
+    public void responseSuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        CompletableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseSuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        CompletableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        CompletableFuture<Response<String>> future = service.response();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
index 89d2b9537..fd3c8dda0 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -16,14 +16,18 @@
 package retrofit2.adapter.java8;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
+
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -32,69 +36,85 @@
 import static org.junit.Assert.fail;
 
 public final class Java8CallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
-  @Rule public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-  private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
-  private Retrofit retrofit;
+    private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
+    private Retrofit retrofit;
 
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
+    @Before
+    public void setUp() {
+        retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(factory)
+                .build();
+    }
 
-  @Test public void responseType() {
-    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
-    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
-    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
-    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
+    @Test
+    public void responseType() {
+        Type bodyClass = new TypeToken<CompletableFuture<String>>() {
+        }.getType();
+        assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+        Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+    }
 
-  @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
+    @Test
+    public void nonListenableFutureReturnsNull() {
+        CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+        assertThat(adapter).isNull();
+    }
 
-  @Test public void rawTypeThrows() {
-    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    @Test
+    public void rawTypeThrows() {
+        Type observableType = new TypeToken<CompletableFuture>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+        }
     }
-  }
 
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    @Test
+    public void rawResponseTypeThrows() {
+        Type observableType = new TypeToken<CompletableFuture<Response>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
index de4b63e61..c42ca7a30 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index 0087d887c..dce2776df 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -1,22 +1,24 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit-adapters</artifactId>
-  <name>Adapters</name>
-  <packaging>pom</packaging>
+    <artifactId>retrofit-adapters</artifactId>
+    <name>Adapters</name>
+    <packaging>pom</packaging>
 
-  <modules>
-    <module>guava</module>
-    <module>java8</module>
-    <module>rxjava</module>
-  </modules>
+    <modules>
+        <module>guava</module>
+        <module>java8</module>
+        <module>rxjava</module>
+    </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index f553469c5..7c902aec4 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -1,48 +1,50 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-rxjava</artifactId>
-  <name>Adapter: RxJava</name>
+    <artifactId>adapter-rxjava</artifactId>
+    <name>Adapter: RxJava</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.reactivex</groupId>
+            <artifactId>rxjava</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
index 78b668905..e1b933067 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CompletableHelper.java
@@ -16,6 +16,7 @@
 package retrofit2.adapter.rxjava;
 
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
@@ -29,64 +30,68 @@
 import rx.subscriptions.Subscriptions;
 
 final class CompletableHelper {
-  static CallAdapter<Completable> createCallAdapter(Scheduler scheduler) {
-    return new CompletableCallAdapter(scheduler);
-  }
-
-  private static final class CompletableCallOnSubscribe implements CompletableOnSubscribe {
-    private final Call originalCall;
-
-    CompletableCallOnSubscribe(Call originalCall) {
-      this.originalCall = originalCall;
+    static CallAdapter<Completable> createCallAdapter(Scheduler scheduler) {
+        return new CompletableCallAdapter(scheduler);
     }
 
-    @Override public void call(CompletableSubscriber subscriber) {
-      // Since Call is a one-shot type, clone it for each new subscriber.
-      final Call call = originalCall.clone();
+    private static final class CompletableCallOnSubscribe implements CompletableOnSubscribe {
+        private final Call originalCall;
 
-      // Attempt to cancel the call if it is still in-flight on unsubscription.
-      Subscription subscription = Subscriptions.create(new Action0() {
-        @Override public void call() {
-          call.cancel();
+        CompletableCallOnSubscribe(Call originalCall) {
+            this.originalCall = originalCall;
         }
-      });
-      subscriber.onSubscribe(subscription);
 
-      try {
-        Response response = call.execute();
-        if (!subscription.isUnsubscribed()) {
-          if (response.isSuccessful()) {
-            subscriber.onCompleted();
-          } else {
-            subscriber.onError(new HttpException(response));
-          }
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (!subscription.isUnsubscribed()) {
-          subscriber.onError(t);
+        @Override
+        public void call(CompletableSubscriber subscriber) {
+            // Since Call is a one-shot type, clone it for each new subscriber.
+            final Call call = originalCall.clone();
+
+            // Attempt to cancel the call if it is still in-flight on unsubscription.
+            Subscription subscription = Subscriptions.create(new Action0() {
+                @Override
+                public void call() {
+                    call.cancel();
+                }
+            });
+            subscriber.onSubscribe(subscription);
+
+            try {
+                Response response = call.execute();
+                if (!subscription.isUnsubscribed()) {
+                    if (response.isSuccessful()) {
+                        subscriber.onCompleted();
+                    } else {
+                        subscriber.onError(new HttpException(response));
+                    }
+                }
+            } catch (Throwable t) {
+                Exceptions.throwIfFatal(t);
+                if (!subscription.isUnsubscribed()) {
+                    subscriber.onError(t);
+                }
+            }
         }
-      }
     }
-  }
 
-  static class CompletableCallAdapter implements CallAdapter<Completable> {
-    private final Scheduler scheduler;
+    static class CompletableCallAdapter implements CallAdapter<Completable> {
+        private final Scheduler scheduler;
 
-    CompletableCallAdapter(Scheduler scheduler) {
-      this.scheduler = scheduler;
-    }
+        CompletableCallAdapter(Scheduler scheduler) {
+            this.scheduler = scheduler;
+        }
 
-    @Override public Type responseType() {
-      return Void.class;
-    }
+        @Override
+        public Type responseType() {
+            return Void.class;
+        }
 
-    @Override public Completable adapt(Call call) {
-      Completable completable = Completable.create(new CompletableCallOnSubscribe(call));
-      if (scheduler != null) {
-        return completable.subscribeOn(scheduler);
-      }
-      return completable;
+        @Override
+        public Completable adapt(Call call) {
+            Completable completable = Completable.create(new CompletableCallOnSubscribe(call));
+            if (scheduler != null) {
+                return completable.subscribeOn(scheduler);
+            }
+            return completable;
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
index 7b5377ea5..efd7c5992 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -2,33 +2,39 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
+/**
+ * Exception for an unexpected, non-2xx HTTP response.
+ */
 public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super("HTTP " + response.code() + " " + response.message());
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /**
+     * HTTP status code.
+     */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /**
+     * HTTP status message.
+     */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java
index 321f463f9..c1d1606e0 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/OperatorMapResponseToBodyOrError.java
@@ -26,31 +26,35 @@
  * to use {@link Observable#flatMap(Func1)} which breaks producer requests from propagating.
  */
 final class OperatorMapResponseToBodyOrError<T> implements Operator<T, Response<T>> {
-  private static final OperatorMapResponseToBodyOrError<Object> INSTANCE =
-      new OperatorMapResponseToBodyOrError<>();
+    private static final OperatorMapResponseToBodyOrError<Object> INSTANCE =
+            new OperatorMapResponseToBodyOrError<>();
 
-  @SuppressWarnings("unchecked") // Safe because of erasure.
-  static <R> OperatorMapResponseToBodyOrError<R> instance() {
-    return (OperatorMapResponseToBodyOrError<R>) INSTANCE;
-  }
+    @SuppressWarnings("unchecked") // Safe because of erasure.
+    static <R> OperatorMapResponseToBodyOrError<R> instance() {
+        return (OperatorMapResponseToBodyOrError<R>) INSTANCE;
+    }
 
-  @Override public Subscriber<? super Response<T>> call(final Subscriber<? super T> child) {
-    return new Subscriber<Response<T>>(child) {
-      @Override public void onNext(Response<T> response) {
-        if (response.isSuccessful()) {
-          child.onNext(response.body());
-        } else {
-          child.onError(new HttpException(response));
-        }
-      }
+    @Override
+    public Subscriber<? super Response<T>> call(final Subscriber<? super T> child) {
+        return new Subscriber<Response<T>>(child) {
+            @Override
+            public void onNext(Response<T> response) {
+                if (response.isSuccessful()) {
+                    child.onNext(response.body());
+                } else {
+                    child.onError(new HttpException(response));
+                }
+            }
 
-      @Override public void onCompleted() {
-        child.onCompleted();
-      }
+            @Override
+            public void onCompleted() {
+                child.onCompleted();
+            }
 
-      @Override public void onError(Throwable e) {
-        child.onError(e);
-      }
-    };
-  }
+            @Override
+            public void onError(Throwable e) {
+                child.onError(e);
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 8d68e9e7f..b695afc39 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -16,50 +16,55 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import retrofit2.Response;
 
-/** The result of executing an HTTP request. */
+/**
+ * The result of executing an HTTP request.
+ */
 public final class Result<T> {
-  public static <T> Result<T> error(Throwable error) {
-    if (error == null) throw new NullPointerException("error == null");
-    return new Result<>(null, error);
-  }
+    public static <T> Result<T> error(Throwable error) {
+        if (error == null) throw new NullPointerException("error == null");
+        return new Result<>(null, error);
+    }
 
-  public static <T> Result<T> response(Response<T> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return new Result<>(response, null);
-  }
+    public static <T> Result<T> response(Response<T> response) {
+        if (response == null) throw new NullPointerException("response == null");
+        return new Result<>(response, null);
+    }
 
-  private final Response<T> response;
-  private final Throwable error;
+    private final Response<T> response;
+    private final Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
-    this.response = response;
-    this.error = error;
-  }
+    private Result(Response<T> response, Throwable error) {
+        this.response = response;
+        this.error = error;
+    }
 
-  /**
-   * The response received from executing an HTTP request. Only present when {@link #isError()} is
-   * false, null otherwise.
-   */
-  public Response<T> response() {
-    return response;
-  }
+    /**
+     * The response received from executing an HTTP request. Only present when {@link #isError()} is
+     * false, null otherwise.
+     */
+    public Response<T> response() {
+        return response;
+    }
 
-  /**
-   * The error experienced while attempting to execute an HTTP request. Only present when {@link
-   * #isError()} is true, null otherwise.
-   * <p>
-   * If the error is an {@link IOException} then there was a problem with the transport to the
-   * remote server. Any other exception type indicates an unexpected failure and should be
-   * considered fatal (configuration error, programming error, etc.).
-   */
-  public Throwable error() {
-    return error;
-  }
+    /**
+     * The error experienced while attempting to execute an HTTP request. Only present when {@link
+     * #isError()} is true, null otherwise.
+     * <p/>
+     * If the error is an {@link IOException} then there was a problem with the transport to the
+     * remote server. Any other exception type indicates an unexpected failure and should be
+     * considered fatal (configuration error, programming error, etc.).
+     */
+    public Throwable error() {
+        return error;
+    }
 
-  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
-  public boolean isError() {
-    return error != null;
-  }
+    /**
+     * {@code true} if the request resulted in an error. See {@link #error()} for the cause.
+     */
+    public boolean isError() {
+        return error != null;
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index f0feb4b21..15b682897 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.atomic.AtomicBoolean;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
@@ -34,7 +35,7 @@
 
 /**
  * A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables.
- * <p>
+ * <p/>
  * Adding this class to {@link Retrofit} allows you to return {@link Observable} from service
  * methods.
  * <pre><code>
@@ -56,217 +57,229 @@
  * </ul>
  */
 public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
-  /**
-   * Returns an instance which creates synchronous observables that do not operate on any scheduler
-   * by default.
-   */
-  public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory(null);
-  }
-
-  /**
-   * Returns an instance which creates synchronous observables that
-   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
-   */
-  public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
-    if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJavaCallAdapterFactory(scheduler);
-  }
-
-  private final Scheduler scheduler;
-
-  private RxJavaCallAdapterFactory(Scheduler scheduler) {
-    this.scheduler = scheduler;
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = getRawType(returnType);
-    String canonicalName = rawType.getCanonicalName();
-    boolean isSingle = "rx.Single".equals(canonicalName);
-    boolean isCompletable = "rx.Completable".equals(canonicalName);
-    if (rawType != Observable.class && !isSingle && !isCompletable) {
-      return null;
-    }
-    if (!isCompletable && !(returnType instanceof ParameterizedType)) {
-      String name = isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    /**
+     * Returns an instance which creates synchronous observables that do not operate on any scheduler
+     * by default.
+     */
+    public static RxJavaCallAdapterFactory create() {
+        return new RxJavaCallAdapterFactory(null);
     }
 
-    if (isCompletable) {
-      // Add Completable-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      // Note that this has to be done separately since Completable doesn't have a parametrized
-      // type.
-      return CompletableHelper.createCallAdapter(scheduler);
+    /**
+     * Returns an instance which creates synchronous observables that
+     * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+     */
+    public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
+        if (scheduler == null) throw new NullPointerException("scheduler == null");
+        return new RxJavaCallAdapterFactory(scheduler);
     }
 
-    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType, scheduler);
-    if (isSingle) {
-      // Add Single-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      return SingleHelper.makeSingle(callAdapter);
-    }
-    return callAdapter;
-  }
-
-  private CallAdapter<Observable<?>> getCallAdapter(Type returnType, Scheduler scheduler) {
-    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = getRawType(observableType);
-    if (rawObservableType == Response.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Response must be parameterized"
-            + " as Response<Foo> or Response<? extends Foo>");
-      }
-      Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResponseCallAdapter(responseType, scheduler);
-    }
+    private final Scheduler scheduler;
 
-    if (rawObservableType == Result.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Result must be parameterized"
-            + " as Result<Foo> or Result<? extends Foo>");
-      }
-      Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      return new ResultCallAdapter(responseType, scheduler);
+    private RxJavaCallAdapterFactory(Scheduler scheduler) {
+        this.scheduler = scheduler;
     }
 
-    return new SimpleCallAdapter(observableType, scheduler);
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        Class<?> rawType = getRawType(returnType);
+        String canonicalName = rawType.getCanonicalName();
+        boolean isSingle = "rx.Single".equals(canonicalName);
+        boolean isCompletable = "rx.Completable".equals(canonicalName);
+        if (rawType != Observable.class && !isSingle && !isCompletable) {
+            return null;
+        }
+        if (!isCompletable && !(returnType instanceof ParameterizedType)) {
+            String name = isSingle ? "Single" : "Observable";
+            throw new IllegalStateException(name + " return type must be parameterized"
+                    + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+        }
 
-  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
-    private final Call<T> originalCall;
+        if (isCompletable) {
+            // Add Completable-converter wrapper from a separate class. This defers classloading such that
+            // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+            // Note that this has to be done separately since Completable doesn't have a parametrized
+            // type.
+            return CompletableHelper.createCallAdapter(scheduler);
+        }
 
-    CallOnSubscribe(Call<T> originalCall) {
-      this.originalCall = originalCall;
+        CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType, scheduler);
+        if (isSingle) {
+            // Add Single-converter wrapper from a separate class. This defers classloading such that
+            // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+            return SingleHelper.makeSingle(callAdapter);
+        }
+        return callAdapter;
     }
 
-    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
-      // Since Call is a one-shot type, clone it for each new subscriber.
-      Call<T> call = originalCall.clone();
+    private CallAdapter<Observable<?>> getCallAdapter(Type returnType, Scheduler scheduler) {
+        Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+        Class<?> rawObservableType = getRawType(observableType);
+        if (rawObservableType == Response.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Response must be parameterized"
+                        + " as Response<Foo> or Response<? extends Foo>");
+            }
+            Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+            return new ResponseCallAdapter(responseType, scheduler);
+        }
+
+        if (rawObservableType == Result.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Result must be parameterized"
+                        + " as Result<Foo> or Result<? extends Foo>");
+            }
+            Type responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+            return new ResultCallAdapter(responseType, scheduler);
+        }
 
-      // Wrap the call in a helper which handles both unsubscription and backpressure.
-      RequestArbiter<T> requestArbiter = new RequestArbiter<>(call, subscriber);
-      subscriber.add(requestArbiter);
-      subscriber.setProducer(requestArbiter);
+        return new SimpleCallAdapter(observableType, scheduler);
     }
-  }
 
-  static final class RequestArbiter<T> extends AtomicBoolean implements Subscription, Producer {
-    private final Call<T> call;
-    private final Subscriber<? super Response<T>> subscriber;
+    static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
+        private final Call<T> originalCall;
 
-    RequestArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
-      this.call = call;
-      this.subscriber = subscriber;
-    }
+        CallOnSubscribe(Call<T> originalCall) {
+            this.originalCall = originalCall;
+        }
 
-    @Override public void request(long n) {
-      if (n < 0) throw new IllegalArgumentException("n < 0: " + n);
-      if (n == 0) return; // Nothing to do when requesting 0.
-      if (!compareAndSet(false, true)) return; // Request was already triggered.
+        @Override
+        public void call(final Subscriber<? super Response<T>> subscriber) {
+            // Since Call is a one-shot type, clone it for each new subscriber.
+            Call<T> call = originalCall.clone();
 
-      try {
-        Response<T> response = call.execute();
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onNext(response);
+            // Wrap the call in a helper which handles both unsubscription and backpressure.
+            RequestArbiter<T> requestArbiter = new RequestArbiter<>(call, subscriber);
+            subscriber.add(requestArbiter);
+            subscriber.setProducer(requestArbiter);
         }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        if (!subscriber.isUnsubscribed()) {
-          subscriber.onError(t);
+    }
+
+    static final class RequestArbiter<T> extends AtomicBoolean implements Subscription, Producer {
+        private final Call<T> call;
+        private final Subscriber<? super Response<T>> subscriber;
+
+        RequestArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
+            this.call = call;
+            this.subscriber = subscriber;
         }
-        return;
-      }
 
-      if (!subscriber.isUnsubscribed()) {
-        subscriber.onCompleted();
-      }
-    }
+        @Override
+        public void request(long n) {
+            if (n < 0) throw new IllegalArgumentException("n < 0: " + n);
+            if (n == 0) return; // Nothing to do when requesting 0.
+            if (!compareAndSet(false, true)) return; // Request was already triggered.
+
+            try {
+                Response<T> response = call.execute();
+                if (!subscriber.isUnsubscribed()) {
+                    subscriber.onNext(response);
+                }
+            } catch (Throwable t) {
+                Exceptions.throwIfFatal(t);
+                if (!subscriber.isUnsubscribed()) {
+                    subscriber.onError(t);
+                }
+                return;
+            }
 
-    @Override public void unsubscribe() {
-      call.cancel();
-    }
+            if (!subscriber.isUnsubscribed()) {
+                subscriber.onCompleted();
+            }
+        }
 
-    @Override public boolean isUnsubscribed() {
-      return call.isCanceled();
+        @Override
+        public void unsubscribe() {
+            call.cancel();
+        }
+
+        @Override
+        public boolean isUnsubscribed() {
+            return call.isCanceled();
+        }
     }
-  }
 
-  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-    private final Scheduler scheduler;
+    static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
+        private final Type responseType;
+        private final Scheduler scheduler;
 
-    ResponseCallAdapter(Type responseType, Scheduler scheduler) {
-      this.responseType = responseType;
-      this.scheduler = scheduler;
-    }
+        ResponseCallAdapter(Type responseType, Scheduler scheduler) {
+            this.responseType = responseType;
+            this.scheduler = scheduler;
+        }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+        @Override
+        public Type responseType() {
+            return responseType;
+        }
 
-    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
-      Observable<Response<R>> observable = Observable.create(new CallOnSubscribe<>(call));
-      if (scheduler != null) {
-        return observable.subscribeOn(scheduler);
-      }
-      return observable;
+        @Override
+        public <R> Observable<Response<R>> adapt(Call<R> call) {
+            Observable<Response<R>> observable = Observable.create(new CallOnSubscribe<>(call));
+            if (scheduler != null) {
+                return observable.subscribeOn(scheduler);
+            }
+            return observable;
+        }
     }
-  }
 
-  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-    private final Scheduler scheduler;
+    static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
+        private final Type responseType;
+        private final Scheduler scheduler;
 
-    SimpleCallAdapter(Type responseType, Scheduler scheduler) {
-      this.responseType = responseType;
-      this.scheduler = scheduler;
-    }
+        SimpleCallAdapter(Type responseType, Scheduler scheduler) {
+            this.responseType = responseType;
+            this.scheduler = scheduler;
+        }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+        @Override
+        public Type responseType() {
+            return responseType;
+        }
 
-    @Override public <R> Observable<R> adapt(Call<R> call) {
-      Observable<R> observable = Observable.create(new CallOnSubscribe<>(call)) //
-          .lift(OperatorMapResponseToBodyOrError.<R>instance());
-      if (scheduler != null) {
-        return observable.subscribeOn(scheduler);
-      }
-      return observable;
+        @Override
+        public <R> Observable<R> adapt(Call<R> call) {
+            Observable<R> observable = Observable.create(new CallOnSubscribe<>(call)) //
+                    .lift(OperatorMapResponseToBodyOrError.<R>instance());
+            if (scheduler != null) {
+                return observable.subscribeOn(scheduler);
+            }
+            return observable;
+        }
     }
-  }
 
-  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
-    private final Type responseType;
-    private final Scheduler scheduler;
+    static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
+        private final Type responseType;
+        private final Scheduler scheduler;
 
-    ResultCallAdapter(Type responseType, Scheduler scheduler) {
-      this.responseType = responseType;
-      this.scheduler = scheduler;
-    }
+        ResultCallAdapter(Type responseType, Scheduler scheduler) {
+            this.responseType = responseType;
+            this.scheduler = scheduler;
+        }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+        @Override
+        public Type responseType() {
+            return responseType;
+        }
 
-    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
-      Observable<Result<R>> observable = Observable.create(new CallOnSubscribe<>(call)) //
-          .map(new Func1<Response<R>, Result<R>>() {
-            @Override public Result<R> call(Response<R> response) {
-              return Result.response(response);
-            }
-          }).onErrorReturn(new Func1<Throwable, Result<R>>() {
-            @Override public Result<R> call(Throwable throwable) {
-              return Result.error(throwable);
+        @Override
+        public <R> Observable<Result<R>> adapt(Call<R> call) {
+            Observable<Result<R>> observable = Observable.create(new CallOnSubscribe<>(call)) //
+                    .map(new Func1<Response<R>, Result<R>>() {
+                        @Override
+                        public Result<R> call(Response<R> response) {
+                            return Result.response(response);
+                        }
+                    }).onErrorReturn(new Func1<Throwable, Result<R>>() {
+                        @Override
+                        public Result<R> call(Throwable throwable) {
+                            return Result.error(throwable);
+                        }
+                    });
+            if (scheduler != null) {
+                return observable.subscribeOn(scheduler);
             }
-          });
-      if (scheduler != null) {
-        return observable.subscribeOn(scheduler);
-      }
-      return observable;
+            return observable;
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
index e0073cfae..70706ac9a 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/SingleHelper.java
@@ -16,22 +16,25 @@
 package retrofit2.adapter.rxjava;
 
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import rx.Observable;
 import rx.Single;
 
 final class SingleHelper {
-  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
-    return new CallAdapter<Single<?>>() {
-      @Override public Type responseType() {
-        return callAdapter.responseType();
-      }
+    static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
+        return new CallAdapter<Single<?>>() {
+            @Override
+            public Type responseType() {
+                return callAdapter.responseType();
+            }
 
-      @Override public <R> Single<?> adapt(Call<R> call) {
-        Observable<?> observable = callAdapter.adapt(call);
-        return observable.toSingle();
-      }
-    };
-  }
+            @Override
+            public <R> Single<?> adapt(Call<R> call) {
+                Observable<?> observable = callAdapter.adapt(call);
+                return observable.toSingle();
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
index bb02e3d47..a0a419960 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableSchedulerTest.java
@@ -17,9 +17,11 @@
 
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
@@ -27,31 +29,35 @@
 import rx.schedulers.TestScheduler;
 
 public final class CompletableSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Completable completable();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void completableUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<Void> subscriber = new TestSubscriber<>();
-    service.completable().subscribe(subscriber);
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertCompleted();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void completableUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<Void> subscriber = new TestSubscriber<>();
+        service.completable().subscribe(subscriber);
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertCompleted();
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index 0cdd11155..8202fb4e3 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -16,11 +16,14 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
@@ -30,47 +33,53 @@
 import static org.junit.Assert.fail;
 
 public final class CompletableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-  interface Service {
-    @GET("/") Completable completable();
-  }
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
 
-  private Service service;
+    private Service service;
 
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
 
-  @Test public void completableSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-    service.completable().await();
-  }
+    @Test
+    public void completableSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+        service.completable().await();
+    }
 
-  @Test public void completableSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
+    @Test
+    public void completableSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+        try {
+            service.completable().await();
+            fail();
+        } catch (RuntimeException e) {
+            Throwable cause = e.getCause();
+            assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+        }
     }
-  }
 
-  @Test public void completableFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    @Test
+    public void completableFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    try {
-      service.completable().await();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+        try {
+            service.completable().await();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
index e0a1c2d41..0f90de1b0 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableSchedulerTest.java
@@ -17,9 +17,11 @@
 
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -28,62 +30,72 @@
 import rx.schedulers.TestScheduler;
 
 public final class ObservableSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-    subscriber.assertCompleted();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<String> subscriber = new TestSubscriber<>();
+        service.body().subscribe(subscriber);
+        subscriber.assertNoValues();
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertValueCount(1);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+        service.response().subscribe(subscriber);
+        subscriber.assertNoValues();
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertValueCount(1);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+        service.result().subscribe(subscriber);
+        subscriber.assertNoValues();
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertValueCount(1);
+        subscriber.assertCompleted();
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index f3e05adea..795cf6e12 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -16,11 +16,14 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -33,163 +36,182 @@
 import static org.junit.Assert.fail;
 
 public final class ObservableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingObservable<String> o = service.body().toBlocking();
-    assertThat(o.first()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
     }
-  }
 
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        BlockingObservable<String> o = service.body().toBlocking();
+        assertThat(o.first()).isEqualTo("Hi");
+    }
 
-    BlockingObservable<String> o = service.body().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        BlockingObservable<String> o = service.body().toBlocking();
+        try {
+            o.first();
+            fail();
+        } catch (RuntimeException e) {
+            Throwable cause = e.getCause();
+            assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+        }
     }
-  }
 
-  @Test public void bodyRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        BlockingObservable<String> o = service.body().toBlocking();
+        try {
+            o.first();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
+    }
 
-    TestSubscriber<String> subscriber = new TestSubscriber<>(0);
-    Observable<String> o = service.body();
+    @Test
+    public void bodyRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+        TestSubscriber<String> subscriber = new TestSubscriber<>(0);
+        Observable<String> o = service.body();
 
-    subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
+        o.subscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(0);
 
-    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
+        subscriber.requestMore(1);
+        assertThat(server.getRequestCount()).isEqualTo(1);
 
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
+        subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+        BlockingObservable<Response<String>> o = service.response().toBlocking();
+        Response<String> response = o.first();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.first();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
+    @Test
+    public void responseSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+        BlockingObservable<Response<String>> o = service.response().toBlocking();
+        Response<String> response = o.first();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
 
-    BlockingObservable<Response<String>> o = service.response().toBlocking();
-    try {
-      o.first();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        BlockingObservable<Response<String>> o = service.response().toBlocking();
+        try {
+            o.first();
+            fail();
+        } catch (RuntimeException t) {
+            assertThat(t.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 
-  @Test public void responseRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
+    @Test
+    public void responseRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Response<String>> o = service.response();
+        TestSubscriber<Response<String>> subscriber = new TestSubscriber<>(0);
+        Observable<Response<String>> o = service.response();
 
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+        o.subscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(0);
 
-    subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.requestMore(1);
+        assertThat(server.getRequestCount()).isEqualTo(1);
 
-    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
+        subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
 
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
+        BlockingObservable<Result<String>> o = service.result().toBlocking();
+        Result<String> result = o.first();
+        assertThat(result.isError()).isFalse();
+        Response<String> response = result.response();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
 
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+    @Test
+    public void resultSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
+        BlockingObservable<Result<String>> o = service.result().toBlocking();
+        Result<String> result = o.first();
+        assertThat(result.isError()).isFalse();
+        Response<String> response = result.response();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
 
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.first();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
+        BlockingObservable<Result<String>> o = service.result().toBlocking();
+        Result<String> result = o.first();
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isInstanceOf(IOException.class);
+    }
 
-  @Test public void resultRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
+    @Test
+    public void resultRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>(0);
-    Observable<Result<String>> o = service.result();
+        TestSubscriber<Result<String>> subscriber = new TestSubscriber<>(0);
+        Observable<Result<String>> o = service.result();
 
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(0);
+        o.subscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(0);
 
-    subscriber.requestMore(1);
-    assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.requestMore(1);
+        assertThat(server.getRequestCount()).isEqualTo(1);
 
-    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
+        subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
index 7c62c14ad..fa84636d1 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
@@ -16,7 +16,9 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.adapter.rxjava.Result;
 
@@ -24,37 +26,41 @@
 import static org.junit.Assert.fail;
 
 public final class ResultTest {
-  @Test public void response() {
-    Response<String> response = Response.success("Hi");
-    Result<String> result = Result.response(response);
-    assertThat(result.isError()).isFalse();
-    assertThat(result.error()).isNull();
-    assertThat(result.response()).isSameAs(response);
-  }
-
-  @Test public void nullResponseThrows() {
-    try {
-      Result.response(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("response == null");
+    @Test
+    public void response() {
+        Response<String> response = Response.success("Hi");
+        Result<String> result = Result.response(response);
+        assertThat(result.isError()).isFalse();
+        assertThat(result.error()).isNull();
+        assertThat(result.response()).isSameAs(response);
+    }
+
+    @Test
+    public void nullResponseThrows() {
+        try {
+            Result.response(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("response == null");
+        }
     }
-  }
-
-  @Test public void error() {
-    Throwable error = new IOException();
-    Result<Object> result = Result.error(error);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isSameAs(error);
-    assertThat(result.response()).isNull();
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Result.error(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("error == null");
+
+    @Test
+    public void error() {
+        Throwable error = new IOException();
+        Result<Object> result = Result.error(error);
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isSameAs(error);
+        assertThat(result.response()).isNull();
+    }
+
+    @Test
+    public void nullErrorThrows() {
+        try {
+            Result.error(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("error == null");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
index 3c2e435ad..d18519e8e 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -16,11 +16,14 @@
 package retrofit2.adapter.rxjava;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
+
 import org.junit.Before;
 import org.junit.Test;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -31,141 +34,170 @@
 import static org.junit.Assert.fail;
 
 public final class RxJavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-  private Retrofit retrofit;
-
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl("http://localhost:1")
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
-
-  @Test public void nullSchedulerThrows() {
-    try {
-      RxJavaCallAdapterFactory.createWithScheduler(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("scheduler == null");
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+    private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    private Retrofit retrofit;
+
+    @Before
+    public void setUp() {
+        retrofit = new Retrofit.Builder()
+                .baseUrl("http://localhost:1")
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(factory)
+                .build();
     }
-  }
-
-  @Test public void nonRxJavaTypeReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
-
-  @Test public void responseTypes() {
-    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
-    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
-    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
-    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-
-    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
-    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
-    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
-    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
-
-  @Test public void rawBodyTypeThrows() {
-    Type observableType = new TypeToken<Observable>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+
+    @Test
+    public void nullSchedulerThrows() {
+        try {
+            RxJavaCallAdapterFactory.createWithScheduler(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("scheduler == null");
+        }
     }
 
-    Type singleType = new TypeToken<Single>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    @Test
+    public void nonRxJavaTypeReturnsNull() {
+        CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+        assertThat(adapter).isNull();
     }
-  }
-
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+
+    @Test
+    public void responseTypes() {
+        Type oBodyClass = new TypeToken<Observable<String>>() {
+        }.getType();
+        assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sBodyClass = new TypeToken<Single<String>>() {
+        }.getType();
+        assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sBodyWildcard = new TypeToken<Single<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+        Type sBodyGeneric = new TypeToken<Single<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+
+        Type oResponseClass = new TypeToken<Observable<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResponseClass = new TypeToken<Single<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oResultClass = new TypeToken<Observable<Result<String>>>() {
+        }.getType();
+        assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResultClass = new TypeToken<Single<Result<String>>>() {
+        }.getType();
+        assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
     }
 
-    Type singleType = new TypeToken<Single<Response>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    @Test
+    public void rawBodyTypeThrows() {
+        Type observableType = new TypeToken<Observable>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+        }
+
+        Type singleType = new TypeToken<Single>() {
+        }.getType();
+        try {
+            factory.get(singleType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+        }
     }
-  }
-
-  @Test public void rawResultTypeThrows() {
-    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+
+    @Test
+    public void rawResponseTypeThrows() {
+        Type observableType = new TypeToken<Observable<Response>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
+
+        Type singleType = new TypeToken<Single<Response>>() {
+        }.getType();
+        try {
+            factory.get(singleType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
     }
 
-    Type singleType = new TypeToken<Single<Result>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    @Test
+    public void rawResultTypeThrows() {
+        Type observableType = new TypeToken<Observable<Result>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+        }
+
+        Type singleType = new TypeToken<Single<Result>>() {
+        }.getType();
+        try {
+            factory.get(singleType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
index 671370e02..ed8f1524d 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleSchedulerTest.java
@@ -17,9 +17,11 @@
 
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -28,59 +30,69 @@
 import rx.schedulers.TestScheduler;
 
 public final class SingleSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<String> subscriber = new TestSubscriber<>();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoValues();
-    subscriber.assertNoTerminalEvent();
-
-    scheduler.triggerActions();
-    subscriber.assertValueCount(1);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<String> subscriber = new TestSubscriber<>();
+        service.body().subscribe(subscriber);
+        subscriber.assertNoValues();
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertValueCount(1);
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<Response<String>> subscriber = new TestSubscriber<>();
+        service.response().subscribe(subscriber);
+        subscriber.assertNoValues();
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertValueCount(1);
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        TestSubscriber<Result<String>> subscriber = new TestSubscriber<>();
+        service.result().subscribe(subscriber);
+        subscriber.assertNoValues();
+        subscriber.assertNoTerminalEvent();
+
+        scheduler.triggerActions();
+        subscriber.assertValueCount(1);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index 67c5a3d22..695e15e50 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -16,11 +16,14 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,115 +35,131 @@
 import static org.junit.Assert.fail;
 
 public final class SingleTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingSingle<String> o = service.body().toBlocking();
-    assertThat(o.value()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
     }
-  }
 
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    private Service service;
 
-    BlockingSingle<String> o = service.body().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
     }
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    Response<String> response = o.value();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingSingle<Response<String>> o = service.response().toBlocking();
-    try {
-      o.value();
-      fail();
-    } catch (RuntimeException t) {
-      assertThat(t.getCause()).isInstanceOf(IOException.class);
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        BlockingSingle<String> o = service.body().toBlocking();
+        assertThat(o.value()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        BlockingSingle<String> o = service.body().toBlocking();
+        try {
+            o.value();
+            fail();
+        } catch (RuntimeException e) {
+            Throwable cause = e.getCause();
+            assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 Client Error");
+        }
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        BlockingSingle<String> o = service.body().toBlocking();
+        try {
+            o.value();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        BlockingSingle<Response<String>> o = service.response().toBlocking();
+        Response<String> response = o.value();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        BlockingSingle<Response<String>> o = service.response().toBlocking();
+        Response<String> response = o.value();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        BlockingSingle<Response<String>> o = service.response().toBlocking();
+        try {
+            o.value();
+            fail();
+        } catch (RuntimeException t) {
+            assertThat(t.getCause()).isInstanceOf(IOException.class);
+        }
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        BlockingSingle<Result<String>> o = service.result().toBlocking();
+        Result<String> result = o.value();
+        assertThat(result.isError()).isFalse();
+        Response<String> response = result.response();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void resultSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        BlockingSingle<Result<String>> o = service.result().toBlocking();
+        Result<String> result = o.value();
+        assertThat(result.isError()).isFalse();
+        Response<String> response = result.response();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        BlockingSingle<Result<String>> o = service.result().toBlocking();
+        Result<String> result = o.value();
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isInstanceOf(IOException.class);
     }
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isFalse();
-    Response<String> response = result.response();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    BlockingSingle<Result<String>> o = service.result().toBlocking();
-    Result<String> result = o.value();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
index c44038d02..893a5200f 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index c54261634..fabd3ce3f 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -1,43 +1,45 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-gson</artifactId>
-  <name>Converter: Gson</name>
+    <artifactId>converter-gson</artifactId>
+    <name>Converter: Gson</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index e6c702705..d926f8d4b 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -18,8 +18,10 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -27,47 +29,47 @@
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
- * <p>
+ * <p/>
  * Because Gson is so flexible in the types it supports, this converter assumes that it can handle
  * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
  * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
  * last to allow the other converters a chance to see their types.
  */
 public final class GsonConverterFactory extends Converter.Factory {
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public static GsonConverterFactory create() {
-    return create(new Gson());
-  }
+    /**
+     * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+     * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+     */
+    public static GsonConverterFactory create() {
+        return create(new Gson());
+    }
 
-  /**
-   * Create an instance using {@code gson} for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public static GsonConverterFactory create(Gson gson) {
-    return new GsonConverterFactory(gson);
-  }
+    /**
+     * Create an instance using {@code gson} for conversion. Encoding to JSON and
+     * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+     */
+    public static GsonConverterFactory create(Gson gson) {
+        return new GsonConverterFactory(gson);
+    }
 
-  private final Gson gson;
+    private final Gson gson;
 
-  private GsonConverterFactory(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
-    this.gson = gson;
-  }
+    private GsonConverterFactory(Gson gson) {
+        if (gson == null) throw new NullPointerException("gson == null");
+        this.gson = gson;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonResponseBodyConverter<>(gson, adapter);
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+        return new GsonResponseBodyConverter<>(gson, adapter);
+    }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonRequestBodyConverter<>(gson, adapter);
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+        return new GsonRequestBodyConverter<>(gson, adapter);
+    }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 2e30a4478..2c778e97c 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -18,33 +18,36 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.nio.charset.Charset;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
 import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-  private static final Charset UTF_8 = Charset.forName("UTF-8");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
 
-  private final Gson gson;
-  private final TypeAdapter<T> adapter;
+    private final Gson gson;
+    private final TypeAdapter<T> adapter;
 
-  GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
-    this.gson = gson;
-    this.adapter = adapter;
-  }
+    GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+        this.gson = gson;
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
-    JsonWriter jsonWriter = gson.newJsonWriter(writer);
-    adapter.write(jsonWriter, value);
-    jsonWriter.close();
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+        JsonWriter jsonWriter = gson.newJsonWriter(writer);
+        adapter.write(jsonWriter, value);
+        jsonWriter.close();
+        return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+    }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
index bd9509a18..cd407a9af 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -18,25 +18,28 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final Gson gson;
-  private final TypeAdapter<T> adapter;
+    private final Gson gson;
+    private final TypeAdapter<T> adapter;
 
-  GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
-    this.gson = gson;
-    this.adapter = adapter;
-  }
+    GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+        this.gson = gson;
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    JsonReader jsonReader = gson.newJsonReader(value.charStream());
-    try {
-      return adapter.read(jsonReader);
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        JsonReader jsonReader = gson.newJsonReader(value.charStream());
+        try {
+            return adapter.read(jsonReader);
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
index 5f584ec85..23874c3c2 100644
--- a/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -21,13 +21,17 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -37,108 +41,120 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class GsonConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
+    interface AnInterface {
+        String getName();
+    }
+
+    static class AnImplementation implements AnInterface {
+        private final String theName;
+
+        AnImplementation(String name) {
+            theName = name;
+        }
+
+        @Override
+        public String getName() {
+            return theName;
+        }
+    }
+
+    static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
+        @Override
+        public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+            jsonWriter.beginObject();
+            jsonWriter.name("name").value(anInterface.getName());
+            jsonWriter.endObject();
+        }
 
-  static class AnImplementation implements AnInterface {
-    private final String theName;
+        @Override
+        public AnInterface read(JsonReader jsonReader) throws IOException {
+            jsonReader.beginObject();
+
+            String name = null;
+            while (jsonReader.peek() != JsonToken.END_OBJECT) {
+                switch (jsonReader.nextName()) {
+                    case "name":
+                        name = jsonReader.nextString();
+                        break;
+                }
+            }
+
+            jsonReader.endObject();
+            return new AnImplementation(name);
+        }
+    }
 
-    AnImplementation(String name) {
-      theName = name;
+    interface Service {
+        @POST("/")
+        Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+
+        @POST("/")
+        Call<AnInterface> anInterface(@Body AnInterface impl);
     }
 
-    @Override public String getName() {
-      return theName;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Gson gson = new GsonBuilder()
+                .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+                .setLenient()
+                .create();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(GsonConverterFactory.create(gson))
+                .build();
+        service = retrofit.create(Service.class);
     }
-  }
 
-  static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
-    @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
+    @Test
+    public void anInterface() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+        Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+        Response<AnInterface> response = call.execute();
+        AnInterface body = response.body();
+        assertThat(body.getName()).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
 
-    @Override public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
+    @Test
+    public void anImplementation() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
 
-      String name = null;
-      while (jsonReader.peek() != JsonToken.END_OBJECT) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    }
+
+    @Test
+    public void serializeUsesConfiguration() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{}"));
+
+        service.anImplementation(new AnImplementation(null)).execute();
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    }
+
+    @Test
+    public void deserializeUsesConfiguration() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
 
-      jsonReader.endObject();
-      return new AnImplementation(name);
+        Response<AnImplementation> response =
+                service.anImplementation(new AnImplementation("value")).execute();
+        assertThat(response.body().getName()).isNull();
     }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
-        .setLenient()
-        .create();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(GsonConverterFactory.create(gson))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void serializeUsesConfiguration() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{}"));
-
-    service.anImplementation(new AnImplementation(null)).execute();
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void deserializeUsesConfiguration() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
-
-    Response<AnImplementation> response =
-        service.anImplementation(new AnImplementation("value")).execute();
-    assertThat(response.body().getName()).isNull();
-  }
 }
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 89765a744..ea1d64e02 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -1,43 +1,45 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-jackson</artifactId>
-  <name>Converter: Jackson</name>
+    <artifactId>converter-jackson</artifactId>
+    <name>Converter: Jackson</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.fasterxml.jackson.core</groupId>
-      <artifactId>jackson-databind</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index f6db311be..013a2d85d 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -19,8 +19,10 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -28,43 +30,47 @@
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Jackson.
- * <p>
+ * <p/>
  * Because Jackson is so flexible in the types it supports, this converter assumes that it can
  * handle all types. If you are mixing JSON serialization with something else (such as protocol
  * buffers), you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this
  * instance} last to allow the other converters a chance to see their types.
  */
 public final class JacksonConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
-  public static JacksonConverterFactory create() {
-    return create(new ObjectMapper());
-  }
+    /**
+     * Create an instance using a default {@link ObjectMapper} instance for conversion.
+     */
+    public static JacksonConverterFactory create() {
+        return create(new ObjectMapper());
+    }
 
-  /** Create an instance using {@code mapper} for conversion. */
-  public static JacksonConverterFactory create(ObjectMapper mapper) {
-    return new JacksonConverterFactory(mapper);
-  }
+    /**
+     * Create an instance using {@code mapper} for conversion.
+     */
+    public static JacksonConverterFactory create(ObjectMapper mapper) {
+        return new JacksonConverterFactory(mapper);
+    }
 
-  private final ObjectMapper mapper;
+    private final ObjectMapper mapper;
 
-  private JacksonConverterFactory(ObjectMapper mapper) {
-    if (mapper == null) throw new NullPointerException("mapper == null");
-    this.mapper = mapper;
-  }
+    private JacksonConverterFactory(ObjectMapper mapper) {
+        if (mapper == null) throw new NullPointerException("mapper == null");
+        this.mapper = mapper;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectReader reader = mapper.reader(javaType);
-    return new JacksonResponseBodyConverter<>(reader);
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        JavaType javaType = mapper.getTypeFactory().constructType(type);
+        ObjectReader reader = mapper.reader(javaType);
+        return new JacksonResponseBodyConverter<>(reader);
+    }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerWithType(javaType);
-    return new JacksonRequestBodyConverter<>(writer);
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        JavaType javaType = mapper.getTypeFactory().constructType(type);
+        ObjectWriter writer = mapper.writerWithType(javaType);
+        return new JacksonRequestBodyConverter<>(writer);
+    }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index bd20a0ae0..103701ae7 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -16,22 +16,25 @@
 package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectWriter;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
-  private final ObjectWriter adapter;
+    private final ObjectWriter adapter;
 
-  JacksonRequestBodyConverter(ObjectWriter adapter) {
-    this.adapter = adapter;
-  }
+    JacksonRequestBodyConverter(ObjectWriter adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    byte[] bytes = adapter.writeValueAsBytes(value);
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        byte[] bytes = adapter.writeValueAsBytes(value);
+        return RequestBody.create(MEDIA_TYPE, bytes);
+    }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
index f51fde7df..b329d5de6 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
@@ -16,22 +16,25 @@
 package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectReader;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final ObjectReader adapter;
+    private final ObjectReader adapter;
 
-  JacksonResponseBodyConverter(ObjectReader adapter) {
-    this.adapter = adapter;
-  }
+    JacksonResponseBodyConverter(ObjectReader adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return adapter.readValue(value.charStream());
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return adapter.readValue(value.charStream());
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
index 19c18538e..485774d3e 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
@@ -26,13 +26,17 @@
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -43,117 +47,127 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JacksonConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
+    interface AnInterface {
+        String getName();
+    }
 
-  static class AnImplementation implements AnInterface {
-    private String theName;
+    static class AnImplementation implements AnInterface {
+        private String theName;
 
-    AnImplementation() {
-    }
+        AnImplementation() {
+        }
+
+        AnImplementation(String name) {
+            theName = name;
+        }
 
-    AnImplementation(String name) {
-      theName = name;
+        @Override
+        public String getName() {
+            return theName;
+        }
     }
 
-    @Override public String getName() {
-      return theName;
+    static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
+        AnInterfaceSerializer() {
+            super(AnInterface.class);
+        }
+
+        @Override
+        public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
+                              SerializerProvider serializerProvider) throws IOException {
+            jsonGenerator.writeStartObject();
+            jsonGenerator.writeFieldName("name");
+            jsonGenerator.writeString(anInterface.getName());
+            jsonGenerator.writeEndObject();
+        }
     }
-  }
 
-  static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
-    AnInterfaceSerializer() {
-      super(AnInterface.class);
+    static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
+        AnInterfaceDeserializer() {
+            super(AnInterface.class);
+        }
+
+        @Override
+        public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
+                throws IOException {
+            if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
+                throw new AssertionError("Expected start object.");
+            }
+
+            String name = null;
+
+            while (jp.nextToken() != JsonToken.END_OBJECT) {
+                switch (jp.getCurrentName()) {
+                    case "name":
+                        name = jp.getValueAsString();
+                        break;
+                }
+            }
+
+            return new AnImplementation(name);
+        }
     }
 
-    @Override public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
-        SerializerProvider serializerProvider) throws IOException {
-      jsonGenerator.writeStartObject();
-      jsonGenerator.writeFieldName("name");
-      jsonGenerator.writeString(anInterface.getName());
-      jsonGenerator.writeEndObject();
+    interface Service {
+        @POST("/")
+        Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+
+        @POST("/")
+        Call<AnInterface> anInterface(@Body AnInterface impl);
     }
-  }
 
-  static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
-    AnInterfaceDeserializer() {
-      super(AnInterface.class);
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        SimpleModule module = new SimpleModule();
+        module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
+        module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
+        ObjectMapper mapper = new ObjectMapper();
+        mapper.registerModule(module);
+        mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
+        mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
+        mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
+        mapper.setVisibilityChecker(mapper.getSerializationConfig()
+                .getDefaultVisibilityChecker()
+                .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(JacksonConverterFactory.create(mapper))
+                .build();
+        service = retrofit.create(Service.class);
     }
 
-    @Override public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
-        throws IOException {
-      if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
-        throw new AssertionError("Expected start object.");
-      }
+    @Test
+    public void anInterface() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
 
-      String name = null;
+        Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+        Response<AnInterface> response = call.execute();
+        AnInterface body = response.body();
+        assertThat(body.getName()).isEqualTo("value");
 
-      while (jp.nextToken() != JsonToken.END_OBJECT) {
-        switch (jp.getCurrentName()) {
-          case "name":
-            name = jp.getValueAsString();
-            break;
-        }
-      }
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    }
+
+    @Test
+    public void anImplementation() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
 
-      return new AnImplementation(name);
+        RecordedRequest request = server.takeRequest();
+        // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    SimpleModule module = new SimpleModule();
-    module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
-    module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
-    ObjectMapper mapper = new ObjectMapper();
-    mapper.registerModule(module);
-    mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
-    mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
-    mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
-    mapper.setVisibilityChecker(mapper.getSerializationConfig()
-        .getDefaultVisibilityChecker()
-        .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(JacksonConverterFactory.create(mapper))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
 }
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 913dd8353..d97a1dd4a 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -1,43 +1,45 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-moshi</artifactId>
-  <name>Converter: Moshi</name>
+    <artifactId>converter-moshi</artifactId>
+    <name>Converter: Moshi</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.moshi</groupId>
+            <artifactId>moshi</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index c4831f937..ea845155e 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -17,8 +17,10 @@
 
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.Moshi;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -26,54 +28,60 @@
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
- * <p>
+ * <p/>
  * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
  * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
  * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
  * last to allow the other converters a chance to see their types.
  */
 public final class MoshiConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Moshi} instance for conversion. */
-  public static MoshiConverterFactory create() {
-    return create(new Moshi.Builder().build());
-  }
+    /**
+     * Create an instance using a default {@link Moshi} instance for conversion.
+     */
+    public static MoshiConverterFactory create() {
+        return create(new Moshi.Builder().build());
+    }
 
-  /** Create an instance using {@code moshi} for conversion. */
-  public static MoshiConverterFactory create(Moshi moshi) {
-    return new MoshiConverterFactory(moshi, false);
-  }
+    /**
+     * Create an instance using {@code moshi} for conversion.
+     */
+    public static MoshiConverterFactory create(Moshi moshi) {
+        return new MoshiConverterFactory(moshi, false);
+    }
 
-  private final Moshi moshi;
-  private final boolean lenient;
+    private final Moshi moshi;
+    private final boolean lenient;
 
-  private MoshiConverterFactory(Moshi moshi, boolean lenient) {
-    if (moshi == null) throw new NullPointerException("moshi == null");
-    this.moshi = moshi;
-    this.lenient = lenient;
-  }
+    private MoshiConverterFactory(Moshi moshi, boolean lenient) {
+        if (moshi == null) throw new NullPointerException("moshi == null");
+        this.moshi = moshi;
+        this.lenient = lenient;
+    }
 
-  /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
-  public MoshiConverterFactory asLenient() {
-    return new MoshiConverterFactory(moshi, true);
-  }
+    /**
+     * Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters.
+     */
+    public MoshiConverterFactory asLenient() {
+        return new MoshiConverterFactory(moshi, true);
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
-    if (lenient) {
-      adapter = adapter.lenient();
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        JsonAdapter<?> adapter = moshi.adapter(type);
+        if (lenient) {
+            adapter = adapter.lenient();
+        }
+        return new MoshiResponseBodyConverter<>(adapter);
     }
-    return new MoshiResponseBodyConverter<>(adapter);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type);
-    if (lenient) {
-      adapter = adapter.lenient();
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        JsonAdapter<?> adapter = moshi.adapter(type);
+        if (lenient) {
+            adapter = adapter.lenient();
+        }
+        return new MoshiRequestBodyConverter<>(adapter);
     }
-    return new MoshiRequestBodyConverter<>(adapter);
-  }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index ac3d095d3..342c158a5 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -16,24 +16,27 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
 import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
-  private final JsonAdapter<T> adapter;
+    private final JsonAdapter<T> adapter;
 
-  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    adapter.toJson(buffer, value);
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        adapter.toJson(buffer, value);
+        return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+    }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index b45b99c42..fdbda4363 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -16,22 +16,25 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final JsonAdapter<T> adapter;
+    private final JsonAdapter<T> adapter;
 
-  MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return adapter.fromJson(value.source());
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return adapter.fromJson(value.source());
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index 3a54a7ebe..f8facbf16 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -20,13 +20,17 @@
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.ToJson;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -38,117 +42,128 @@
 import static org.junit.Assert.fail;
 
 public final class MoshiConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
+    interface AnInterface {
+        String getName();
+    }
 
-  static class AnImplementation implements AnInterface {
-    private final String theName;
+    static class AnImplementation implements AnInterface {
+        private final String theName;
 
-    AnImplementation(String name) {
-      theName = name;
+        AnImplementation(String name) {
+            theName = name;
+        }
+
+        @Override
+        public String getName() {
+            return theName;
+        }
     }
 
-    @Override public String getName() {
-      return theName;
+    static class AnInterfaceAdapter {
+        @ToJson
+        public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+            jsonWriter.beginObject();
+            jsonWriter.name("name").value(anInterface.getName());
+            jsonWriter.endObject();
+        }
+
+        @FromJson
+        public AnInterface read(JsonReader jsonReader) throws IOException {
+            jsonReader.beginObject();
+
+            String name = null;
+            while (jsonReader.hasNext()) {
+                switch (jsonReader.nextName()) {
+                    case "name":
+                        name = jsonReader.nextString();
+                        break;
+                }
+            }
+
+            jsonReader.endObject();
+            return new AnImplementation(name);
+        }
     }
-  }
 
-  static class AnInterfaceAdapter {
-    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
+    interface Service {
+        @POST("/")
+        Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+
+        @POST("/")
+        Call<AnInterface> anInterface(@Body AnInterface impl);
     }
 
-    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+    private Service serviceLenient;
+
+    @Before
+    public void setUp() {
+        Moshi moshi = new Moshi.Builder()
+                .add(new AnInterfaceAdapter())
+                .build();
+        MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
+        MoshiConverterFactory factoryLenient = factory.asLenient();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(factory)
+                .build();
+        Retrofit retrofitLenient = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(factoryLenient)
+                .build();
+        service = retrofit.create(Service.class);
+        serviceLenient = retrofitLenient.create(Service.class);
+    }
 
-      String name = null;
-      while (jsonReader.hasNext()) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
+    @Test
+    public void anInterface() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
 
-      jsonReader.endObject();
-      return new AnImplementation(name);
+        Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+        Response<AnInterface> response = call.execute();
+        AnInterface body = response.body();
+        assertThat(body.getName()).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-  private Service serviceLenient;
-
-  @Before public void setUp() {
-    Moshi moshi = new Moshi.Builder()
-        .add(new AnInterfaceAdapter())
-        .build();
-    MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
-    MoshiConverterFactory factoryLenient = factory.asLenient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factory)
-        .build();
-    Retrofit retrofitLenient = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factoryLenient)
-        .build();
-    service = retrofit.create(Service.class);
-    serviceLenient = retrofitLenient.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void asLenient() throws IOException, InterruptedException {
-    MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
-    server.enqueue(malformedResponse);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertEquals(e.getMessage(),
-          "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+
+    @Test
+    public void anImplementation() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
 
-    Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call2.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-  }
+    @Test
+    public void asLenient() throws IOException, InterruptedException {
+        MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
+        server.enqueue(malformedResponse);
+        server.enqueue(malformedResponse);
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertEquals(e.getMessage(),
+                    "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+        }
+
+        Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call2.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
+    }
 }
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 87b1463cc..06884e7f2 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -1,26 +1,28 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit-converters</artifactId>
-  <name>Converters</name>
-  <packaging>pom</packaging>
+    <artifactId>retrofit-converters</artifactId>
+    <name>Converters</name>
+    <packaging>pom</packaging>
 
-  <modules>
-    <module>gson</module>
-    <module>protobuf</module>
-    <module>jackson</module>
-    <module>wire</module>
-    <module>simplexml</module>
-    <module>scalars</module>
-    <module>moshi</module>
-  </modules>
+    <modules>
+        <module>gson</module>
+        <module>protobuf</module>
+        <module>jackson</module>
+        <module>wire</module>
+        <module>simplexml</module>
+        <module>scalars</module>
+        <module>moshi</module>
+    </modules>
 </project>
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 24f0f6865..4e7979153 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -1,43 +1,45 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-protobuf</artifactId>
-  <name>Converter: Protocol Buffers</name>
+    <artifactId>converter-protobuf</artifactId>
+    <name>Converter: Protocol Buffers</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.protobuf</groupId>
-      <artifactId>protobuf-java</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.protobuf</groupId>
+            <artifactId>protobuf-java</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index 9b544eb0d..b4d4a7886 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -18,9 +18,11 @@
 import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -28,58 +30,60 @@
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
- * <p>
+ * <p/>
  * This converter only applies for types which extend from {@link MessageLite} (or one of its
  * subclasses).
  */
 public final class ProtoConverterFactory extends Converter.Factory {
-  public static ProtoConverterFactory create() {
-    return new ProtoConverterFactory(null);
-  }
-
-  /** Create an instance which uses {@code registry} when deserializing. */
-  public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
-    return new ProtoConverterFactory(registry);
-  }
+    public static ProtoConverterFactory create() {
+        return new ProtoConverterFactory(null);
+    }
 
-  private final ExtensionRegistryLite registry;
+    /**
+     * Create an instance which uses {@code registry} when deserializing.
+     */
+    public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
+        return new ProtoConverterFactory(registry);
+    }
 
-  private ProtoConverterFactory(ExtensionRegistryLite registry) {
-    this.registry = registry;
-  }
+    private final ExtensionRegistryLite registry;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
-    }
-    Class<?> c = (Class<?>) type;
-    if (!MessageLite.class.isAssignableFrom(c)) {
-      return null;
+    private ProtoConverterFactory(ExtensionRegistryLite registry) {
+        this.registry = registry;
     }
 
-    Parser<MessageLite> parser;
-    try {
-      Field field = c.getDeclaredField("PARSER");
-      //noinspection unchecked
-      parser = (Parser<MessageLite>) field.get(null);
-    } catch (NoSuchFieldException | IllegalAccessException e) {
-      throw new IllegalArgumentException(
-          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
-    }
-    return new ProtoResponseBodyConverter<>(parser, registry);
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        Class<?> c = (Class<?>) type;
+        if (!MessageLite.class.isAssignableFrom(c)) {
+            return null;
+        }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
+        Parser<MessageLite> parser;
+        try {
+            Field field = c.getDeclaredField("PARSER");
+            //noinspection unchecked
+            parser = (Parser<MessageLite>) field.get(null);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            throw new IllegalArgumentException(
+                    "Found a protobuf message but " + c.getName() + " had no PARSER field.");
+        }
+        return new ProtoResponseBodyConverter<>(parser, registry);
     }
-    if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
-      return null;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
+            return null;
+        }
+        return new ProtoRequestBodyConverter<>();
     }
-    return new ProtoRequestBodyConverter<>();
-  }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 814dc326b..d515819b4 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -16,16 +16,19 @@
 package retrofit2.converter.protobuf;
 
 import com.google.protobuf.MessageLite;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public RequestBody convert(T value) throws IOException {
-    byte[] bytes = value.toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        byte[] bytes = value.toByteArray();
+        return RequestBody.create(MEDIA_TYPE, bytes);
+    }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index 324199458..73ae0b11f 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -19,27 +19,30 @@
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
-    implements Converter<ResponseBody, T> {
-  private final Parser<T> parser;
-  private final ExtensionRegistryLite registry;
+        implements Converter<ResponseBody, T> {
+    private final Parser<T> parser;
+    private final ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
-    this.parser = parser;
-    this.registry = registry;
-  }
+    ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
+        this.parser = parser;
+        this.registry = registry;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return parser.parseFrom(value.byteStream(), registry);
-    } catch (InvalidProtocolBufferException e) {
-      throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return parser.parseFrom(value.byteStream(), registry);
+        } catch (InvalidProtocolBufferException e) {
+            throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
index 99d2bb208..0bc5d38e9 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
@@ -4,555 +4,606 @@
 package retrofit2.converter.protobuf;
 
 public final class PhoneProtos {
-  private PhoneProtos() {}
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistry registry) {
-    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
-  }
-  public interface PhoneOrBuilder extends
-      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
-      com.google.protobuf.GeneratedMessage.
-          ExtendableMessageOrBuilder<Phone> {
-
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    boolean hasNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    java.lang.String getNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    com.google.protobuf.ByteString
-        getNumberBytes();
-  }
-  /**
-   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-   */
-  public static final class Phone extends
-      com.google.protobuf.GeneratedMessage.ExtendableMessage<
-        Phone> implements
-      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
-      PhoneOrBuilder {
-    // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
-      super(builder);
-      this.unknownFields = builder.getUnknownFields();
+    private PhoneProtos() {
     }
-    private Phone(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
 
-    private static final Phone defaultInstance;
-    public static Phone getDefaultInstance() {
-      return defaultInstance;
+    public static void registerAllExtensions(
+            com.google.protobuf.ExtensionRegistry registry) {
+        registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
     }
 
-    public Phone getDefaultInstanceForType() {
-      return defaultInstance;
+    public interface PhoneOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
+            com.google.protobuf.GeneratedMessage.
+                    ExtendableMessageOrBuilder<Phone> {
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        boolean hasNumber();
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        java.lang.String getNumber();
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        com.google.protobuf.ByteString
+        getNumberBytes();
     }
 
-    private final com.google.protobuf.UnknownFieldSet unknownFields;
-    @java.lang.Override
-    public final com.google.protobuf.UnknownFieldSet
+    /**
+     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+     */
+    public static final class Phone extends
+            com.google.protobuf.GeneratedMessage.ExtendableMessage<
+                    Phone> implements
+            // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
+            PhoneOrBuilder {
+        // Use Phone.newBuilder() to construct.
+        private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
+            super(builder);
+            this.unknownFields = builder.getUnknownFields();
+        }
+
+        private Phone(boolean noInit) {
+            this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance();
+        }
+
+        private static final Phone defaultInstance;
+
+        public static Phone getDefaultInstance() {
+            return defaultInstance;
+        }
+
+        public Phone getDefaultInstanceForType() {
+            return defaultInstance;
+        }
+
+        private final com.google.protobuf.UnknownFieldSet unknownFields;
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
         getUnknownFields() {
-      return this.unknownFields;
-    }
-    private Phone(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      initFields();
-      int mutable_bitField0_ = 0;
-      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
-          com.google.protobuf.UnknownFieldSet.newBuilder();
-      try {
-        boolean done = false;
-        while (!done) {
-          int tag = input.readTag();
-          switch (tag) {
-            case 0:
-              done = true;
-              break;
-            default: {
-              if (!parseUnknownField(input, unknownFields,
-                                     extensionRegistry, tag)) {
-                done = true;
-              }
-              break;
-            }
-            case 10: {
-              com.google.protobuf.ByteString bs = input.readBytes();
-              bitField0_ |= 0x00000001;
-              number_ = bs;
-              break;
+            return this.unknownFields;
+        }
+
+        private Phone(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            initFields();
+            int mutable_bitField0_ = 0;
+            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+                    com.google.protobuf.UnknownFieldSet.newBuilder();
+            try {
+                boolean done = false;
+                while (!done) {
+                    int tag = input.readTag();
+                    switch (tag) {
+                        case 0:
+                            done = true;
+                            break;
+                        default: {
+                            if (!parseUnknownField(input, unknownFields,
+                                    extensionRegistry, tag)) {
+                                done = true;
+                            }
+                            break;
+                        }
+                        case 10: {
+                            com.google.protobuf.ByteString bs = input.readBytes();
+                            bitField0_ |= 0x00000001;
+                            number_ = bs;
+                            break;
+                        }
+                    }
+                }
+            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                throw e.setUnfinishedMessage(this);
+            } catch (java.io.IOException e) {
+                throw new com.google.protobuf.InvalidProtocolBufferException(
+                        e.getMessage()).setUnfinishedMessage(this);
+            } finally {
+                this.unknownFields = unknownFields.build();
+                makeExtensionsImmutable();
             }
-          }
-        }
-      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-        throw e.setUnfinishedMessage(this);
-      } catch (java.io.IOException e) {
-        throw new com.google.protobuf.InvalidProtocolBufferException(
-            e.getMessage()).setUnfinishedMessage(this);
-      } finally {
-        this.unknownFields = unknownFields.build();
-        makeExtensionsImmutable();
-      }
-    }
-    public static final com.google.protobuf.Descriptors.Descriptor
+        }
+
+        public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-    }
+            return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+        }
 
-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-          .ensureFieldAccessorsInitialized(
-              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-    }
+            return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+        }
 
-    public static com.google.protobuf.Parser<Phone> PARSER =
-        new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-        return new Phone(input, extensionRegistry);
-      }
-    };
-
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
-    }
+        public static com.google.protobuf.Parser<Phone> PARSER =
+                new com.google.protobuf.AbstractParser<Phone>() {
+                    public Phone parsePartialFrom(
+                            com.google.protobuf.CodedInputStream input,
+                            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                            throws com.google.protobuf.InvalidProtocolBufferException {
+                        return new Phone(input, extensionRegistry);
+                    }
+                };
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<Phone> getParserForType() {
+            return PARSER;
+        }
 
-    private int bitField0_;
-    public static final int NUMBER_FIELD_NUMBER = 1;
-    private java.lang.Object number_;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public boolean hasNumber() {
-      return ((bitField0_ & 0x00000001) == 0x00000001);
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public java.lang.String getNumber() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        return (java.lang.String) ref;
-      } else {
-        com.google.protobuf.ByteString bs = 
-            (com.google.protobuf.ByteString) ref;
-        java.lang.String s = bs.toStringUtf8();
-        if (bs.isValidUtf8()) {
-          number_ = s;
-        }
-        return s;
-      }
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public com.google.protobuf.ByteString
+        private int bitField0_;
+        public static final int NUMBER_FIELD_NUMBER = 1;
+        private java.lang.Object number_;
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        public boolean hasNumber() {
+            return ((bitField0_ & 0x00000001) == 0x00000001);
+        }
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        public java.lang.String getNumber() {
+            java.lang.Object ref = number_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                if (bs.isValidUtf8()) {
+                    number_ = s;
+                }
+                return s;
+            }
+        }
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        public com.google.protobuf.ByteString
         getNumberBytes() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b = 
-            com.google.protobuf.ByteString.copyFromUtf8(
-                (java.lang.String) ref);
-        number_ = b;
-        return b;
-      } else {
-        return (com.google.protobuf.ByteString) ref;
-      }
-    }
+            java.lang.Object ref = number_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                number_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
 
-    private void initFields() {
-      number_ = "";
-    }
-    private byte memoizedIsInitialized = -1;
-    public final boolean isInitialized() {
-      byte isInitialized = memoizedIsInitialized;
-      if (isInitialized == 1) return true;
-      if (isInitialized == 0) return false;
-
-      if (!extensionsAreInitialized()) {
-        memoizedIsInitialized = 0;
-        return false;
-      }
-      memoizedIsInitialized = 1;
-      return true;
-    }
+        private void initFields() {
+            number_ = "";
+        }
 
-    public void writeTo(com.google.protobuf.CodedOutputStream output)
-                        throws java.io.IOException {
-      getSerializedSize();
-      com.google.protobuf.GeneratedMessage
-        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter extensionWriter =
-          newExtensionWriter();
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        output.writeBytes(1, getNumberBytes());
-      }
-      extensionWriter.writeUntil(3, output);
-      getUnknownFields().writeTo(output);
-    }
+        private byte memoizedIsInitialized = -1;
 
-    private int memoizedSerializedSize = -1;
-    public int getSerializedSize() {
-      int size = memoizedSerializedSize;
-      if (size != -1) return size;
-
-      size = 0;
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.CodedOutputStream
-          .computeBytesSize(1, getNumberBytes());
-      }
-      size += extensionsSerializedSize();
-      size += getUnknownFields().getSerializedSize();
-      memoizedSerializedSize = size;
-      return size;
-    }
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
 
-    private static final long serialVersionUID = 0L;
-    @java.lang.Override
-    protected java.lang.Object writeReplace()
-        throws java.io.ObjectStreamException {
-      return super.writeReplace();
-    }
+            if (!extensionsAreInitialized()) {
+                memoizedIsInitialized = 0;
+                return false;
+            }
+            memoizedIsInitialized = 1;
+            return true;
+        }
 
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        byte[] data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseDelimitedFrom(input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return PARSER.parseFrom(input, extensionRegistry);
-    }
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            getSerializedSize();
+            com.google.protobuf.GeneratedMessage
+                    .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter extensionWriter =
+                    newExtensionWriter();
+            if (((bitField0_ & 0x00000001) == 0x00000001)) {
+                output.writeBytes(1, getNumberBytes());
+            }
+            extensionWriter.writeUntil(3, output);
+            getUnknownFields().writeTo(output);
+        }
 
-    public static Builder newBuilder() { return Builder.create(); }
-    public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
-      return newBuilder().mergeFrom(prototype);
-    }
-    public Builder toBuilder() { return newBuilder(this); }
+        private int memoizedSerializedSize = -1;
+
+        public int getSerializedSize() {
+            int size = memoizedSerializedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (((bitField0_ & 0x00000001) == 0x00000001)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBytesSize(1, getNumberBytes());
+            }
+            size += extensionsSerializedSize();
+            size += getUnknownFields().getSerializedSize();
+            memoizedSerializedSize = size;
+            return size;
+        }
+
+        private static final long serialVersionUID = 0L;
+
+        @java.lang.Override
+        protected java.lang.Object writeReplace()
+                throws java.io.ObjectStreamException {
+            return super.writeReplace();
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
 
-    @java.lang.Override
-    protected Builder newBuilderForType(
-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-      Builder builder = new Builder(parent);
-      return builder;
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return PARSER.parseFrom(input);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return PARSER.parseFrom(input, extensionRegistry);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return PARSER.parseDelimitedFrom(input);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return PARSER.parseDelimitedFrom(input, extensionRegistry);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return PARSER.parseFrom(input);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return PARSER.parseFrom(input, extensionRegistry);
+        }
+
+        public static Builder newBuilder() {
+            return Builder.create();
+        }
+
+        public Builder newBuilderForType() {
+            return newBuilder();
+        }
+
+        public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
+            return newBuilder().mergeFrom(prototype);
+        }
+
+        public Builder toBuilder() {
+            return newBuilder(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+
+        /**
+         * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessage.ExtendableBuilder<
+                        retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
+                // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
+                retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+            }
+
+            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+            }
+
+            // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
+            private Builder() {
+                maybeForceBuilderInitialization();
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+                super(parent);
+                maybeForceBuilderInitialization();
+            }
+
+            private void maybeForceBuilderInitialization() {
+                if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+                }
+            }
+
+            private static Builder create() {
+                return new Builder();
+            }
+
+            public Builder clear() {
+                super.clear();
+                number_ = "";
+                bitField0_ = (bitField0_ & ~0x00000001);
+                return this;
+            }
+
+            public Builder clone() {
+                return create().mergeFrom(buildPartial());
+            }
+
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+            }
+
+            public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+                return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
+            }
+
+            public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
+                retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
+                retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
+                int from_bitField0_ = bitField0_;
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.number_ = number_;
+                result.bitField0_ = to_bitField0_;
+                onBuilt();
+                return result;
+            }
+
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
+                    return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone) other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
+                if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance())
+                    return this;
+                if (other.hasNumber()) {
+                    bitField0_ |= 0x00000001;
+                    number_ = other.number_;
+                    onChanged();
+                }
+                this.mergeExtensionFields(other);
+                this.mergeUnknownFields(other.getUnknownFields());
+                return this;
+            }
+
+            public final boolean isInitialized() {
+                if (!extensionsAreInitialized()) {
+
+                    return false;
+                }
+                return true;
+            }
+
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
+                try {
+                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
+                    throw e;
+                } finally {
+                    if (parsedMessage != null) {
+                        mergeFrom(parsedMessage);
+                    }
+                }
+                return this;
+            }
+
+            private int bitField0_;
+
+            private java.lang.Object number_ = "";
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public boolean hasNumber() {
+                return ((bitField0_ & 0x00000001) == 0x00000001);
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public java.lang.String getNumber() {
+                java.lang.Object ref = number_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    if (bs.isValidUtf8()) {
+                        number_ = s;
+                    }
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public com.google.protobuf.ByteString
+            getNumberBytes() {
+                java.lang.Object ref = number_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    number_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public Builder setNumber(
+                    java.lang.String value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                number_ = value;
+                onChanged();
+                return this;
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public Builder clearNumber() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                number_ = getDefaultInstance().getNumber();
+                onChanged();
+                return this;
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public Builder setNumberBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                number_ = value;
+                onChanged();
+                return this;
+            }
+
+            // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
+        }
+
+        static {
+            defaultInstance = new Phone(true);
+            defaultInstance.initFields();
+        }
+
+        // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
     }
+
+    public static final int VOICEMAIL_FIELD_NUMBER = 2;
     /**
-     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+     * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
      */
-    public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
-          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
-        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
-        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
-      public static final com.google.protobuf.Descriptors.Descriptor
-          getDescriptor() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-          internalGetFieldAccessorTable() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-            .ensureFieldAccessorsInitialized(
-                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-      }
-
-      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
-      private Builder() {
-        maybeForceBuilderInitialization();
-      }
-
-      private Builder(
-          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-        super(parent);
-        maybeForceBuilderInitialization();
-      }
-      private void maybeForceBuilderInitialization() {
-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-        }
-      }
-      private static Builder create() {
-        return new Builder();
-      }
-
-      public Builder clear() {
-        super.clear();
-        number_ = "";
-        bitField0_ = (bitField0_ & ~0x00000001);
-        return this;
-      }
-
-      public Builder clone() {
-        return create().mergeFrom(buildPartial());
-      }
-
-      public com.google.protobuf.Descriptors.Descriptor
-          getDescriptorForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
-        if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
-        }
-        return result;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
-        int from_bitField0_ = bitField0_;
-        int to_bitField0_ = 0;
-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
-          to_bitField0_ |= 0x00000001;
-        }
-        result.number_ = number_;
-        result.bitField0_ = to_bitField0_;
-        onBuilt();
-        return result;
-      }
-
-      public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
-          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
-        } else {
-          super.mergeFrom(other);
-          return this;
-        }
-      }
-
-      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
-        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
-        if (other.hasNumber()) {
-          bitField0_ |= 0x00000001;
-          number_ = other.number_;
-          onChanged();
-        }
-        this.mergeExtensionFields(other);
-        this.mergeUnknownFields(other.getUnknownFields());
-        return this;
-      }
-
-      public final boolean isInitialized() {
-        if (!extensionsAreInitialized()) {
-          
-          return false;
-        }
-        return true;
-      }
-
-      public Builder mergeFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws java.io.IOException {
-        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
-        try {
-          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
-        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e;
-        } finally {
-          if (parsedMessage != null) {
-            mergeFrom(parsedMessage);
-          }
-        }
-        return this;
-      }
-      private int bitField0_;
-
-      private java.lang.Object number_ = "";
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public boolean hasNumber() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public java.lang.String getNumber() {
-        java.lang.Object ref = number_;
-        if (!(ref instanceof java.lang.String)) {
-          com.google.protobuf.ByteString bs =
-              (com.google.protobuf.ByteString) ref;
-          java.lang.String s = bs.toStringUtf8();
-          if (bs.isValidUtf8()) {
-            number_ = s;
-          }
-          return s;
-        } else {
-          return (java.lang.String) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public com.google.protobuf.ByteString
-          getNumberBytes() {
-        java.lang.Object ref = number_;
-        if (ref instanceof String) {
-          com.google.protobuf.ByteString b = 
-              com.google.protobuf.ByteString.copyFromUtf8(
-                  (java.lang.String) ref);
-          number_ = b;
-          return b;
-        } else {
-          return (com.google.protobuf.ByteString) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumber(
-          java.lang.String value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder clearNumber() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        number_ = getDefaultInstance().getNumber();
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumberBytes(
-          com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-
-      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
-    }
+    public static final
+    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+            retrofit2.converter.protobuf.PhoneProtos.Phone,
+            java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
+            .newFileScopedGeneratedExtension(
+                    java.lang.Boolean.class,
+                    null);
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+    private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+            internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
 
-    static {
-      defaultInstance = new Phone(true);
-      defaultInstance.initFields();
+    public static com.google.protobuf.Descriptors.FileDescriptor
+    getDescriptor() {
+        return descriptor;
     }
 
-    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
-  }
+    private static com.google.protobuf.Descriptors.FileDescriptor
+            descriptor;
 
-  public static final int VOICEMAIL_FIELD_NUMBER = 2;
-  /**
-   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
-   */
-  public static final
-    com.google.protobuf.GeneratedMessage.GeneratedExtension<
-      retrofit2.converter.protobuf.PhoneProtos.Phone,
-      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
-          .newFileScopedGeneratedExtension(
-        java.lang.Boolean.class,
-        null);
-  private static final com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-  private static
-    com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
-
-  public static com.google.protobuf.Descriptors.FileDescriptor
-      getDescriptor() {
-    return descriptor;
-  }
-  private static com.google.protobuf.Descriptors.FileDescriptor
-      descriptor;
-  static {
-    java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\034retrofit2.converte" +
-      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
-      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
-      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
-      ".protobufB\013PhoneProtos"
-    };
-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
-          public com.google.protobuf.ExtensionRegistry assignDescriptors(
-              com.google.protobuf.Descriptors.FileDescriptor root) {
-            descriptor = root;
-            return null;
-          }
+    static {
+        java.lang.String[] descriptorData = {
+                "\n\022protos/phone.proto\022\034retrofit2.converte" +
+                        "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
+                        "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
+                        "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
+                        ".protobufB\013PhoneProtos"
         };
-    com.google.protobuf.Descriptors.FileDescriptor
-      .internalBuildGeneratedFileFrom(descriptorData,
-        new com.google.protobuf.Descriptors.FileDescriptor[] {
-        }, assigner);
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
-      getDescriptor().getMessageTypes().get(0);
-    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
-      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
-        new java.lang.String[] { "Number", });
-    voicemail.internalInit(descriptor.getExtensions().get(0));
-  }
-
-  // @@protoc_insertion_point(outer_class_scope)
+        com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
+                new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
+                    public com.google.protobuf.ExtensionRegistry assignDescriptors(
+                            com.google.protobuf.Descriptors.FileDescriptor root) {
+                        descriptor = root;
+                        return null;
+                    }
+                };
+        com.google.protobuf.Descriptors.FileDescriptor
+                .internalBuildGeneratedFileFrom(descriptorData,
+                        new com.google.protobuf.Descriptors.FileDescriptor[]{
+                        }, assigner);
+        internal_static_retrofit2_converter_protobuf_Phone_descriptor =
+                getDescriptor().getMessageTypes().get(0);
+        internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+                internal_static_retrofit2_converter_protobuf_Phone_descriptor,
+                new java.lang.String[]{"Number",});
+        voicemail.internalInit(descriptor.getExtensions().get(0));
+    }
+
+    // @@protoc_insertion_point(outer_class_scope)
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 5a585b21f..b011a8935 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -17,16 +17,20 @@
 
 import com.google.protobuf.ExtensionRegistry;
 import com.google.protobuf.InvalidProtocolBufferException;
+
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -39,120 +43,137 @@
 import static retrofit2.converter.protobuf.PhoneProtos.Phone;
 
 public final class ProtoConverterFactoryTest {
-  interface Service {
-    @GET("/") Call<Phone> get();
-    @POST("/") Call<Phone> post(@Body Phone impl);
-    @GET("/") Call<String> wrongClass();
-    @GET("/") Call<List<String>> wrongType();
-  }
-  interface ServiceWithRegistry {
-    @GET("/") Call<Phone> get();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-  private ServiceWithRegistry serviceWithRegistry;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ProtoConverterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-
-    ExtensionRegistry registry = ExtensionRegistry.newInstance();
-    PhoneProtos.registerAllExtensions(registry);
-    Retrofit retrofitWithRegistry = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
-        .build();
-    serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
-  }
-
-  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
-  }
-
-  @Test public void deserializeEmpty() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call<Phone> call = service.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.hasNumber()).isFalse();
-  }
-
-  @Test public void deserializeUsesRegistry() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = serviceWithRegistry.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
-    assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
-  }
-
-  @Test public void deserializeWrongClass() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongClass();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+    interface Service {
+        @GET("/")
+        Call<Phone> get();
+
+        @POST("/")
+        Call<Phone> post(@Body Phone impl);
+
+        @GET("/")
+        Call<String> wrongClass();
+
+        @GET("/")
+        Call<List<String>> wrongType();
     }
-  }
-
-  @Test public void deserializeWrongType() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongType();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for java.util.List<java.lang.String>\n"
-          + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+
+    interface ServiceWithRegistry {
+        @GET("/")
+        Call<Phone> get();
+    }
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+    private ServiceWithRegistry serviceWithRegistry;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ProtoConverterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+
+        ExtensionRegistry registry = ExtensionRegistry.newInstance();
+        PhoneProtos.registerAllExtensions(registry);
+        Retrofit retrofitWithRegistry = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
+                .build();
+        serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
     }
-  }
-
-  @Test public void deserializeWrongValue() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("////");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.get();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
-          .hasMessageContaining("input ended unexpectedly");
+
+    @Test
+    public void serializeAndDeserialize() throws IOException, InterruptedException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+    }
+
+    @Test
+    public void deserializeEmpty() throws IOException {
+        server.enqueue(new MockResponse());
+
+        Call<Phone> call = service.get();
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.hasNumber()).isFalse();
+    }
+
+    @Test
+    public void deserializeUsesRegistry() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<Phone> call = serviceWithRegistry.get();
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+        assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
+    }
+
+    @Test
+    public void deserializeWrongClass() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongClass();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method Service.wrongClass");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+        }
+    }
+
+    @Test
+    public void deserializeWrongType() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongType();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for java.util.List<java.lang.String>\n"
+                    + "    for method Service.wrongType");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+        }
+    }
+
+    @Test
+    public void deserializeWrongValue() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("////");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<?> call = service.get();
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
+                    .hasMessageContaining("input ended unexpectedly");
+        }
     }
-  }
 }
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index b8710068b..6eb5b41c5 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -1,39 +1,41 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-scalars</artifactId>
-  <name>Converter: Java Scalars</name>
+    <artifactId>converter-scalars</artifactId>
+    <name>Converter: Java Scalars</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index fd65200d4..bef837918 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -16,18 +16,20 @@
 package retrofit2.converter.scalars;
 
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import retrofit2.Converter;
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+    static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
+    private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
 
-  private ScalarRequestBodyConverter() {
-  }
+    private ScalarRequestBodyConverter() {
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
+    }
 }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
index a91d87c82..2368ba0d6 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
@@ -16,87 +16,97 @@
 package retrofit2.converter.scalars;
 
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ScalarResponseBodyConverters {
-  private ScalarResponseBodyConverters() {
-  }
+    private ScalarResponseBodyConverters() {
+    }
 
-  static final class StringResponseBodyConverter implements Converter<ResponseBody, String> {
-    static final StringResponseBodyConverter INSTANCE = new StringResponseBodyConverter();
+    static final class StringResponseBodyConverter implements Converter<ResponseBody, String> {
+        static final StringResponseBodyConverter INSTANCE = new StringResponseBodyConverter();
 
-    @Override public String convert(ResponseBody value) throws IOException {
-      return value.string();
+        @Override
+        public String convert(ResponseBody value) throws IOException {
+            return value.string();
+        }
     }
-  }
 
-  static final class BooleanResponseBodyConverter implements Converter<ResponseBody, Boolean> {
-    static final BooleanResponseBodyConverter INSTANCE = new BooleanResponseBodyConverter();
+    static final class BooleanResponseBodyConverter implements Converter<ResponseBody, Boolean> {
+        static final BooleanResponseBodyConverter INSTANCE = new BooleanResponseBodyConverter();
 
-    @Override public Boolean convert(ResponseBody value) throws IOException {
-      return Boolean.valueOf(value.string());
+        @Override
+        public Boolean convert(ResponseBody value) throws IOException {
+            return Boolean.valueOf(value.string());
+        }
     }
-  }
 
-  static final class ByteResponseBodyConverter implements Converter<ResponseBody, Byte> {
-    static final ByteResponseBodyConverter INSTANCE = new ByteResponseBodyConverter();
+    static final class ByteResponseBodyConverter implements Converter<ResponseBody, Byte> {
+        static final ByteResponseBodyConverter INSTANCE = new ByteResponseBodyConverter();
 
-    @Override public Byte convert(ResponseBody value) throws IOException {
-      return Byte.valueOf(value.string());
+        @Override
+        public Byte convert(ResponseBody value) throws IOException {
+            return Byte.valueOf(value.string());
+        }
     }
-  }
-
-  static final class CharacterResponseBodyConverter implements Converter<ResponseBody, Character> {
-    static final CharacterResponseBodyConverter INSTANCE = new CharacterResponseBodyConverter();
-
-    @Override public Character convert(ResponseBody value) throws IOException {
-      String body = value.string();
-      if (body.length() != 1) {
-        throw new IOException(
-            "Expected body of length 1 for Character conversion but was " + body.length());
-      }
-      return body.charAt(0);
+
+    static final class CharacterResponseBodyConverter implements Converter<ResponseBody, Character> {
+        static final CharacterResponseBodyConverter INSTANCE = new CharacterResponseBodyConverter();
+
+        @Override
+        public Character convert(ResponseBody value) throws IOException {
+            String body = value.string();
+            if (body.length() != 1) {
+                throw new IOException(
+                        "Expected body of length 1 for Character conversion but was " + body.length());
+            }
+            return body.charAt(0);
+        }
     }
-  }
 
-  static final class DoubleResponseBodyConverter implements Converter<ResponseBody, Double> {
-    static final DoubleResponseBodyConverter INSTANCE = new DoubleResponseBodyConverter();
+    static final class DoubleResponseBodyConverter implements Converter<ResponseBody, Double> {
+        static final DoubleResponseBodyConverter INSTANCE = new DoubleResponseBodyConverter();
 
-    @Override public Double convert(ResponseBody value) throws IOException {
-      return Double.valueOf(value.string());
+        @Override
+        public Double convert(ResponseBody value) throws IOException {
+            return Double.valueOf(value.string());
+        }
     }
-  }
 
-  static final class FloatResponseBodyConverter implements Converter<ResponseBody, Float> {
-    static final FloatResponseBodyConverter INSTANCE = new FloatResponseBodyConverter();
+    static final class FloatResponseBodyConverter implements Converter<ResponseBody, Float> {
+        static final FloatResponseBodyConverter INSTANCE = new FloatResponseBodyConverter();
 
-    @Override public Float convert(ResponseBody value) throws IOException {
-      return Float.valueOf(value.string());
+        @Override
+        public Float convert(ResponseBody value) throws IOException {
+            return Float.valueOf(value.string());
+        }
     }
-  }
 
-  static final class IntegerResponseBodyConverter implements Converter<ResponseBody, Integer> {
-    static final IntegerResponseBodyConverter INSTANCE = new IntegerResponseBodyConverter();
+    static final class IntegerResponseBodyConverter implements Converter<ResponseBody, Integer> {
+        static final IntegerResponseBodyConverter INSTANCE = new IntegerResponseBodyConverter();
 
-    @Override public Integer convert(ResponseBody value) throws IOException {
-      return Integer.valueOf(value.string());
+        @Override
+        public Integer convert(ResponseBody value) throws IOException {
+            return Integer.valueOf(value.string());
+        }
     }
-  }
 
-  static final class LongResponseBodyConverter implements Converter<ResponseBody, Long> {
-    static final LongResponseBodyConverter INSTANCE = new LongResponseBodyConverter();
+    static final class LongResponseBodyConverter implements Converter<ResponseBody, Long> {
+        static final LongResponseBodyConverter INSTANCE = new LongResponseBodyConverter();
 
-    @Override public Long convert(ResponseBody value) throws IOException {
-      return Long.valueOf(value.string());
+        @Override
+        public Long convert(ResponseBody value) throws IOException {
+            return Long.valueOf(value.string());
+        }
     }
-  }
 
-  static final class ShortResponseBodyConverter implements Converter<ResponseBody, Short> {
-    static final ShortResponseBodyConverter INSTANCE = new ShortResponseBodyConverter();
+    static final class ShortResponseBodyConverter implements Converter<ResponseBody, Short> {
+        static final ShortResponseBodyConverter INSTANCE = new ShortResponseBodyConverter();
 
-    @Override public Short convert(ResponseBody value) throws IOException {
-      return Short.valueOf(value.string());
+        @Override
+        public Short convert(ResponseBody value) throws IOException {
+            return Short.valueOf(value.string());
+        }
     }
-  }
 }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
index 5bf838fe9..423eb0f7b 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -36,67 +37,68 @@
  * to {@code text/plain} bodies.
  */
 public final class ScalarsConverterFactory extends Converter.Factory {
-  public static ScalarsConverterFactory create() {
-    return new ScalarsConverterFactory();
-  }
-
-  private ScalarsConverterFactory() {
-  }
-
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (type == String.class
-        || type == boolean.class
-        || type == Boolean.class
-        || type == byte.class
-        || type == Byte.class
-        || type == char.class
-        || type == Character.class
-        || type == double.class
-        || type == Double.class
-        || type == float.class
-        || type == Float.class
-        || type == int.class
-        || type == Integer.class
-        || type == long.class
-        || type == Long.class
-        || type == short.class
-        || type == Short.class) {
-      return ScalarRequestBodyConverter.INSTANCE;
+    public static ScalarsConverterFactory create() {
+        return new ScalarsConverterFactory();
     }
-    return null;
-  }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class) {
-      return StringResponseBodyConverter.INSTANCE;
-    }
-    if (type == Boolean.class || type == boolean.class) {
-      return BooleanResponseBodyConverter.INSTANCE;
-    }
-    if (type == Byte.class || type == byte.class) {
-      return ByteResponseBodyConverter.INSTANCE;
-    }
-    if (type == Character.class || type == char.class) {
-      return CharacterResponseBodyConverter.INSTANCE;
+    private ScalarsConverterFactory() {
     }
-    if (type == Double.class || type == double.class) {
-      return DoubleResponseBodyConverter.INSTANCE;
-    }
-    if (type == Float.class || type == float.class) {
-      return FloatResponseBodyConverter.INSTANCE;
-    }
-    if (type == Integer.class || type == int.class) {
-      return IntegerResponseBodyConverter.INSTANCE;
-    }
-    if (type == Long.class || type == long.class) {
-      return LongResponseBodyConverter.INSTANCE;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (type == String.class
+                || type == boolean.class
+                || type == Boolean.class
+                || type == byte.class
+                || type == Byte.class
+                || type == char.class
+                || type == Character.class
+                || type == double.class
+                || type == Double.class
+                || type == float.class
+                || type == Float.class
+                || type == int.class
+                || type == Integer.class
+                || type == long.class
+                || type == Long.class
+                || type == short.class
+                || type == Short.class) {
+            return ScalarRequestBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    if (type == Short.class || type == short.class) {
-      return ShortResponseBodyConverter.INSTANCE;
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (type == String.class) {
+            return StringResponseBodyConverter.INSTANCE;
+        }
+        if (type == Boolean.class || type == boolean.class) {
+            return BooleanResponseBodyConverter.INSTANCE;
+        }
+        if (type == Byte.class || type == byte.class) {
+            return ByteResponseBodyConverter.INSTANCE;
+        }
+        if (type == Character.class || type == char.class) {
+            return CharacterResponseBodyConverter.INSTANCE;
+        }
+        if (type == Double.class || type == double.class) {
+            return DoubleResponseBodyConverter.INSTANCE;
+        }
+        if (type == Float.class || type == float.class) {
+            return FloatResponseBodyConverter.INSTANCE;
+        }
+        if (type == Integer.class || type == int.class) {
+            return IntegerResponseBodyConverter.INSTANCE;
+        }
+        if (type == Long.class || type == long.class) {
+            return LongResponseBodyConverter.INSTANCE;
+        }
+        if (type == Short.class || type == short.class) {
+            return ShortResponseBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 }
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index cc19d4fbc..2b3d5765a 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -16,13 +16,16 @@
 package retrofit2.converter.scalars;
 
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -35,256 +38,314 @@
 import static org.junit.Assert.fail;
 
 public final class ScalarsConverterFactoryTest {
-  interface Service {
-      @POST("/") Call<ResponseBody> object(@Body Object body);
-
-      @POST("/") Call<ResponseBody> stringObject(@Body String body);
-      @POST("/") Call<ResponseBody> booleanPrimitive(@Body boolean body);
-      @POST("/") Call<ResponseBody> booleanObject(@Body Boolean body);
-      @POST("/") Call<ResponseBody> bytePrimitive(@Body byte body);
-      @POST("/") Call<ResponseBody> byteObject(@Body Byte body);
-      @POST("/") Call<ResponseBody> charPrimitive(@Body char body);
-      @POST("/") Call<ResponseBody> charObject(@Body Character body);
-      @POST("/") Call<ResponseBody> doublePrimitive(@Body double body);
-      @POST("/") Call<ResponseBody> doubleObject(@Body Double body);
-      @POST("/") Call<ResponseBody> floatPrimitive(@Body float body);
-      @POST("/") Call<ResponseBody> floatObject(@Body Float body);
-      @POST("/") Call<ResponseBody> integerPrimitive(@Body int body);
-      @POST("/") Call<ResponseBody> integerObject(@Body Integer body);
-      @POST("/") Call<ResponseBody> longPrimitive(@Body long body);
-      @POST("/") Call<ResponseBody> longObject(@Body Long body);
-      @POST("/") Call<ResponseBody> shortPrimitive(@Body short body);
-      @POST("/") Call<ResponseBody> shortObject(@Body Short body);
-
-      @GET("/") Call<Object> object();
-
-      @GET("/") Call<String> stringObject();
-      @GET("/") Call<Boolean> booleanObject();
-      @GET("/") Call<Byte> byteObject();
-      @GET("/") Call<Character> charObject();
-      @GET("/") Call<Double> doubleObject();
-      @GET("/") Call<Float> floatObject();
-      @GET("/") Call<Integer> integerObject();
-      @GET("/") Call<Long> longObject();
-      @GET("/") Call<Short> shortObject();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ScalarsConverterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void unsupportedRequestTypesNotMatched() {
-    try {
-      service.object(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
-          + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.Object.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
-    }
-  }
-
-  @Test public void supportedRequestTypes() throws IOException, InterruptedException {
-    RecordedRequest request;
-
-    server.enqueue(new MockResponse());
-    service.stringObject("string").execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("6");
-    assertThat(request.getBody().readUtf8()).isEqualTo("string");
-
-    server.enqueue(new MockResponse());
-    service.booleanPrimitive(true).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("4");
-    assertThat(request.getBody().readUtf8()).isEqualTo("true");
-
-    server.enqueue(new MockResponse());
-    service.booleanObject(false).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("5");
-    assertThat(request.getBody().readUtf8()).isEqualTo("false");
-
-    server.enqueue(new MockResponse());
-    service.bytePrimitive((byte) 0).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("0");
-
-    server.enqueue(new MockResponse());
-    service.byteObject((byte) 1).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("1");
-
-    server.enqueue(new MockResponse());
-    service.charPrimitive('a').execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("a");
-
-    server.enqueue(new MockResponse());
-    service.charObject('b').execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("b");
-
-    server.enqueue(new MockResponse());
-    service.doublePrimitive(2.2d).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("2.2");
-
-    server.enqueue(new MockResponse());
-    service.doubleObject(3.3d).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("3.3");
-
-    server.enqueue(new MockResponse());
-    service.floatPrimitive(4.4f).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("4.4");
-
-    server.enqueue(new MockResponse());
-    service.floatObject(5.5f).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("5.5");
-
-    server.enqueue(new MockResponse());
-    service.integerPrimitive(6).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("6");
-
-    server.enqueue(new MockResponse());
-    service.integerObject(7).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("7");
-
-    server.enqueue(new MockResponse());
-    service.longPrimitive(8L).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("8");
-
-    server.enqueue(new MockResponse());
-    service.longObject(9L).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("9");
-
-    server.enqueue(new MockResponse());
-    service.shortPrimitive((short) 10).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("2");
-    assertThat(request.getBody().readUtf8()).isEqualTo("10");
-
-    server.enqueue(new MockResponse());
-    service.shortObject((short) 11).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("2");
-    assertThat(request.getBody().readUtf8()).isEqualTo("11");
-  }
-
-  @Test public void unsupportedResponseTypesNotMatched() {
-    try {
-      service.object();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.Object\n"
-          + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.Object.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
-    }
-  }
-
-  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("test"));
-    Response<String> stringResponse = service.stringObject().execute();
-    assertThat(stringResponse.body()).isEqualTo("test");
-
-    server.enqueue(new MockResponse().setBody("true"));
-    Response<Boolean> booleanResponse = service.booleanObject().execute();
-    assertThat(booleanResponse.body()).isTrue();
-
-    server.enqueue(new MockResponse().setBody("5"));
-    Response<Byte> byteResponse = service.byteObject().execute();
-    assertThat(byteResponse.body()).isEqualTo((byte) 5);
-
-    server.enqueue(new MockResponse().setBody("b"));
-    Response<Character> characterResponse = service.charObject().execute();
-    assertThat(characterResponse.body()).isEqualTo('b');
-
-    server.enqueue(new MockResponse().setBody(""));
-    try {
-      service.charObject().execute();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
-    }
+    interface Service {
+        @POST("/")
+        Call<ResponseBody> object(@Body Object body);
+
+        @POST("/")
+        Call<ResponseBody> stringObject(@Body String body);
+
+        @POST("/")
+        Call<ResponseBody> booleanPrimitive(@Body boolean body);
+
+        @POST("/")
+        Call<ResponseBody> booleanObject(@Body Boolean body);
+
+        @POST("/")
+        Call<ResponseBody> bytePrimitive(@Body byte body);
+
+        @POST("/")
+        Call<ResponseBody> byteObject(@Body Byte body);
+
+        @POST("/")
+        Call<ResponseBody> charPrimitive(@Body char body);
+
+        @POST("/")
+        Call<ResponseBody> charObject(@Body Character body);
+
+        @POST("/")
+        Call<ResponseBody> doublePrimitive(@Body double body);
+
+        @POST("/")
+        Call<ResponseBody> doubleObject(@Body Double body);
+
+        @POST("/")
+        Call<ResponseBody> floatPrimitive(@Body float body);
+
+        @POST("/")
+        Call<ResponseBody> floatObject(@Body Float body);
+
+        @POST("/")
+        Call<ResponseBody> integerPrimitive(@Body int body);
+
+        @POST("/")
+        Call<ResponseBody> integerObject(@Body Integer body);
+
+        @POST("/")
+        Call<ResponseBody> longPrimitive(@Body long body);
 
-    server.enqueue(new MockResponse().setBody("bb"));
-    try {
-      service.charObject().execute();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+        @POST("/")
+        Call<ResponseBody> longObject(@Body Long body);
+
+        @POST("/")
+        Call<ResponseBody> shortPrimitive(@Body short body);
+
+        @POST("/")
+        Call<ResponseBody> shortObject(@Body Short body);
+
+        @GET("/")
+        Call<Object> object();
+
+        @GET("/")
+        Call<String> stringObject();
+
+        @GET("/")
+        Call<Boolean> booleanObject();
+
+        @GET("/")
+        Call<Byte> byteObject();
+
+        @GET("/")
+        Call<Character> charObject();
+
+        @GET("/")
+        Call<Double> doubleObject();
+
+        @GET("/")
+        Call<Float> floatObject();
+
+        @GET("/")
+        Call<Integer> integerObject();
+
+        @GET("/")
+        Call<Long> longObject();
+
+        @GET("/")
+        Call<Short> shortObject();
     }
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    Response<Double> doubleResponse = service.doubleObject().execute();
-    assertThat(doubleResponse.body()).isEqualTo(13.13);
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    Response<Float> floatResponse = service.floatObject().execute();
-    assertThat(floatResponse.body()).isEqualTo(13.13f);
+    private Service service;
 
-    server.enqueue(new MockResponse().setBody("13"));
-    Response<Integer> integerResponse = service.integerObject().execute();
-    assertThat(integerResponse.body()).isEqualTo(13);
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ScalarsConverterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
 
-    server.enqueue(new MockResponse().setBody("1347"));
-    Response<Long> longResponse = service.longObject().execute();
-    assertThat(longResponse.body()).isEqualTo(1347L);
+    @Test
+    public void unsupportedRequestTypesNotMatched() {
+        try {
+            service.object(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
+                    + "    for method Service.object");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.Object.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+        }
+    }
 
-    server.enqueue(new MockResponse().setBody("134"));
-    Response<Short> shortResponse = service.shortObject().execute();
-    assertThat(shortResponse.body()).isEqualTo((short) 134);
-  }
+    @Test
+    public void supportedRequestTypes() throws IOException, InterruptedException {
+        RecordedRequest request;
+
+        server.enqueue(new MockResponse());
+        service.stringObject("string").execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("6");
+        assertThat(request.getBody().readUtf8()).isEqualTo("string");
+
+        server.enqueue(new MockResponse());
+        service.booleanPrimitive(true).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("4");
+        assertThat(request.getBody().readUtf8()).isEqualTo("true");
+
+        server.enqueue(new MockResponse());
+        service.booleanObject(false).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("5");
+        assertThat(request.getBody().readUtf8()).isEqualTo("false");
+
+        server.enqueue(new MockResponse());
+        service.bytePrimitive((byte) 0).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("0");
+
+        server.enqueue(new MockResponse());
+        service.byteObject((byte) 1).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("1");
+
+        server.enqueue(new MockResponse());
+        service.charPrimitive('a').execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("a");
+
+        server.enqueue(new MockResponse());
+        service.charObject('b').execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("b");
+
+        server.enqueue(new MockResponse());
+        service.doublePrimitive(2.2d).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("2.2");
+
+        server.enqueue(new MockResponse());
+        service.doubleObject(3.3d).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("3.3");
+
+        server.enqueue(new MockResponse());
+        service.floatPrimitive(4.4f).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("4.4");
+
+        server.enqueue(new MockResponse());
+        service.floatObject(5.5f).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("5.5");
+
+        server.enqueue(new MockResponse());
+        service.integerPrimitive(6).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("6");
+
+        server.enqueue(new MockResponse());
+        service.integerObject(7).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("7");
+
+        server.enqueue(new MockResponse());
+        service.longPrimitive(8L).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("8");
+
+        server.enqueue(new MockResponse());
+        service.longObject(9L).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("9");
+
+        server.enqueue(new MockResponse());
+        service.shortPrimitive((short) 10).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("2");
+        assertThat(request.getBody().readUtf8()).isEqualTo("10");
+
+        server.enqueue(new MockResponse());
+        service.shortObject((short) 11).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("2");
+        assertThat(request.getBody().readUtf8()).isEqualTo("11");
+    }
+
+    @Test
+    public void unsupportedResponseTypesNotMatched() {
+        try {
+            service.object();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.Object\n"
+                    + "    for method Service.object");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.Object.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+        }
+    }
+
+    @Test
+    public void supportedResponseTypes() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("test"));
+        Response<String> stringResponse = service.stringObject().execute();
+        assertThat(stringResponse.body()).isEqualTo("test");
+
+        server.enqueue(new MockResponse().setBody("true"));
+        Response<Boolean> booleanResponse = service.booleanObject().execute();
+        assertThat(booleanResponse.body()).isTrue();
+
+        server.enqueue(new MockResponse().setBody("5"));
+        Response<Byte> byteResponse = service.byteObject().execute();
+        assertThat(byteResponse.body()).isEqualTo((byte) 5);
+
+        server.enqueue(new MockResponse().setBody("b"));
+        Response<Character> characterResponse = service.charObject().execute();
+        assertThat(characterResponse.body()).isEqualTo('b');
+
+        server.enqueue(new MockResponse().setBody(""));
+        try {
+            service.charObject().execute();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+        }
+
+        server.enqueue(new MockResponse().setBody("bb"));
+        try {
+            service.charObject().execute();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+        }
+
+        server.enqueue(new MockResponse().setBody("13.13"));
+        Response<Double> doubleResponse = service.doubleObject().execute();
+        assertThat(doubleResponse.body()).isEqualTo(13.13);
+
+        server.enqueue(new MockResponse().setBody("13.13"));
+        Response<Float> floatResponse = service.floatObject().execute();
+        assertThat(floatResponse.body()).isEqualTo(13.13f);
+
+        server.enqueue(new MockResponse().setBody("13"));
+        Response<Integer> integerResponse = service.integerObject().execute();
+        assertThat(integerResponse.body()).isEqualTo(13);
+
+        server.enqueue(new MockResponse().setBody("1347"));
+        Response<Long> longResponse = service.longObject().execute();
+        assertThat(longResponse.body()).isEqualTo(1347L);
+
+        server.enqueue(new MockResponse().setBody("134"));
+        Response<Short> shortResponse = service.shortObject().execute();
+        assertThat(shortResponse.body()).isEqualTo((short) 134);
+    }
 }
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
index 3bbd190bb..f3c76849f 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -18,11 +18,14 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -31,100 +34,120 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ScalarsConverterPrimitivesFactoryTest {
-  interface Service {
-    @GET("/") boolean booleanPrimitive();
-    @GET("/") byte bytePrimitive();
-    @GET("/") char charPrimitive();
-    @GET("/") double doublePrimitive();
-    @GET("/") float floatPrimitive();
-    @GET("/") int integerPrimitive();
-    @GET("/") long longPrimitive();
-    @GET("/") short shortPrimitive();
-  }
-
-  static class DirectCallIOException extends RuntimeException {
-    DirectCallIOException(String message, IOException e) {
-      super(message, e);
+    interface Service {
+        @GET("/")
+        boolean booleanPrimitive();
+
+        @GET("/")
+        byte bytePrimitive();
+
+        @GET("/")
+        char charPrimitive();
+
+        @GET("/")
+        double doublePrimitive();
+
+        @GET("/")
+        float floatPrimitive();
+
+        @GET("/")
+        int integerPrimitive();
+
+        @GET("/")
+        long longPrimitive();
+
+        @GET("/")
+        short shortPrimitive();
     }
-  }
-
-  static class DirectCallAdapterFactory extends CallAdapter.Factory {
-    @Override
-    public CallAdapter<?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      return new CallAdapter<Object>() {
-        @Override public Type responseType() {
-          return returnType;
-        }
 
-        @Override public Object adapt(Call call) {
-          try {
-            return call.execute().body();
-          } catch (IOException e) {
-            throw new DirectCallIOException(e.getMessage(), e);
-          }
+    static class DirectCallIOException extends RuntimeException {
+        DirectCallIOException(String message, IOException e) {
+            super(message, e);
         }
-      };
     }
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ScalarsConverterFactory.create())
-        .addCallAdapterFactory(new DirectCallAdapterFactory())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("true"));
-    boolean booleanResponse = service.booleanPrimitive();
-    assertThat(booleanResponse).isTrue();
-
-    server.enqueue(new MockResponse().setBody("5"));
-    byte byteResponse = service.bytePrimitive();
-    assertThat(byteResponse).isEqualTo((byte) 5);
-
-    server.enqueue(new MockResponse().setBody("b"));
-    char characterResponse = service.charPrimitive();
-    assertThat(characterResponse).isEqualTo('b');
-
-    server.enqueue(new MockResponse().setBody(""));
-    try {
-      service.charPrimitive();
-    } catch (DirectCallIOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+
+    static class DirectCallAdapterFactory extends CallAdapter.Factory {
+        @Override
+        public CallAdapter<?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+            return new CallAdapter<Object>() {
+                @Override
+                public Type responseType() {
+                    return returnType;
+                }
+
+                @Override
+                public Object adapt(Call call) {
+                    try {
+                        return call.execute().body();
+                    } catch (IOException e) {
+                        throw new DirectCallIOException(e.getMessage(), e);
+                    }
+                }
+            };
+        }
     }
 
-    server.enqueue(new MockResponse().setBody("bb"));
-    try {
-      service.charPrimitive();
-    } catch (DirectCallIOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ScalarsConverterFactory.create())
+                .addCallAdapterFactory(new DirectCallAdapterFactory())
+                .build();
+        service = retrofit.create(Service.class);
     }
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    double doubleResponse = service.doublePrimitive();
-    assertThat(doubleResponse).isEqualTo(13.13);
+    @Test
+    public void supportedResponseTypes() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("true"));
+        boolean booleanResponse = service.booleanPrimitive();
+        assertThat(booleanResponse).isTrue();
+
+        server.enqueue(new MockResponse().setBody("5"));
+        byte byteResponse = service.bytePrimitive();
+        assertThat(byteResponse).isEqualTo((byte) 5);
+
+        server.enqueue(new MockResponse().setBody("b"));
+        char characterResponse = service.charPrimitive();
+        assertThat(characterResponse).isEqualTo('b');
+
+        server.enqueue(new MockResponse().setBody(""));
+        try {
+            service.charPrimitive();
+        } catch (DirectCallIOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+        }
+
+        server.enqueue(new MockResponse().setBody("bb"));
+        try {
+            service.charPrimitive();
+        } catch (DirectCallIOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+        }
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    float floatResponse = service.floatPrimitive();
-    assertThat(floatResponse).isEqualTo(13.13f);
+        server.enqueue(new MockResponse().setBody("13.13"));
+        double doubleResponse = service.doublePrimitive();
+        assertThat(doubleResponse).isEqualTo(13.13);
 
-    server.enqueue(new MockResponse().setBody("13"));
-    int integerResponse = service.integerPrimitive();
-    assertThat(integerResponse).isEqualTo(13);
+        server.enqueue(new MockResponse().setBody("13.13"));
+        float floatResponse = service.floatPrimitive();
+        assertThat(floatResponse).isEqualTo(13.13f);
 
-    server.enqueue(new MockResponse().setBody("1347"));
-    long longResponse = service.longPrimitive();
-    assertThat(longResponse).isEqualTo(1347L);
+        server.enqueue(new MockResponse().setBody("13"));
+        int integerResponse = service.integerPrimitive();
+        assertThat(integerResponse).isEqualTo(13);
 
-    server.enqueue(new MockResponse().setBody("134"));
-    short shortResponse = service.shortPrimitive();
-    assertThat(shortResponse).isEqualTo((short) 134);
-  }
+        server.enqueue(new MockResponse().setBody("1347"));
+        long longResponse = service.longPrimitive();
+        assertThat(longResponse).isEqualTo(1347L);
+
+        server.enqueue(new MockResponse().setBody("134"));
+        short shortResponse = service.shortPrimitive();
+        assertThat(shortResponse).isEqualTo((short) 134);
+    }
 }
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index 88bf7abfd..394250695 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -1,43 +1,45 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-simplexml</artifactId>
-  <name>Converter: SimpleXML</name>
+    <artifactId>converter-simplexml</artifactId>
+    <name>Converter: SimpleXML</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.simpleframework</groupId>
-      <artifactId>simple-xml</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.simpleframework</groupId>
+            <artifactId>simple-xml</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index b7563455e..a4a94f188 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -17,69 +17,80 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
 /**
  * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
- * <p>
+ * <p/>
  * This converter only applies for class types. Parameterized types (e.g., {@code List<Foo>}) are
  * not handled.
  */
 public final class SimpleXmlConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Persister} instance for conversion. */
-  public static SimpleXmlConverterFactory create() {
-    return create(new Persister());
-  }
+    /**
+     * Create an instance using a default {@link Persister} instance for conversion.
+     */
+    public static SimpleXmlConverterFactory create() {
+        return create(new Persister());
+    }
 
-  /** Create an instance using {@code serializer} for conversion. */
-  public static SimpleXmlConverterFactory create(Serializer serializer) {
-    return new SimpleXmlConverterFactory(serializer, true);
-  }
+    /**
+     * Create an instance using {@code serializer} for conversion.
+     */
+    public static SimpleXmlConverterFactory create(Serializer serializer) {
+        return new SimpleXmlConverterFactory(serializer, true);
+    }
 
-  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
-  public static SimpleXmlConverterFactory createNonStrict() {
-    return createNonStrict(new Persister());
-  }
+    /**
+     * Create an instance using a default {@link Persister} instance for non-strict conversion.
+     */
+    public static SimpleXmlConverterFactory createNonStrict() {
+        return createNonStrict(new Persister());
+    }
 
-  /** Create an instance using {@code serializer} for non-strict conversion. */
-  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
-    return new SimpleXmlConverterFactory(serializer, false);
-  }
+    /**
+     * Create an instance using {@code serializer} for non-strict conversion.
+     */
+    public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+        return new SimpleXmlConverterFactory(serializer, false);
+    }
 
-  private final Serializer serializer;
-  private final boolean strict;
+    private final Serializer serializer;
+    private final boolean strict;
 
-  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
-    this.serializer = serializer;
-    this.strict = strict;
-  }
+    private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+        if (serializer == null) throw new NullPointerException("serializer == null");
+        this.serializer = serializer;
+        this.strict = strict;
+    }
 
-  public boolean isStrict() {
-    return strict;
-  }
+    public boolean isStrict() {
+        return strict;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class)) {
-      return null;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (!(type instanceof Class)) {
+            return null;
+        }
+        Class<?> cls = (Class<?>) type;
+        return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
     }
-    Class<?> cls = (Class<?>) type;
-    return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class)) {
-      return null;
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class)) {
+            return null;
+        }
+        return new SimpleXmlRequestBodyConverter<>(serializer);
     }
-    return new SimpleXmlRequestBodyConverter<>(serializer);
-  }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index 06aeee1e6..30b7a57c8 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -17,31 +17,35 @@
 
 import java.io.IOException;
 import java.io.OutputStreamWriter;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
+
 import org.simpleframework.xml.Serializer;
+
 import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
-  private static final String CHARSET = "UTF-8";
-
-  private final Serializer serializer;
-
-  SimpleXmlRequestBodyConverter(Serializer serializer) {
-    this.serializer = serializer;
-  }
-
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    try {
-      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(value, osw);
-      osw.flush();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+    private static final String CHARSET = "UTF-8";
+
+    private final Serializer serializer;
+
+    SimpleXmlRequestBodyConverter(Serializer serializer) {
+        this.serializer = serializer;
+    }
+
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        try {
+            OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+            serializer.write(value, osw);
+            osw.flush();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+        return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
     }
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
index 01759f449..540c1c71e 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
@@ -16,34 +16,38 @@
 package retrofit2.converter.simplexml;
 
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
+
 import org.simpleframework.xml.Serializer;
+
 import retrofit2.Converter;
 
 final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final Class<T> cls;
-  private final Serializer serializer;
-  private final boolean strict;
+    private final Class<T> cls;
+    private final Serializer serializer;
+    private final boolean strict;
 
-  SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
-    this.cls = cls;
-    this.serializer = serializer;
-    this.strict = strict;
-  }
+    SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
+        this.cls = cls;
+        this.serializer = serializer;
+        this.strict = strict;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      T read = serializer.read(cls, value.charStream(), strict);
-      if (read == null) {
-        throw new IllegalStateException("Could not deserialize body as " + cls);
-      }
-      return read;
-    } catch (RuntimeException | IOException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            T read = serializer.read(cls, value.charStream(), strict);
+            if (read == null) {
+                throw new IllegalStateException("Could not deserialize body as " + cls);
+            }
+            return read;
+        } catch (RuntimeException | IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
index 18d2e146f..952d9011a 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
@@ -21,45 +21,49 @@
 
 @Default(value = DefaultType.FIELD)
 final class MyObject {
-  @Element private String message;
-  @Element private int count;
+    @Element
+    private String message;
+    @Element
+    private int count;
 
-  public MyObject() {
-  }
+    public MyObject() {
+    }
 
-  public MyObject(String message, int count) {
-    this.message = message;
-    this.count = count;
-  }
+    public MyObject(String message, int count) {
+        this.message = message;
+        this.count = count;
+    }
 
-  public void setMessage(String message) {
-    this.message = message;
-  }
+    public void setMessage(String message) {
+        this.message = message;
+    }
 
-  public String getMessage() {
-    return message;
-  }
+    public String getMessage() {
+        return message;
+    }
 
-  public void setCount(int count) {
-    this.count = count;
-  }
+    public void setCount(int count) {
+        this.count = count;
+    }
 
-  public int getCount() {
-    return count;
-  }
+    public int getCount() {
+        return count;
+    }
 
-  @Override public int hashCode() {
-    int result = 1;
-    result = result * 31 + count;
-    result = result * 31 + (message == null ? 0 : message.hashCode());
-    return result;
-  }
+    @Override
+    public int hashCode() {
+        int result = 1;
+        result = result * 31 + count;
+        result = result * 31 + (message == null ? 0 : message.hashCode());
+        return result;
+    }
 
-  @Override public boolean equals(Object obj) {
-    if (obj == this) return true;
-    if (!(obj instanceof MyObject)) return false;
-    MyObject other = (MyObject) obj;
-    return count == other.count
-        && (message == null ? other.message == null : message.equals(other.message));
-  }
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) return true;
+        if (!(obj instanceof MyObject)) return false;
+        MyObject other = (MyObject) obj;
+        return count == other.count
+                && (message == null ? other.message == null : message.equals(other.message));
+    }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
index 8b5ed7d62..7bc1aae7d 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
@@ -17,10 +17,12 @@
 
 import java.io.IOException;
 import java.nio.charset.Charset;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -29,6 +31,7 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -40,78 +43,89 @@
 import static org.junit.Assert.fail;
 
 public class SimpleXmlConverterFactoryTest {
-  interface Service {
-    @GET("/") Call<MyObject> get();
-    @POST("/") Call<MyObject> post(@Body MyObject impl);
-    @GET("/") Call<String> wrongClass();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
-    Persister persister = new Persister(format);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(SimpleXmlConverterFactory.create(persister))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyWays() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(
-        "<my-object><message>hello world</message><count>10</count></my-object>"));
-
-    Call<MyObject> call = service.post(new MyObject("hello world", 10));
-    Response<MyObject> response = call.execute();
-    MyObject body = response.body();
-    assertThat(body.getMessage()).isEqualTo("hello world");
-    assertThat(body.getCount()).isEqualTo(10);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo(
-        "<my-object><message>hello world</message><count>10</count></my-object>");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
-  }
-
-  @Test public void honorsCharacterEncoding() throws IOException {
-    Buffer buffer = new Buffer().writeString(
-        "<my-object><message>你好，世界</message><count>10</count></my-object>",
-        Charset.forName("GBK"));
-    server.enqueue(
-        new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
-
-    Call<MyObject> call = service.get();
-    Response<MyObject> response = call.execute();
-    MyObject body = response.body();
-    assertThat(body.getMessage()).isEqualTo("你好，世界");
-  }
-
-  @Test public void deserializeWrongValue() throws IOException {
-    server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
-
-    Call<?> call = service.get();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(ElementException.class)
-          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
+    interface Service {
+        @GET("/")
+        Call<MyObject> get();
+
+        @POST("/")
+        Call<MyObject> post(@Body MyObject impl);
+
+        @GET("/")
+        Call<String> wrongClass();
     }
-  }
-
-  @Test public void deserializeWrongClass() throws IOException {
-    server.enqueue(new MockResponse().setBody(
-        "<my-object><message>hello world</message><count>10</count></my-object>"));
-
-    Call<?> call = service.wrongClass();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+        Persister persister = new Persister(format);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(SimpleXmlConverterFactory.create(persister))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyWays() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody(
+                "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+        Call<MyObject> call = service.post(new MyObject("hello world", 10));
+        Response<MyObject> response = call.execute();
+        MyObject body = response.body();
+        assertThat(body.getMessage()).isEqualTo("hello world");
+        assertThat(body.getCount()).isEqualTo(10);
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo(
+                "<my-object><message>hello world</message><count>10</count></my-object>");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
+    }
+
+    @Test
+    public void honorsCharacterEncoding() throws IOException {
+        Buffer buffer = new Buffer().writeString(
+                "<my-object><message>你好，世界</message><count>10</count></my-object>",
+                Charset.forName("GBK"));
+        server.enqueue(
+                new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
+
+        Call<MyObject> call = service.get();
+        Response<MyObject> response = call.execute();
+        MyObject body = response.body();
+        assertThat(body.getMessage()).isEqualTo("你好，世界");
+    }
+
+    @Test
+    public void deserializeWrongValue() throws IOException {
+        server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
+
+        Call<?> call = service.get();
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(ElementException.class)
+                    .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
+        }
+    }
+
+    @Test
+    public void deserializeWrongClass() throws IOException {
+        server.enqueue(new MockResponse().setBody(
+                "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+        Call<?> call = service.wrongClass();
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+        }
     }
-  }
 }
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index b341112db..729f4929f 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -4,51 +4,53 @@
   ~ Copyright 2013 Square, Inc.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-wire</artifactId>
-  <name>Converter: Wire Protocol Buffers</name>
+    <artifactId>converter-wire</artifactId>
+    <name>Converter: Wire Protocol Buffers</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.wire</groupId>
-      <artifactId>wire-runtime</artifactId>
-      <exclusions>
-        <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
-        <exclusion>
-          <groupId>com.squareup.okio</groupId>
-          <artifactId>okio</artifactId>
-        </exclusion>
-      </exclusions>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.wire</groupId>
+            <artifactId>wire-runtime</artifactId>
+            <exclusions>
+                <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
+                <exclusion>
+                    <groupId>com.squareup.okio</groupId>
+                    <artifactId>okio</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index fbaaeac4a..cec277233 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -17,8 +17,10 @@
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -26,44 +28,44 @@
 
 /**
  * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
- * <p>
+ * <p/>
  * This converter only applies for types which extend from {@link Message}.
  */
 public final class WireConverterFactory extends Converter.Factory {
-  public static WireConverterFactory create() {
-    return new WireConverterFactory();
-  }
-
-  private WireConverterFactory() {
-  }
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
+    public static WireConverterFactory create() {
+        return new WireConverterFactory();
     }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      return null;
+
+    private WireConverterFactory() {
     }
-    //noinspection unchecked
-    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
-    return new WireResponseBodyConverter<>(adapter);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        Class<?> c = (Class<?>) type;
+        if (!Message.class.isAssignableFrom(c)) {
+            return null;
+        }
+        //noinspection unchecked
+        ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+        return new WireResponseBodyConverter<>(adapter);
     }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      return null;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        Class<?> c = (Class<?>) type;
+        if (!Message.class.isAssignableFrom(c)) {
+            return null;
+        }
+        //noinspection unchecked
+        ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+        return new WireRequestBodyConverter<>(adapter);
     }
-    //noinspection unchecked
-    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
-    return new WireRequestBodyConverter<>(adapter);
-  }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index d388a944c..5717d4080 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -17,24 +17,27 @@
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
 import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  private final ProtoAdapter<T> adapter;
+    private final ProtoAdapter<T> adapter;
 
-  WireRequestBodyConverter(ProtoAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    WireRequestBodyConverter(ProtoAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    adapter.encode(buffer, value);
-    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        adapter.encode(buffer, value);
+        return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
+    }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
index 5ab321381..b040b289c 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
@@ -17,23 +17,26 @@
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class WireResponseBodyConverter<T extends Message<T, ?>>
-    implements Converter<ResponseBody, T> {
-  private final ProtoAdapter<T> adapter;
+        implements Converter<ResponseBody, T> {
+    private final ProtoAdapter<T> adapter;
 
-  WireResponseBodyConverter(ProtoAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    WireResponseBodyConverter(ProtoAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return adapter.decode(value.source());
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return adapter.decode(value.source());
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
index c085094bb..50ecabc4b 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
@@ -9,127 +9,131 @@
 import com.squareup.wire.ProtoWriter;
 import com.squareup.wire.WireField;
 import com.squareup.wire.internal.Internal;
+
 import java.io.IOException;
 import java.lang.Object;
 import java.lang.Override;
 import java.lang.String;
 import java.lang.StringBuilder;
+
 import okio.ByteString;
 
 public final class Phone extends Message<Phone, Phone.Builder> {
-  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
-
-  private static final long serialVersionUID = 0L;
-
-  public static final String DEFAULT_NUMBER = "";
-
-  @WireField(
-      tag = 1,
-      adapter = "com.squareup.wire.ProtoAdapter#STRING"
-  )
-  public final String number;
-
-  public Phone(String number) {
-    this(number, ByteString.EMPTY);
-  }
-
-  public Phone(String number, ByteString unknownFields) {
-    super(ADAPTER, unknownFields);
-    this.number = number;
-  }
-
-  @Override
-  public Builder newBuilder() {
-    Builder builder = new Builder();
-    builder.number = number;
-    builder.addUnknownFields(unknownFields());
-    return builder;
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) return true;
-    if (!(other instanceof Phone)) return false;
-    Phone o = (Phone) other;
-    return Internal.equals(unknownFields(), o.unknownFields())
-        && Internal.equals(number, o.number);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode;
-    if (result == 0) {
-      result = unknownFields().hashCode();
-      result = result * 37 + (number != null ? number.hashCode() : 0);
-      super.hashCode = result;
-    }
-    return result;
-  }
+    public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
 
-  @Override
-  public String toString() {
-    StringBuilder builder = new StringBuilder();
-    if (number != null) builder.append(", number=").append(number);
-    return builder.replace(0, 2, "Phone{").append('}').toString();
-  }
+    private static final long serialVersionUID = 0L;
 
-  public static final class Builder extends Message.Builder<Phone, Builder> {
-    public String number;
+    public static final String DEFAULT_NUMBER = "";
 
-    public Builder() {
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String number;
+
+    public Phone(String number) {
+        this(number, ByteString.EMPTY);
     }
 
-    public Builder number(String number) {
-      this.number = number;
-      return this;
+    public Phone(String number, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.number = number;
     }
 
     @Override
-    public Phone build() {
-      return new Phone(number, buildUnknownFields());
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.number = number;
+        builder.addUnknownFields(unknownFields());
+        return builder;
     }
-  }
 
-  private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
-    ProtoAdapter_Phone() {
-      super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (!(other instanceof Phone)) return false;
+        Phone o = (Phone) other;
+        return Internal.equals(unknownFields(), o.unknownFields())
+                && Internal.equals(number, o.number);
     }
 
     @Override
-    public int encodedSize(Phone value) {
-      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
-          + value.unknownFields().size();
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (number != null ? number.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
     }
 
     @Override
-    public void encode(ProtoWriter writer, Phone value) throws IOException {
-      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
-      writer.writeBytes(value.unknownFields());
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (number != null) builder.append(", number=").append(number);
+        return builder.replace(0, 2, "Phone{").append('}').toString();
     }
 
-    @Override
-    public Phone decode(ProtoReader reader) throws IOException {
-      Builder builder = new Builder();
-      long token = reader.beginMessage();
-      for (int tag; (tag = reader.nextTag()) != -1;) {
-        switch (tag) {
-          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
-          default: {
-            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
-            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
-            builder.addUnknownField(tag, fieldEncoding, value);
-          }
+    public static final class Builder extends Message.Builder<Phone, Builder> {
+        public String number;
+
+        public Builder() {
+        }
+
+        public Builder number(String number) {
+            this.number = number;
+            return this;
+        }
+
+        @Override
+        public Phone build() {
+            return new Phone(number, buildUnknownFields());
         }
-      }
-      reader.endMessage(token);
-      return builder.build();
     }
 
-    @Override
-    public Phone redact(Phone value) {
-      Builder builder = value.newBuilder();
-      builder.clearUnknownFields();
-      return builder.build();
+    private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
+        ProtoAdapter_Phone() {
+            super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+        }
+
+        @Override
+        public int encodedSize(Phone value) {
+            return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, Phone value) throws IOException {
+            if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public Phone decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.number(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public Phone redact(Phone value) {
+            Builder builder = value.newBuilder();
+            builder.clearUnknownFields();
+            return builder.build();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index e972d5287..0a979775e 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -18,14 +18,17 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -37,95 +40,109 @@
 import static org.junit.Assert.fail;
 
 public final class WireConverterFactoryTest {
-  interface Service {
-    @GET("/") Call<Phone> get();
-    @POST("/") Call<Phone> post(@Body Phone impl);
-    @GET("/") Call<String> wrongClass();
-    @GET("/") Call<List<String>> wrongType();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(WireConverterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = service.post(new Phone("(519) 867-5309"));
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.number).isEqualTo("(519) 867-5309");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
-  }
-
-  @Test public void deserializeEmpty() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call<Phone> call = service.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.number).isNull();
-  }
-
-  @Test public void deserializeWrongClass() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongClass();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+    interface Service {
+        @GET("/")
+        Call<Phone> get();
+
+        @POST("/")
+        Call<Phone> post(@Body Phone impl);
+
+        @GET("/")
+        Call<String> wrongClass();
+
+        @GET("/")
+        Call<List<String>> wrongType();
     }
-  }
-
-  @Test public void deserializeWrongType() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongType();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for java.util.List<java.lang.String>\n"
-          + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(WireConverterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
     }
-  }
 
-  @Test public void deserializeWrongValue() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("////");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+    @Test
+    public void serializeAndDeserialize() throws IOException, InterruptedException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<Phone> call = service.post(new Phone("(519) 867-5309"));
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.number).isEqualTo("(519) 867-5309");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+    }
+
+    @Test
+    public void deserializeEmpty() throws IOException {
+        server.enqueue(new MockResponse());
+
+        Call<Phone> call = service.get();
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.number).isNull();
+    }
+
+    @Test
+    public void deserializeWrongClass() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongClass();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method Service.wrongClass");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.wire.WireConverterFactory");
+        }
+    }
+
+    @Test
+    public void deserializeWrongType() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongType();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for java.util.List<java.lang.String>\n"
+                    + "    for method Service.wrongType");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.wire.WireConverterFactory");
+        }
+    }
 
-    Call<?> call = service.get();
-    try {
-      call.execute();
-      fail();
-    } catch (EOFException ignored) {
+    @Test
+    public void deserializeWrongValue() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("////");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<?> call = service.get();
+        try {
+            call.execute();
+            fail();
+        } catch (EOFException ignored) {
+        }
     }
-  }
 }
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 3483e13db..7f55b735e 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -1,39 +1,41 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit-mock</artifactId>
-  <name>Retrofit Mock Adapter</name>
+    <artifactId>retrofit-mock</artifactId>
+    <name>Retrofit Mock Adapter</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f7..1e649b624 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -28,117 +29,130 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 final class BehaviorCall<T> implements Call<T> {
-  final NetworkBehavior behavior;
-  final ExecutorService backgroundExecutor;
-  final Call<T> delegate;
-
-  private volatile Future<?> task;
-  volatile boolean canceled;
-  private volatile boolean executed;
-
-  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
-    this.behavior = behavior;
-    this.backgroundExecutor = backgroundExecutor;
-    this.delegate = delegate;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public Call<T> clone() {
-    return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
-  }
-
-  @Override public Request request() {
-    return delegate.request();
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+    final NetworkBehavior behavior;
+    final ExecutorService backgroundExecutor;
+    final Call<T> delegate;
+
+    private volatile Future<?> task;
+    volatile boolean canceled;
+    private volatile boolean executed;
+
+    BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
+        this.behavior = behavior;
+        this.backgroundExecutor = backgroundExecutor;
+        this.delegate = delegate;
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public Call<T> clone() {
+        return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
+    }
+
+    @Override
+    public Request request() {
+        return delegate.request();
     }
-    task = backgroundExecutor.submit(new Runnable() {
-      boolean delaySleep() {
-        long sleepMs = behavior.calculateDelay(MILLISECONDS);
-        if (sleepMs > 0) {
-          try {
-            Thread.sleep(sleepMs);
-          } catch (InterruptedException e) {
-            callback.onFailure(BehaviorCall.this, new IOException("canceled"));
-            return false;
-          }
+
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed");
+            executed = true;
         }
-        return true;
-      }
-
-      @Override public void run() {
-        if (canceled) {
-          callback.onFailure(BehaviorCall.this, new IOException("canceled"));
-        } else if (behavior.calculateIsFailure()) {
-          if (delaySleep()) {
-            callback.onFailure(BehaviorCall.this, behavior.failureException());
-          }
-        } else {
-          delegate.enqueue(new Callback<T>() {
-            @Override public void onResponse(Call<T> call, Response<T> response) {
-              if (delaySleep()) {
-                callback.onResponse(call, response);
-              }
+        task = backgroundExecutor.submit(new Runnable() {
+            boolean delaySleep() {
+                long sleepMs = behavior.calculateDelay(MILLISECONDS);
+                if (sleepMs > 0) {
+                    try {
+                        Thread.sleep(sleepMs);
+                    } catch (InterruptedException e) {
+                        callback.onFailure(BehaviorCall.this, new IOException("canceled"));
+                        return false;
+                    }
+                }
+                return true;
             }
 
-            @Override public void onFailure(Call<T> call, Throwable t) {
-              if (delaySleep()) {
-                callback.onFailure(call, t);
-              }
+            @Override
+            public void run() {
+                if (canceled) {
+                    callback.onFailure(BehaviorCall.this, new IOException("canceled"));
+                } else if (behavior.calculateIsFailure()) {
+                    if (delaySleep()) {
+                        callback.onFailure(BehaviorCall.this, behavior.failureException());
+                    }
+                } else {
+                    delegate.enqueue(new Callback<T>() {
+                        @Override
+                        public void onResponse(Call<T> call, Response<T> response) {
+                            if (delaySleep()) {
+                                callback.onResponse(call, response);
+                            }
+                        }
+
+                        @Override
+                        public void onFailure(Call<T> call, Throwable t) {
+                            if (delaySleep()) {
+                                callback.onFailure(call, t);
+                            }
+                        }
+                    });
+                }
             }
-          });
+        });
+    }
+
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
+    }
+
+    @Override
+    public Response<T> execute() throws IOException {
+        final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        enqueue(new Callback<T>() {
+            @Override
+            public void onResponse(Call<T> call, Response<T> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<T> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new IOException("canceled");
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    enqueue(new Callback<T>() {
-      @Override public void onResponse(Call<T> call, Response<T> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<T> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    try {
-      latch.await();
-    } catch (InterruptedException e) {
-      throw new IOException("canceled");
+        Response<T> response = responseRef.get();
+        if (response != null) return response;
+        Throwable failure = failureRef.get();
+        if (failure instanceof RuntimeException) throw (RuntimeException) failure;
+        if (failure instanceof IOException) throw (IOException) failure;
+        throw new RuntimeException(failure);
     }
-    Response<T> response = responseRef.get();
-    if (response != null) return response;
-    Throwable failure = failureRef.get();
-    if (failure instanceof RuntimeException) throw (RuntimeException) failure;
-    if (failure instanceof IOException) throw (IOException) failure;
-    throw new RuntimeException(failure);
-  }
-
-  @Override public void cancel() {
-    canceled = true;
-    Future<?> task = this.task;
-    if (task != null) {
-      task.cancel(true);
+
+    @Override
+    public void cancel() {
+        canceled = true;
+        Future<?> task = this.task;
+        if (task != null) {
+            task.cancel(true);
+        }
     }
-  }
 
-  @Override public boolean isCanceled() {
-    return canceled;
-  }
+    @Override
+    public boolean isCanceled() {
+        return canceled;
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 7c9361f65..6f4c2191d 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutorService;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -33,35 +34,35 @@
  * @see MockRetrofit#create(Class)
  */
 public final class BehaviorDelegate<T> {
-  final Retrofit retrofit;
-  private final NetworkBehavior behavior;
-  private final ExecutorService executor;
-  private final Class<T> service;
+    final Retrofit retrofit;
+    private final NetworkBehavior behavior;
+    private final ExecutorService executor;
+    private final Class<T> service;
 
-  BehaviorDelegate(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor,
-      Class<T> service) {
-    this.retrofit = retrofit;
-    this.behavior = behavior;
-    this.executor = executor;
-    this.service = service;
-  }
+    BehaviorDelegate(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor,
+                     Class<T> service) {
+        this.retrofit = retrofit;
+        this.behavior = behavior;
+        this.executor = executor;
+        this.service = service;
+    }
 
-  public T returningResponse(Object response) {
-    return returning(Calls.response(response));
-  }
+    public T returningResponse(Object response) {
+        return returning(Calls.response(response));
+    }
 
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public T returning(Call<?> call) {
-    final Call<?> behaviorCall = new BehaviorCall<>(behavior, executor, call);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
-        new InvocationHandler() {
-          @Override
-          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            Type returnType = method.getGenericReturnType();
-            Annotation[] methodAnnotations = method.getAnnotations();
-            CallAdapter<?> callAdapter = retrofit.callAdapter(returnType, methodAnnotations);
-            return callAdapter.adapt(behaviorCall);
-          }
-        });
-  }
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public T returning(Call<?> call) {
+        final Call<?> behaviorCall = new BehaviorCall<>(behavior, executor, call);
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[]{service},
+                new InvocationHandler() {
+                    @Override
+                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                        Type returnType = method.getGenericReturnType();
+                        Annotation[] methodAnnotations = method.getAnnotations();
+                        CallAdapter<?> callAdapter = retrofit.callAdapter(returnType, methodAnnotations);
+                        return callAdapter.adapt(behaviorCall);
+                    }
+                });
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490aee..1472033e0 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,82 +16,99 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
 
-/** Factory methods for creating {@link Call} instances which immediately respond or fail. */
+/**
+ * Factory methods for creating {@link Call} instances which immediately respond or fail.
+ */
 public final class Calls {
-  public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
-  }
-
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        return response;
-      }
-
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onResponse(this, response);
-      }
-
-      @Override public boolean isExecuted() {
-        return false;
-      }
-
-      @Override public void cancel() {
-      }
-
-      @Override public boolean isCanceled() {
-        return false;
-      }
-
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-
-      @Override public Request request() {
-        return response.raw().request();
-      }
-    };
-  }
-
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
-      }
-
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(this, failure);
-      }
-
-      @Override public boolean isExecuted() {
-        return false;
-      }
-
-      @Override public void cancel() {
-      }
-
-      @Override public boolean isCanceled() {
-        return false;
-      }
-
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-
-      @Override public Request request() {
-        return new Request.Builder().url("http://localhost").build();
-      }
-    };
-  }
-
-  private Calls() {
-    throw new AssertionError("No instances.");
-  }
+    public static <T> Call<T> response(T successValue) {
+        return response(Response.success(successValue));
+    }
+
+    public static <T> Call<T> response(final Response<T> response) {
+        return new Call<T>() {
+            @Override
+            public Response<T> execute() throws IOException {
+                return response;
+            }
+
+            @Override
+            public void enqueue(Callback<T> callback) {
+                callback.onResponse(this, response);
+            }
+
+            @Override
+            public boolean isExecuted() {
+                return false;
+            }
+
+            @Override
+            public void cancel() {
+            }
+
+            @Override
+            public boolean isCanceled() {
+                return false;
+            }
+
+            @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+            @Override
+            public Call<T> clone() {
+                return this;
+            }
+
+            @Override
+            public Request request() {
+                return response.raw().request();
+            }
+        };
+    }
+
+    public static <T> Call<T> failure(final IOException failure) {
+        return new Call<T>() {
+            @Override
+            public Response<T> execute() throws IOException {
+                throw failure;
+            }
+
+            @Override
+            public void enqueue(Callback<T> callback) {
+                callback.onFailure(this, failure);
+            }
+
+            @Override
+            public boolean isExecuted() {
+                return false;
+            }
+
+            @Override
+            public void cancel() {
+            }
+
+            @Override
+            public boolean isCanceled() {
+                return false;
+            }
+
+            @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+            @Override
+            public Call<T> clone() {
+                return this;
+            }
+
+            @Override
+            public Request request() {
+                return new Request.Builder().url("http://localhost").build();
+            }
+        };
+    }
+
+    private Calls() {
+        throw new AssertionError("No instances.");
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..5a93accce 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -18,62 +18,63 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+
 import retrofit2.Retrofit;
 
 public final class MockRetrofit {
-  private final Retrofit retrofit;
-  private final NetworkBehavior behavior;
-  private final ExecutorService executor;
+    private final Retrofit retrofit;
+    private final NetworkBehavior behavior;
+    private final ExecutorService executor;
 
-  MockRetrofit(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor) {
-    this.retrofit = retrofit;
-    this.behavior = behavior;
-    this.executor = executor;
-  }
+    MockRetrofit(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor) {
+        this.retrofit = retrofit;
+        this.behavior = behavior;
+        this.executor = executor;
+    }
 
-  public Retrofit retrofit() {
-    return retrofit;
-  }
+    public Retrofit retrofit() {
+        return retrofit;
+    }
 
-  public NetworkBehavior networkBehavior() {
-    return behavior;
-  }
+    public NetworkBehavior networkBehavior() {
+        return behavior;
+    }
 
-  public Executor backgroundExecutor() {
-    return executor;
-  }
+    public Executor backgroundExecutor() {
+        return executor;
+    }
 
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> BehaviorDelegate<T> create(Class<T> service) {
-    return new BehaviorDelegate<>(retrofit, behavior, executor, service);
-  }
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> BehaviorDelegate<T> create(Class<T> service) {
+        return new BehaviorDelegate<>(retrofit, behavior, executor, service);
+    }
 
-  public static final class Builder {
-    private final Retrofit retrofit;
-    private NetworkBehavior behavior;
-    private ExecutorService executor;
+    public static final class Builder {
+        private final Retrofit retrofit;
+        private NetworkBehavior behavior;
+        private ExecutorService executor;
 
-    public Builder(Retrofit retrofit) {
-      if (retrofit == null) throw new NullPointerException("retrofit == null");
-      this.retrofit = retrofit;
-    }
+        public Builder(Retrofit retrofit) {
+            if (retrofit == null) throw new NullPointerException("retrofit == null");
+            this.retrofit = retrofit;
+        }
 
-    public Builder networkBehavior(NetworkBehavior behavior) {
-      if (behavior == null) throw new NullPointerException("behavior == null");
-      this.behavior = behavior;
-      return this;
-    }
+        public Builder networkBehavior(NetworkBehavior behavior) {
+            if (behavior == null) throw new NullPointerException("behavior == null");
+            this.behavior = behavior;
+            return this;
+        }
 
-    public Builder backgroundExecutor(ExecutorService executor) {
-      if (executor == null) throw new NullPointerException("executor == null");
-      this.executor = executor;
-      return this;
-    }
+        public Builder backgroundExecutor(ExecutorService executor) {
+            if (executor == null) throw new NullPointerException("executor == null");
+            this.executor = executor;
+            return this;
+        }
 
-    public MockRetrofit build() {
-      if (behavior == null) behavior = NetworkBehavior.create();
-      if (executor == null) executor = Executors.newCachedThreadPool();
-      return new MockRetrofit(retrofit, behavior, executor);
+        public MockRetrofit build() {
+            if (behavior == null) behavior = NetworkBehavior.create();
+            if (executor == null) executor = Executors.newCachedThreadPool();
+            return new MockRetrofit(retrofit, behavior, executor);
+        }
     }
-  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index d182862cb..5187d2ba5 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -23,7 +23,7 @@
 
 /**
  * A simple emulation of the behavior of network calls.
- * <p>
+ * <p/>
  * This class models three properties of a network:
  * <ul>
  * <li>Delay – the time it takes before a response is received (successful or otherwise).</li>
@@ -32,121 +32,141 @@
  * </ul>
  * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
  * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
- * <p>
+ * <p/>
  * By default, instances of this class will use a 2 second delay with 40% variance and failures
  * will occur 3% of the time.
  */
 public final class NetworkBehavior {
-  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
-  private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
-  private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+    private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+    private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by ±40%.
+    private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
 
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
     /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
+     * Applies {@link NetworkBehavior} to instances of {@code T}.
      */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
-
-  /** Create an instance with default behavior. */
-  public static NetworkBehavior create() {
-    return new NetworkBehavior(new Random());
-  }
-
-  /**
-   * Create an instance with default behavior which uses {@code random} to control variance and
-   * failure calculation.
-   */
-  public static NetworkBehavior create(Random random) {
-    if (random == null) throw new NullPointerException("random == null");
-    return new NetworkBehavior(random);
-  }
-
-  private final Random random;
-
-  private volatile long delayMs = DEFAULT_DELAY_MS;
-  private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
-  private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile Throwable failureException = new IOException("Mock failure!");
-
-  private NetworkBehavior(Random random) {
-    this.random = random;
-  }
-
-  /** Set the network round trip delay. */
-  public void setDelay(long amount, TimeUnit unit) {
-    if (amount < 0) {
-      throw new IllegalArgumentException("Amount must be positive value.");
+    public interface Adapter<T> {
+        /**
+         * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+         * traits when interacted with.
+         */
+        T applyBehavior(NetworkBehavior behavior, T value);
     }
-    this.delayMs = unit.toMillis(amount);
-  }
-
-  /** The network round trip delay. */
-  public long delay(TimeUnit unit) {
-    return MILLISECONDS.convert(delayMs, unit);
-  }
-
-  /** Set the plus-or-minus variance percentage of the network round trip delay. */
-  public void setVariancePercent(int variancePercent) {
-    if (variancePercent < 0 || variancePercent > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+
+    /**
+     * Create an instance with default behavior.
+     */
+    public static NetworkBehavior create() {
+        return new NetworkBehavior(new Random());
     }
-    this.variancePercent = variancePercent;
-  }
-
-  /** The plus-or-minus variance percentage of the network round trip delay. */
-  public int variancePercent() {
-    return variancePercent;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public void setFailurePercent(int failurePercent) {
-    if (failurePercent < 0 || failurePercent > 100) {
-      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+
+    /**
+     * Create an instance with default behavior which uses {@code random} to control variance and
+     * failure calculation.
+     */
+    public static NetworkBehavior create(Random random) {
+        if (random == null) throw new NullPointerException("random == null");
+        return new NetworkBehavior(random);
     }
-    this.failurePercent = failurePercent;
-  }
-
-  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public int failurePercent() {
-    return failurePercent;
-  }
-
-  /** Set the exception to be used when a failure is triggered. */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+
+    private final Random random;
+
+    private volatile long delayMs = DEFAULT_DELAY_MS;
+    private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
+    private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
+    private volatile Throwable failureException = new IOException("Mock failure!");
+
+    private NetworkBehavior(Random random) {
+        this.random = random;
+    }
+
+    /**
+     * Set the network round trip delay.
+     */
+    public void setDelay(long amount, TimeUnit unit) {
+        if (amount < 0) {
+            throw new IllegalArgumentException("Amount must be positive value.");
+        }
+        this.delayMs = unit.toMillis(amount);
+    }
+
+    /**
+     * The network round trip delay.
+     */
+    public long delay(TimeUnit unit) {
+        return MILLISECONDS.convert(delayMs, unit);
+    }
+
+    /**
+     * Set the plus-or-minus variance percentage of the network round trip delay.
+     */
+    public void setVariancePercent(int variancePercent) {
+        if (variancePercent < 0 || variancePercent > 100) {
+            throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+        }
+        this.variancePercent = variancePercent;
+    }
+
+    /**
+     * The plus-or-minus variance percentage of the network round trip delay.
+     */
+    public int variancePercent() {
+        return variancePercent;
+    }
+
+    /**
+     * Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}.
+     */
+    public void setFailurePercent(int failurePercent) {
+        if (failurePercent < 0 || failurePercent > 100) {
+            throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+        }
+        this.failurePercent = failurePercent;
+    }
+
+    /**
+     * The percentage of calls to {@link #calculateIsFailure()} that return {@code true}.
+     */
+    public int failurePercent() {
+        return failurePercent;
+    }
+
+    /**
+     * Set the exception to be used when a failure is triggered.
+     */
+    public void setFailureException(Throwable t) {
+        if (t == null) {
+            throw new NullPointerException("t == null");
+        }
+        this.failureException = t;
+    }
+
+    /**
+     * The exception to be used when a failure is triggered.
+     */
+    public Throwable failureException() {
+        return failureException;
+    }
+
+    /**
+     * Randomly determine whether this call should result in a network failure in accordance with
+     * configured behavior. When true, {@link #failureException()} should be thrown.
+     */
+    public boolean calculateIsFailure() {
+        int randomValue = random.nextInt(100);
+        return randomValue < failurePercent;
+    }
+
+    /**
+     * Get the delay that should be used for delaying a response in accordance with configured
+     * behavior.
+     */
+    public long calculateDelay(TimeUnit unit) {
+        float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
+        float lowerBound = 1f - delta; // 0.2f --> 0.8f
+        float upperBound = 1f + delta; // 0.2f --> 1.2f
+        float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+        float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
+        long callDelayMs = (long) (delayMs * delayPercent);
+        return MILLISECONDS.convert(callDelayMs, unit);
     }
-    this.failureException = t;
-  }
-
-  /** The exception to be used when a failure is triggered. */
-  public Throwable failureException() {
-    return failureException;
-  }
-
-  /**
-   * Randomly determine whether this call should result in a network failure in accordance with
-   * configured behavior. When true, {@link #failureException()} should be thrown.
-   */
-  public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
-  }
-
-  /**
-   * Get the delay that should be used for delaying a response in accordance with configured
-   * behavior.
-   */
-  public long calculateDelay(TimeUnit unit) {
-    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
-    float lowerBound = 1f - delta; // 0.2f --> 0.8f
-    float upperBound = 1f + delta; // 0.2f --> 1.2f
-    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
-    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
-    long callDelayMs = (long) (delayMs * delayPercent);
-    return MILLISECONDS.convert(callDelayMs, unit);
-  }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
index 7199da059..b05c87fd3 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
@@ -22,8 +22,10 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
+
 import org.junit.Before;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
@@ -36,263 +38,288 @@
 import static org.junit.Assert.fail;
 
 public final class BehaviorDelegateTest {
-  interface DoWorkService {
-    Call<String> response();
-    Call<String> failure();
-  }
-
-  private final IOException mockFailure = new IOException("Timeout!");
-  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
-  private DoWorkService service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-    final BehaviorDelegate<DoWorkService> delegate = mockRetrofit.create(DoWorkService.class);
-
-    service = new DoWorkService() {
-      @Override public Call<String> response() {
-        Call<String> response = Calls.response("Response!");
-        return delegate.returning(response).response();
-      }
-
-      @Override public Call<String> failure() {
-        Call<String> failure = Calls.failure(mockFailure);
-        return delegate.returning(failure).failure();
-      }
-    };
-  }
-
-  @Test public void syncFailureThrowsAfterDelay() {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Call<String> call = service.response();
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(e).isSameAs(behavior.failureException());
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    interface DoWorkService {
+        Call<String> response();
+
+        Call<String> failure();
+    }
+
+    private final IOException mockFailure = new IOException("Timeout!");
+    private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+    private DoWorkService service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com")
+                .build();
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+        final BehaviorDelegate<DoWorkService> delegate = mockRetrofit.create(DoWorkService.class);
+
+        service = new DoWorkService() {
+            @Override
+            public Call<String> response() {
+                Call<String> response = Calls.response("Response!");
+                return delegate.returning(response).response();
+            }
+
+            @Override
+            public Call<String> failure() {
+                Call<String> failure = Calls.failure(mockFailure);
+                return delegate.returning(failure).failure();
+            }
+        };
+    }
+
+    @Test
+    public void syncFailureThrowsAfterDelay() {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(100);
+
+        Call<String> call = service.response();
+
+        long startNanos = System.nanoTime();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+            assertThat(e).isSameAs(behavior.failureException());
+            assertThat(tookMs).isGreaterThanOrEqualTo(100);
+        }
+    }
+
+    @Test
+    public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(100);
+
+        Call<String> call = service.response();
+
+        final long startNanos = System.nanoTime();
+        final AtomicLong tookMs = new AtomicLong();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(1, SECONDS));
+
+        assertThat(failureRef.get()).isSameAs(behavior.failureException());
+        assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    }
+
+    @Test
+    public void syncSuccessReturnsAfterDelay() throws IOException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.response();
+
+        long startNanos = System.nanoTime();
+        Response<String> response = call.execute();
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+
+        assertThat(response.body()).isEqualTo("Response!");
+        assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    }
+
+    @Test
+    public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.response();
+
+        final long startNanos = System.nanoTime();
+        final AtomicLong tookMs = new AtomicLong();
+        final AtomicReference<String> actual = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+                actual.set(response.body());
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                throw new AssertionError();
+            }
+        });
+        assertTrue(latch.await(1, SECONDS));
+
+        assertThat(actual.get()).isEqualTo("Response!");
+        assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    }
+
+    @Test
+    public void syncFailureThrownAfterDelay() {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.failure();
+
+        long startNanos = System.nanoTime();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+            assertThat(tookMs).isGreaterThanOrEqualTo(100);
+            assertThat(e).isSameAs(mockFailure);
+        }
     }
-  }
-
-  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Call<String> call = service.response();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(failureRef.get()).isSameAs(behavior.failureException());
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void syncSuccessReturnsAfterDelay() throws IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.response();
-
-    long startNanos = System.nanoTime();
-    Response<String> response = call.execute();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-
-    assertThat(response.body()).isEqualTo("Response!");
-    assertThat(tookMs).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.response();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<String> actual = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(response.body());
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(actual.get()).isEqualTo("Response!");
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void syncFailureThrownAfterDelay() {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.failure();
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e).isSameAs(mockFailure);
+
+    @Test
+    public void asyncFailureCalledAfterDelay() throws InterruptedException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.failure();
+
+        final AtomicLong tookMs = new AtomicLong();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        final long startNanos = System.nanoTime();
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(1, SECONDS));
+
+        assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+        assertThat(failureRef.get()).isSameAs(mockFailure);
     }
-  }
-
-  @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.failure();
-
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    final long startNanos = System.nanoTime();
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(failureRef.get()).isSameAs(mockFailure);
-  }
-
-  @Test public void syncCanBeCanceled() throws IOException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    new Thread(new Runnable() {
-      @Override public void run() {
+
+    @Test
+    public void syncCanBeCanceled() throws IOException {
+        behavior.setDelay(10, SECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Thread.sleep(100);
+                    call.cancel();
+                } catch (InterruptedException ignored) {
+                }
+            }
+        }).start();
+
         try {
-          Thread.sleep(100);
-          call.cancel();
-        } catch (InterruptedException ignored) {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
         }
-      }
-    }).start();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
     }
-  }
-
-  @Test public void asyncCanBeCanceled() throws InterruptedException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    // TODO we shouldn't need to sleep
-    Thread.sleep(100); // Ensure the task has started.
-    call.cancel();
-
-    assertTrue(latch.await(1, SECONDS));
-    assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
-  }
-
-  @Test public void syncCanceledBeforeStart() throws IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    call.cancel();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+
+    @Test
+    public void asyncCanBeCanceled() throws InterruptedException {
+        behavior.setDelay(10, SECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        // TODO we shouldn't need to sleep
+        Thread.sleep(100); // Ensure the task has started.
+        call.cancel();
+
+        assertTrue(latch.await(1, SECONDS));
+        assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+    }
+
+    @Test
+    public void syncCanceledBeforeStart() throws IOException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+
+        call.cancel();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+        }
+    }
+
+    @Test
+    public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
+        behavior.setDelay(10, SECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+        call.cancel();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        assertTrue(latch.await(1, SECONDS));
+        assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
     }
-  }
-
-  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-    call.cancel();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    assertTrue(latch.await(1, SECONDS));
-    assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
-  }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
index 3599cc972..19aa6aa79 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
@@ -2,72 +2,82 @@
 
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class MockRetrofitTest {
-  private final Retrofit retrofit = new Retrofit.Builder().baseUrl("http://example.com").build();
-  private final NetworkBehavior behavior = NetworkBehavior.create();
-  private final ExecutorService executor = Executors.newSingleThreadExecutor();
+    private final Retrofit retrofit = new Retrofit.Builder().baseUrl("http://example.com").build();
+    private final NetworkBehavior behavior = NetworkBehavior.create();
+    private final ExecutorService executor = Executors.newSingleThreadExecutor();
 
-  @Test public void retrofitNullThrows() {
-    try {
-      new MockRetrofit.Builder(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("retrofit == null");
+    @Test
+    public void retrofitNullThrows() {
+        try {
+            new MockRetrofit.Builder(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("retrofit == null");
+        }
     }
-  }
 
-  @Test public void retrofitPropagated() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
-    assertThat(mockRetrofit.retrofit()).isSameAs(retrofit);
-  }
+    @Test
+    public void retrofitPropagated() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+        assertThat(mockRetrofit.retrofit()).isSameAs(retrofit);
+    }
 
-  @Test public void networkBehaviorNullThrows() {
-    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
-    try {
-      builder.networkBehavior(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("behavior == null");
+    @Test
+    public void networkBehaviorNullThrows() {
+        MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
+        try {
+            builder.networkBehavior(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("behavior == null");
+        }
     }
-  }
 
-  @Test public void networkBehaviorDefault() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
-    assertThat(mockRetrofit.networkBehavior()).isNotNull();
-  }
+    @Test
+    public void networkBehaviorDefault() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+        assertThat(mockRetrofit.networkBehavior()).isNotNull();
+    }
 
-  @Test public void networkBehaviorPropagated() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-    assertThat(mockRetrofit.networkBehavior()).isSameAs(behavior);
-  }
+    @Test
+    public void networkBehaviorPropagated() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+        assertThat(mockRetrofit.networkBehavior()).isSameAs(behavior);
+    }
 
-  @Test public void backgroundExecutorNullThrows() {
-    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
-    try {
-      builder.backgroundExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
+    @Test
+    public void backgroundExecutorNullThrows() {
+        MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
+        try {
+            builder.backgroundExecutor(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("executor == null");
+        }
     }
-  }
 
-  @Test public void backgroundExecutorDefault() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
-    assertThat(mockRetrofit.backgroundExecutor()).isNotNull();
-  }
+    @Test
+    public void backgroundExecutorDefault() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+        assertThat(mockRetrofit.backgroundExecutor()).isNotNull();
+    }
 
-  @Test public void backgroundExecutorPropagated() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .backgroundExecutor(executor)
-        .build();
-    assertThat(mockRetrofit.backgroundExecutor()).isSameAs(executor);
-  }
+    @Test
+    public void backgroundExecutorPropagated() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .backgroundExecutor(executor)
+                .build();
+        assertThat(mockRetrofit.backgroundExecutor()).isSameAs(executor);
+    }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 7ccccc0df..0c235a00f 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -16,6 +16,7 @@
 package retrofit2.mock;
 
 import java.util.Random;
+
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -24,84 +25,89 @@
 import static org.junit.Assert.fail;
 
 public final class NetworkBehaviorTest {
-  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+    private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
-  @Test public void delayMustBePositive() {
-    try {
-      behavior.setDelay(-1, SECONDS);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Amount must be positive value.");
+    @Test
+    public void delayMustBePositive() {
+        try {
+            behavior.setDelay(-1, SECONDS);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Amount must be positive value.");
+        }
     }
-  }
 
-  @Test public void varianceRestrictsRange() {
-    try {
-      behavior.setVariancePercent(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-    try {
-      behavior.setVariancePercent(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    @Test
+    public void varianceRestrictsRange() {
+        try {
+            behavior.setVariancePercent(-13);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+        }
+        try {
+            behavior.setVariancePercent(174);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+        }
     }
-  }
 
-  @Test public void failureRestrictsRange() {
-    try {
-      behavior.setFailurePercent(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
-    }
-    try {
-      behavior.setFailurePercent(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    @Test
+    public void failureRestrictsRange() {
+        try {
+            behavior.setFailurePercent(-13);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+        }
+        try {
+            behavior.setFailurePercent(174);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+        }
     }
-  }
 
-  @Test public void failurePercentageIsAccurate() {
-    behavior.setFailurePercent(0);
-    for (int i = 0; i < 10000; i++) {
-      assertThat(behavior.calculateIsFailure()).isFalse();
-    }
+    @Test
+    public void failurePercentageIsAccurate() {
+        behavior.setFailurePercent(0);
+        for (int i = 0; i < 10000; i++) {
+            assertThat(behavior.calculateIsFailure()).isFalse();
+        }
 
-    behavior.setFailurePercent(3);
-    int failures = 0;
-    for (int i = 0; i < 100000; i++) {
-      if (behavior.calculateIsFailure()) {
-        failures += 1;
-      }
+        behavior.setFailurePercent(3);
+        int failures = 0;
+        for (int i = 0; i < 100000; i++) {
+            if (behavior.calculateIsFailure()) {
+                failures += 1;
+            }
+        }
+        assertThat(failures).isEqualTo(2964); // ~3% of 100k
     }
-    assertThat(failures).isEqualTo(2964); // ~3% of 100k
-  }
 
-  @Test public void delayVarianceIsAccurate() {
-    behavior.setDelay(2, SECONDS);
+    @Test
+    public void delayVarianceIsAccurate() {
+        behavior.setDelay(2, SECONDS);
 
-    behavior.setVariancePercent(0);
-    for (int i = 0; i < 100000; i++) {
-      assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
-    }
+        behavior.setVariancePercent(0);
+        for (int i = 0; i < 100000; i++) {
+            assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
+        }
 
-    behavior.setVariancePercent(40);
-    long lowerBound = Integer.MAX_VALUE;
-    long upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      long delay = behavior.calculateDelay(MILLISECONDS);
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
+        behavior.setVariancePercent(40);
+        long lowerBound = Integer.MAX_VALUE;
+        long upperBound = Integer.MIN_VALUE;
+        for (int i = 0; i < 100000; i++) {
+            long delay = behavior.calculateDelay(MILLISECONDS);
+            if (delay > upperBound) {
+                upperBound = delay;
+            }
+            if (delay < lowerBound) {
+                lowerBound = delay;
+            }
+        }
+        assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
+        assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
     }
-    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
-    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
-  }
 }
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index a80f03897..1d062f18b 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -1,65 +1,67 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit</artifactId>
-  <name>Retrofit</name>
+    <artifactId>retrofit</artifactId>
+    <name>Retrofit</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <optional>true</optional>
+        </dependency>
 
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <optional>true</optional>
-    </dependency>
+        <dependency>
+            <groupId>org.codehaus.mojo</groupId>
+            <artifactId>animal-sniffer-annotations</artifactId>
+            <optional>true</optional>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.robolectric</groupId>
-      <artifactId>robolectric</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.robolectric</groupId>
+            <artifactId>robolectric</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index d580c00fb..5e4344c8f 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,96 +18,104 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == ResponseBody.class) {
-      if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
-        return StreamingResponseBodyConverter.INSTANCE;
-      }
-      return BufferingResponseBodyConverter.INSTANCE;
-    }
-    if (type == Void.class) {
-      return VoidResponseBodyConverter.INSTANCE;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (type == ResponseBody.class) {
+            if (Utils.isAnnotationPresent(annotations, Streaming.class)) {
+                return StreamingResponseBodyConverter.INSTANCE;
+            }
+            return BufferingResponseBodyConverter.INSTANCE;
+        }
+        if (type == Void.class) {
+            return VoidResponseBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
-      return RequestBodyConverter.INSTANCE;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+            return RequestBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class) {
-      return StringConverter.INSTANCE;
+    @Override
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                Retrofit retrofit) {
+        if (type == String.class) {
+            return StringConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  static final class StringConverter implements Converter<String, String> {
-    static final StringConverter INSTANCE = new StringConverter();
+    static final class StringConverter implements Converter<String, String> {
+        static final StringConverter INSTANCE = new StringConverter();
 
-    @Override public String convert(String value) throws IOException {
-      return value;
+        @Override
+        public String convert(String value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
-    static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
+    static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
+        static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
-    @Override public Void convert(ResponseBody value) throws IOException {
-      value.close();
-      return null;
+        @Override
+        public Void convert(ResponseBody value) throws IOException {
+            value.close();
+            return null;
+        }
     }
-  }
 
-  static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
-    static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
+    static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
+        static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
-    @Override public RequestBody convert(RequestBody value) throws IOException {
-      return value;
+        @Override
+        public RequestBody convert(RequestBody value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class StreamingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
+    static final class StreamingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      return value;
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            return value;
+        }
     }
-  }
-
-  static final class BufferingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
-
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        return Utils.buffer(value);
-      } finally {
-        value.close();
-      }
+
+    static final class BufferingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
+
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                return Utils.buffer(value);
+            } finally {
+                value.close();
+            }
+        }
     }
-  }
 
-  static final class ToStringConverter implements Converter<Object, String> {
-    static final ToStringConverter INSTANCE = new ToStringConverter();
+    static final class ToStringConverter implements Converter<Object, String> {
+        static final ToStringConverter INSTANCE = new ToStringConverter();
 
-    @Override public String convert(Object value) {
-      return value.toString();
+        @Override
+        public String convert(Object value) {
+            return value.toString();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..532c15870 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 
 /**
@@ -23,7 +24,7 @@
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
  * to retry a failed call.
- *
+ * <p/>
  * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
@@ -32,42 +33,46 @@
  * @param <T> Successful response body type.
  */
 public interface Call<T> extends Cloneable {
-  /**
-   * Synchronously send the request and return its response.
-   *
-   * @throws IOException if a problem occurred talking to the server.
-   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
-   * or decoding the response.
-   */
-  Response<T> execute() throws IOException;
+    /**
+     * Synchronously send the request and return its response.
+     *
+     * @throws IOException      if a problem occurred talking to the server.
+     * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+     *                          or decoding the response.
+     */
+    Response<T> execute() throws IOException;
 
-  /**
-   * Asynchronously send the request and notify {@code callback} of its response or if an error
-   * occurred talking to the server, creating the request, or processing the response.
-   */
-  void enqueue(Callback<T> callback);
+    /**
+     * Asynchronously send the request and notify {@code callback} of its response or if an error
+     * occurred talking to the server, creating the request, or processing the response.
+     */
+    void enqueue(Callback<T> callback);
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+     */
+    boolean isExecuted();
 
-  /**
-   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
-   * yet been executed it never will be.
-   */
-  void cancel();
+    /**
+     * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+     * yet been executed it never will be.
+     */
+    void cancel();
 
-  /** True if {@link #cancel()} was called. */
-  boolean isCanceled();
+    /**
+     * True if {@link #cancel()} was called.
+     */
+    boolean isCanceled();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call<T> clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     */
+    Call<T> clone();
 
-  /** The original HTTP request. */
-  Request request();
+    /**
+     * The original HTTP request.
+     */
+    Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 2f56683b8..8bd1ba6ba 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -25,61 +25,61 @@
  * the {@link Retrofit} instance.
  */
 public interface CallAdapter<T> {
-  /**
-   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
-   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
-   * is used to prepare the {@code call} passed to {@code #adapt}.
-   * <p>
-   * Note: This is typically not the same type as the {@code returnType} provided to this call
-   * adapter's factory.
-   */
-  Type responseType();
-
-  /**
-   * Returns an instance of {@code T} which delegates to {@code call}.
-   * <p>
-   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
-   * return a new {@code Async<R>} which invoked {@code call} when run.
-   * <pre><code>
-   * &#64;Override
-   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
-   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
-   *     &#64;Override
-   *     public Response&lt;R&gt; call() throws Exception {
-   *       return call.execute();
-   *     }
-   *   });
-   * }
-   * </code></pre>
-   */
-  <R> T adapt(Call<R> call);
-
-  /**
-   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
-   * Retrofit#create(Class) the service interface} methods.
-   */
-  abstract class Factory {
     /**
-     * Returns a call adapter for interface methods that return {@code returnType}, or null if it
-     * cannot be handled by this factory.
+     * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+     * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+     * is used to prepare the {@code call} passed to {@code #adapt}.
+     * <p/>
+     * Note: This is typically not the same type as the {@code returnType} provided to this call
+     * adapter's factory.
      */
-    public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit);
+    Type responseType();
 
     /**
-     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
-     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     * Returns an instance of {@code T} which delegates to {@code call}.
+     * <p/>
+     * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+     * return a new {@code Async<R>} which invoked {@code call} when run.
+     * <pre><code>
+     * &#64;Override
+     * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+     *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
+     *     &#64;Override
+     *     public Response&lt;R&gt; call() throws Exception {
+     *       return call.execute();
+     *     }
+     *   });
+     * }
+     * </code></pre>
      */
-    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
-      return Utils.getParameterUpperBound(index, type);
-    }
+    <R> T adapt(Call<R> call);
 
     /**
-     * Extract the raw class type from {@code type}. For example, the type representing
-     * {@code List<? extends Runnable>} returns {@code List.class}.
+     * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+     * Retrofit#create(Class) the service interface} methods.
      */
-    protected static Class<?> getRawType(Type type) {
-      return Utils.getRawType(type);
+    abstract class Factory {
+        /**
+         * Returns a call adapter for interface methods that return {@code returnType}, or null if it
+         * cannot be handled by this factory.
+         */
+        public abstract CallAdapter<?> get(Type returnType, Annotation[] annotations,
+                                           Retrofit retrofit);
+
+        /**
+         * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+         * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+         */
+        protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+            return Utils.getParameterUpperBound(index, type);
+        }
+
+        /**
+         * Extract the raw class type from {@code type}. For example, the type representing
+         * {@code List<? extends Runnable>} returns {@code List.class}.
+         */
+        protected static Class<?> getRawType(Type type) {
+            return Utils.getRawType(type);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 62c93a621..b845e970a 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -18,7 +18,7 @@
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
- * <p>
+ * <p/>
  * Callback methods are executed using the {@link Retrofit} callback executor. When none is
  * specified, the following defaults are used:
  * <ul>
@@ -29,17 +29,17 @@
  * @param <T> Successful response body type.
  */
 public interface Callback<T> {
-  /**
-   * Invoked for a received HTTP response.
-   * <p>
-   * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
-   * Call {@link Response#isSuccessful()} to determine if the response indicates success.
-   */
-  void onResponse(Call<T> call, Response<T> response);
+    /**
+     * Invoked for a received HTTP response.
+     * <p/>
+     * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
+     * Call {@link Response#isSuccessful()} to determine if the response indicates success.
+     */
+    void onResponse(Call<T> call, Response<T> response);
 
-  /**
-   * Invoked when a network exception occurred talking to the server or when an unexpected
-   * exception occurred creating the request or processing the response.
-   */
-  void onFailure(Call<T> call, Throwable t);
+    /**
+     * Invoked when a network exception occurred talking to the server or when an unexpected
+     * exception occurred creating the request or processing the response.
+     */
+    void onFailure(Call<T> call, Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 604bcf086..73581b394 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
@@ -36,42 +37,44 @@
  * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
-  T convert(F value) throws IOException;
+    T convert(F value) throws IOException;
 
-  /** Creates {@link Converter} instances based on a type and target usage. */
-  abstract class Factory {
     /**
-     * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for
-     * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
-     * declaration.
+     * Creates {@link Converter} instances based on a type and target usage.
      */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return null;
-    }
+    abstract class Factory {
+        /**
+         * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for
+         * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
+         * declaration.
+         */
+        public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                                Retrofit retrofit) {
+            return null;
+        }
 
-    /**
-     * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for types
-     * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
-     * values.
-     */
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      return null;
-    }
+        /**
+         * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for types
+         * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
+         * values.
+         */
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            return null;
+        }
 
-    /**
-     * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for types
-     * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
-     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
-     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
-     */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return null;
+        /**
+         * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for types
+         * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
+         * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+         * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
+         */
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                    Retrofit retrofit) {
+            return null;
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index dd6e79244..90167e909 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -24,23 +24,25 @@
  * asynchronous calls this is a thread provided by OkHttp's dispatcher.
  */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
-  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+    static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
+        }
 
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-      @Override public <R> Call<R> adapt(Call<R> call) {
-        return call;
-      }
-    };
-  }
+            @Override
+            public <R> Call<R> adapt(Call<R> call) {
+                return call;
+            }
+        };
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index 0c44243c6..cb678a4fd 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,91 +19,105 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override
-  public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public <R> Call<R> adapt(Call<R> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
     final Executor callbackExecutor;
-    final Call<T> delegate;
 
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
+    ExecutorCallAdapterFactory(Executor callbackExecutor) {
+        this.callbackExecutor = callbackExecutor;
     }
 
-    @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
+    @Override
+    public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
         }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
+            @Override
+            public <R> Call<R> adapt(Call<R> call) {
+                return new ExecutorCallbackCall<>(callbackExecutor, call);
             }
-          });
-        }
-      });
+        };
     }
 
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
+    static final class ExecutorCallbackCall<T> implements Call<T> {
+        final Executor callbackExecutor;
+        final Call<T> delegate;
 
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
+        ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+            this.callbackExecutor = callbackExecutor;
+            this.delegate = delegate;
+        }
 
-    @Override public void cancel() {
-      delegate.cancel();
-    }
+        @Override
+        public void enqueue(final Callback<T> callback) {
+            if (callback == null) throw new NullPointerException("callback == null");
+
+            delegate.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, final Response<T> response) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (delegate.isCanceled()) {
+                                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+                            } else {
+                                callback.onResponse(ExecutorCallbackCall.this, response);
+                            }
+                        }
+                    });
+                }
+
+                @Override
+                public void onFailure(Call<T> call, final Throwable t) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onFailure(ExecutorCallbackCall.this, t);
+                        }
+                    });
+                }
+            });
+        }
 
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
+        @Override
+        public boolean isExecuted() {
+            return delegate.isExecuted();
+        }
 
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
+        @Override
+        public Response<T> execute() throws IOException {
+            return delegate.execute();
+        }
+
+        @Override
+        public void cancel() {
+            delegate.cancel();
+        }
 
-    @Override public Request request() {
-      return delegate.request();
+        @Override
+        public boolean isCanceled() {
+            return delegate.isCanceled();
+        }
+
+        @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+        @Override
+        public Call<T> clone() {
+            return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+        }
+
+        @Override
+        public Request request() {
+            return delegate.request();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 5aa102db2..ad6dd606c 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -25,274 +26,291 @@
 import okio.Okio;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T> serviceMethod;
-  private final Object[] args;
-
-  private volatile boolean canceled;
-
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
-  private boolean executed;
-
-  OkHttpCall(ServiceMethod<T> serviceMethod, Object[] args) {
-    this.serviceMethod = serviceMethod;
-    this.args = args;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(serviceMethod, args);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else {
-        throw (RuntimeException) creationFailure;
-      }
-    }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException e) {
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
+    private final ServiceMethod<T> serviceMethod;
+    private final Object[] args;
 
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    private volatile boolean canceled;
 
-    okhttp3.Call call;
-    Throwable failure;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          failure = creationFailure = t;
-        }
-      }
-    }
+    // All guarded by this.
+    private okhttp3.Call rawCall;
+    private Throwable creationFailure; // Either a RuntimeException or IOException.
+    private boolean executed;
 
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
+    OkHttpCall(ServiceMethod<T> serviceMethod, Object[] args) {
+        this.serviceMethod = serviceMethod;
+        this.args = args;
     }
 
-    if (canceled) {
-      call.cancel();
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(serviceMethod, args);
     }
 
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
-          throws IOException {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            return call.request();
         }
-        callSuccess(response);
-      }
-
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            } else {
+                throw (RuntimeException) creationFailure;
+            }
         }
-      }
-
-      private void callFailure(Throwable e) {
         try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException e) {
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
+    }
 
-      private void callSuccess(Response<T> response) {
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          t.printStackTrace();
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    failure = creationFailure = t;
+                }
+            }
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else {
-          throw (RuntimeException) creationFailure;
+
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
         }
-      }
 
-      call = rawCall;
-      if (call == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException e) {
-          creationFailure = e;
-          throw e;
+        if (canceled) {
+            call.cancel();
         }
-      }
+
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
+                    throws IOException {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    callFailure(e);
+                    return;
+                }
+                callSuccess(response);
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callSuccess(Response<T> response) {
+                try {
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    return parseResponse(call.execute());
-  }
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                } else {
+                    throw (RuntimeException) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException e) {
+                    creationFailure = e;
+                    throw e;
+                }
+            }
+        }
 
-  private okhttp3.Call createRawCall() throws IOException {
-    Request request = serviceMethod.toRequest(args);
-    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
-    }
+        if (canceled) {
+            call.cancel();
+        }
 
-    if (code == 204 || code == 205) {
-      return Response.success(null, rawResponse);
+        return parseResponse(call.execute());
     }
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
-    try {
-      T body = serviceMethod.toResponse(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+    private okhttp3.Call createRawCall() throws IOException {
+        Request request = serviceMethod.toRequest(args);
+        okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
+        }
+        return call;
     }
-  }
 
-  public void cancel() {
-    canceled = true;
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        if (code == 204 || code == 205) {
+            return Response.success(null, rawResponse);
+        }
 
-  @Override public boolean isCanceled() {
-    return canceled;
-  }
+        ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+        try {
+            T body = serviceMethod.toResponse(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
+    }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
-    private final long contentLength;
+    public void cancel() {
+        canceled = true;
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    @Override
+    public boolean isCanceled() {
+        return canceled;
     }
 
-    @Override public long contentLength() {
-      return contentLength;
-    }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final MediaType contentType;
+        private final long contentLength;
 
-    @Override public BufferedSource source() {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+        NoContentResponseBody(MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
-    private final ResponseBody delegate;
-    IOException thrownException;
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public long contentLength() {
+            return contentLength;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
+        @Override
+        public BufferedSource source() {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public long contentLength() {
-      return delegate.contentLength();
-    }
+    static final class ExceptionCatchingRequestBody extends ResponseBody {
+        private final ResponseBody delegate;
+        IOException thrownException;
 
-    @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+        ExceptionCatchingRequestBody(ResponseBody delegate) {
+            this.delegate = delegate;
         }
-      });
-    }
 
-    @Override public void close() {
-      delegate.close();
-    }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..7044a7d9b 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
@@ -25,280 +26,294 @@
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, T value) throws IOException;
-
-  final ParameterHandler<Iterable<T>> iterable() {
-    return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (T value : values) {
-          ParameterHandler.this.apply(builder, value);
-        }
-      }
-    };
-  }
-
-  final ParameterHandler<Object> array() {
-    return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, Object values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (int i = 0, size = Array.getLength(values); i < size; i++) {
-          //noinspection unchecked
-          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
-        }
-      }
-    };
-  }
-
-  static final class RelativeUrl extends ParameterHandler<Object> {
-    @Override void apply(RequestBuilder builder, Object value) {
-      builder.setRelativeUrl(value);
+    abstract void apply(RequestBuilder builder, T value) throws IOException;
+
+    final ParameterHandler<Iterable<T>> iterable() {
+        return new ParameterHandler<Iterable<T>>() {
+            @Override
+            void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (T value : values) {
+                    ParameterHandler.this.apply(builder, value);
+                }
+            }
+        };
     }
-  }
 
-  static final class Header<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-
-    Header(String name, Converter<T, String> valueConverter) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
+    final ParameterHandler<Object> array() {
+        return new ParameterHandler<Object>() {
+            @Override
+            void apply(RequestBuilder builder, Object values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (int i = 0, size = Array.getLength(values); i < size; i++) {
+                    //noinspection unchecked
+                    ParameterHandler.this.apply(builder, (T) Array.get(values, i));
+                }
+            }
+        };
     }
-  }
 
-  static final class Path<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+    static final class RelativeUrl extends ParameterHandler<Object> {
+        @Override
+        void apply(RequestBuilder builder, Object value) {
+            builder.setRelativeUrl(value);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Header<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
 
-  static final class Query<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        Header(String name, Converter<T, String> valueConverter) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+        }
 
-    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addHeader(name, valueConverter.convert(value));
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Path<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException(
+                        "Path parameter \"" + name + "\" value must not be null.");
+            }
+            builder.addPathParam(name, valueConverter.convert(value), encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Query map was null.");
-      }
+    static final class Query<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Query map contained null value for key '" + entryKey + "'.");
+        Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
-      }
-    }
-  }
-
-  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
 
-    HeaderMap(Converter<T, String> valueConverter) {
-      this.valueConverter = valueConverter;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addQueryParam(name, valueConverter.convert(value), encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Header map was null.");
-      }
+    static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String headerName = entry.getKey();
-        if (headerName == null) {
-          throw new IllegalArgumentException("Header map contained null key.");
+        QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        T headerValue = entry.getValue();
-        if (headerValue == null) {
-          throw new IllegalArgumentException(
-              "Header map contained null value for key '" + headerName + "'.");
-        }
-        builder.addHeader(headerName, valueConverter.convert(headerValue));
-      }
-    }
-  }
 
-  static final class Field<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Query map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Query map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Query map contained null value for key '" + entryKey + "'.");
+                }
+                builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
 
-  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        HeaderMap(Converter<T, String> valueConverter) {
+            this.valueConverter = valueConverter;
+        }
 
-    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Header map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String headerName = entry.getKey();
+                if (headerName == null) {
+                    throw new IllegalArgumentException("Header map contained null key.");
+                }
+                T headerValue = entry.getValue();
+                if (headerValue == null) {
+                    throw new IllegalArgumentException(
+                            "Header map contained null value for key '" + headerName + "'.");
+                }
+                builder.addHeader(headerName, valueConverter.convert(headerValue));
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Field map was null.");
-      }
+    static final class Field<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
+        Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Field map contained null value for key '" + entryKey + "'.");
+
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addFormField(name, valueConverter.convert(value), encoded);
         }
-        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
-      }
     }
-  }
 
-  static final class Part<T> extends ParameterHandler<T> {
-    private final Headers headers;
-    private final Converter<T, RequestBody> converter;
+    static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-    Part(Headers headers, Converter<T, RequestBody> converter) {
-      this.headers = headers;
-      this.converter = converter;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) {
-      if (value == null) return; // Skip null values.
+        FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.addPart(headers, body);
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Field map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Field map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Field map contained null value for key '" + entryKey + "'.");
+                }
+                builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+            }
+        }
     }
-  }
 
-  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
-    static final RawPart INSTANCE = new RawPart();
+    static final class Part<T> extends ParameterHandler<T> {
+        private final Headers headers;
+        private final Converter<T, RequestBody> converter;
 
-    private RawPart() {
-    }
+        Part(Headers headers, Converter<T, RequestBody> converter) {
+            this.headers = headers;
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
-      if (value != null) { // Skip null values.
-        builder.addPart(value);
-      }
+        @Override
+        void apply(RequestBuilder builder, T value) {
+            if (value == null) return; // Skip null values.
+
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.addPart(headers, body);
+        }
     }
-  }
 
-  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, RequestBody> valueConverter;
-    private final String transferEncoding;
+    static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+        static final RawPart INSTANCE = new RawPart();
+
+        private RawPart() {
+        }
 
-    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
-      this.valueConverter = valueConverter;
-      this.transferEncoding = transferEncoding;
+        @Override
+        void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+            if (value != null) { // Skip null values.
+                builder.addPart(value);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Part map was null.");
-      }
+    static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, RequestBody> valueConverter;
+        private final String transferEncoding;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Part map contained null value for key '" + entryKey + "'.");
+        PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+            this.valueConverter = valueConverter;
+            this.transferEncoding = transferEncoding;
         }
 
-        Headers headers = Headers.of(
-            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-
-        builder.addPart(headers, valueConverter.convert(entryValue));
-      }
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Part map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Part map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Part map contained null value for key '" + entryKey + "'.");
+                }
+
+                Headers headers = Headers.of(
+                        "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+                        "Content-Transfer-Encoding", transferEncoding);
+
+                builder.addPart(headers, valueConverter.convert(entryValue));
+            }
+        }
     }
-  }
 
-  static final class Body<T> extends ParameterHandler<T> {
-    private final Converter<T, RequestBody> converter;
+    static final class Body<T> extends ParameterHandler<T> {
+        private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T, RequestBody> converter) {
-      this.converter = converter;
-    }
+        Body(Converter<T, RequestBody> converter) {
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, T value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.setBody(body);
+        @Override
+        void apply(RequestBuilder builder, T value) {
+            if (value == null) {
+                throw new IllegalArgumentException("Body parameter value must not be null.");
+            }
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.setBody(body);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index e67159bff..67007a1e6 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,138 +18,148 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("org.robovm.apple.foundation.NSObject");
-      return new IOS();
-    } catch (ClassNotFoundException ignored) {
-    }
-    return new Platform();
-  }
+    private static final Platform PLATFORM = findPlatform();
 
-  Executor defaultCallbackExecutor() {
-    return null;
-  }
+    static Platform get() {
+        return PLATFORM;
+    }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    private static Platform findPlatform() {
+        try {
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("org.robovm.apple.foundation.NSObject");
+            return new IOS();
+        } catch (ClassNotFoundException ignored) {
+        }
+        return new Platform();
     }
-    return DefaultCallAdapterFactory.INSTANCE;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
+
+    Executor defaultCallbackExecutor() {
+        return null;
     }
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
+    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+        if (callbackExecutor != null) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+        return DefaultCallAdapterFactory.INSTANCE;
     }
-  }
 
-  static class Android extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+            throws Throwable {
+        throw new UnsupportedOperationException();
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
 
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                                   Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                    .unreflectSpecial(method, declaringClass)
+                    .bindTo(object)
+                    .invokeWithArguments(args);
+        }
     }
-  }
 
-  static class IOS extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
+    static class Android extends Platform {
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
+
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }
     }
 
-    static class MainThreadExecutor implements Executor {
-      private static Object queue;
-      private static Method addOperation;
+    static class IOS extends Platform {
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
 
-      static {
-        try {
-          // queue = NSOperationQueue.getMainQueue();
-          Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
-          queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
-          addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
-        } catch (Exception e) {
-          throw new AssertionError(e);
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
         }
-      }
 
-      @Override public void execute(Runnable r) {
-        try {
-          // queue.addOperation(r);
-          addOperation.invoke(queue, r);
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-          throw new AssertionError(e);
-        } catch (InvocationTargetException e) {
-          Throwable cause = e.getCause();
-          if (cause instanceof RuntimeException) {
-            throw (RuntimeException) cause;
-          } else if (cause instanceof Error) {
-            throw (Error) cause;
-          }
-          throw new RuntimeException(cause);
+        static class MainThreadExecutor implements Executor {
+            private static Object queue;
+            private static Method addOperation;
+
+            static {
+                try {
+                    // queue = NSOperationQueue.getMainQueue();
+                    Class<?> operationQueue = Class.forName("org.robovm.apple.foundation.NSOperationQueue");
+                    queue = operationQueue.getDeclaredMethod("getMainQueue").invoke(null);
+                    addOperation = operationQueue.getDeclaredMethod("addOperation", Runnable.class);
+                } catch (Exception e) {
+                    throw new AssertionError(e);
+                }
+            }
+
+            @Override
+            public void execute(Runnable r) {
+                try {
+                    // queue.addOperation(r);
+                    addOperation.invoke(queue, r);
+                } catch (IllegalArgumentException | IllegalAccessException e) {
+                    throw new AssertionError(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    if (cause instanceof RuntimeException) {
+                        throw (RuntimeException) cause;
+                    } else if (cause instanceof Error) {
+                        throw (Error) cause;
+                    }
+                    throw new RuntimeException(cause);
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 1303418d3..b855411f4 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -27,216 +28,219 @@
 import okio.BufferedSink;
 
 final class RequestBuilder {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
-
-  private final String method;
-
-  private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
-
-  private final Request.Builder requestBuilder;
-  private MediaType contentType;
-
-  private final boolean hasBody;
-  private MultipartBody.Builder multipartBuilder;
-  private FormBody.Builder formBuilder;
-  private RequestBody body;
-
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder();
-    this.contentType = contentType;
-    this.hasBody = hasBody;
-
-    if (headers != null) {
-      requestBuilder.headers(headers);
-    }
+    private static final char[] HEX_DIGITS =
+            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+    private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+
+    private final String method;
+
+    private final HttpUrl baseUrl;
+    private String relativeUrl;
+    private HttpUrl.Builder urlBuilder;
+
+    private final Request.Builder requestBuilder;
+    private MediaType contentType;
+
+    private final boolean hasBody;
+    private MultipartBody.Builder multipartBuilder;
+    private FormBody.Builder formBuilder;
+    private RequestBody body;
+
+    RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
+                   MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+        this.method = method;
+        this.baseUrl = baseUrl;
+        this.relativeUrl = relativeUrl;
+        this.requestBuilder = new Request.Builder();
+        this.contentType = contentType;
+        this.hasBody = hasBody;
+
+        if (headers != null) {
+            requestBuilder.headers(headers);
+        }
 
-    if (isFormEncoded) {
-      // Will be set to 'body' in 'build'.
-      formBuilder = new FormBody.Builder();
-    } else if (isMultipart) {
-      // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBody.Builder();
-      multipartBuilder.setType(MultipartBody.FORM);
-    }
-  }
-
-  void setRelativeUrl(Object relativeUrl) {
-    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
-    this.relativeUrl = relativeUrl.toString();
-  }
-
-  void addHeader(String name, String value) {
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      contentType = MediaType.parse(value);
-    } else {
-      requestBuilder.addHeader(name, value);
+        if (isFormEncoded) {
+            // Will be set to 'body' in 'build'.
+            formBuilder = new FormBody.Builder();
+        } else if (isMultipart) {
+            // Will be set to 'body' in 'build'.
+            multipartBuilder = new MultipartBody.Builder();
+            multipartBuilder.setType(MultipartBody.FORM);
+        }
     }
-  }
 
-  void addPathParam(String name, String value, boolean encoded) {
-    if (relativeUrl == null) {
-      // The relative URL is cleared when the first query parameter is set.
-      throw new AssertionError();
-    }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
-  }
-
-  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
-    int codePoint;
-    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, 0, i);
-        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
-        return out.readUtf8();
-      }
+    void setRelativeUrl(Object relativeUrl) {
+        if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
+        this.relativeUrl = relativeUrl.toString();
     }
 
-    // Fast path: no characters required encoding.
-    return input;
-  }
-
-  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
-      boolean alreadyEncoded) {
-    Buffer utf8Buffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
-        }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
-        }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
+    void addHeader(String name, String value) {
+        if ("Content-Type".equalsIgnoreCase(name)) {
+            contentType = MediaType.parse(value);
+        } else {
+            requestBuilder.addHeader(name, value);
+        }
     }
-  }
-
-  void addQueryParam(String name, String value, boolean encoded) {
-    if (relativeUrl != null) {
-      // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.newBuilder(relativeUrl);
-      if (urlBuilder == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
-      relativeUrl = null;
+
+    void addPathParam(String name, String value, boolean encoded) {
+        if (relativeUrl == null) {
+            // The relative URL is cleared when the first query parameter is set.
+            throw new AssertionError();
+        }
+        relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
+    }
+
+    private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+        int codePoint;
+        for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Slow path: the character at i requires encoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(input, 0, i);
+                canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+                return out.readUtf8();
+            }
+        }
+
+        // Fast path: no characters required encoding.
+        return input;
+    }
+
+    private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+                                            boolean alreadyEncoded) {
+        Buffer utf8Buffer = null; // Lazily allocated.
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                    && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            } else if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Percent encode this character.
+                if (utf8Buffer == null) {
+                    utf8Buffer = new Buffer();
+                }
+                utf8Buffer.writeUtf8CodePoint(codePoint);
+                while (!utf8Buffer.exhausted()) {
+                    int b = utf8Buffer.readByte() & 0xff;
+                    out.writeByte('%');
+                    out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.writeByte(HEX_DIGITS[b & 0xf]);
+                }
+            } else {
+                // This character doesn't need encoding. Just copy it over.
+                out.writeUtf8CodePoint(codePoint);
+            }
+        }
     }
 
-    if (encoded) {
-      urlBuilder.addEncodedQueryParameter(name, value);
-    } else {
-      urlBuilder.addQueryParameter(name, value);
+    void addQueryParam(String name, String value, boolean encoded) {
+        if (relativeUrl != null) {
+            // Do a one-time combination of the built relative URL and the base URL.
+            urlBuilder = baseUrl.newBuilder(relativeUrl);
+            if (urlBuilder == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+            relativeUrl = null;
+        }
+
+        if (encoded) {
+            urlBuilder.addEncodedQueryParameter(name, value);
+        } else {
+            urlBuilder.addQueryParameter(name, value);
+        }
     }
-  }
 
-  void addFormField(String name, String value, boolean encoded) {
-    if (encoded) {
-      formBuilder.addEncoded(name, value);
-    } else {
-      formBuilder.add(name, value);
+    void addFormField(String name, String value, boolean encoded) {
+        if (encoded) {
+            formBuilder.addEncoded(name, value);
+        } else {
+            formBuilder.add(name, value);
+        }
     }
-  }
-
-  void addPart(Headers headers, RequestBody body) {
-    multipartBuilder.addPart(headers, body);
-  }
-
-  void addPart(MultipartBody.Part part) {
-    multipartBuilder.addPart(part);
-  }
-
-  void setBody(RequestBody body) {
-    this.body = body;
-  }
-
-  Request build() {
-    HttpUrl url;
-    HttpUrl.Builder urlBuilder = this.urlBuilder;
-    if (urlBuilder != null) {
-      url = urlBuilder.build();
-    } else {
-      // No query parameters triggered builder creation, just combine the relative URL and base URL.
-      url = baseUrl.resolve(relativeUrl);
-      if (url == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
+
+    void addPart(Headers headers, RequestBody body) {
+        multipartBuilder.addPart(headers, body);
     }
 
-    RequestBody body = this.body;
-    if (body == null) {
-      // Try to pull from one of the builders.
-      if (formBuilder != null) {
-        body = formBuilder.build();
-      } else if (multipartBuilder != null) {
-        body = multipartBuilder.build();
-      } else if (hasBody) {
-        // Body is absent, make an empty body.
-        body = RequestBody.create(null, new byte[0]);
-      }
+    void addPart(MultipartBody.Part part) {
+        multipartBuilder.addPart(part);
     }
 
-    MediaType contentType = this.contentType;
-    if (contentType != null) {
-      if (body != null) {
-        body = new ContentTypeOverridingRequestBody(body, contentType);
-      } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
-      }
+    void setBody(RequestBody body) {
+        this.body = body;
     }
 
-    return requestBuilder
-        .url(url)
-        .method(method, body)
-        .build();
-  }
+    Request build() {
+        HttpUrl url;
+        HttpUrl.Builder urlBuilder = this.urlBuilder;
+        if (urlBuilder != null) {
+            url = urlBuilder.build();
+        } else {
+            // No query parameters triggered builder creation, just combine the relative URL and base URL.
+            url = baseUrl.resolve(relativeUrl);
+            if (url == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+        }
 
-  private static class ContentTypeOverridingRequestBody extends RequestBody {
-    private final RequestBody delegate;
-    private final MediaType contentType;
+        RequestBody body = this.body;
+        if (body == null) {
+            // Try to pull from one of the builders.
+            if (formBuilder != null) {
+                body = formBuilder.build();
+            } else if (multipartBuilder != null) {
+                body = multipartBuilder.build();
+            } else if (hasBody) {
+                // Body is absent, make an empty body.
+                body = RequestBody.create(null, new byte[0]);
+            }
+        }
 
-    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
-      this.delegate = delegate;
-      this.contentType = contentType;
-    }
+        MediaType contentType = this.contentType;
+        if (contentType != null) {
+            if (body != null) {
+                body = new ContentTypeOverridingRequestBody(body, contentType);
+            } else {
+                requestBuilder.addHeader("Content-Type", contentType.toString());
+            }
+        }
 
-    @Override public MediaType contentType() {
-      return contentType;
+        return requestBuilder
+                .url(url)
+                .method(method, body)
+                .build();
     }
 
-    @Override public long contentLength() throws IOException {
-      return delegate.contentLength();
-    }
+    private static class ContentTypeOverridingRequestBody extends RequestBody {
+        private final RequestBody delegate;
+        private final MediaType contentType;
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      delegate.writeTo(sink);
+        ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
+            this.delegate = delegate;
+            this.contentType = contentType;
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
+
+        @Override
+        public long contentLength() throws IOException {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            delegate.writeTo(sink);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index 939363b3d..2b7a75c4d 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -20,110 +20,130 @@
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
-/** An HTTP response. */
+/**
+ * An HTTP response.
+ */
 public final class Response<T> {
-  /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
-    return success(body, new okhttp3.Response.Builder() //
-        .code(200)
-        .message("OK")
-        .protocol(Protocol.HTTP_1_1)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
+    /**
+     * Create a synthetic successful response with {@code body} as the deserialized body.
+     */
+    public static <T> Response<T> success(T body) {
+        return success(body, new okhttp3.Response.Builder() //
+                .code(200)
+                .message("OK")
+                .protocol(Protocol.HTTP_1_1)
+                .request(new Request.Builder().url("http://localhost/").build())
+                .build());
+    }
 
-  /**
-   * Create a synthetic successful response using {@code headers} with {@code body} as the
-   * deserialized body.
-   */
-  public static <T> Response<T> success(T body, Headers headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
-    return success(body, new okhttp3.Response.Builder() //
-        .code(200)
-        .message("OK")
-        .protocol(Protocol.HTTP_1_1)
-        .headers(headers)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
+    /**
+     * Create a synthetic successful response using {@code headers} with {@code body} as the
+     * deserialized body.
+     */
+    public static <T> Response<T> success(T body, Headers headers) {
+        if (headers == null) throw new NullPointerException("headers == null");
+        return success(body, new okhttp3.Response.Builder() //
+                .code(200)
+                .message("OK")
+                .protocol(Protocol.HTTP_1_1)
+                .headers(headers)
+                .request(new Request.Builder().url("http://localhost/").build())
+                .build());
+    }
 
-  /**
-   * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
-   * body.
-   */
-  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
-    if (!rawResponse.isSuccessful()) {
-      throw new IllegalArgumentException("rawResponse must be successful response");
+    /**
+     * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
+     * body.
+     */
+    public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
+        if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+        if (!rawResponse.isSuccessful()) {
+            throw new IllegalArgumentException("rawResponse must be successful response");
+        }
+        return new Response<>(rawResponse, body, null);
     }
-    return new Response<>(rawResponse, body, null);
-  }
 
-  /**
-   * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
-   * as the error body.
-   */
-  public static <T> Response<T> error(int code, ResponseBody body) {
-    if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
-    return error(body, new okhttp3.Response.Builder() //
-        .code(code)
-        .protocol(Protocol.HTTP_1_1)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
+    /**
+     * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
+     * as the error body.
+     */
+    public static <T> Response<T> error(int code, ResponseBody body) {
+        if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
+        return error(body, new okhttp3.Response.Builder() //
+                .code(code)
+                .protocol(Protocol.HTTP_1_1)
+                .request(new Request.Builder().url("http://localhost/").build())
+                .build());
+    }
 
-  /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
-  public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
-    if (rawResponse.isSuccessful()) {
-      throw new IllegalArgumentException("rawResponse should not be successful response");
+    /**
+     * Create an error response from {@code rawResponse} with {@code body} as the error body.
+     */
+    public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
+        if (body == null) throw new NullPointerException("body == null");
+        if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+        if (rawResponse.isSuccessful()) {
+            throw new IllegalArgumentException("rawResponse should not be successful response");
+        }
+        return new Response<>(rawResponse, null, body);
     }
-    return new Response<>(rawResponse, null, body);
-  }
 
-  private final okhttp3.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+    private final okhttp3.Response rawResponse;
+    private final T body;
+    private final ResponseBody errorBody;
 
-  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
-    this.rawResponse = rawResponse;
-    this.body = body;
-    this.errorBody = errorBody;
-  }
+    private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+        this.rawResponse = rawResponse;
+        this.body = body;
+        this.errorBody = errorBody;
+    }
 
-  /** The raw response from the HTTP client. */
-  public okhttp3.Response raw() {
-    return rawResponse;
-  }
+    /**
+     * The raw response from the HTTP client.
+     */
+    public okhttp3.Response raw() {
+        return rawResponse;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return rawResponse.code();
-  }
+    /**
+     * HTTP status code.
+     */
+    public int code() {
+        return rawResponse.code();
+    }
 
-  /** HTTP status message or null if unknown. */
-  public String message() {
-    return rawResponse.message();
-  }
+    /**
+     * HTTP status message or null if unknown.
+     */
+    public String message() {
+        return rawResponse.message();
+    }
 
-  /** HTTP headers. */
-  public Headers headers() {
-    return rawResponse.headers();
-  }
+    /**
+     * HTTP headers.
+     */
+    public Headers headers() {
+        return rawResponse.headers();
+    }
 
-  /** Returns true if {@link #code()} is in the range [200..300). */
-  public boolean isSuccessful() {
-    return rawResponse.isSuccessful();
-  }
+    /**
+     * Returns true if {@link #code()} is in the range [200..300).
+     */
+    public boolean isSuccessful() {
+        return rawResponse.isSuccessful();
+    }
 
-  /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
-  public T body() {
-    return body;
-  }
+    /**
+     * The deserialized response body of a {@linkplain #isSuccessful() successful} response.
+     */
+    public T body() {
+        return body;
+    }
 
-  /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
-  public ResponseBody errorBody() {
-    return errorBody;
-  }
+    /**
+     * The raw response body of an {@linkplain #isSuccessful() unsuccessful} response.
+     */
+    public ResponseBody errorBody() {
+        return errorBody;
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index b194d4ed5..34ec79a85 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
+
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -41,7 +42,7 @@
  * Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to
  * define how requests are made. Create instances using {@linkplain Builder
  * the builder} and pass your interface to {@link #create} to generate an implementation.
- * <p>
+ * <p/>
  * For example,
  * <pre><code>
  * Retrofit retrofit = new Retrofit.Builder()
@@ -57,514 +58,519 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
-
-  private final okhttp3.Call.Factory callFactory;
-  private final HttpUrl baseUrl;
-  private final List<Converter.Factory> converterFactories;
-  private final List<CallAdapter.Factory> adapterFactories;
-  private final Executor callbackExecutor;
-  private final boolean validateEagerly;
-
-  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
-    this.callFactory = callFactory;
-    this.baseUrl = baseUrl;
-    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
-    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
-    this.callbackExecutor = callbackExecutor;
-    this.validateEagerly = validateEagerly;
-  }
-
-  /**
-   * Create an implementation of the API endpoints defined by the {@code service} interface.
-   * <p>
-   * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
-   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
-   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
-   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
-   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
-   * parameter with {@link Url @Url}.
-   * <p>
-   * Method parameters can be used to replace parts of the URL by annotating them with
-   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
-   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
-   * {@link retrofit2.http.Query @Query}.
-   * <p>
-   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
-   * object will be converted to request representation by one of the {@link Converter.Factory}
-   * instances. A {@link RequestBody} can also be used for a raw representation.
-   * <p>
-   * Alternative request body formats are supported by method annotations and corresponding
-   * parameter annotations:
-   * <ul>
-   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
-   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
-   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
-   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
-   * </ul>
-   * <p>
-   * Additional static headers can be added for an endpoint using the
-   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
-   * header annotate a parameter with {@link Header @Header}.
-   * <p>
-   * By default, methods return a {@link Call} which represents the HTTP request. The generic
-   * parameter of the call is the response body type and will be converted by one of the
-   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
-   * representation. {@link Void} can be used if you do not care about the body contents.
-   * <p>
-   * For example:
-   * <pre>
-   * public interface CategoryService {
-   *   &#64;POST("category/{cat}/")
-   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
-   * }
-   * </pre>
-   */
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new InvocationHandler() {
-          private final Platform platform = Platform.get();
-
-          @Override public Object invoke(Object proxy, Method method, Object... args)
-              throws Throwable {
-            // If the method is a method from Object then defer to normal invocation.
-            if (method.getDeclaringClass() == Object.class) {
-              return method.invoke(this, args);
-            }
-            if (platform.isDefaultMethod(method)) {
-              return platform.invokeDefaultMethod(method, service, proxy, args);
-            }
-            ServiceMethod serviceMethod = loadServiceMethod(method);
-            OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.callAdapter.adapt(okHttpCall);
-          }
-        });
-  }
-
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
-        loadServiceMethod(method);
-      }
-    }
-  }
-
-  ServiceMethod loadServiceMethod(Method method) {
-    ServiceMethod result;
-    synchronized (serviceMethodCache) {
-      result = serviceMethodCache.get(method);
-      if (result == null) {
-        result = new ServiceMethod.Builder(this, method).build();
-        serviceMethodCache.put(method, result);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
-   * Typically an instance of {@link OkHttpClient}.
-   */
-  public okhttp3.Call.Factory callFactory() {
-    return callFactory;
-  }
-
-  /** The API base URL. */
-  public HttpUrl baseUrl() {
-    return baseUrl;
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
-   */
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return adapterFactories;
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
-    return nextCallAdapter(null, returnType, annotations);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
-      Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
-      if (adapter != null) {
-        return adapter;
-      }
+    private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();
+
+    private final okhttp3.Call.Factory callFactory;
+    private final HttpUrl baseUrl;
+    private final List<Converter.Factory> converterFactories;
+    private final List<CallAdapter.Factory> adapterFactories;
+    private final Executor callbackExecutor;
+    private final boolean validateEagerly;
+
+    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+             List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+             Executor callbackExecutor, boolean validateEagerly) {
+        this.callFactory = callFactory;
+        this.baseUrl = baseUrl;
+        this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
+        this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
+        this.callbackExecutor = callbackExecutor;
+        this.validateEagerly = validateEagerly;
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(returnType)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
-   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
-   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
-   */
-  public List<Converter.Factory> converterFactories() {
-    return converterFactories;
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
-    checkNotNull(methodAnnotations, "methodAnnotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter.Factory factory = converterFactories.get(i);
-      Converter<?, RequestBody> converter =
-          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, RequestBody>) converter;
-      }
+    /**
+     * Create an implementation of the API endpoints defined by the {@code service} interface.
+     * <p/>
+     * The relative path for a given method is obtained from an annotation on the method describing
+     * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+     * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+     * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+     * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+     * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+     * parameter with {@link Url @Url}.
+     * <p/>
+     * Method parameters can be used to replace parts of the URL by annotating them with
+     * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+     * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+     * {@link retrofit2.http.Query @Query}.
+     * <p/>
+     * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+     * object will be converted to request representation by one of the {@link Converter.Factory}
+     * instances. A {@link RequestBody} can also be used for a raw representation.
+     * <p/>
+     * Alternative request body formats are supported by method annotations and corresponding
+     * parameter annotations:
+     * <ul>
+     * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+     * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+     * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+     * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+     * </ul>
+     * <p/>
+     * Additional static headers can be added for an endpoint using the
+     * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+     * header annotate a parameter with {@link Header @Header}.
+     * <p/>
+     * By default, methods return a {@link Call} which represents the HTTP request. The generic
+     * parameter of the call is the response body type and will be converted by one of the
+     * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+     * representation. {@link Void} can be used if you do not care about the body contents.
+     * <p/>
+     * For example:
+     * <pre>
+     * public interface CategoryService {
+     *   &#64;POST("category/{cat}/")
+     *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+     * }
+     * </pre>
+     */
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> T create(final Class<T> service) {
+        Utils.validateServiceInterface(service);
+        if (validateEagerly) {
+            eagerlyValidateMethods(service);
+        }
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
+                new InvocationHandler() {
+                    private final Platform platform = Platform.get();
+
+                    @Override
+                    public Object invoke(Object proxy, Method method, Object... args)
+                            throws Throwable {
+                        // If the method is a method from Object then defer to normal invocation.
+                        if (method.getDeclaringClass() == Object.class) {
+                            return method.invoke(this, args);
+                        }
+                        if (platform.isDefaultMethod(method)) {
+                            return platform.invokeDefaultMethod(method, service, proxy, args);
+                        }
+                        ServiceMethod serviceMethod = loadServiceMethod(method);
+                        OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
+                        return serviceMethod.callAdapter.adapt(okHttpCall);
+                    }
+                });
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
-    return nextResponseBodyConverter(null, type, annotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).responseBodyConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<ResponseBody, T>) converter;
-      }
+    private void eagerlyValidateMethods(Class<?> service) {
+        Platform platform = Platform.get();
+        for (Method method : service.getDeclaredMethods()) {
+            if (!platform.isDefaultMethod(method)) {
+                loadServiceMethod(method);
+            }
+        }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
+    ServiceMethod loadServiceMethod(Method method) {
+        ServiceMethod result;
+        synchronized (serviceMethodCache) {
+            result = serviceMethodCache.get(method);
+            if (result == null) {
+                result = new ServiceMethod.Builder(this, method).build();
+                serviceMethodCache.put(method, result);
+            }
+        }
+        return result;
     }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+
+    /**
+     * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+     * Typically an instance of {@link OkHttpClient}.
+     */
+    public okhttp3.Call.Factory callFactory() {
+        return callFactory;
     }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link String} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, String>) converter;
-      }
+
+    /**
+     * The API base URL.
+     */
+    public HttpUrl baseUrl() {
+        return baseUrl;
     }
 
-    // Nothing matched. Resort to default converter which just calls toString().
-    //noinspection unchecked
-    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
-  }
-
-  /**
-   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
-   * in which case callbacks should be made synchronously on the background thread.
-   */
-  public Executor callbackExecutor() {
-    return callbackExecutor;
-  }
-
-  /**
-   * Build a new {@link Retrofit}.
-   * <p>
-   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static final class Builder {
-    private Platform platform;
-    private okhttp3.Call.Factory callFactory;
-    private HttpUrl baseUrl;
-    private List<Converter.Factory> converterFactories = new ArrayList<>();
-    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
-    private boolean validateEagerly;
-
-    Builder(Platform platform) {
-      this.platform = platform;
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
+    /**
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+     */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+        return adapterFactories;
     }
 
-    public Builder() {
-      this(Platform.get());
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
+     */
+    public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+        return nextCallAdapter(null, returnType, annotations);
     }
 
     /**
-     * The HTTP client used for requests.
-     * <p>
-     * This is a convenience method for calling {@link #callFactory}.
-     * <p>
-     * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
-     * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
-     * instance to prevent this if desired.
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
      */
-    public Builder client(OkHttpClient client) {
-      return callFactory(checkNotNull(client, "client == null"));
+    public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+                                          Annotation[] annotations) {
+        checkNotNull(returnType, "returnType == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = adapterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+            if (adapter != null) {
+                return adapter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+                .append(returnType)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * Specify a custom call factory for creating {@link Call} instances.
-     * <p>
-     * Note: Calling {@link #client} automatically sets this value.
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+     * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+     * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
      */
-    public Builder callFactory(okhttp3.Call.Factory factory) {
-      this.callFactory = checkNotNull(factory, "factory == null");
-      return this;
+    public List<Converter.Factory> converterFactories() {
+        return converterFactories;
     }
 
     /**
-     * Set the API base URL.
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories}.
      *
-     * @see #baseUrl(HttpUrl)
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+    public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
     }
 
     /**
-     * Set the API base URL.
-     * <p>
-     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
-     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
-     * {@code <a href="">} link on a website resolving on the current URL.
-     * <p>
-     * <b>Base URLs should always end in {@code /}.</b>
-     * <p>
-     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
-     * append themselves to a base which has path components.
-     * <p>
-     * <b>Correct:</b><br>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/api/foo/bar/
-     * <p>
-     * <b>Incorrect:</b><br>
-     * Base URL: http://example.com/api<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * This method enforces that {@code baseUrl} has a trailing {@code /}.
-     * <p>
-     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
-     * <p>
-     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
-     * components.
-     * <p>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * <b>Endpoint values may be a full URL.</b>
-     * <p>
-     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
-     * replace the scheme of {@code baseUrl}.
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: https://github.com/square/retrofit/<br>
-     * Result: https://github.com/square/retrofit/
-     * <p>
-     * Base URL: http://example.com<br>
-     * Endpoint: //github.com/square/retrofit/<br>
-     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      List<String> pathSegments = baseUrl.pathSegments();
-      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
-        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
-      }
-      this.baseUrl = baseUrl;
-      return this;
+    public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
+                                                                  Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+        checkNotNull(methodAnnotations, "methodAnnotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter.Factory factory = converterFactories.get(i);
+            Converter<?, RequestBody> converter =
+                    factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, RequestBody>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
-    /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory factory) {
-      converterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    /**
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
+     */
+    public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+        return nextResponseBodyConverter(null, type, annotations);
     }
 
     /**
-     * Add a call adapter factory for supporting service method return types other than {@link
-     * Call}.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
+                                                                    Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter<ResponseBody, ?> converter =
+                    converterFactories.get(i).responseBodyConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<ResponseBody, T>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
-     * your service method.
-     * <p>
-     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
-     * return types}.
+     * Returns a {@link Converter} for {@code type} to {@link String} from the available
+     * {@linkplain #converterFactories() factories}.
      */
-    public Builder callbackExecutor(Executor executor) {
-      this.callbackExecutor = checkNotNull(executor, "executor == null");
-      return this;
+    public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<?, String> converter =
+                    converterFactories.get(i).stringConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, String>) converter;
+            }
+        }
+
+        // Nothing matched. Resort to default converter which just calls toString().
+        //noinspection unchecked
+        return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
     }
 
     /**
-     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
-     * the configuration of all methods in the supplied interface.
+     * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+     * in which case callbacks should be made synchronously on the background thread.
      */
-    public Builder validateEagerly(boolean validateEagerly) {
-      this.validateEagerly = validateEagerly;
-      return this;
+    public Executor callbackExecutor() {
+        return callbackExecutor;
     }
 
     /**
-     * Create the {@link Retrofit} instance using the configured values.
-     * <p>
-     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
-     * OkHttpClient} will be created and used.
+     * Build a new {@link Retrofit}.
+     * <p/>
+     * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+     * are optional.
      */
-    public Retrofit build() {
-      if (baseUrl == null) {
-        throw new IllegalStateException("Base URL required.");
-      }
-
-      okhttp3.Call.Factory callFactory = this.callFactory;
-      if (callFactory == null) {
-        callFactory = new OkHttpClient();
-      }
-
-      Executor callbackExecutor = this.callbackExecutor;
-      if (callbackExecutor == null) {
-        callbackExecutor = platform.defaultCallbackExecutor();
-      }
-
-      // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
-
-      // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
-
-      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+    public static final class Builder {
+        private Platform platform;
+        private okhttp3.Call.Factory callFactory;
+        private HttpUrl baseUrl;
+        private List<Converter.Factory> converterFactories = new ArrayList<>();
+        private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+        private Executor callbackExecutor;
+        private boolean validateEagerly;
+
+        Builder(Platform platform) {
+            this.platform = platform;
+            // Add the built-in converter factory first. This prevents overriding its behavior but also
+            // ensures correct behavior when using converters that consume all types.
+            converterFactories.add(new BuiltInConverters());
+        }
+
+        public Builder() {
+            this(Platform.get());
+        }
+
+        /**
+         * The HTTP client used for requests.
+         * <p/>
+         * This is a convenience method for calling {@link #callFactory}.
+         * <p/>
+         * Note: This method <b>does not</b> make a defensive copy of {@code client}. Changes to its
+         * settings will affect subsequent requests. Pass in a {@linkplain OkHttpClient#clone() cloned}
+         * instance to prevent this if desired.
+         */
+        public Builder client(OkHttpClient client) {
+            return callFactory(checkNotNull(client, "client == null"));
+        }
+
+        /**
+         * Specify a custom call factory for creating {@link Call} instances.
+         * <p/>
+         * Note: Calling {@link #client} automatically sets this value.
+         */
+        public Builder callFactory(okhttp3.Call.Factory factory) {
+            this.callFactory = checkNotNull(factory, "factory == null");
+            return this;
+        }
+
+        /**
+         * Set the API base URL.
+         *
+         * @see #baseUrl(HttpUrl)
+         */
+        public Builder baseUrl(String baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+            if (httpUrl == null) {
+                throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+            }
+            return baseUrl(httpUrl);
+        }
+
+        /**
+         * Set the API base URL.
+         * <p/>
+         * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+         * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+         * {@code <a href="">} link on a website resolving on the current URL.
+         * <p/>
+         * <b>Base URLs should always end in {@code /}.</b>
+         * <p/>
+         * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+         * append themselves to a base which has path components.
+         * <p/>
+         * <b>Correct:</b><br>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/api/foo/bar/
+         * <p/>
+         * <b>Incorrect:</b><br>
+         * Base URL: http://example.com/api<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p/>
+         * This method enforces that {@code baseUrl} has a trailing {@code /}.
+         * <p/>
+         * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+         * <p/>
+         * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+         * components.
+         * <p/>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p/>
+         * Base URL: http://example.com/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p/>
+         * <b>Endpoint values may be a full URL.</b>
+         * <p/>
+         * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+         * replace the scheme of {@code baseUrl}.
+         * <p/>
+         * Base URL: http://example.com/<br>
+         * Endpoint: https://github.com/square/retrofit/<br>
+         * Result: https://github.com/square/retrofit/
+         * <p/>
+         * Base URL: http://example.com<br>
+         * Endpoint: //github.com/square/retrofit/<br>
+         * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+         */
+        public Builder baseUrl(HttpUrl baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            List<String> pathSegments = baseUrl.pathSegments();
+            if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+                throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+            }
+            this.baseUrl = baseUrl;
+            return this;
+        }
+
+        /**
+         * Add converter factory for serialization and deserialization of objects.
+         */
+        public Builder addConverterFactory(Converter.Factory factory) {
+            converterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * Add a call adapter factory for supporting service method return types other than {@link
+         * Call}.
+         */
+        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+            adapterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+         * your service method.
+         * <p/>
+         * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+         * return types}.
+         */
+        public Builder callbackExecutor(Executor executor) {
+            this.callbackExecutor = checkNotNull(executor, "executor == null");
+            return this;
+        }
+
+        /**
+         * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+         * the configuration of all methods in the supplied interface.
+         */
+        public Builder validateEagerly(boolean validateEagerly) {
+            this.validateEagerly = validateEagerly;
+            return this;
+        }
+
+        /**
+         * Create the {@link Retrofit} instance using the configured values.
+         * <p/>
+         * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+         * OkHttpClient} will be created and used.
+         */
+        public Retrofit build() {
+            if (baseUrl == null) {
+                throw new IllegalStateException("Base URL required.");
+            }
+
+            okhttp3.Call.Factory callFactory = this.callFactory;
+            if (callFactory == null) {
+                callFactory = new OkHttpClient();
+            }
+
+            Executor callbackExecutor = this.callbackExecutor;
+            if (callbackExecutor == null) {
+                callbackExecutor = platform.defaultCallbackExecutor();
+            }
+
+            // Make a defensive copy of the adapters and add the default Call adapter.
+            List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+            adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+
+            // Make a defensive copy of the converters.
+            List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+            return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
+                    callbackExecutor, validateEagerly);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index facede01f..b52410055 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -55,699 +56,705 @@
 import retrofit2.http.QueryMap;
 import retrofit2.http.Url;
 
-/** Adapts an invocation of an interface method into an HTTP call. */
+/**
+ * Adapts an invocation of an interface method into an HTTP call.
+ */
 final class ServiceMethod<T> {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-
-  final okhttp3.Call.Factory callFactory;
-  final CallAdapter<?> callAdapter;
-
-  private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, T> responseConverter;
-  private final String httpMethod;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-
-  ServiceMethod(Builder<T> builder) {
-    this.callFactory = builder.retrofit.callFactory();
-    this.callAdapter = builder.callAdapter;
-    this.baseUrl = builder.retrofit.baseUrl();
-    this.responseConverter = builder.responseConverter;
-    this.httpMethod = builder.httpMethod;
-    this.relativeUrl = builder.relativeUrl;
-    this.headers = builder.headers;
-    this.contentType = builder.contentType;
-    this.hasBody = builder.hasBody;
-    this.isFormEncoded = builder.isFormEncoded;
-    this.isMultipart = builder.isMultipart;
-    this.parameterHandlers = builder.parameterHandlers;
-  }
-
-  /** Builds an HTTP request from method arguments. */
-  Request toRequest(Object... args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args != null ? args.length : 0;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+    static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+    final okhttp3.Call.Factory callFactory;
+    final CallAdapter<?> callAdapter;
+
+    private final HttpUrl baseUrl;
+    private final Converter<ResponseBody, T> responseConverter;
+    private final String httpMethod;
+    private final String relativeUrl;
+    private final Headers headers;
+    private final MediaType contentType;
+    private final boolean hasBody;
+    private final boolean isFormEncoded;
+    private final boolean isMultipart;
+    private final ParameterHandler<?>[] parameterHandlers;
+
+    ServiceMethod(Builder<T> builder) {
+        this.callFactory = builder.retrofit.callFactory();
+        this.callAdapter = builder.callAdapter;
+        this.baseUrl = builder.retrofit.baseUrl();
+        this.responseConverter = builder.responseConverter;
+        this.httpMethod = builder.httpMethod;
+        this.relativeUrl = builder.relativeUrl;
+        this.headers = builder.headers;
+        this.contentType = builder.contentType;
+        this.hasBody = builder.hasBody;
+        this.isFormEncoded = builder.isFormEncoded;
+        this.isMultipart = builder.isMultipart;
+        this.parameterHandlers = builder.parameterHandlers;
     }
 
-    for (int p = 0; p < argumentCount; p++) {
-      handlers[p].apply(requestBuilder, args[p]);
-    }
+    /**
+     * Builds an HTTP request from method arguments.
+     */
+    Request toRequest(Object... args) throws IOException {
+        RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+                contentType, hasBody, isFormEncoded, isMultipart);
 
-    return requestBuilder.build();
-  }
-
-  /** Builds a method return value from an HTTP response body. */
-  T toResponse(ResponseBody body) throws IOException {
-    return responseConverter.convert(body);
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder<T> {
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    Type responseType;
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotUrl;
-    String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    String relativeUrl;
-    Headers headers;
-    MediaType contentType;
-    Set<String> relativeUrlParamNames;
-    ParameterHandler<?>[] parameterHandlers;
-    Converter<ResponseBody, T> responseConverter;
-    CallAdapter<?> callAdapter;
-
-    public Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
+        @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+                ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    public ServiceMethod build() {
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError("'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
-
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
-
-      if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
-
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
-        }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
-              parameterType);
+        int argumentCount = args != null ? args.length : 0;
+        if (argumentCount != handlers.length) {
+            throw new IllegalArgumentException("Argument count (" + argumentCount
+                    + ") doesn't match expected count (" + handlers.length + ")");
         }
 
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
+        for (int p = 0; p < argumentCount; p++) {
+            handlers[p].apply(requestBuilder, args[p]);
         }
 
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
-      }
-
-      return new ServiceMethod<>(this);
+        return requestBuilder.build();
     }
 
-    private CallAdapter<?> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create call adapter for %s", returnType);
-      }
+    /**
+     * Builds a method return value from an HTTP response body.
+     */
+    T toResponse(ResponseBody body) throws IOException {
+        return responseConverter.convert(body);
     }
 
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError("HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
-
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
-        }
-      }
-
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
-
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-        }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          contentType = MediaType.parse(headerValue);
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
-
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
-      ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method. This
+     * requires potentially-expensive reflection so it is best to build each service method only once
+     * and reuse it. Builders cannot be reused.
+     */
+    static final class Builder<T> {
+        final Retrofit retrofit;
+        final Method method;
+        final Annotation[] methodAnnotations;
+        final Annotation[][] parameterAnnotationsArray;
+        final Type[] parameterTypes;
+
+        Type responseType;
+        boolean gotField;
+        boolean gotPart;
+        boolean gotBody;
+        boolean gotPath;
+        boolean gotQuery;
+        boolean gotUrl;
+        String httpMethod;
+        boolean hasBody;
+        boolean isFormEncoded;
+        boolean isMultipart;
+        String relativeUrl;
+        Headers headers;
+        MediaType contentType;
+        Set<String> relativeUrlParamNames;
+        ParameterHandler<?>[] parameterHandlers;
+        Converter<ResponseBody, T> responseConverter;
+        CallAdapter<?> callAdapter;
+
+        public Builder(Retrofit retrofit, Method method) {
+            this.retrofit = retrofit;
+            this.method = method;
+            this.methodAnnotations = method.getAnnotations();
+            this.parameterTypes = method.getGenericParameterTypes();
+            this.parameterAnnotationsArray = method.getParameterAnnotations();
+        }
+
+        public ServiceMethod build() {
+            callAdapter = createCallAdapter();
+            responseType = callAdapter.responseType();
+            if (responseType == Response.class || responseType == okhttp3.Response.class) {
+                throw methodError("'"
+                        + Utils.getRawType(responseType).getName()
+                        + "' is not a valid response body type. Did you mean ResponseBody?");
+            }
+            responseConverter = createResponseConverter();
 
-        if (annotationAction == null) {
-          continue;
-        }
+            for (Annotation annotation : methodAnnotations) {
+                parseMethodAnnotation(annotation);
+            }
 
-        if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
-        }
+            if (httpMethod == null) {
+                throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+            }
 
-        result = annotationAction;
-      }
+            if (!hasBody) {
+                if (isMultipart) {
+                    throw methodError(
+                            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+                }
+                if (isFormEncoded) {
+                    throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+                            + "request body (e.g., @POST).");
+                }
+            }
 
-      if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
-      }
+            int parameterCount = parameterAnnotationsArray.length;
+            parameterHandlers = new ParameterHandler<?>[parameterCount];
+            for (int p = 0; p < parameterCount; p++) {
+                Type parameterType = parameterTypes[p];
+                if (Utils.hasUnresolvableType(parameterType)) {
+                    throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+                            parameterType);
+                }
+
+                Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+                if (parameterAnnotations == null) {
+                    throw parameterError(p, "No Retrofit annotation found.");
+                }
+
+                parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+            }
 
-      return result;
-    }
+            if (relativeUrl == null && !gotUrl) {
+                throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+            }
+            if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+                throw methodError("Non-body HTTP method cannot contain @Body.");
+            }
+            if (isFormEncoded && !gotField) {
+                throw methodError("Form-encoded method must contain at least one @Field.");
+            }
+            if (isMultipart && !gotPart) {
+                throw methodError("Multipart method must contain at least one @Part.");
+            }
 
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+            return new ServiceMethod<>(this);
         }
 
-        gotUrl = true;
-
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
-        } else {
-          throw parameterError(p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+        private CallAdapter<?> createCallAdapter() {
+            Type returnType = method.getGenericReturnType();
+            if (Utils.hasUnresolvableType(returnType)) {
+                throw methodError(
+                        "Method return type must not include a type variable or wildcard: %s", returnType);
+            }
+            if (returnType == void.class) {
+                throw methodError("Service methods cannot return void.");
+            }
+            Annotation[] annotations = method.getAnnotations();
+            try {
+                return retrofit.callAdapter(returnType, annotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                throw methodError(e, "Unable to create call adapter for %s", returnType);
+            }
         }
 
-      } else if (annotation instanceof Path) {
-        if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
+        private void parseMethodAnnotation(Annotation annotation) {
+            if (annotation instanceof DELETE) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+            } else if (annotation instanceof GET) {
+                parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+            } else if (annotation instanceof HEAD) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+                if (!Void.class.equals(responseType)) {
+                    throw methodError("HEAD method must use Void as response type.");
+                }
+            } else if (annotation instanceof PATCH) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+            } else if (annotation instanceof POST) {
+                parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+            } else if (annotation instanceof PUT) {
+                parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+            } else if (annotation instanceof OPTIONS) {
+                parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+            } else if (annotation instanceof HTTP) {
+                HTTP http = (HTTP) annotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            } else if (annotation instanceof retrofit2.http.Headers) {
+                String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError("@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotation instanceof Multipart) {
+                if (isFormEncoded) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                isMultipart = true;
+            } else if (annotation instanceof FormUrlEncoded) {
+                if (isMultipart) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                isFormEncoded = true;
+            }
         }
 
-      } else if (annotation instanceof QueryMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
-        }
+        private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+            if (this.httpMethod != null) {
+                throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+                        this.httpMethod, httpMethod);
+            }
+            this.httpMethod = httpMethod;
+            this.hasBody = hasBody;
 
-      } else if (annotation instanceof HeaderMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+            if (value.isEmpty()) {
+                return;
+            }
 
-        return new ParameterHandler.HeaderMap<>(valueConverter);
+            // Get the relative URL path and existing query string, if present.
+            int question = value.indexOf('?');
+            if (question != -1 && question < value.length() - 1) {
+                // Ensure the query string does not have any named parameters.
+                String queryParams = value.substring(question + 1);
+                Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+                if (queryParamMatcher.find()) {
+                    throw methodError("URL query string \"%s\" must not have replace block. "
+                            + "For dynamic query parameters use @Query.", queryParams);
+                }
+            }
 
-      } else if (annotation instanceof Field) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
+            this.relativeUrl = value;
+            this.relativeUrlParamNames = parsePathParameters(value);
+        }
+
+        private Headers parseHeaders(String[] headers) {
+            Headers.Builder builder = new Headers.Builder();
+            for (String header : headers) {
+                int colon = header.indexOf(':');
+                if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                    throw methodError(
+                            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+                }
+                String headerName = header.substring(0, colon);
+                String headerValue = header.substring(colon + 1).trim();
+                if ("Content-Type".equalsIgnoreCase(headerName)) {
+                    contentType = MediaType.parse(headerValue);
+                } else {
+                    builder.add(headerName, headerValue);
+                }
+            }
+            return builder.build();
         }
 
-      } else if (annotation instanceof FieldMap) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+        private ParameterHandler<?> parseParameter(
+                int p, Type parameterType, Annotation[] annotations) {
+            ParameterHandler<?> result = null;
+            for (Annotation annotation : annotations) {
+                ParameterHandler<?> annotationAction = parseParameterAnnotation(
+                        p, parameterType, annotations, annotation);
 
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+                if (annotationAction == null) {
+                    continue;
+                }
 
-      } else if (annotation instanceof Part) {
-        if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                if (result != null) {
+                    throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+                }
+
+                result = annotationAction;
             }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+
+            if (result == null) {
+                throw parameterError(p, "No Retrofit annotation found.");
             }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
+
+            return result;
+        }
+
+        private ParameterHandler<?> parseParameterAnnotation(
+                int p, Type type, Annotation[] annotations, Annotation annotation) {
+            if (annotation instanceof Url) {
+                if (gotUrl) {
+                    throw parameterError(p, "Multiple @Url method annotations found.");
+                }
+                if (gotPath) {
+                    throw parameterError(p, "@Path parameters may not be used with @Url.");
+                }
+                if (gotQuery) {
+                    throw parameterError(p, "A @Url parameter must not come after a @Query");
+                }
+                if (relativeUrl != null) {
+                    throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+                }
+
+                gotUrl = true;
+
+                if (type == HttpUrl.class
+                        || type == String.class
+                        || type == URI.class
+                        || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+                    return new ParameterHandler.RelativeUrl();
+                } else {
+                    throw parameterError(p,
+                            "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+                }
+
+            } else if (annotation instanceof Path) {
+                if (gotQuery) {
+                    throw parameterError(p, "A @Path parameter must not come after a @Query.");
+                }
+                if (gotUrl) {
+                    throw parameterError(p, "@Path parameters may not be used with @Url.");
+                }
+                if (relativeUrl == null) {
+                    throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+                }
+                gotPath = true;
+
+                Path path = (Path) annotation;
+                String name = path.value();
+                validatePathName(p, name);
+
+                Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+                return new ParameterHandler.Path<>(name, converter, path.encoded());
+
+            } else if (annotation instanceof Query) {
+                Query query = (Query) annotation;
+                String name = query.value();
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQuery = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof QueryMap) {
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@QueryMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
+
+            } else if (annotation instanceof Header) {
+                Header header = (Header) annotation;
+                String name = header.value();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Header<>(name, converter);
+                }
+
+            } else if (annotation instanceof HeaderMap) {
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@HeaderMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.HeaderMap<>(valueConverter);
+
+            } else if (annotation instanceof Field) {
+                if (!isFormEncoded) {
+                    throw parameterError(p, "@Field parameters can only be used with form encoding.");
+                }
+                Field field = (Field) annotation;
+                String name = field.value();
+                boolean encoded = field.encoded();
+
+                gotField = true;
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+                } else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).array();
+                } else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded);
+                }
+
+            } else if (annotation instanceof FieldMap) {
+                if (!isFormEncoded) {
+                    throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+                }
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@FieldMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                gotField = true;
+                return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+
+            } else if (annotation instanceof Part) {
+                if (!isMultipart) {
+                    throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+                }
+                Part part = (Part) annotation;
+                gotPart = true;
+
+                String partName = part.value();
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (partName.isEmpty()) {
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = rawParameterType.getComponentType();
+                        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        return ParameterHandler.RawPart.INSTANCE;
+                    } else {
+                        throw parameterError(p,
+                                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                    }
+                } else {
+                    Headers headers =
+                            Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                                    "Content-Transfer-Encoding", part.encoding());
+
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                    + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).iterable();
+                    } else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                    + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).array();
+                    } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                + "include a part name in the annotation.");
+                    } else {
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter);
+                    }
+                }
+
+            } else if (annotation instanceof PartMap) {
+                if (!isMultipart) {
+                    throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+                }
+                gotPart = true;
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@PartMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+                }
+
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+                    throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+                            + "Use @Part List<Part> or a different value type instead.");
+                }
+
+                Converter<?, RequestBody> valueConverter =
+                        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+                PartMap partMap = (PartMap) annotation;
+                return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+
+            } else if (annotation instanceof Body) {
+                if (isFormEncoded || isMultipart) {
+                    throw parameterError(p,
+                            "@Body parameters cannot be used with form or multi-part encoding.");
+                }
+                if (gotBody) {
+                    throw parameterError(p, "Multiple @Body method annotations found.");
+                }
+
+                Converter<?, RequestBody> converter;
+                try {
+                    converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                } catch (RuntimeException e) {
+                    // Wide exception range because factories are user code.
+                    throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+                }
+                gotBody = true;
+                return new ParameterHandler.Body<>(converter);
             }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+
+            return null; // Not a Retrofit annotation.
+        }
+
+        private void validatePathName(int p, String name) {
+            if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+                throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+                        PARAM_URL_REGEX.pattern(), name);
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
+            // Verify URL replacement name is actually present in the URL path.
+            if (!relativeUrlParamNames.contains(name)) {
+                throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
             }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
-          }
         }
 
-      } else if (annotation instanceof PartMap) {
-        if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
-        }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+        private Converter<ResponseBody, T> createResponseConverter() {
+            Annotation[] annotations = method.getAnnotations();
+            try {
+                return retrofit.responseBodyConverter(responseType, annotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                throw methodError(e, "Unable to create converter for %s", responseType);
+            }
         }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
 
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+        private RuntimeException methodError(String message, Object... args) {
+            return methodError(null, message, args);
         }
 
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
+        private RuntimeException methodError(Throwable cause, String message, Object... args) {
+            message = String.format(message, args);
+            return new IllegalArgumentException(message
+                    + "\n    for method "
+                    + method.getDeclaringClass().getSimpleName()
+                    + "."
+                    + method.getName(), cause);
         }
 
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
-
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
-
-      } else if (annotation instanceof Body) {
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
+        private RuntimeException parameterError(
+                Throwable cause, int p, String message, Object... args) {
+            return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
         }
 
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+        private RuntimeException parameterError(int p, String message, Object... args) {
+            return methodError(message + " (parameter #" + (p + 1) + ")", args);
         }
-        gotBody = true;
-        return new ParameterHandler.Body<>(converter);
-      }
-
-      return null; // Not a Retrofit annotation.
-    }
-
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
-
-    private Converter<ResponseBody, T> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create converter for %s", responseType);
-      }
     }
 
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+        Matcher m = PARAM_URL_REGEX.matcher(path);
+        Set<String> patterns = new LinkedHashSet<>();
+        while (m.find()) {
+            patterns.add(m.group(1));
+        }
+        return patterns;
     }
 
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
-    }
-
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
-    }
-
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
+    static Class<?> boxIfPrimitive(Class<?> type) {
+        if (boolean.class == type) return Boolean.class;
+        if (byte.class == type) return Byte.class;
+        if (char.class == type) return Character.class;
+        if (double.class == type) return Double.class;
+        if (float.class == type) return Float.class;
+        if (int.class == type) return Integer.class;
+        if (long.class == type) return Long.class;
+        if (short.class == type) return Short.class;
+        return type;
     }
-    return patterns;
-  }
-
-  static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 09ab09064..827a82a20 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -26,471 +26,491 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
 final class Utils {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+    static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
 
-  private Utils() {
-    // No instances.
-  }
+    private Utils() {
+        // No instances.
+    }
 
-  static Class<?> getRawType(Type type) {
-    if (type == null) throw new NullPointerException("type == null");
+    static Class<?> getRawType(Type type) {
+        if (type == null) throw new NullPointerException("type == null");
 
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-    }
-    if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-    }
-    if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-    }
-    if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-    }
+        if (type instanceof Class<?>) {
+            // Type is a normal class.
+            return (Class<?>) type;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+
+            // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+            // suspects some pathological case related to nested classes exists.
+            Type rawType = parameterizedType.getRawType();
+            if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+            return (Class<?>) rawType;
+        }
+        if (type instanceof GenericArrayType) {
+            Type componentType = ((GenericArrayType) type).getGenericComponentType();
+            return Array.newInstance(getRawType(componentType), 0).getClass();
+        }
+        if (type instanceof TypeVariable) {
+            // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+            // type that's more general than necessary is okay.
+            return Object.class;
+        }
+        if (type instanceof WildcardType) {
+            return getRawType(((WildcardType) type).getUpperBounds()[0]);
+        }
 
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
-    }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
+    }
+
+    /**
+     * Returns true if {@code a} and {@code b} are equal.
+     */
+    static boolean equals(Type a, Type b) {
+        if (a == b) {
+            return true; // Also handles (a == null && b == null).
+
+        } else if (a instanceof Class) {
+            return a.equals(b); // Class already specifies equals().
+
+        } else if (a instanceof ParameterizedType) {
+            if (!(b instanceof ParameterizedType)) return false;
+            ParameterizedType pa = (ParameterizedType) a;
+            ParameterizedType pb = (ParameterizedType) b;
+            return equal(pa.getOwnerType(), pb.getOwnerType())
+                    && pa.getRawType().equals(pb.getRawType())
+                    && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+        } else if (a instanceof GenericArrayType) {
+            if (!(b instanceof GenericArrayType)) return false;
+            GenericArrayType ga = (GenericArrayType) a;
+            GenericArrayType gb = (GenericArrayType) b;
+            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+        } else if (a instanceof WildcardType) {
+            if (!(b instanceof WildcardType)) return false;
+            WildcardType wa = (WildcardType) a;
+            WildcardType wb = (WildcardType) b;
+            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+                    && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+        } else if (a instanceof TypeVariable) {
+            if (!(b instanceof TypeVariable)) return false;
+            TypeVariable<?> va = (TypeVariable<?>) a;
+            TypeVariable<?> vb = (TypeVariable<?>) b;
+            return va.getGenericDeclaration() == vb.getGenericDeclaration()
+                    && va.getName().equals(vb.getName());
+
+        } else {
+            return false; // This isn't a type we support!
+        }
     }
 
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
+    /**
+     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+     */
+    static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+        if (toResolve == rawType) return context;
+
+        // We skip searching through interfaces if unknown is an interface.
+        if (toResolve.isInterface()) {
+            Class<?>[] interfaces = rawType.getInterfaces();
+            for (int i = 0, length = interfaces.length; i < length; i++) {
+                if (interfaces[i] == toResolve) {
+                    return rawType.getGenericInterfaces()[i];
+                } else if (toResolve.isAssignableFrom(interfaces[i])) {
+                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+                }
+            }
+        }
 
-    // We can't resolve this further.
-    return toResolve;
-  }
+        // Check our supertypes.
+        if (!rawType.isInterface()) {
+            while (rawType != Object.class) {
+                Class<?> rawSupertype = rawType.getSuperclass();
+                if (rawSupertype == toResolve) {
+                    return rawType.getGenericSuperclass();
+                } else if (toResolve.isAssignableFrom(rawSupertype)) {
+                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+                }
+                rawType = rawSupertype;
+            }
+        }
 
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
+        // We can't resolve this further.
+        return toResolve;
     }
-    throw new NoSuchElementException();
-  }
-
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
+
+    private static int indexOf(Object[] array, Object toFind) {
+        for (int i = 0; i < array.length; i++) {
+            if (toFind.equals(array[i])) return i;
+        }
+        throw new NoSuchElementException();
+    }
+
+    private static boolean equal(Object a, Object b) {
+        return a == b || (a != null && a.equals(b));
+    }
+
+    static int hashCodeOrZero(Object o) {
+        return o != null ? o.hashCode() : 0;
+    }
+
+    static String typeToString(Type type) {
+        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+    }
+
+    /**
+     * Returns the generic form of {@code supertype}. For example, if this is {@code
+     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+     * Iterable.class}.
+     *
+     * @param supertype a superclass of, or interface implemented by, this.
+     */
+    static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+        if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+        return resolve(context, contextRawType,
+                getGenericSupertype(context, contextRawType, supertype));
+    }
+
+    static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+        // This implementation is made a little more complicated in an attempt to avoid object-creation.
+        while (true) {
+            if (toResolve instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+                if (toResolve == typeVariable) {
+                    return toResolve;
+                }
+
+            } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+                Class<?> original = (Class<?>) toResolve;
+                Type componentType = original.getComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof GenericArrayType) {
+                GenericArrayType original = (GenericArrayType) toResolve;
+                Type componentType = original.getGenericComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            } else if (toResolve instanceof ParameterizedType) {
+                ParameterizedType original = (ParameterizedType) toResolve;
+                Type ownerType = original.getOwnerType();
+                Type newOwnerType = resolve(context, contextRawType, ownerType);
+                boolean changed = newOwnerType != ownerType;
+
+                Type[] args = original.getActualTypeArguments();
+                for (int t = 0, length = args.length; t < length; t++) {
+                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+                    if (resolvedTypeArgument != args[t]) {
+                        if (!changed) {
+                            args = args.clone();
+                            changed = true;
+                        }
+                        args[t] = resolvedTypeArgument;
+                    }
+                }
+
+                return changed
+                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+                        : original;
+
+            } else if (toResolve instanceof WildcardType) {
+                WildcardType original = (WildcardType) toResolve;
+                Type[] originalLowerBound = original.getLowerBounds();
+                Type[] originalUpperBound = original.getUpperBounds();
+
+                if (originalLowerBound.length == 1) {
+                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+                    if (lowerBound != originalLowerBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{Object.class}, new Type[]{lowerBound});
+                    }
+                } else if (originalUpperBound.length == 1) {
+                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+                    if (upperBound != originalUpperBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{upperBound}, EMPTY_TYPE_ARRAY);
+                    }
+                }
+                return original;
+
+            } else {
+                return toResolve;
             }
-            args[t] = resolvedTypeArgument;
-          }
         }
+    }
 
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
+    private static Type resolveTypeVariable(
+            Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+        Class<?> declaredByRaw = declaringClassOf(unknown);
 
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
+        // We can't reduce this further.
+        if (declaredByRaw == null) return unknown;
 
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
+        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+        if (declaredBy instanceof ParameterizedType) {
+            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
         }
-        return original;
 
-      } else {
-        return toResolve;
-      }
+        return unknown;
     }
-  }
-
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
 
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+    /**
+     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+     * a class.
+     */
+    private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
     }
 
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
+    static void checkNotPrimitive(Type type) {
+        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+            throw new IllegalArgumentException();
+        }
     }
-  }
 
-  static <T> T checkNotNull(T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
-    }
-    return object;
-  }
-
-  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
-  static boolean isAnnotationPresent(Annotation[] annotations,
-      Class<? extends Annotation> cls) {
-    for (Annotation annotation : annotations) {
-      if (cls.isInstance(annotation)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  static ResponseBody buffer(final ResponseBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.source().readAll(buffer);
-    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
-  }
-
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("API declarations must be interfaces.");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+    static <T> T checkNotNull(T object, String message) {
+        if (object == null) {
+            throw new NullPointerException(message);
+        }
+        return object;
     }
-  }
 
-  static Type getParameterUpperBound(int index, ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    if (index < 0 || index >= types.length) {
-      throw new IllegalArgumentException(
-          "Index " + index + " not in range [0," + types.length + ") for " + type);
-    }
-    Type paramType = types[index];
-    if (paramType instanceof WildcardType) {
-      return ((WildcardType) paramType).getUpperBounds()[0];
+    /**
+     * Returns true if {@code annotations} contains an instance of {@code cls}.
+     */
+    static boolean isAnnotationPresent(Annotation[] annotations,
+                                       Class<? extends Annotation> cls) {
+        for (Annotation annotation : annotations) {
+            if (cls.isInstance(annotation)) {
+                return true;
+            }
+        }
+        return false;
     }
-    return paramType;
-  }
 
-  static boolean hasUnresolvableType(Type type) {
-    if (type instanceof Class<?>) {
-      return false;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
-        if (hasUnresolvableType(typeArgument)) {
-          return true;
-        }
-      }
-      return false;
-    }
-    if (type instanceof GenericArrayType) {
-      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
-    }
-    if (type instanceof TypeVariable) {
-      return true;
-    }
-    if (type instanceof WildcardType) {
-      return true;
-    }
-    String className = type == null ? "null" : type.getClass().getName();
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-        + "GenericArrayType, but <" + type + "> is of type " + className);
-  }
-
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-    return getParameterUpperBound(0, (ParameterizedType) returnType);
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
+    static ResponseBody buffer(final ResponseBody body) throws IOException {
+        Buffer buffer = new Buffer();
+        body.source().readAll(buffer);
+        return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
     }
 
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
+    static <T> void validateServiceInterface(Class<T> service) {
+        if (!service.isInterface()) {
+            throw new IllegalArgumentException("API declarations must be interfaces.");
+        }
+        // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+        // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+        // the recommended pattern.
+        if (service.getInterfaces().length > 0) {
+            throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+        }
     }
 
-    @Override public Type getRawType() {
-      return rawType;
+    static Type getParameterUpperBound(int index, ParameterizedType type) {
+        Type[] types = type.getActualTypeArguments();
+        if (index < 0 || index >= types.length) {
+            throw new IllegalArgumentException(
+                    "Index " + index + " not in range [0," + types.length + ") for " + type);
+        }
+        Type paramType = types[index];
+        if (paramType instanceof WildcardType) {
+            return ((WildcardType) paramType).getUpperBounds()[0];
+        }
+        return paramType;
     }
 
-    @Override public Type getOwnerType() {
-      return ownerType;
+    static boolean hasUnresolvableType(Type type) {
+        if (type instanceof Class<?>) {
+            return false;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+                if (hasUnresolvableType(typeArgument)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        if (type instanceof GenericArrayType) {
+            return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+        }
+        if (type instanceof TypeVariable) {
+            return true;
+        }
+        if (type instanceof WildcardType) {
+            return true;
+        }
+        String className = type == null ? "null" : type.getClass().getName();
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + className);
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    static Type getCallResponseType(Type returnType) {
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalArgumentException(
+                    "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+        return getParameterUpperBound(0, (ParameterizedType) returnType);
     }
 
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
-    }
+    private static final class ParameterizedTypeImpl implements ParameterizedType {
+        private final Type ownerType;
+        private final Type rawType;
+        private final Type[] typeArguments;
 
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
-    }
-  }
+        public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+            // Require an owner type if the raw type needs it.
+            if (rawType instanceof Class<?>
+                    && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+                throw new IllegalArgumentException();
+            }
 
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
+            this.ownerType = ownerType;
+            this.rawType = rawType;
+            this.typeArguments = typeArguments.clone();
 
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
+            for (Type typeArgument : this.typeArguments) {
+                if (typeArgument == null) throw new NullPointerException();
+                checkNotPrimitive(typeArgument);
+            }
+        }
 
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
+        @Override
+        public Type[] getActualTypeArguments() {
+            return typeArguments.clone();
+        }
 
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Utils.equals(this, (GenericArrayType) o);
-    }
+        @Override
+        public Type getRawType() {
+            return rawType;
+        }
 
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
+        @Override
+        public Type getOwnerType() {
+            return ownerType;
+        }
 
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+        }
 
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+        }
 
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+        @Override
+        public String toString() {
+            StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+            result.append(typeToString(rawType));
+            if (typeArguments.length == 0) return result.toString();
+            result.append("<").append(typeToString(typeArguments[0]));
+            for (int i = 1; i < typeArguments.length; i++) {
+                result.append(", ").append(typeToString(typeArguments[i]));
+            }
+            return result.append(">").toString();
+        }
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
-    }
+    private static final class GenericArrayTypeImpl implements GenericArrayType {
+        private final Type componentType;
+
+        public GenericArrayTypeImpl(Type componentType) {
+            this.componentType = componentType;
+        }
+
+        @Override
+        public Type getGenericComponentType() {
+            return componentType;
+        }
 
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof GenericArrayType
+                    && Utils.equals(this, (GenericArrayType) o);
+        }
+
+        @Override
+        public int hashCode() {
+            return componentType.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return typeToString(componentType) + "[]";
+        }
     }
 
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
+    /**
+     * The WildcardType interface supports multiple upper bounds and multiple
+     * lower bounds. We only support what the Java 6 language needs - at most one
+     * bound. If a lower bound is set, the upper bound must be Object.class.
+     */
+    private static final class WildcardTypeImpl implements WildcardType {
+        private final Type upperBound;
+        private final Type lowerBound;
+
+        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+            if (lowerBounds.length > 1) throw new IllegalArgumentException();
+            if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+            if (lowerBounds.length == 1) {
+                if (lowerBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(lowerBounds[0]);
+                if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+                this.lowerBound = lowerBounds[0];
+                this.upperBound = Object.class;
+            } else {
+                if (upperBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(upperBounds[0]);
+                this.lowerBound = null;
+                this.upperBound = upperBounds[0];
+            }
+        }
+
+        @Override
+        public Type[] getUpperBounds() {
+            return new Type[]{upperBound};
+        }
+
+        @Override
+        public Type[] getLowerBounds() {
+            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        }
+
+        @Override
+        public String toString() {
+            if (lowerBound != null) return "? super " + typeToString(lowerBound);
+            if (upperBound == Object.class) return "?";
+            return "? extends " + typeToString(upperBound);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 98d1d8684..2b34619c9 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
@@ -30,7 +31,7 @@
  * body). The object will be serialized using the {@link Retrofit Retrofit} instance
  * {@link Converter Converter} and the result will be set directly as the
  * request body.
- * <p>
+ * <p/>
  * Body parameters may not be {@code null}.
  */
 @Documented
diff --git a/retrofit/src/main/java/retrofit2/http/DELETE.java b/retrofit/src/main/java/retrofit2/http/DELETE.java
index 4a2b3e519..e773e1d6d 100644
--- a/retrofit/src/main/java/retrofit2/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit2/http/DELETE.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a DELETE request. */
+/**
+ * Make a DELETE request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 4dbd1bf11..30bd64e9e 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -24,11 +24,11 @@
 
 /**
  * Named pair for a form-encoded request.
- * <p>
+ * <p/>
  * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * field pair for each non-{@code null} item.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre><code>
  * &#64;FormUrlEncoded
@@ -39,7 +39,7 @@
  * </code></pre>
  * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
- * <p>
+ * <p/>
  * Array/Varargs Example:
  * <pre><code>
  * &#64;FormUrlEncoded
@@ -56,8 +56,10 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Field {
-  String value();
+    String value();
 
-  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index a7eb1ee86..603b40a7a 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -24,7 +24,7 @@
 
 /**
  * Named key/value pairs for a form-encoded request.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre><code>
  * &#64;FormUrlEncoded
@@ -33,7 +33,7 @@
  * </code></pre>
  * Calling with {@code foo.things(ImmutableMap.of("foo", "bar", "kit", "kat")} yields a request
  * body of {@code foo=bar&kit=kat}.
- * <p>
+ * <p/>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see FormUrlEncoded
@@ -43,6 +43,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
-  /** Specifies whether the names and values are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the names and values are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java b/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java
index cb00931d0..8bd1dafde 100644
--- a/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java
+++ b/retrofit/src/main/java/retrofit2/http/FormUrlEncoded.java
@@ -25,7 +25,7 @@
 /**
  * Denotes that the request body will use form URL encoding. Fields should be declared as
  * parameters and annotated with {@link Field @Field}.
- * <p>
+ * <p/>
  * Requests made with this annotation will have {@code application/x-www-form-urlencoded} MIME
  * type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to
  * <a href="http://tools.ietf.org/html/rfc3986">RFC-3986</a>.
diff --git a/retrofit/src/main/java/retrofit2/http/GET.java b/retrofit/src/main/java/retrofit2/http/GET.java
index deca1820d..d4caedca6 100644
--- a/retrofit/src/main/java/retrofit2/http/GET.java
+++ b/retrofit/src/main/java/retrofit2/http/GET.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a GET request. */
+/**
+ * Make a GET request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface GET {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HEAD.java b/retrofit/src/main/java/retrofit2/http/HEAD.java
index 077787d4f..46fe339bb 100644
--- a/retrofit/src/main/java/retrofit2/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit2/http/HEAD.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a HEAD request. */
+/**
+ * Make a HEAD request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HEAD {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index 101eecf3b..39c4e5d1f 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -43,14 +44,16 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HTTP {
-  String method();
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String path() default "";
-  boolean hasBody() default false;
+    String method();
+
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String path() default "";
+
+    boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index b8f7a70ea..045764acd 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -30,7 +30,7 @@
  * </code></pre>
  * Header parameters may be {@code null} which will omit them from the request. Passing a
  * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
- * <p>
+ * <p/>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
  *
@@ -41,5 +41,5 @@
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Header {
-  String value();
+    String value();
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index aa1facd39..45eda0542 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -25,9 +25,9 @@
 
 /**
  * Adds headers specified in the {@link Map}.
- * <p>
+ * <p/>
  * Values are converted to strings using {@link String#valueOf(Object)}.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre>
  * &#64;GET("/search")
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index b360f3ec3..b1d5ca81e 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -46,5 +46,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface Headers {
-  String[] value();
+    String[] value();
 }
diff --git a/retrofit/src/main/java/retrofit2/http/OPTIONS.java b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
index 17dc085e3..329a7f139 100644
--- a/retrofit/src/main/java/retrofit2/http/OPTIONS.java
+++ b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make an OPTIONS request. */
+/**
+ * Make an OPTIONS request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface OPTIONS {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PATCH.java b/retrofit/src/main/java/retrofit2/http/PATCH.java
index 035276982..5ee8f8b92 100644
--- a/retrofit/src/main/java/retrofit2/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit2/http/PATCH.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a PATCH request. */
+/**
+ * Make a PATCH request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PATCH {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/POST.java b/retrofit/src/main/java/retrofit2/http/POST.java
index 34352cd34..b019bd5b9 100644
--- a/retrofit/src/main/java/retrofit2/http/POST.java
+++ b/retrofit/src/main/java/retrofit2/http/POST.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a POST request. */
+/**
+ * Make a POST request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface POST {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PUT.java b/retrofit/src/main/java/retrofit2/http/PUT.java
index 0d4437f86..d2a110d43 100644
--- a/retrofit/src/main/java/retrofit2/http/PUT.java
+++ b/retrofit/src/main/java/retrofit2/http/PUT.java
@@ -18,22 +18,25 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a PUT request. */
+/**
+ * Make a PUT request.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PUT {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p/>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index f320c088f..3ed5f482e 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -25,7 +26,7 @@
 
 /**
  * Denotes a single part of a multi-part request.
- * <p>
+ * <p/>
  * The parameter type on which this annotation exists will be processed in one of three ways:
  * <ul>
  * <li>If the type is {@link okhttp3.MultipartBody.Part} the contents will be used directly. Omit
@@ -37,9 +38,9 @@
  * {@linkplain Converter a converter}. Supply the part name in the annotation (e.g.,
  * {@code @Part("foo") Image photo}).</li>
  * </ul>
- * <p>
+ * <p/>
  * Values may be {@code null} which will omit them from the request body.
- * <p>
+ * <p/>
  * <pre><code>
  * &#64;Multipart
  * &#64;POST("/")
@@ -47,18 +48,21 @@
  *     &#64;Part("description") String description,
  *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
  * </code></pre>
- * <p>
+ * <p/>
  * Part parameters may not be {@code null}.
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Part {
-  /**
-   * The name of the part. Required for all parameter types except
-   * {@link okhttp3.MultipartBody.Part}.
-   */
-  String value() default "";
-  /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default "binary";
+    /**
+     * The name of the part. Required for all parameter types except
+     * {@link okhttp3.MultipartBody.Part}.
+     */
+    String value() default "";
+
+    /**
+     * The {@code Content-Transfer-Encoding} of this part.
+     */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 79eae2147..be1ff9612 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -25,7 +26,7 @@
 
 /**
  * Denotes name and value parts of a multi-part request.
- * <p>
+ * <p/>
  * Values of the map on which this annotation exists will be processed in one of two ways:
  * <ul>
  * <li>If the type is {@link okhttp3.RequestBody RequestBody} the value will be used
@@ -33,7 +34,7 @@
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
- * <p>
+ * <p/>
  * <pre><code>
  * &#64;Multipart
  * &#64;POST("/upload")
@@ -41,7 +42,7 @@
  *     &#64;Part("file") RequestBody file,
  *     &#64;PartMap Map&lt;String, RequestBody&gt; params);
  * </code></pre>
- * <p>
+ * <p/>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Multipart
@@ -51,6 +52,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of the parts. */
-  String encoding() default "binary";
+    /**
+     * The {@code Content-Transfer-Encoding} of the parts.
+     */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index 4d8c6f054..4cc7004d9 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -25,14 +25,14 @@
 /**
  * Named replacement in a URL path segment. Values are converted to string using
  * {@link String#valueOf(Object)} and URL encoded.
- * <p>
+ * <p/>
  * Simple example:
  * <pre><code>
  * &#64;GET("/image/{id}")
  * Call&lt;ResponseBody&gt; example(@Path("id") int id);
  * </code></pre>
  * Calling with {@code foo.example(1)} yields {@code /image/1}.
- * <p>
+ * <p/>
  * Values are URL encoded by default. Disable with {@code encoded=true}.
  * <pre><code>
  * &#64;GET("/user/{name}")
@@ -43,17 +43,17 @@
  * </code></pre>
  * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
  * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
- * <p>
+ * <p/>
  * Path parameters may not be {@code null}.
  */
 @Documented
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Path {
-  String value();
+    String value();
 
-  /**
-   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
-   */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 01d294f3a..a20dfba6b 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -24,25 +24,25 @@
 
 /**
  * Query parameter appended to the URL.
- * <p>
+ * <p/>
  * Values are converted to strings using {@link String#valueOf(Object)} and then URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * query parameter for each non-{@code null} item.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre><code>
  * &#64;GET("/list")
  * Call&lt;ResponseBody&gt; list(@Query("page") int page);
  * </code></pre>
  * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
- * <p>
+ * <p/>
  * Example with {@code null}:
  * <pre><code>
  * &#64;GET("/list")
  * Call&lt;ResponseBody&gt; list(@Query("category") String category);
  * </code></pre>
  * Calling with {@code foo.list(null)} yields {@code /list}.
- * <p>
+ * <p/>
  * Array/Varargs Example:
  * <pre><code>
  * &#64;GET("/list")
@@ -50,7 +50,7 @@
  * </code></pre>
  * Calling with {@code foo.list("bar", "baz")} yields
  * {@code /list?category=bar&category=baz}.
- * <p>
+ * <p/>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
  * <pre><code>
@@ -65,11 +65,13 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
-  /** The query parameter name. */
-  String value();
+    /**
+     * The query parameter name.
+     */
+    String value();
 
-  /**
-   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
-   */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 27e6ae836..d40e8310a 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -24,9 +24,9 @@
 
 /**
  * Query parameter keys and values appended to the URL.
- * <p>
+ * <p/>
  * Both keys and values are converted to strings using {@link String#valueOf(Object)}.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre><code>
  * &#64;GET("/search")
@@ -34,7 +34,7 @@
  * </code></pre>
  * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
  * {@code /search?foo=bar&kit=kat}.
- * <p>
+ * <p/>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
  * <pre><code>
@@ -43,7 +43,7 @@
  * </code></pre>
  * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+bar"))} yields
  * {@code /search?foo=foo+bar}.
- * <p>
+ * <p/>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
@@ -52,6 +52,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
-  /** Specifies whether parameter names and values are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether parameter names and values are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index 31187ca3d..165c8e58b 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 import retrofit2.Retrofit;
 
@@ -30,7 +31,7 @@
  * &#64;GET
  * Call&lt;ResponseBody&gt; list(@Url String url);
  * </code></pre>
- * <p>
+ * <p/>
  * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
  * the value will be resolved against a base URL to create the full endpoint URL.
  */
diff --git a/retrofit/src/main/java/retrofit2/http/package-info.java b/retrofit/src/main/java/retrofit2/http/package-info.java
index 2777d51b7..13ed7d48d 100644
--- a/retrofit/src/main/java/retrofit2/http/package-info.java
+++ b/retrofit/src/main/java/retrofit2/http/package-info.java
@@ -1,4 +1,6 @@
 // Copyright 2014 Square, Inc.
 
-/** Annotations for interface methods to control the HTTP request behavior. */
+/**
+ * Annotations for interface methods to control the HTTP request behavior.
+ */
 package retrofit2.http;
diff --git a/retrofit/src/test/java/retrofit2/CallAdapterTest.java b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
index d1ed83480..454aa32e7 100644
--- a/retrofit/src/test/java/retrofit2/CallAdapterTest.java
+++ b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
@@ -16,10 +16,12 @@
 package retrofit2;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.Map;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -28,69 +30,78 @@
 import static retrofit2.CallAdapter.Factory.getRawType;
 
 public final class CallAdapterTest {
-  @Test public void parameterizedTypeInvalidIndex() {
-    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    try {
-      getParameterUpperBound(-1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+    @Test
+    public void parameterizedTypeInvalidIndex() {
+        ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {
+        }.getType();
+        try {
+            getParameterUpperBound(-1, listOfString);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+        }
+        try {
+            getParameterUpperBound(1, listOfString);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+        }
     }
-    try {
-      getParameterUpperBound(1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+
+    @Test
+    public void parameterizedTypes() {
+        ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
+
+        ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
+        assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
+
+        ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
     }
-  }
-
-  @Test public void parameterizedTypes() {
-    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
-
-    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
-    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
-
-    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType();
-    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
-  }
-
-  @Test public void rawTypeThrowsOnNull() {
-    try {
-      getRawType(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("type == null");
+
+    @Test
+    public void rawTypeThrowsOnNull() {
+        try {
+            getRawType(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("type == null");
+        }
     }
-  }
 
-  @Test public void rawTypes() throws NoSuchMethodException {
-    assertThat(getRawType(String.class)).isSameAs(String.class);
+    @Test
+    public void rawTypes() throws NoSuchMethodException {
+        assertThat(getRawType(String.class)).isSameAs(String.class);
 
-    Type listOfString = new TypeToken<List<String>>() {}.getType();
-    assertThat(getRawType(listOfString)).isSameAs(List.class);
+        Type listOfString = new TypeToken<List<String>>() {
+        }.getType();
+        assertThat(getRawType(listOfString)).isSameAs(List.class);
 
-    Type stringArray = new TypeToken<String[]>() {}.getType();
-    assertThat(getRawType(stringArray)).isSameAs(String[].class);
+        Type stringArray = new TypeToken<String[]>() {
+        }.getType();
+        assertThat(getRawType(stringArray)).isSameAs(String[].class);
 
-    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
+        Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+        }.getType()).getActualTypeArguments()[0];
+        assertThat(getRawType(wild)).isSameAs(CharSequence.class);
 
-    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wildParam)).isSameAs(List.class);
+        Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
+        }.getType()).getActualTypeArguments()[0];
+        assertThat(getRawType(wildParam)).isSameAs(List.class);
 
-    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
-    assertThat(getRawType(typeVar)).isSameAs(Object.class);
-  }
+        Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
+        assertThat(getRawType(typeVar)).isSameAs(Object.class);
+    }
 
-  @SuppressWarnings("unused") // Used reflectively.
-  static class A<T> {
-    T method() {
-      return null;
+    @SuppressWarnings("unused") // Used reflectively.
+    static class A<T> {
+        T method() {
+            return null;
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index 18dd035af..51caec9bd 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -21,6 +21,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -32,8 +33,10 @@
 import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
+
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
@@ -50,898 +53,987 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class CallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Call<String> getString();
-    @GET("/") Call<ResponseBody> getBody();
-    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
-    @POST("/") Call<String> postString(@Body String body);
-    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
-  }
-
-  @Test public void http200Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http200Async() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Async() throws InterruptedException, IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void transportProblemSync() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void transportProblemAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Throwable failure = failureRef.get();
-    assertThat(failure).isInstanceOf(IOException.class);
-  }
-
-  @Test public void conversionProblemOutgoingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void conversionProblemIncomingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
-    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient.Builder() //
-        .addInterceptor(new Interceptor() {
-          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-            okhttp3.Response response = chain.proceed(chain.request());
-            ResponseBody body = response.body();
-            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-              @Override public long read(Buffer sink, long byteCount) throws IOException {
-                throw new IOException("cause");
-              }
-            });
-            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-            return response.newBuilder().body(body).build();
-          }
-        }).build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .client(client)
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                try {
-                  return value.string();
-                } catch (IOException e) {
-                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-                  throw new RuntimeException("wrapper", e);
-                }
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("cause");
-    }
-  }
-
-  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(204);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(205);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void executeCallOnce() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-    server.enqueue(new MockResponse());
-    Call<String> call = example.getString();
-    call.execute();
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Already executed.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("1234"));
-
-    Response<ResponseBody> response = example.getBody().execute();
-    assertThat(response.body().string()).isEqualTo("1234");
-  }
-
-  @Test public void responseBodyBuffers() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call<ResponseBody> buffered = example.getBody();
-    // When buffering we will detect all socket problems before returning the Response.
-    try {
-      buffered.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void responseBodyStreams() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Response<ResponseBody> response = example.getStreamingBody().execute();
-
-    ResponseBody streamedBody = response.body();
-    // When streaming we only detect socket problems as the ResponseBody is read.
-    try {
-      streamedBody.string();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(2);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
-    try {
-      rawBody.source();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
-    }
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(0);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
-  }
-
-  @Test public void reportsExecutedSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.execute();
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void reportsExecutedAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {}
-      @Override public void onFailure(Call<String> call, Throwable t) {}
-    });
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void cancelBeforeExecute() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Canceled");
-    }
-  }
-
-  @Test public void cancelBeforeEnqueue() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).hasMessage("Canceled");
-  }
-
-  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-    server.enqueue(new MockResponse().setBody("Hello"));
-
-    Call<String> call = service.getString();
-    assertThat(call.execute().body()).isEqualTo("Hi");
-
-    Call<String> cloned = call.clone();
-    assertThat(cloned.execute().body()).isEqualTo("Hello");
-  }
-
-  @Test public void cancelRequest() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    Call<String> call = service.getString();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
-  }
-
-  @Test public void requestBeforeExecuteCreates() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Call<String> getString();
+
+        @GET("/")
+        Call<ResponseBody> getBody();
+
+        @GET("/")
+        @Streaming
+        Call<ResponseBody> getStreamingBody();
+
+        @POST("/")
+        Call<String> postString(@Body String body);
+
+        @POST("/{a}")
+        Call<String> postRequestBody(@Path("a") Object a);
+    }
+
+    @Test
+    public void http200Sync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http200Async() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Response<String> response = responseRef.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http404Sync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.code()).isEqualTo(404);
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http404Async() throws InterruptedException, IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Response<String> response = responseRef.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.code()).isEqualTo(404);
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void transportProblemSync() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+        Call<String> call = example.getString();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException ignored) {
+        }
+    }
+
+    @Test
+    public void transportProblemAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Throwable failure = failureRef.get();
+        assertThat(failure).isInstanceOf(IOException.class);
+    }
+
+    @Test
+    public void conversionProblemOutgoingSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+                                                                          Retrofit retrofit) {
+                        return new Converter<String, RequestBody>() {
+                            @Override
+                            public RequestBody convert(String value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        Call<String> call = example.postString("Hi");
+        try {
+            call.execute();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertThat(e).hasMessage("I am broken!");
+        }
+    }
+
+    @Test
+    public void conversionProblemOutgoingAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+                                                                          Retrofit retrofit) {
+                        return new Converter<String, RequestBody>() {
+                            @Override
+                            public RequestBody convert(String value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.postString("Hi").enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+                .hasMessage("I am broken!");
+    }
+
+    @Test
+    public void conversionProblemIncomingSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.postString("Hi");
+        try {
+            call.execute();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertThat(e).hasMessage("I am broken!");
+        }
+    }
+
+    @Test
+    public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
+        // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
+        OkHttpClient client = new OkHttpClient.Builder() //
+                .addInterceptor(new Interceptor() {
+                    @Override
+                    public okhttp3.Response intercept(Chain chain) throws IOException {
+                        okhttp3.Response response = chain.proceed(chain.request());
+                        ResponseBody body = response.body();
+                        BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+                            @Override
+                            public long read(Buffer sink, long byteCount) throws IOException {
+                                throw new IOException("cause");
+                            }
+                        });
+                        body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+                        return response.newBuilder().body(body).build();
+                    }
+                }).build();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .client(client)
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                try {
+                                    return value.string();
+                                } catch (IOException e) {
+                                    // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                                    throw new RuntimeException("wrapper", e);
+                                }
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("cause");
+        }
+    }
+
+    @Test
+    public void conversionProblemIncomingAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.postString("Hi").enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+                .hasMessage("I am broken!");
+    }
+
+    @Test
+    public void http204SkipsConverter() throws IOException {
+        final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return converter;
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.code()).isEqualTo(204);
+        assertThat(response.body()).isNull();
+        verifyNoMoreInteractions(converter);
+    }
+
+    @Test
+    public void http205SkipsConverter() throws IOException {
+        final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                                                                            Annotation[] annotations, Retrofit retrofit) {
+                        return converter;
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.code()).isEqualTo(205);
+        assertThat(response.body()).isNull();
+        verifyNoMoreInteractions(converter);
+    }
+
+    @Test
+    public void executeCallOnce() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+        server.enqueue(new MockResponse());
+        Call<String> call = example.getString();
+        call.execute();
+        try {
+            call.execute();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Already executed.");
+        }
+    }
+
+    @Test
+    public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("1234"));
+
+        Response<ResponseBody> response = example.getBody().execute();
+        assertThat(response.body().string()).isEqualTo("1234");
+    }
+
+    @Test
+    public void responseBodyBuffers() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse()
+                .setBody("1234")
+                .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+        Call<ResponseBody> buffered = example.getBody();
+        // When buffering we will detect all socket problems before returning the Response.
+        try {
+            buffered.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("unexpected end of stream");
+        }
+    }
+
+    @Test
+    public void responseBodyStreams() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse()
+                .setBody("1234")
+                .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+        Response<ResponseBody> response = example.getStreamingBody().execute();
+
+        ResponseBody streamedBody = response.body();
+        // When streaming we only detect socket problems as the ResponseBody is read.
+        try {
+            streamedBody.string();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("unexpected end of stream");
+        }
+    }
+
+    @Test
+    public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("Hi");
+        ResponseBody rawBody = response.raw().body();
+        assertThat(rawBody.contentLength()).isEqualTo(2);
+        assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
+        try {
+            rawBody.source();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
+        }
+    }
+
+    @Test
+    public void emptyResponse() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("");
+        ResponseBody rawBody = response.raw().body();
+        assertThat(rawBody.contentLength()).isEqualTo(0);
+        assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
+    }
+
+    @Test
+    public void reportsExecutedSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        assertThat(call.isExecuted()).isFalse();
+
+        call.execute();
+        assertThat(call.isExecuted()).isTrue();
+    }
+
+    @Test
+    public void reportsExecutedAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        assertThat(call.isExecuted()).isFalse();
+
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertThat(call.isExecuted()).isTrue();
+    }
+
+    @Test
+    public void cancelBeforeExecute() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+        Call<String> call = service.getString();
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Canceled");
+        }
+    }
+
+    @Test
+    public void cancelBeforeEnqueue() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+        Call<String> call = service.getString();
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).hasMessage("Canceled");
+    }
+
+    @Test
+    public void cloningExecutedRequestDoesNotCopyState() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+        server.enqueue(new MockResponse().setBody("Hello"));
+
+        Call<String> call = service.getString();
+        assertThat(call.execute().body()).isEqualTo("Hi");
+
+        Call<String> cloned = call.clone();
+        assertThat(cloned.execute().body()).isEqualTo("Hello");
+    }
+
+    @Test
+    public void cancelRequest() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+        Call<String> call = service.getString();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+    }
+
+    @Test
+    public void requestBeforeExecuteCreates() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        call.execute();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterExecuteReturnsCachedValue() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.execute();
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
-      throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+    }
+
+    @Test
+    public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.request();
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+    }
+
+    @Test
+    public void requestThrowingBeforeEnqueueFailsEnqueue()
+            throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+    }
+
+    @Test
+    public void requestAfterEnqueueReturnsCachedValue() throws IOException,
+            InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterEnqueueFailingThrows() throws IOException,
+            InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index 24b871052..21dbb1264 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -16,12 +16,15 @@
 package retrofit2;
 
 import com.google.common.reflect.TypeToken;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -34,137 +37,164 @@
 
 @SuppressWarnings("unchecked")
 public final class ExecutorCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final Retrofit retrofit = new Retrofit.Builder()
-      .baseUrl("http://localhost:1")
-      .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
-    }
-  });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
-
-  @Test public void rawTypeThrows() {
-    try {
-      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-  }
-
-  @Test public void responseType() {
-    Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-  }
-
-  @Test public void adaptedCallExecute() throws IOException {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
-        return response;
-      }
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+    private final Retrofit retrofit = new Retrofit.Builder()
+            .baseUrl("http://localhost:1")
+            .build();
+    private final Callback<String> callback = mock(Callback.class);
+    private final Executor callbackExecutor = spy(new Executor() {
+        @Override
+        public void execute(Runnable runnable) {
+            runnable.run();
+        }
     });
-    assertThat(call.execute()).isSameAs(response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(call, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
-      }
-    };
-    Call<String> call = (Call<String>) adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(call, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  @Test public void adaptedCallCancel() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<Call<?>> adapter =
-        (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  static class EmptyCall implements Call<String> {
-    @Override public void enqueue(Callback<String> callback) {
-      throw new UnsupportedOperationException();
+    private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
+
+    @Test
+    public void rawTypeThrows() {
+        try {
+            factory.get(Call.class, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+    }
+
+    @Test
+    public void responseType() {
+        Type classType = new TypeToken<Call<String>>() {
+        }.getType();
+        assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type wilcardType = new TypeToken<Call<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type genericType = new TypeToken<Call<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
     }
 
-    @Override public boolean isExecuted() {
-      return false;
+    @Test
+    public void adaptedCallExecute() throws IOException {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Response<String> response = Response.success("Hi");
+        Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+            @Override
+            public Response<String> execute() throws IOException {
+                return response;
+            }
+        });
+        assertThat(call.execute()).isSameAs(response);
     }
 
-    @Override public Response<String> execute() throws IOException {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Response<String> response = Response.success("Hi");
+        EmptyCall originalCall = new EmptyCall() {
+            @Override
+            public void enqueue(Callback<String> callback) {
+                callback.onResponse(this, response);
+            }
+        };
+        Call<String> call = (Call<String>) adapter.adapt(originalCall);
+        call.enqueue(callback);
+        verify(callbackExecutor).execute(any(Runnable.class));
+        verify(callback).onResponse(call, response);
     }
 
-    @Override public void cancel() {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Throwable throwable = new IOException();
+        EmptyCall originalCall = new EmptyCall() {
+            @Override
+            public void enqueue(Callback<String> callback) {
+                callback.onFailure(this, throwable);
+            }
+        };
+        Call<String> call = (Call<String>) adapter.adapt(originalCall);
+        call.enqueue(callback);
+        verify(callbackExecutor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(callbackExecutor);
+        verify(callback).onFailure(call, throwable);
+        verifyNoMoreInteractions(callback);
     }
 
-    @Override public boolean isCanceled() {
-      return false;
+    @Test
+    public void adaptedCallCloneDeepCopy() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        Call<String> delegate = mock(Call.class);
+        Call<String> call = (Call<String>) adapter.adapt(delegate);
+        Call<String> cloned = call.clone();
+        assertThat(cloned).isNotSameAs(call);
+        verify(delegate).clone();
+        verifyNoMoreInteractions(delegate);
     }
 
-    @Override public Call<String> clone() {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallCancel() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<Call<?>> adapter =
+                (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        Call<String> delegate = mock(Call.class);
+        Call<String> call = (Call<String>) adapter.adapt(delegate);
+        call.cancel();
+        verify(delegate).cancel();
+        verifyNoMoreInteractions(delegate);
     }
 
-    @Override public Request request() {
-      throw new UnsupportedOperationException();
+    static class EmptyCall implements Call<String> {
+        @Override
+        public void enqueue(Callback<String> callback) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isExecuted() {
+            return false;
+        }
+
+        @Override
+        public Response<String> execute() throws IOException {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void cancel() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isCanceled() {
+            return false;
+        }
+
+        @Override
+        public Call<String> clone() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Request request() {
+            throw new UnsupportedOperationException();
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
index 8333969c6..3d6647329 100644
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -17,29 +17,29 @@
 
 // TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
 public final class Java8DefaultMethodsTest {
-  //@Rule public final MockWebServer server = new MockWebServer();
-  //
-  //interface Example {
-  //  @GET("/") Call<String> user(@Query("name") String name);
-  //
-  //  default Call<String> user() {
-  //    return user("hey");
-  //  }
-  //}
-  //
-  //@Test public void test() throws IOException {
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //
-  //  Retrofit retrofit = new Retrofit.Builder()
-  //      .baseUrl(server.url("/"))
-  //      .addConverterFactory(new ToStringConverterFactory())
-  //      .build();
-  //  Example example = retrofit.create(Example.class);
-  //
-  //  Response<String> response = example.user().execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //}
+    //@Rule public final MockWebServer server = new MockWebServer();
+    //
+    //interface Example {
+    //  @GET("/") Call<String> user(@Query("name") String name);
+    //
+    //  default Call<String> user() {
+    //    return user("hey");
+    //  }
+    //}
+    //
+    //@Test public void test() throws IOException {
+    //  server.enqueue(new MockResponse().setBody("Hi"));
+    //  server.enqueue(new MockResponse().setBody("Hi"));
+    //
+    //  Retrofit retrofit = new Retrofit.Builder()
+    //      .baseUrl(server.url("/"))
+    //      .addConverterFactory(new ToStringConverterFactory())
+    //      .build();
+    //  Example example = retrofit.create(Example.class);
+    //
+    //  Response<String> response = example.user().execute();
+    //  assertThat(response.body()).isEqualTo("Hi");
+    //  Response<String> response = example.user("hi").execute();
+    //  assertThat(response.body()).isEqualTo("Hi");
+    //}
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
index 63fa57b6c..4fed99328 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
@@ -16,11 +16,14 @@
 package retrofit2;
 
 import android.net.Uri;
+
 import okhttp3.Request;
 import okhttp3.ResponseBody;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+
 import retrofit2.http.GET;
 import retrofit2.http.Url;
 
@@ -30,33 +33,35 @@
 @RunWith(RobolectricTestRunner.class)
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestBuilderAndroidTest {
-  @Test public void getWithAndroidUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
-    }
+    @Test
+    public void getWithAndroidUriUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Uri url) {
+                return null;
+            }
+        }
 
-    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithAndroidUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
+        Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
     }
 
-    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
+    @Test
+    public void getWithAndroidUriUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Uri url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 042e08fd1..1cb630596 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.MultipartBody;
@@ -33,8 +34,10 @@
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okio.Buffer;
+
 import org.junit.Ignore;
 import org.junit.Test;
+
 import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
@@ -65,2431 +68,2679 @@
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
-
-  @Test public void customMethodNoBody() {
-    class Example {
-      @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodWithBody() {
-    class Example {
-      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
-    class Example {
-      @GET("/foo?bar={bar}") //
-      Call<ResponseBody> method(@Path("bar") String thing) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body @Query("nope") String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @interface NonNull {}
-
-  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "yep");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
-    }
-  }
-
-  @Test public void lackingMethod() {
-    class Example {
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Part("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartWithPartMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@PartMap Map<String, String> params) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Field("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") //
-      @Headers({}) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenMalformed() {
-    class Example {
-      @GET("/") //
-      @Headers("Malformed") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") //
-      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(String a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapMustBeAMap() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
-  }
-
-  @Test public void queryMapRejectsNull() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullKeys() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullValues() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put("kit", null);
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void getWithHeaderMap() {
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
-        return null;
-      }
+    private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+
+    @Test
+    public void customMethodNoBody() {
+        class Example {
+            @HTTP(method = "CUSTOM1", path = "/foo")
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("CUSTOM1");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+        assertThat(request.body()).isNull();
+    }
+
+    @Ignore("https://github.com/square/okhttp/issues/229")
+    @Test
+    public void customMethodWithBody() {
+        class Example {
+            @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("CUSTOM2");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void onlyOneEncodingIsAllowedMultipartFirst() {
+        class Example {
+            @Multipart //
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one encoding annotation is allowed.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+        class Example {
+            @FormUrlEncoded //
+            @Multipart //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one encoding annotation is allowed.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void invalidPathParam() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Path("hey!") String thing) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+                            + " Found: hey! (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void pathParamNotAllowedInQuery() throws Exception {
+        class Example {
+            @GET("/foo?bar={bar}")
+                //
+            Call<ResponseBody> method(@Path("bar") String thing) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "URL query string \"bar={bar}\" must not have replace block."
+                            + " For dynamic query parameters use @Query.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipleParameterAnnotationsNotAllowed() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Body @Query("nope") String o) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @interface NonNull {
+    }
+
+    @Test
+    public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "yep");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
+    }
+
+    @Test
+    public void twoMethodsFail() {
+        class Example {
+            @PATCH("/foo") //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void lackingMethod() {
+        class Example {
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitMultipartForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Part("a") int a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitMultipartWithPartMapForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, String> params) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartFailsOnNonBodyMethod() {
+        class Example {
+            @Multipart //
+            @GET("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartFailsWithNoParts() {
+        class Example {
+            @Multipart //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multipart method must contain at least one @Part.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitFormEncodingByFieldForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Field("a") int a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitFormEncodingByFieldMapForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void formEncodingFailsOnNonBodyMethod() {
+        class Example {
+            @FormUrlEncoded //
+            @GET("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void formEncodingFailsWithNoParts() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headersFailWhenEmptyOnMethod() {
+        class Example {
+            @GET("/") //
+            @Headers({})
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headersFailWhenMalformed() {
+        class Example {
+            @GET("/") //
+            @Headers("Malformed")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void pathParamNonPathParamAndTypedBytes() {
+        class Example {
+            @PUT("/{a}")
+                //
+            Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void parameterWithoutAnnotation() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(String a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void nonBodyHttpMethodWithSingleEntity() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Body String o) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void queryMapMustBeAMap() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap List<String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void queryMapSupportsSubclasses() {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Foo a) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+    }
+
+    @Test
+    public void queryMapRejectsNull() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map was null.");
+        }
+    }
+
+    @Test
+    public void queryMapRejectsNullKeys() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        Map<String, String> queryParams = new LinkedHashMap<>();
+        queryParams.put("ping", "pong");
+        queryParams.put(null, "kat");
+
+        try {
+            buildRequest(Example.class, queryParams);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map contained null key.");
+        }
+    }
+
+    @Test
+    public void queryMapRejectsNullValues() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        Map<String, String> queryParams = new LinkedHashMap<>();
+        queryParams.put("ping", "pong");
+        queryParams.put("kit", null);
+
+        try {
+            buildRequest(Example.class, queryParams);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+        }
+    }
+
+    @Test
+    public void getWithHeaderMap() {
+        class Example {
+            @GET("/search")
+            Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+                return null;
+            }
+        }
+
+        Map<String, Object> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put("Accept-Charset", "utf-8");
+
+        Request request = buildRequest(Example.class, headers);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+        assertThat(request.body()).isNull();
+        assertThat(request.headers().size()).isEqualTo(2);
+        assertThat(request.header("Accept")).isEqualTo("text/plain");
+        assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+    }
+
+    @Test
+    public void headerMapMustBeAMap() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap List<String> headers) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headerMapSupportsSubclasses() {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @GET("/search")
+            Call<ResponseBody> method(@HeaderMap Foo headers) {
+                return null;
+            }
+        }
+
+        Foo headers = new Foo();
+        headers.put("Accept", "text/plain");
+
+        Request request = buildRequest(Example.class, headers);
+        assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+        assertThat(request.headers().size()).isEqualTo(1);
+        assertThat(request.header("Accept")).isEqualTo("text/plain");
+    }
+
+    @Test
+    public void headerMapRejectsNull() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, (Map<String, String>) null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map was null.");
+        }
+    }
+
+    @Test
+    public void headerMapRejectsNullKeys() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        Map<String, String> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put(null, "utf-8");
+
+        try {
+            buildRequest(Example.class, headers);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map contained null key.");
+        }
+    }
+
+    @Test
+    public void headerMapRejectsNullValues() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        Map<String, String> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put("Accept-Charset", null);
+
+        try {
+            buildRequest(Example.class, headers);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+        }
+    }
+
+    @Test
+    public void twoBodies() {
+        class Example {
+            @PUT("/")
+                //
+            Call<ResponseBody> method(@Body String o1, @Body String o2) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void bodyInNonBodyRequest() {
+        class Example {
+            @Multipart //
+            @PUT("/")
+                //
+            Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void get() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void delete() {
+        class Example {
+            @DELETE("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("DELETE");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertNull(request.body());
+    }
+
+    @Test
+    public void head() {
+        class Example {
+            @HEAD("/foo/bar/")
+                //
+            Call<Void> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("HEAD");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headWithoutVoidThrows() {
+        class Example {
+            @HEAD("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "HEAD method must use Void as response type.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void post() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void put() {
+        class Example {
+            @PUT("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("PUT");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void patch() {
+        class Example {
+            @PATCH("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("PATCH");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void options() {
+        class Example {
+            @OPTIONS("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("OPTIONS");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "po ng");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUnusedAndInvalidNamedPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/{kit,kat}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "po%20ng");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathSegments() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/pong/more");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathStillPreventsRequestSplitting() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/\r\npong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void pathParamRequired() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+        }
+    }
+
+    @Test
+    public void getWithQueryParam() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedQueryParam() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "p%20o%20n%20g");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void queryParamOptionalOmitsQuery() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, new Object[]{null});
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    }
+
+    @Test
+    public void queryParamOptional() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
+                                      @Query("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", null, "kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+    }
+
+    @Test
+    public void getWithQueryUrlAndParam() {
+        class Example {
+            @GET("/foo/bar/?hi=mom")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQuery() {
+        class Example {
+            @GET("/foo/bar/?hi=mom")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
+                                      @Query("riff") String riff) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", "kat", "raff");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryThenPathThrows() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "kat", "pong");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithPathAndQueryQuestionMarkParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong?", "kat?");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryAmpersandParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong&", "kat&");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryHashParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong#", "kat#");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamList() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") List<Object> keys) {
+                return null;
+            }
+        }
+
+        List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+        Request request = buildRequest(Example.class, values);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") Object[] keys) {
+                return null;
+            }
+        }
+
+        Object[] values = {1, 2, null, "three"};
+        Request request = buildRequest(Example.class, new Object[]{values});
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamPrimitiveArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") int[] keys) {
+                return null;
+            }
+        }
+
+        int[] values = {1, 2, 3};
+        Request request = buildRequest(Example.class, new Object[]{values});
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamMap() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
+                return null;
+            }
+        }
+
+        Map<String, Object> params = new LinkedHashMap<>();
+        params.put("kit", "kat");
+        params.put("ping", "pong");
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedQueryParamMap() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
+                return null;
+            }
+        }
+
+        Map<String, Object> params = new LinkedHashMap<>();
+        params.put("kit", "k%20t");
+        params.put("pi%20ng", "p%20g");
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getAbsoluteUrl() {
+        class Example {
+            @GET("http://example2.com/foo/bar/")
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithStringUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithJavaUriUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url URI url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, URI.create("foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithStringUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithJavaUriUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url URI url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUrlAbsoluteSameHost() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithHttpUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url HttpUrl url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithNullUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url HttpUrl url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, (HttpUrl) null);
+            fail();
+        } catch (NullPointerException expected) {
+            assertThat(expected).hasMessage("@Url parameter is null.");
+        }
+    }
+
+    @Test
+    public void getWithNonStringUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+                            + " (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getUrlAndUrlParamThrows() {
+        class Example {
+            @GET("foo/bar")
+            Call<ResponseBody> method(@Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithoutUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithUrlThenPathThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithPathThenUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithQueryThenUrlThrows() {
+        class Example {
+            @GET("foo/bar")
+            Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "hey", "foo/bar/");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithUrlThenQuery() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "foo/bar/", "hey!");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+    }
+
+    @Test
+    public void postWithUrl() {
+        class Example {
+            @POST
+            Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void normalPostWithPathParam() {
+        class Example {
+            @POST("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+        Request request = buildRequest(Example.class, "pong", body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
+        assertBody(request.body(), "Hi!");
+    }
+
+    @Test
+    public void emptyBody() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "");
+    }
+
+    @Ignore("https://github.com/square/okhttp/issues/229")
+    @Test
+    public void customMethodEmptyBody() {
+        class Example {
+            @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true)
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("CUSTOM");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "");
+    }
+
+    @Test
+    public void bodyResponseBody() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void bodyRequired() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+        }
+    }
+
+    @Test
+    public void bodyWithPathParams() {
+        class Example {
+            @POST("/foo/bar/{ping}/{kit}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+        Request request = buildRequest(Example.class, "pong", body, "kat");
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+        assertBody(request.body(), "Hi!");
+    }
+
+    @Test
+    public void simpleMultipart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", RequestBody.create(
+                MediaType.parse("text/plain"), "kat"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartArray() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String[] ping) {
+                return null;
+            }
+        }
+
+        Request request =
+                buildRequest(Example.class, new Object[]{new String[]{"pong1", "pong2"}});
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong1\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong2\r\n--");
+    }
+
+    @Test
+    public void multipartRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part RequestBody part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartIterableRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part List<RequestBody> part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartArrayRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part RequestBody[] part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartOkHttpPartForbidsName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartOkHttpPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
+        Request request = buildRequest(Example.class, part);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpIterablePart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+        MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+        Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"foo\"\r\n")
+                .contains("\r\nbar\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpArrayPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+        MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+        Request request =
+                buildRequest(Example.class, new Object[]{new MultipartBody.Part[]{part1, part2}});
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"foo\"\r\n")
+                .contains("\r\nbar\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpPartWithFilename() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part =
+                MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+        Request request = buildRequest(Example.class, part);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartIterable() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") List<String> ping) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong1\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong2\r\n--");
+    }
+
+    @Test
+    public void multipartIterableOkHttpPart() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartArrayOkHttpPart() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartWithEncoding() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
+                                      @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", RequestBody.create(
+                MediaType.parse("text/plain"), "kat"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("Content-Transfer-Encoding: 7-bit")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMap() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", RequestBody.create(null, "kat"));
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMapWithEncoding() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", RequestBody.create(null, "kat"));
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMapRejectsNonStringKeys() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsOkHttpPartValues() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNull() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map was null.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNullKeys() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put(null, RequestBody.create(null, "kat"));
+
+        try {
+            buildRequest(Example.class, params);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map contained null key.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNullValues() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", null);
+
+        try {
+            buildRequest(Example.class, params);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapMustBeMap() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap List<Object> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, Collections.emptyList());
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapSupportsSubclasses() throws IOException {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Foo parts) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        Buffer buffer = new Buffer();
+        request.body().writeTo(buffer);
+        assertThat(buffer.readUtf8())
+                .contains("name=\"hello\"")
+                .contains("\r\n\r\nworld\r\n--");
+    }
+
+    @Test
+    public void multipartNullRemovesPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong", null);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong\r\n--");
+    }
+
+    @Test
+    public void multipartPartOptional() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") RequestBody ping) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+        }
+    }
+
+    @Test
+    public void simpleFormEncoded() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", "pong");
+        assertBody(request.body(), "foo=bar&ping=pong");
+    }
+
+    @Test
+    public void formEncodedWithEncodedNameFieldParam() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "ba%20r");
+        assertBody(request.body(), "na%20me=ba%20r");
+    }
+
+    @Test
+    public void formEncodedFieldOptional() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
+                                      @Field("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", null, "kat");
+        assertBody(request.body(), "foo=bar&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldList() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldArray() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        Object[] values = {1, 2, null, "three"};
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldPrimitiveArray() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        int[] values = {1, 2, 3};
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+    }
+
+    @Test
+    public void formEncodedWithEncodedNameFieldParamMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("k%20it", "k%20at");
+        fieldMap.put("pin%20g", "po%20ng");
+
+        Request request = buildRequest(Example.class, fieldMap);
+        assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+    }
+
+    @Test
+    public void formEncodedFieldMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put("ping", "pong");
+
+        Request request = buildRequest(Example.class, fieldMap);
+        assertBody(request.body(), "kit=kat&ping=pong");
+    }
+
+    @Test
+    public void fieldMapRejectsNull() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map was null.");
+        }
+    }
+
+    @Test
+    public void fieldMapRejectsNullKeys() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put(null, "pong");
+
+        try {
+            buildRequest(Example.class, fieldMap);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map contained null key.");
+        }
+    }
+
+    @Test
+    public void fieldMapRejectsNullValues() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put("foo", null);
+
+        try {
+            buildRequest(Example.class, fieldMap);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+        }
+    }
+
+    @Test
+    public void fieldMapMustBeAMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap List<String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void fieldMapSupportsSubclasses() throws IOException {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Foo a) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        Buffer buffer = new Buffer();
+        request.body().writeTo(buffer);
+        assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+    }
+
+    @Test
+    public void simpleHeaders() {
+        class Example {
+            @GET("/foo/bar/")
+            @Headers({
+                    "ping: pong",
+                    "kit: kat"
+            })
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.get("ping")).isEqualTo("pong");
+        assertThat(headers.get("kit")).isEqualTo("kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamToString() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("kit") BigInteger kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, new BigInteger("1234"));
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(1);
+        assertThat(headers.get("kit")).isEqualTo("1234");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParam() {
+        class Example {
+            @GET("/foo/bar/") //
+            @Headers("ping: pong")
+                //
+            Call<ResponseBody> method(@Header("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "kat");
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.get("ping")).isEqualTo("pong");
+        assertThat(headers.get("kit")).isEqualTo("kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamList() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("foo") List<String> kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.values("foo")).containsExactly("bar", "baz");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("foo") String[] kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, (Object) new String[]{"bar", null, "baz"});
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.values("foo")).containsExactly("bar", "baz");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void contentTypeAnnotationHeaderOverrides() {
+        class Example {
+            @POST("/") //
+            @Headers("Content-Type: text/not-plain")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
+        class Example {
+            @DELETE("/") //
+            @Headers("Content-Type: text/not-plain")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void contentTypeParameterHeaderOverrides() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+        Request request = buildRequest(Example.class, "text/not-plain", body);
+        assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void malformedAnnotationRelativeUrlThrows() {
+        class Example {
+            @GET("ftp://example.org")
+            Call<ResponseBody> get() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+        }
+    }
+
+    @Test
+    public void malformedParameterRelativeUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> get(@Url String relativeUrl) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, "ftp://example.org");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+        }
+    }
+
+    private static void assertBody(RequestBody body, String expected) {
+        assertThat(body).isNotNull();
+        Buffer buffer = new Buffer();
+        try {
+            body.writeTo(buffer);
+            assertThat(buffer.readUtf8()).isEqualTo(expected);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    static Request buildRequest(Class<?> cls, Object... args) {
+        final AtomicReference<Request> requestRef = new AtomicReference<>();
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                requestRef.set(request);
+                throw new UnsupportedOperationException("Not implemented");
+            }
+        };
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(new ToStringConverterFactory())
+                .callFactory(callFactory)
+                .build();
+
+        Method method = TestingUtils.onlyMethod(cls);
+        ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
+        OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+        Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
+        try {
+            call.execute();
+            throw new AssertionError();
+        } catch (UnsupportedOperationException ignored) {
+            return requestRef.get();
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new AssertionError(e);
+        }
     }
-
-    Map<String, Object> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", "utf-8");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.body()).isNull();
-    assertThat(request.headers().size()).isEqualTo(2);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
-  }
-
-  @Test public void headerMapMustBeAMap() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap List<String> headers) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void headerMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Foo headers) {
-        return null;
-      }
-    }
-
-    Foo headers = new Foo();
-    headers.put("Accept", "text/plain");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.headers().size()).isEqualTo(1);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-  }
-
-  @Test public void headerMapRejectsNull() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (Map<String, String>) null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullKeys() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put(null, "utf-8");
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullValues() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", null);
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
-    }
-  }
-
-  @Test public void twoBodies() {
-    class Example {
-      @PUT("/") //
-      Call<ResponseBody> method(@Body String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void get() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void delete() {
-    class Example {
-      @DELETE("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("DELETE");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertNull(request.body());
-  }
-
-  @Test public void head() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<Void> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("HEAD");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headWithoutVoidThrows() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HEAD method must use Void as response type.\n    for method Example.method");
-    }
-  }
-
-  @Test public void post() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void put() {
-    class Example {
-      @PUT("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void patch() {
-    class Example {
-      @PATCH("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PATCH");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void options() {
-    class Example {
-      @OPTIONS("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("OPTIONS");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnusedAndInvalidNamedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathSegments() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/pong/more");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\npong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void pathParamRequired() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
-    }
-  }
-
-  @Test public void getWithQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p%20o%20n%20g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void queryParamOptionalOmitsQuery() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void queryParamOptional() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
-          @Query("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQuery() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
-          @Query("riff") String riff) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", "kat", "raff");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryThenPathThrows() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "kat", "pong");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong?", "kat?");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong&", "kat&");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong#", "kat#");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") List<Object> keys) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
-    Request request = buildRequest(Example.class, values);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") Object[] keys) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamPrimitiveArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") int[] keys) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "kat");
-    params.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "k%20t");
-    params.put("pi%20ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getAbsoluteUrl() {
-    class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUrlAbsoluteSameHost() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithHttpUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithNullUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (HttpUrl) null);
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
-    }
-  }
-
-  @Test public void getWithNonStringUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
-              + " (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void getUrlAndUrlParamThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithoutUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenPathThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathThenUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithQueryThenUrlThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "hey", "foo/bar/");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenQuery() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
-  }
-
-  @Test public void postWithUrl() {
-    class Example {
-      @POST
-      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void normalPostWithPathParam() {
-    class Example {
-      @POST("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void emptyBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodEmptyBody() {
-    class Example {
-      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Test public void bodyResponseBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void bodyRequired() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
-    }
-  }
-
-  @Test public void bodyWithPathParams() {
-    class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body, "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void simpleMultipart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartArray() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String[] ping) {
-        return null;
-      }
-    }
-
-    Request request =
-        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartIterableRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<RequestBody> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPartForbidsName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpIterablePart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpArrayPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request =
-        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpPartWithFilename() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part =
-        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartIterable() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<String> ping) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartIterableOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMap() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapRejectsNonStringKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsOkHttpPartValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNull() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put(null, RequestBody.create(null, "kat"));
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", null);
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void multipartPartMapMustBeMap() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap List<Object> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, Collections.emptyList());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Foo parts) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8())
-        .contains("name=\"hello\"")
-        .contains("\r\n\r\nworld\r\n--");
-  }
-
-  @Test public void multipartNullRemovesPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong", null);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong\r\n--");
-  }
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba%20r");
-    assertBody(request.body(), "na%20me=ba%20r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertBody(request.body(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("k%20it", "k%20at");
-    fieldMap.put("pin%20g", "po%20ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNull() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullValues() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void fieldMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
-  }
-
-  @Test public void simpleHeaders() {
-    class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamToString() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new BigInteger("1234"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Call<ResponseBody> method(@Header("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") List<String> kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") String[] kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void contentTypeAnnotationHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeParameterHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
-    Request request = buildRequest(Example.class, "text/not-plain", body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedAnnotationRelativeUrlThrows() {
-    class Example {
-      @GET("ftp://example.org")
-      Call<ResponseBody> get() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  @Test public void malformedParameterRelativeUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> get(@Url String relativeUrl) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, "ftp://example.org");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  private static void assertBody(RequestBody body, String expected) {
-    assertThat(body).isNotNull();
-    Buffer buffer = new Buffer();
-    try {
-      body.writeTo(buffer);
-      assertThat(buffer.readUtf8()).isEqualTo(expected);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static Request buildRequest(Class<?> cls, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
-        throw new UnsupportedOperationException("Not implemented");
-      }
-    };
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
-
-    Method method = TestingUtils.onlyMethod(cls);
-    ServiceMethod<?> serviceMethod = retrofit.loadServiceMethod(method);
-    OkHttpCall<?> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<?> call = (Call<?>) serviceMethod.callAdapter.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 3d059b8ad..af1c1b5be 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -18,164 +18,179 @@
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.ResponseBody;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
-  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
-      .code(200)
-      .message("OK")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
-      .code(400)
-      .message("Broken!")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-
-  @Test public void success() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successNullAllowed() {
-    Response<Object> response = Response.success(null);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void successWithHeaders() {
-    Object body = new Object();
-    Headers headers = Headers.of("foo", "bar");
-    Response<Object> response = Response.success(body, headers);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullHeadersThrows() {
-    try {
-      Response.success("", (okhttp3.Headers) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("headers == null");
+    private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
+            .code(200)
+            .message("OK")
+            .protocol(Protocol.HTTP_1_1)
+            .request(new okhttp3.Request.Builder().url("http://localhost").build())
+            .build();
+    private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
+            .code(400)
+            .message("Broken!")
+            .protocol(Protocol.HTTP_1_1)
+            .request(new okhttp3.Request.Builder().url("http://localhost").build())
+            .build();
+
+    @Test
+    public void success() {
+        Object body = new Object();
+        Response<Object> response = Response.success(body);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successNullAllowed() {
+        Response<Object> response = Response.success(null);
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isNull();
+    }
+
+    @Test
+    public void successWithHeaders() {
+        Object body = new Object();
+        Headers headers = Headers.of("foo", "bar");
+        Response<Object> response = Response.success(body, headers);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successWithNullHeadersThrows() {
+        try {
+            Response.success("", (okhttp3.Headers) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("headers == null");
+        }
+    }
+
+    @Test
+    public void successWithRawResponse() {
+        Object body = new Object();
+        Response<Object> response = Response.success(body, successResponse);
+        assertThat(response.raw()).isSameAs(successResponse);
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successWithNullRawResponseThrows() {
+        try {
+            Response.success("", (okhttp3.Response) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("rawResponse == null");
+        }
     }
-  }
-
-  @Test public void successWithRawResponse() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body, successResponse);
-    assertThat(response.raw()).isSameAs(successResponse);
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullRawResponseThrows() {
-    try {
-      Response.success("", (okhttp3.Response) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
+
+    @Test
+    public void successWithErrorRawResponseThrows() {
+        try {
+            Response.success("", errorResponse);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("rawResponse must be successful response");
+        }
     }
-  }
-
-  @Test public void successWithErrorRawResponseThrows() {
-    try {
-      Response.success("", errorResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse must be successful response");
+
+    @Test
+    public void error() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        Response<?> response = Response.error(400, errorBody);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(400);
+        assertThat(response.message()).isNull();
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.body()).isNull();
+        assertThat(response.errorBody()).isSameAs(errorBody);
+    }
+
+    @Test
+    public void nullErrorThrows() {
+        try {
+            Response.error(400, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("body == null");
+        }
     }
-  }
-
-  @Test public void error() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(400, errorBody);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Response.error(400, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
+
+    @Test
+    public void errorWithSuccessCodeThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(200, errorBody);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("code < 400: 200");
+        }
     }
-  }
-
-  @Test public void errorWithSuccessCodeThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(200, errorBody);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("code < 400: 200");
+
+    @Test
+    public void errorWithRawResponse() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        Response<?> response = Response.error(errorBody, errorResponse);
+        assertThat(response.raw()).isSameAs(errorResponse);
+        assertThat(response.code()).isEqualTo(400);
+        assertThat(response.message()).isEqualTo("Broken!");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.body()).isNull();
+        assertThat(response.errorBody()).isSameAs(errorBody);
     }
-  }
-
-  @Test public void errorWithRawResponse() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(errorBody, errorResponse);
-    assertThat(response.raw()).isSameAs(errorResponse);
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isEqualTo("Broken!");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorWithRawResponseThrows() {
-    try {
-      Response.error(null, errorResponse);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
+
+    @Test
+    public void nullErrorWithRawResponseThrows() {
+        try {
+            Response.error(null, errorResponse);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("body == null");
+        }
     }
-  }
-
-  @Test public void errorWithNullRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
+
+    @Test
+    public void errorWithNullRawResponseThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(errorBody, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("rawResponse == null");
+        }
     }
-  }
-
-  @Test public void errorWithSuccessRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, successResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse should not be successful response");
+
+    @Test
+    public void errorWithSuccessRawResponseThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(errorBody, successResponse);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("rawResponse should not be successful response");
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 9c17cab42..20631bd0d 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -39,8 +40,10 @@
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.helpers.DelegatingCallAdapterFactory;
 import retrofit2.helpers.NonMatchingCallAdapterFactory;
 import retrofit2.helpers.NonMatchingConverterFactory;
@@ -64,1239 +67,1379 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class RetrofitTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface CallMethod {
-    @GET("/") Call<String> disallowed();
-    @POST("/") Call<ResponseBody> disallowed(@Body String body);
-
-    @GET("/") Call<retrofit2.Response> badType1();
-    @GET("/") Call<okhttp3.Response> badType2();
-
-    @GET("/") Call<ResponseBody> getResponseBody();
-    @GET("/") Call<Void> getVoid();
-    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
-    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
-    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
-  }
-  interface FutureMethod {
-    @GET("/") Future<String> method();
-  }
-  interface Extending extends CallMethod {
-  }
-  interface StringService {
-    @GET("/") String get();
-  }
-  interface UnresolvableResponseType {
-    @GET("/") <T> Call<T> typeVariable();
-    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
-    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
-    @GET("/") Call<?> wildcard();
-    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
-  }
-  interface UnresolvableParameterType {
-    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
-    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
-    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
-    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
-    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
-  }
-  interface VoidService {
-    @GET("/") void nope();
-  }
-  interface Annotated {
-    @GET("/") @Foo Call<String> method();
-    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
-    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
-
-    @Retention(RUNTIME)
-    @interface Foo {}
-  }
-  interface MutableParameters {
-    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
-  }
-
-  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
-  @Test public void objectMethodsStillWork() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    try {
-      retrofit.create(Extending.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
-    }
-  }
-
-  @Test public void responseTypeCannotBeRetrofitResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType1();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType1");
-    }
-  }
-
-  @Test public void responseTypeCannotBeOkHttpResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType2();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType2");
-    }
-  }
-
-  @Test public void voidReturnTypeNotAllowed() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    VoidService service = retrofit.create(VoidService.class);
-
-    try {
-      service.nope();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void validateEagerlyDisabledByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyDisabledByUser() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(false)
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyFailsAtCreation() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(true)
-        .build();
-
-    try {
-      retrofit.create(VoidService.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void callCallAdapterAddedByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-  }
-
-  @Test public void callCallCustomAdapter() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        if (getRawType(returnType) != Call.class) {
-          return null;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface CallMethod {
+        @GET("/")
+        Call<String> disallowed();
+
+        @POST("/")
+        Call<ResponseBody> disallowed(@Body String body);
+
+        @GET("/")
+        Call<retrofit2.Response> badType1();
+
+        @GET("/")
+        Call<okhttp3.Response> badType2();
+
+        @GET("/")
+        Call<ResponseBody> getResponseBody();
+
+        @GET("/")
+        Call<Void> getVoid();
+
+        @POST("/")
+        Call<ResponseBody> postRequestBody(@Body RequestBody body);
+
+        @GET("/")
+        Call<ResponseBody> queryString(@Query("foo") String foo);
+
+        @GET("/")
+        Call<ResponseBody> queryObject(@Query("foo") Object foo);
+    }
+
+    interface FutureMethod {
+        @GET("/")
+        Future<String> method();
+    }
+
+    interface Extending extends CallMethod {
+    }
+
+    interface StringService {
+        @GET("/")
+        String get();
+    }
+
+    interface UnresolvableResponseType {
+        @GET("/")
+        <T> Call<T> typeVariable();
+
+        @GET("/")
+        <T extends ResponseBody> Call<T> typeVariableUpperBound();
+
+        @GET("/")
+        <T> Call<List<Map<String, Set<T[]>>>> crazy();
+
+        @GET("/")
+        Call<?> wildcard();
+
+        @GET("/")
+        Call<? extends ResponseBody> wildcardUpperBound();
+    }
+
+    interface UnresolvableParameterType {
+        @POST("/")
+        <T> Call<ResponseBody> typeVariable(@Body T body);
+
+        @POST("/")
+        <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
+
+        @POST("/")
+        <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
+
+        @POST("/")
+        Call<ResponseBody> wildcard(@Body List<?> body);
+
+        @POST("/")
+        Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
+    }
+
+    interface VoidService {
+        @GET("/")
+        void nope();
+    }
+
+    interface Annotated {
+        @GET("/")
+        @Foo
+        Call<String> method();
+
+        @POST("/")
+        Call<ResponseBody> bodyParameter(@Foo @Body String param);
+
+        @GET("/")
+        Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
+
+        @Retention(RUNTIME)
+        @interface Foo {
+        }
+    }
+
+    interface MutableParameters {
+        @GET("/")
+        Call<String> method(@Query("i") AtomicInteger value);
+    }
+
+    @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+    @Test
+    public void objectMethodsStillWork() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        assertThat(example.hashCode()).isNotZero();
+        assertThat(example.equals(this)).isFalse();
+        assertThat(example.toString()).isNotEmpty();
+    }
+
+    @Test
+    public void interfaceWithExtendIsNotSupported() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        try {
+            retrofit.create(Extending.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
+        }
+    }
+
+    @Test
+    public void responseTypeCannotBeRetrofitResponse() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        try {
+            service.badType1();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+                            + "    for method CallMethod.badType1");
+        }
+    }
+
+    @Test
+    public void responseTypeCannotBeOkHttpResponse() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        try {
+            service.badType2();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+                            + "    for method CallMethod.badType2");
+        }
+    }
+
+    @Test
+    public void voidReturnTypeNotAllowed() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        VoidService service = retrofit.create(VoidService.class);
+
+        try {
+            service.nope();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageStartingWith(
+                    "Service methods cannot return void.\n    for method VoidService.nope");
+        }
+    }
+
+    @Test
+    public void validateEagerlyDisabledByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+
+        // Should not throw exception about incorrect configuration of the VoidService
+        retrofit.create(VoidService.class);
+    }
+
+    @Test
+    public void validateEagerlyDisabledByUser() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .validateEagerly(false)
+                .build();
+
+        // Should not throw exception about incorrect configuration of the VoidService
+        retrofit.create(VoidService.class);
+    }
+
+    @Test
+    public void validateEagerlyFailsAtCreation() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .validateEagerly(true)
+                .build();
+
+        try {
+            retrofit.create(VoidService.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageStartingWith(
+                    "Service methods cannot return void.\n    for method VoidService.nope");
+        }
+    }
+
+    @Test
+    public void callCallAdapterAddedByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.getResponseBody()).isNotNull();
+    }
+
+    @Test
+    public void callCallCustomAdapter() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        final AtomicBoolean adapterCalled = new AtomicBoolean();
+        class MyCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<?> get(final Type returnType, Annotation[] annotations,
+                                      Retrofit retrofit) {
+                factoryCalled.set(true);
+                if (getRawType(returnType) != Call.class) {
+                    return null;
+                }
+                return new CallAdapter<Call<?>>() {
+                    @Override
+                    public Type responseType() {
+                        return getParameterUpperBound(0, (ParameterizedType) returnType);
+                    }
+
+                    @Override
+                    public <R> Call<R> adapt(Call<R> call) {
+                        adapterCalled.set(true);
+                        return call;
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.getResponseBody()).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+        assertThat(adapterCalled.get()).isTrue();
+    }
+
+    @Test
+    public void customCallAdapter() {
+        class GreetingCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<String> get(Type returnType, Annotation[] annotations,
+                                           Retrofit retrofit) {
+                if (getRawType(returnType) != String.class) {
+                    return null;
+                }
+                return new CallAdapter<String>() {
+                    @Override
+                    public Type responseType() {
+                        return String.class;
+                    }
+
+                    @Override
+                    public <R> String adapt(Call<R> call) {
+                        return "Hi!";
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .addCallAdapterFactory(new GreetingCallAdapterFactory())
+                .build();
+        StringService example = retrofit.create(StringService.class);
+        assertThat(example.get()).isEqualTo("Hi!");
+    }
+
+    @Test
+    public void methodAnnotationsPassedToCallAdapter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations,
+                                      Retrofit retrofit) {
+                annotationsRef.set(annotations);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .addCallAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.method(); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void customCallAdapterMissingThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        FutureMethod example = retrofit.create(FutureMethod.class);
+        try {
+            example.method();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+                    + "    for method FutureMethod.method");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+    }
+
+    @Test
+    public void methodAnnotationsPassedToResponseBodyConverter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                                    Retrofit retrofit) {
+                annotationsRef.set(annotations);
+                return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.method(); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+        final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+        final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                                  Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+                parameterAnnotationsRef.set(parameterAnnotations);
+                methodAnnotationsRef.set(methodAnnotations);
+                return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+                        methodAnnotations, retrofit);
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.bodyParameter(null); // Trigger internal setup.
+
+        assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+        assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
+    }
+
+    @Test
+    public void parameterAnnotationsPassedToStringConverter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                        Retrofit retrofit) {
+                annotationsRef.set(annotations);
+
+                return new Converter<Object, String>() {
+                    @Override
+                    public String convert(Object value) throws IOException {
+                        return String.valueOf(value);
+                    }
+                };
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.queryParameter(null); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void stringConverterNotCalledForString() {
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                        Retrofit retrofit) {
+                throw new AssertionError();
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.queryString(null);
+        assertThat(call).isNotNull();
+        // We also implicitly assert the above factory was not called as it would have thrown.
+    }
+
+    @Test
+    public void stringConverterReturningNullResultsInDefault() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                        Retrofit retrofit) {
+                factoryCalled.set(true);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.queryObject(null);
+        assertThat(call).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonRequestBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        try {
+            example.disallowed("Hi!");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+                    + "    for method CallMethod.disallowed");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters");
+        }
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonResponseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        try {
+            example.disallowed();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method CallMethod.disallowed");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters");
+        }
+    }
+
+    @Test
+    public void requestBodyOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<ResponseBody> response = example.getResponseBody().execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void voidOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<Void> response = example.getVoid().execute();
+        assertThat(response.body()).isNull();
+    }
+
+    @Test
+    public void voidResponsesArePooled() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("abc"));
+        server.enqueue(new MockResponse().setBody("def"));
+
+        example.getVoid().execute();
+        example.getVoid().execute();
+
+        assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+        assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    }
+
+    @Test
+    public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+        Response<ResponseBody> response = example.postRequestBody(body).execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+
+        assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+    }
+
+    @Test
+    public void unresolvableResponseTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
+
+        try {
+            example.typeVariable();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
+        }
+        try {
+            example.typeVariableUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
+        }
+        try {
+            example.crazy();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
+                    + "    for method UnresolvableResponseType.crazy");
+        }
+        try {
+            example.wildcard();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
+        }
+        try {
+            example.wildcardUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
+                    + "    for method UnresolvableResponseType.wildcardUpperBound");
+        }
+    }
+
+    @Test
+    public void unresolvableParameterTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
+
+        try {
+            example.typeVariable(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
+        }
+        try {
+            example.typeVariableUpperBound(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
+        }
+        try {
+            example.crazy(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
+                    + "    for method UnresolvableParameterType.crazy");
+        }
+        try {
+            example.wildcard(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
         }
-        return new CallAdapter<Call<?>>() {
-          @Override public Type responseType() {
-            return getParameterUpperBound(0, (ParameterizedType) returnType);
-          }
-
-          @Override public <R> Call<R> adapt(Call<R> call) {
-            adapterCalled.set(true);
-            return call;
-          }
+        try {
+            example.wildcardUpperBound(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
+                    + "    for method UnresolvableParameterType.wildcardUpperBound");
+        }
+    }
+
+    @Test
+    public void baseUrlRequired() {
+        try {
+            new Retrofit.Builder().build();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Base URL required.");
+        }
+    }
+
+    @Test
+    public void baseUrlNullThrows() {
+        try {
+            new Retrofit.Builder().baseUrl((String) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("baseUrl == null");
+        }
+        try {
+            new Retrofit.Builder().baseUrl((HttpUrl) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("baseUrl == null");
+        }
+    }
+
+    @Test
+    public void baseUrlInvalidThrows() {
+        try {
+            new Retrofit.Builder().baseUrl("ftp://foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+        }
+    }
+
+    @Test
+    public void baseUrlNoTrailingSlashThrows() {
+        try {
+            new Retrofit.Builder().baseUrl("http://example.com/api");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+        }
+        HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+        try {
+            new Retrofit.Builder().baseUrl(parsed);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+        }
+    }
+
+    @Test
+    public void baseUrlStringPropagated() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        HttpUrl baseUrl = retrofit.baseUrl();
+        assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    }
+
+    @Test
+    public void baseHttpUrlPropagated() {
+        HttpUrl url = HttpUrl.parse("http://example.com/");
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(url)
+                .build();
+        assertThat(retrofit.baseUrl()).isSameAs(url);
+    }
+
+    @Test
+    public void clientNullThrows() {
+        try {
+            new Retrofit.Builder().client(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("client == null");
+        }
+    }
+
+    @Test
+    public void callFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com")
+                .build();
+        assertThat(retrofit.callFactory()).isNotNull();
+    }
+
+    @Test
+    public void callFactoryPropagated() {
+        okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+        assertThat(retrofit.callFactory()).isSameAs(callFactory);
+    }
+
+    @Test
+    public void callFactoryClientPropagated() {
+        OkHttpClient client = new OkHttpClient();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .client(client)
+                .build();
+        assertThat(retrofit.callFactory()).isSameAs(client);
+    }
+
+    @Test
+    public void callFactoryUsed() throws IOException {
+        okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                return new OkHttpClient().newCall(request);
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        service.getResponseBody().execute();
+        verify(callFactory).newCall(any(Request.class));
+        verifyNoMoreInteractions(callFactory);
+    }
+
+    @Test
+    public void callFactoryReturningNullThrows() throws IOException {
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                return null;
+            }
         };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-    assertThat(adapterCalled.get()).isTrue();
-  }
-
-  @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        if (getRawType(returnType) != String.class) {
-          return null;
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+        try {
+            call.execute();
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("Call.Factory returned null.");
         }
-        return new CallAdapter<String>() {
-          @Override public Type responseType() {
-            return String.class;
-          }
-
-          @Override public <R> String adapt(Call<R> call) {
-            return "Hi!";
-          }
+    }
+
+    @Test
+    public void callFactoryThrowingPropagates() {
+        final RuntimeException cause = new RuntimeException("Broken!");
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                throw cause;
+            }
         };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new GreetingCallAdapterFactory())
-        .build();
-    StringService example = retrofit.create(StringService.class);
-    assertThat(example.get()).isEqualTo("Hi!");
-  }
-
-  @Test public void methodAnnotationsPassedToCallAdapter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void customCallAdapterMissingThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    FutureMethod example = retrofit.create(FutureMethod.class);
-    try {
-      example.method();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-          + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-  }
-
-  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
-    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
-
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type,
-          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-        parameterAnnotationsRef.set(parameterAnnotations);
-        methodAnnotationsRef.set(methodAnnotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
-            methodAnnotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.bodyParameter(null); // Trigger internal setup.
-
-    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
-    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
-  }
-
-  @Test public void parameterAnnotationsPassedToStringConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-
-        return new Converter<Object, String>() {
-          @Override public String convert(Object value) throws IOException {
-            return String.valueOf(value);
-          }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+        try {
+            call.execute();
+            fail();
+        } catch (Exception e) {
+            assertThat(e).isSameAs(cause);
+        }
+    }
+
+    @Test
+    public void converterNullThrows() {
+        try {
+            new Retrofit.Builder().addConverterFactory(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("factory == null");
+        }
+    }
+
+    @Test
+    public void converterFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        List<Converter.Factory> converterFactories = retrofit.converterFactories();
+        assertThat(converterFactories).hasSize(1);
+        assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+    }
+
+    @Test
+    public void requestConverterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] parameterAnnotations = new Annotation[0];
+        Annotation[] methodAnnotations = new Annotation[1];
+
+        Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+                methodAnnotations, retrofit);
+
+        Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+                parameterAnnotations, methodAnnotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void requestConverterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.requestBodyConverter(type, annotations, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void requestConverterFactorySkippedNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+        NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory1)
+                .addConverterFactory(nonMatchingFactory2)
+                .build();
+
+        try {
+            retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory1.called).isFalse();
+        assertThat(nonMatchingFactory2.called).isTrue();
+    }
+
+    @Test
+    public void responseConverterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
+
+        Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).responseBodyConverter(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void responseConverterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.responseBodyConverter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void responseConverterFactorySkippedNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+        NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory1)
+                .addConverterFactory(nonMatchingFactory2)
+                .build();
+
+        try {
+            retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory1.called).isFalse();
+        assertThat(nonMatchingFactory2.called).isTrue();
+    }
+
+    @Test
+    public void stringConverterFactoryQueried() {
+        Type type = Object.class;
+        Annotation[] annotations = new Annotation[0];
+
+        Converter<?, String> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
+
+        Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).stringConverter(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void converterFactoryPropagated() {
+        Converter.Factory factory = mock(Converter.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+        assertThat(retrofit.converterFactories()).contains(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryNullThrows() {
+        try {
+            new Retrofit.Builder().addCallAdapterFactory(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("factory == null");
+        }
+    }
+
+    @Test
+    public void callAdapterFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callAdapterFactories()).isNotEmpty();
+    }
+
+    @Test
+    public void callAdapterFactoryPropagated() {
+        CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory)
+                .build();
+        assertThat(retrofit.callAdapterFactories()).contains(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+        CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryQueriedCanDelegate() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+        CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory1)
+                .addCallAdapterFactory(factory2)
+                .build();
+
+        doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+        CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory1).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory1);
+        verify(factory2).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory2);
+    }
+
+    @Test
+    public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+        CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+        CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory1)
+                .addCallAdapterFactory(factory2)
+                .addCallAdapterFactory(factory3)
+                .build();
+
+        doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+        CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory1).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory1);
+        verify(factory2).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory2);
+        verify(factory3).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory3);
+    }
+
+    @Test
+    public void callAdapterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.callAdapter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate call adapter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void callAdapterFactoryDelegateNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+        DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+        NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(delegatingFactory1)
+                .addCallAdapterFactory(delegatingFactory2)
+                .addCallAdapterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.callAdapter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate call adapter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+                    + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+
+        assertThat(delegatingFactory1.called).isTrue();
+        assertThat(delegatingFactory2.called).isTrue();
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void callbackExecutorNullThrows() {
+        try {
+            new Retrofit.Builder().callbackExecutor(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("executor == null");
+        }
+    }
+
+    @Test
+    public void callbackExecutorPropagatesDefaultJvm() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callbackExecutor()).isNull();
+    }
+
+    @Test
+    public void callbackExecutorPropagatesDefaultAndroid() {
+        final Executor executor = Executors.newSingleThreadExecutor();
+        Platform platform = new Platform() {
+            @Override
+            Executor defaultCallbackExecutor() {
+                return executor;
+            }
         };
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.queryParameter(null); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void stringConverterNotCalledForString() {
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        throw new AssertionError();
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryString(null);
-    assertThat(call).isNotNull();
-    // We also implicitly assert the above factory was not called as it would have thrown.
-  }
-
-  @Test public void stringConverterReturningNullResultsInDefault() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryObject(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    try {
-      example.disallowed("Hi!");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    try {
-      example.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void requestBodyOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<ResponseBody> response = example.getResponseBody().execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-  }
-
-  @Test public void voidOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<Void> response = example.getVoid().execute();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void voidResponsesArePooled() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    example.getVoid().execute();
-    example.getVoid().execute();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.postRequestBody(body).execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
-  }
-
-  @Test public void unresolvableResponseTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
-
-    try {
-      example.typeVariable();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
-          + "    for method UnresolvableResponseType.crazy");
-    }
-    try {
-      example.wildcard();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
-          + "    for method UnresolvableResponseType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void unresolvableParameterTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
-
-    try {
-      example.typeVariable(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.crazy");
-    }
-    try {
-      example.wildcard(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void baseUrlRequired() {
-    try {
-      new Retrofit.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Base URL required.");
-    }
-  }
-
-  @Test public void baseUrlNullThrows() {
-    try {
-      new Retrofit.Builder().baseUrl((String) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-    try {
-      new Retrofit.Builder().baseUrl((HttpUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-  }
-
-  @Test public void baseUrlInvalidThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("ftp://foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
-    }
-  }
-
-  @Test public void baseUrlNoTrailingSlashThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("http://example.com/api");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
-    try {
-      new Retrofit.Builder().baseUrl(parsed);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-  }
-
-  @Test public void baseUrlStringPropagated() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
-  }
-
-  @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(url)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(url);
-  }
-
-  @Test public void clientNullThrows() {
-    try {
-      new Retrofit.Builder().client(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("client == null");
-    }
-  }
-
-  @Test public void callFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    assertThat(retrofit.callFactory()).isNotNull();
-  }
-
-  @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(callFactory);
-  }
-
-  @Test public void callFactoryClientPropagated() {
-    OkHttpClient client = new OkHttpClient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .client(client)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(client);
-  }
-
-  @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return new OkHttpClient().newCall(request);
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
-  }
-
-  @Test public void callFactoryReturningNullThrows() throws IOException {
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return null;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Call.Factory returned null.");
-    }
-  }
-
-  @Test public void callFactoryThrowingPropagates() {
-    final RuntimeException cause = new RuntimeException("Broken!");
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        throw cause;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (Exception e) {
-      assertThat(e).isSameAs(cause);
-    }
-  }
-
-  @Test public void converterNullThrows() {
-    try {
-      new Retrofit.Builder().addConverterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void converterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
-    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
-  }
-
-  @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
-
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void requestConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.requestBodyConverter(type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void requestConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void responseConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.responseBodyConverter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void responseConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-    assertThat(retrofit.converterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryNullThrows() {
-    try {
-      new Retrofit.Builder().addCallAdapterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void callAdapterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
-  }
-
-  @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-    assertThat(retrofit.callAdapterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .build();
-
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .addCallAdapterFactory(factory3)
-        .build();
-
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
-    CallAdapter<?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
-  }
-
-  @Test public void callAdapterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
-    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(delegatingFactory1)
-        .addCallAdapterFactory(delegatingFactory2)
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(delegatingFactory1.called).isTrue();
-    assertThat(delegatingFactory2.called).isTrue();
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callbackExecutorNullThrows() {
-    try {
-      new Retrofit.Builder().callbackExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
-    }
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultJvm() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isNull();
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultAndroid() {
-    final Executor executor = Executors.newSingleThreadExecutor();
-    Platform platform = new Platform() {
-      @Override Executor defaultCallbackExecutor() {
-        return executor;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder(platform)
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callbackExecutor(executor)
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse());
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
-  @Test public void argumentCapture() throws Exception {
-    AtomicInteger i = new AtomicInteger();
-
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
-
-    i.set(100);
-    Call<String> call1 = mutableParameters.method(i);
-
-    i.set(101);
-    Response<String> response1 = call1.execute();
-
-    i.set(102);
-    assertEquals("a", response1.body());
-    assertEquals("/?i=101", server.takeRequest().getPath());
-
-    i.set(200);
-    Call<String> call2 = call1.clone();
-
-    i.set(201);
-    Response<String> response2 = call2.execute();
-
-    i.set(202);
-    assertEquals("b", response2.body());
-
-    assertEquals("/?i=201", server.takeRequest().getPath());
-  }
+        Retrofit retrofit = new Retrofit.Builder(platform)
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+    }
+
+    @Test
+    public void callbackExecutorPropagated() {
+        Executor executor = mock(Executor.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callbackExecutor(executor)
+                .build();
+        assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+    }
+
+    @Test
+    public void callbackExecutorUsedForSuccess() throws InterruptedException {
+        Executor executor = spy(new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                command.run();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callbackExecutor(executor)
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+
+        server.enqueue(new MockResponse());
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<ResponseBody>() {
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+        verify(executor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(executor);
+    }
+
+    @Test
+    public void callbackExecutorUsedForFailure() throws InterruptedException {
+        Executor executor = spy(new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                command.run();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callbackExecutor(executor)
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<ResponseBody>() {
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+        verify(executor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(executor);
+    }
+
+    /**
+     * Confirm that Retrofit encodes parameters when the call is executed, and not earlier.
+     */
+    @Test
+    public void argumentCapture() throws Exception {
+        AtomicInteger i = new AtomicInteger();
+
+        server.enqueue(new MockResponse().setBody("a"));
+        server.enqueue(new MockResponse().setBody("b"));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
+
+        i.set(100);
+        Call<String> call1 = mutableParameters.method(i);
+
+        i.set(101);
+        Response<String> response1 = call1.execute();
+
+        i.set(102);
+        assertEquals("a", response1.body());
+        assertEquals("/?i=101", server.takeRequest().getPath());
+
+        i.set(200);
+        Call<String> call2 = call1.clone();
+
+        i.set(201);
+        Response<String> response2 = call2.execute();
+
+        i.set(202);
+        assertEquals("b", response2.body());
+
+        assertEquals("/?i=201", server.takeRequest().getPath());
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
index c9c48f31e..61803b211 100644
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
@@ -16,32 +16,34 @@
 package retrofit2;
 
 import java.util.Set;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ServiceMethodTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
+    @Test
+    public void pathParameterParsing() throws Exception {
+        expectParams("/");
+        expectParams("/foo");
+        expectParams("/foo/bar");
+        expectParams("/foo/bar/{}");
+        expectParams("/foo/bar/{taco}", "taco");
+        expectParams("/foo/bar/{t}", "t");
+        expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+        expectParams("/foo/bar/{}/{taco}", "taco");
+        expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+        expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+        expectParams("/foo/bar/{taco-shell}", "taco-shell");
+        expectParams("/foo/bar/{taco_shell}", "taco_shell");
+        expectParams("/foo/bar/{sha256}", "sha256");
+        expectParams("/foo/bar/{TACO}", "TACO");
+        expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+        expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+    }
 
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
-    assertThat(calculated).containsExactly(expected);
-  }
+    private static void expectParams(String path, String... expected) {
+        Set<String> calculated = ServiceMethod.parsePathParameters(path);
+        assertThat(calculated).containsExactly(expected);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 3847509ea..035baa135 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -18,11 +18,11 @@
 import java.lang.reflect.Method;
 
 public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
-    Method[] declaredMethods = c.getDeclaredMethods();
-    if (declaredMethods.length == 1) {
-      return declaredMethods[0];
+    public static Method onlyMethod(Class c) {
+        Method[] declaredMethods = c.getDeclaredMethods();
+        if (declaredMethods.length == 1) {
+            return declaredMethods[0];
+        }
+        throw new IllegalArgumentException("More than one method declared.");
     }
-    throw new IllegalArgumentException("More than one method declared.");
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
index 918b0ea0f..03d23aa3a 100644
--- a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -17,15 +17,16 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return retrofit.nextCallAdapter(this, returnType, annotations);
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        called = true;
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 2b4954813..d8194e5e8 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -17,15 +17,16 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
index 343839944..439506325 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -17,30 +17,33 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingConverterFactory extends Converter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..c32178741 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,30 +26,33 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+    static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                            Retrofit retrofit) {
+        if (String.class.equals(type)) {
+            return new Converter<ResponseBody, String>() {
+                @Override
+                public String convert(ResponseBody value) throws IOException {
+                    return value.string();
+                }
+            };
         }
-      };
+        return null;
     }
-    return null;
-  }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MEDIA_TYPE, value);
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (String.class.equals(type)) {
+            return new Converter<String, RequestBody>() {
+                @Override
+                public RequestBody convert(String value) throws IOException {
+                    return RequestBody.create(MEDIA_TYPE, value);
+                }
+            };
         }
-      };
+        return null;
     }
-    return null;
-  }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index 7623429bd..a7a8ad32f 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -1,64 +1,66 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.3-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.0.3-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>samples</artifactId>
-  <name>Samples</name>
+    <artifactId>samples</artifactId>
+    <name>Samples</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit-mock</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>converter-gson</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>converter-simplexml</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.jsoup</groupId>
-      <artifactId>jsoup</artifactId>
-      <version>${jsoup.version}</version>
-    </dependency>
-  </dependencies>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit-mock</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>converter-gson</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>converter-simplexml</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>${jsoup.version}</version>
+        </dependency>
+    </dependencies>
 
-  <build>
-    <plugins>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+    <build>
+        <plugins>
+            <!-- Do not deploy this as an artifact to Maven central. -->
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-deploy-plugin</artifactId>
+                <configuration>
+                    <skip>true</skip>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 790675975..98595e779 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -38,92 +39,96 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class ChunkingConverter {
-  @Target(PARAMETER)
-  @Retention(RUNTIME)
-  @interface Chunked {
-  }
-
-  /**
-   * A converter which removes known content lengths to force chunking when {@code @Chunked} is
-   * present on {@code @Body} params.
-   */
-  static class ChunkingConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      boolean isBody = false;
-      boolean isChunked = false;
-      for (Annotation annotation : parameterAnnotations) {
-        isBody |= annotation instanceof Body;
-        isChunked |= annotation instanceof Chunked;
-      }
-      if (!isBody || !isChunked) {
-        return null;
-      }
-
-      // Look up the real converter to delegate to.
-      final Converter<Object, RequestBody> delegate =
-          retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
-      // Wrap it in a Converter which removes the content length from the delegate's body.
-      return new Converter<Object, RequestBody>() {
-        @Override public RequestBody convert(Object value) throws IOException {
-          final RequestBody realBody = delegate.convert(value);
-          return new RequestBody() {
-            @Override public MediaType contentType() {
-              return realBody.contentType();
-            }
+    @Target(PARAMETER)
+    @Retention(RUNTIME)
+    @interface Chunked {
+    }
 
-            @Override public void writeTo(BufferedSink sink) throws IOException {
-              realBody.writeTo(sink);
+    /**
+     * A converter which removes known content lengths to force chunking when {@code @Chunked} is
+     * present on {@code @Body} params.
+     */
+    static class ChunkingConverterFactory extends Converter.Factory {
+        @Override
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            boolean isBody = false;
+            boolean isChunked = false;
+            for (Annotation annotation : parameterAnnotations) {
+                isBody |= annotation instanceof Body;
+                isChunked |= annotation instanceof Chunked;
             }
-          };
+            if (!isBody || !isChunked) {
+                return null;
+            }
+
+            // Look up the real converter to delegate to.
+            final Converter<Object, RequestBody> delegate =
+                    retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
+            // Wrap it in a Converter which removes the content length from the delegate's body.
+            return new Converter<Object, RequestBody>() {
+                @Override
+                public RequestBody convert(Object value) throws IOException {
+                    final RequestBody realBody = delegate.convert(value);
+                    return new RequestBody() {
+                        @Override
+                        public MediaType contentType() {
+                            return realBody.contentType();
+                        }
+
+                        @Override
+                        public void writeTo(BufferedSink sink) throws IOException {
+                            realBody.writeTo(sink);
+                        }
+                    };
+                }
+            };
         }
-      };
     }
-  }
 
-  static class Repo {
-    final String owner;
-    final String name;
+    static class Repo {
+        final String owner;
+        final String name;
+
+        Repo(String owner, String name) {
+            this.owner = owner;
+            this.name = name;
+        }
+    }
+
+    interface Service {
+        @POST("/")
+        Call<ResponseBody> sendNormal(@Body Repo repo);
+
+        @POST("/")
+        Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
+    }
+
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.enqueue(new MockResponse());
+        server.enqueue(new MockResponse());
+        server.start();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ChunkingConverterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Repo retrofitRepo = new Repo("square", "retrofit");
+
+        service.sendNormal(retrofitRepo).execute();
+        RecordedRequest normalRequest = server.takeRequest();
+        System.out.println(
+                "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
+
+        service.sendChunked(retrofitRepo).execute();
+        RecordedRequest chunkedRequest = server.takeRequest();
+        System.out.println(
+                "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
 
-    Repo(String owner, String name) {
-      this.owner = owner;
-      this.name = name;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @POST("/")
-    Call<ResponseBody> sendNormal(@Body Repo repo);
-    @POST("/")
-    Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ChunkingConverterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Repo retrofitRepo = new Repo("square", "retrofit");
-
-    service.sendNormal(retrofitRepo).execute();
-    RecordedRequest normalRequest = server.takeRequest();
-    System.out.println(
-        "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
-
-    service.sendChunked(retrofitRepo).execute();
-    RecordedRequest chunkedRequest = server.takeRequest();
-    System.out.println(
-        "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 97c739e39..ae32a9844 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -27,14 +27,17 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.ResponseBody;
+
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
+
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Converter;
@@ -43,104 +46,111 @@
 import retrofit2.http.GET;
 import retrofit2.http.Url;
 
-/** A simple web crawler that uses a Retrofit service to turn URLs into webpages. */
+/**
+ * A simple web crawler that uses a Retrofit service to turn URLs into webpages.
+ */
 public final class Crawler {
-  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
-      new LinkedHashSet<HttpUrl>());
-  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
-  private final PageService pageService;
-
-  public Crawler(PageService pageService) {
-    this.pageService = pageService;
-  }
-
-  public void crawlPage(HttpUrl url) {
-    // Skip hosts that we've visited many times.
-    AtomicInteger hostnameCount = new AtomicInteger();
-    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
-    if (previous != null) hostnameCount = previous;
-    if (hostnameCount.incrementAndGet() > 100) return;
-
-    // Asynchronously visit URL.
-    pageService.get(url).enqueue(new Callback<Page>() {
-      @Override public void onResponse(Call<Page> call, Response<Page> response) {
-        if (!response.isSuccessful()) {
-          System.out.println(call.request().url() + ": failed: " + response.code());
-          return;
-        }
+    private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+            new LinkedHashSet<HttpUrl>());
+    private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
+    private final PageService pageService;
+
+    public Crawler(PageService pageService) {
+        this.pageService = pageService;
+    }
+
+    public void crawlPage(HttpUrl url) {
+        // Skip hosts that we've visited many times.
+        AtomicInteger hostnameCount = new AtomicInteger();
+        AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+        if (previous != null) hostnameCount = previous;
+        if (hostnameCount.incrementAndGet() > 100) return;
+
+        // Asynchronously visit URL.
+        pageService.get(url).enqueue(new Callback<Page>() {
+            @Override
+            public void onResponse(Call<Page> call, Response<Page> response) {
+                if (!response.isSuccessful()) {
+                    System.out.println(call.request().url() + ": failed: " + response.code());
+                    return;
+                }
+
+                // Print this page's URL and title.
+                Page page = response.body();
+                HttpUrl base = response.raw().request().url();
+                System.out.println(base + ": " + page.title);
+
+                // Enqueue its links for visiting.
+                for (String link : page.links) {
+                    HttpUrl linkUrl = base.resolve(link);
+                    if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+                        crawlPage(linkUrl);
+                    }
+                }
+            }
+
+            @Override
+            public void onFailure(Call<Page> call, Throwable t) {
+                System.out.println(call.request().url() + ": failed: " + t);
+            }
+        });
+    }
+
+    public static void main(String... args) throws Exception {
+        Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
+        dispatcher.setMaxRequests(20);
+        dispatcher.setMaxRequestsPerHost(1);
 
-        // Print this page's URL and title.
-        Page page = response.body();
-        HttpUrl base = response.raw().request().url();
-        System.out.println(base + ": " + page.title);
-
-        // Enqueue its links for visiting.
-        for (String link : page.links) {
-          HttpUrl linkUrl = base.resolve(link);
-          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
-            crawlPage(linkUrl);
-          }
+        OkHttpClient okHttpClient = new OkHttpClient.Builder()
+                .dispatcher(dispatcher)
+                .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
+                .build();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(HttpUrl.parse("https://example.com/"))
+                .addConverterFactory(PageAdapter.FACTORY)
+                .client(okHttpClient)
+                .build();
+
+        PageService pageService = retrofit.create(PageService.class);
+
+        Crawler crawler = new Crawler(pageService);
+        crawler.crawlPage(HttpUrl.parse(args[0]));
+    }
+
+    interface PageService {
+        @GET
+        Call<Page> get(@Url HttpUrl url);
+    }
+
+    static class Page {
+        public final String title;
+        public final List<String> links;
+
+        public Page(String title, List<String> links) {
+            this.title = title;
+            this.links = links;
         }
-      }
-
-      @Override public void onFailure(Call<Page> call, Throwable t) {
-        System.out.println(call.request().url() + ": failed: " + t);
-      }
-    });
-  }
-
-  public static void main(String... args) throws Exception {
-    Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
-    dispatcher.setMaxRequests(20);
-    dispatcher.setMaxRequestsPerHost(1);
-
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .dispatcher(dispatcher)
-        .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
-        .build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
-        .addConverterFactory(PageAdapter.FACTORY)
-        .client(okHttpClient)
-        .build();
-
-    PageService pageService = retrofit.create(PageService.class);
-
-    Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
-  }
-
-  interface PageService {
-    @GET Call<Page> get(@Url HttpUrl url);
-  }
-
-  static class Page {
-    public final String title;
-    public final List<String> links;
-
-    public Page(String title, List<String> links) {
-      this.title = title;
-      this.links = links;
     }
-  }
-
-  static final class PageAdapter implements Converter<ResponseBody, Page> {
-    static final Converter.Factory FACTORY = new Converter.Factory() {
-      @Override public Converter<ResponseBody, ?> responseBodyConverter(
-          Type type, Annotation[] annotations, Retrofit retrofit) {
-        if (type == Page.class) return new PageAdapter();
-        return null;
-      }
-    };
-
-    @Override public Page convert(ResponseBody responseBody) throws IOException {
-      Document document = Jsoup.parse(responseBody.string());
-      List<String> links = new ArrayList<>();
-      for (Element element : document.select("a[href]")) {
-        links.add(element.attr("href"));
-      }
-      return new Page(document.title(), Collections.unmodifiableList(links));
+
+    static final class PageAdapter implements Converter<ResponseBody, Page> {
+        static final Converter.Factory FACTORY = new Converter.Factory() {
+            @Override
+            public Converter<ResponseBody, ?> responseBodyConverter(
+                    Type type, Annotation[] annotations, Retrofit retrofit) {
+                if (type == Page.class) return new PageAdapter();
+                return null;
+            }
+        };
+
+        @Override
+        public Page convert(ResponseBody responseBody) throws IOException {
+            Document document = Jsoup.parse(responseBody.string());
+            List<String> links = new ArrayList<>();
+            for (Element element : document.select("a[href]")) {
+                links.add(element.attr("href"));
+            }
+            return new Page(document.title(), Collections.unmodifiableList(links));
+        }
     }
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
index 4fc6c8669..af18dc56f 100644
--- a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -28,46 +29,47 @@
 import retrofit2.http.GET;
 
 public final class DeserializeErrorBody {
-  interface Service {
-    @GET("/user") Call<User> getUser();
-  }
+    interface Service {
+        @GET("/user")
+        Call<User> getUser();
+    }
 
-  static class User {
-    // normal fields...
-  }
+    static class User {
+        // normal fields...
+    }
 
-  static class Error {
-    String message;
-  }
+    static class Error {
+        String message;
+    }
 
-  public static void main(String... args) throws IOException {
-    // Create a local web server which response with a 404 and JSON body.
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse()
-        .setResponseCode(404)
-        .setBody("{\"message\":\"Unable to locate resource\"}"));
+    public static void main(String... args) throws IOException {
+        // Create a local web server which response with a 404 and JSON body.
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse()
+                .setResponseCode(404)
+                .setBody("{\"message\":\"Unable to locate resource\"}"));
 
-    // Create our Service instance with a Retrofit pointing at the local web server and Gson.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-    Service service = retrofit.create(Service.class);
+        // Create our Service instance with a Retrofit pointing at the local web server and Gson.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+        Service service = retrofit.create(Service.class);
 
-    Response<User> response = service.getUser().execute();
+        Response<User> response = service.getUser().execute();
 
-    // Normally you would check response.isSuccess() here before doing the following, but we know
-    // this call will always fail. You could also use response.code() to determine whether to
-    // convert the error body and/or which type to use for conversion.
+        // Normally you would check response.isSuccess() here before doing the following, but we know
+        // this call will always fail. You could also use response.code() to determine whether to
+        // convert the error body and/or which type to use for conversion.
 
-    // Look up a converter for the Error type on the Retrofit instance.
-    Converter<ResponseBody, Error> errorConverter =
-        retrofit.responseBodyConverter(Error.class, new Annotation[0]);
-    // Convert the error body into our Error type.
-    Error error = errorConverter.convert(response.errorBody());
-    System.out.println("ERROR: " + error.message);
+        // Look up a converter for the Error type on the Retrofit instance.
+        Converter<ResponseBody, Error> errorConverter =
+                retrofit.responseBodyConverter(Error.class, new Annotation[0]);
+        // Convert the error body into our Error type.
+        Error error = errorConverter.convert(response.errorBody());
+        System.out.println("ERROR: " + error.message);
 
-    server.shutdown();
-  }
+        server.shutdown();
+    }
 }
diff --git a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
index 7507b840a..04e70a7c6 100644
--- a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
+++ b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
@@ -16,6 +16,7 @@
 package com.example.retrofit;
 
 import java.io.IOException;
+
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -32,55 +33,56 @@
  * that's nearest geographically.
  */
 public final class DynamicBaseUrl {
-  public interface Pop {
-    @GET("robots.txt")
-    Call<ResponseBody> robots();
-  }
+    public interface Pop {
+        @GET("robots.txt")
+        Call<ResponseBody> robots();
+    }
 
-  static final class HostSelectionInterceptor implements Interceptor {
-    private volatile String host;
+    static final class HostSelectionInterceptor implements Interceptor {
+        private volatile String host;
 
-    public void setHost(String host) {
-      this.host = host;
-    }
+        public void setHost(String host) {
+            this.host = host;
+        }
 
-    @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-      String host = this.host;
-      if (host != null) {
-        HttpUrl newUrl = request.url().newBuilder()
-            .host(host)
-            .build();
-        request = request.newBuilder()
-            .url(newUrl)
-            .build();
-      }
-      return chain.proceed(request);
+        @Override
+        public okhttp3.Response intercept(Chain chain) throws IOException {
+            Request request = chain.request();
+            String host = this.host;
+            if (host != null) {
+                HttpUrl newUrl = request.url().newBuilder()
+                        .host(host)
+                        .build();
+                request = request.newBuilder()
+                        .url(newUrl)
+                        .build();
+            }
+            return chain.proceed(request);
+        }
     }
-  }
 
-  public static void main(String... args) throws IOException {
-    HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
+    public static void main(String... args) throws IOException {
+        HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
 
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .addInterceptor(hostSelectionInterceptor)
-        .build();
+        OkHttpClient okHttpClient = new OkHttpClient.Builder()
+                .addInterceptor(hostSelectionInterceptor)
+                .build();
 
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://www.coca-cola.com/")
-        .callFactory(okHttpClient)
-        .build();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://www.coca-cola.com/")
+                .callFactory(okHttpClient)
+                .build();
 
-    Pop pop = retrofit.create(Pop.class);
+        Pop pop = retrofit.create(Pop.class);
 
-    Response<ResponseBody> response1 = pop.robots().execute();
-    System.out.println("Response from: " + response1.raw().request().url());
-    System.out.println(response1.body().string());
+        Response<ResponseBody> response1 = pop.robots().execute();
+        System.out.println("Response from: " + response1.raw().request().url());
+        System.out.println(response1.body().string());
 
-    hostSelectionInterceptor.setHost("www.pepsi.com");
+        hostSelectionInterceptor.setHost("www.pepsi.com");
 
-    Response<ResponseBody> response2 = pop.robots().execute();
-    System.out.println("Response from: " + response2.raw().request().url());
-    System.out.println(response2.body().string());
-  }
+        Response<ResponseBody> response2 = pop.robots().execute();
+        System.out.println("Response from: " + response2.raw().request().url());
+        System.out.println(response2.body().string());
+    }
 }
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
index 0189da92b..04d53ef7c 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingCallAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -33,149 +34,186 @@
  * version whose callback has more granular methods.
  */
 public final class ErrorHandlingCallAdapter {
-  /** A callback which offers granular callbacks for various conditions. */
-  interface MyCallback<T> {
-    /** Called for [200, 300) responses. */
-    void success(Response<T> response);
-    /** Called for 401 responses. */
-    void unauthenticated(Response<?> response);
-    /** Called for [400, 500) responses, except 401. */
-    void clientError(Response<?> response);
-    /** Called for [500, 600) response. */
-    void serverError(Response<?> response);
-    /** Called for network errors while making the call. */
-    void networkError(IOException e);
-    /** Called for unexpected errors while making the call. */
-    void unexpectedError(Throwable t);
-  }
-
-  interface MyCall<T> {
-    void cancel();
-    void enqueue(MyCallback<T> callback);
-    MyCall<T> clone();
-
-    // Left as an exercise for the reader...
-    // TODO MyResponse<T> execute() throws MyHttpException;
-  }
-
-  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      if (getRawType(returnType) != MyCall.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
-      }
-      final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
-      final Executor callbackExecutor = retrofit.callbackExecutor();
-      return new CallAdapter<MyCall<?>>() {
-        @Override public Type responseType() {
-          return responseType;
-        }
-
-        @Override public <R> MyCall<R> adapt(Call<R> call) {
-          return new MyCallAdapter<>(call, callbackExecutor);
-        }
-      };
+    /**
+     * A callback which offers granular callbacks for various conditions.
+     */
+    interface MyCallback<T> {
+        /**
+         * Called for [200, 300) responses.
+         */
+        void success(Response<T> response);
+
+        /**
+         * Called for 401 responses.
+         */
+        void unauthenticated(Response<?> response);
+
+        /**
+         * Called for [400, 500) responses, except 401.
+         */
+        void clientError(Response<?> response);
+
+        /**
+         * Called for [500, 600) response.
+         */
+        void serverError(Response<?> response);
+
+        /**
+         * Called for network errors while making the call.
+         */
+        void networkError(IOException e);
+
+        /**
+         * Called for unexpected errors while making the call.
+         */
+        void unexpectedError(Throwable t);
     }
-  }
 
-  /** Adapts a {@link Call} to {@link MyCall}. */
-  static class MyCallAdapter<T> implements MyCall<T> {
-    private final Call<T> call;
-    private final Executor callbackExecutor;
+    interface MyCall<T> {
+        void cancel();
 
-    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
-      this.call = call;
-      this.callbackExecutor = callbackExecutor;
+        void enqueue(MyCallback<T> callback);
+
+        MyCall<T> clone();
+
+        // Left as an exercise for the reader...
+        // TODO MyResponse<T> execute() throws MyHttpException;
     }
 
-    @Override public void cancel() {
-      call.cancel();
+    public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
+        @Override
+        public CallAdapter<MyCall<?>> get(Type returnType, Annotation[] annotations,
+                                          Retrofit retrofit) {
+            if (getRawType(returnType) != MyCall.class) {
+                return null;
+            }
+            if (!(returnType instanceof ParameterizedType)) {
+                throw new IllegalStateException(
+                        "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
+            }
+            final Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+            final Executor callbackExecutor = retrofit.callbackExecutor();
+            return new CallAdapter<MyCall<?>>() {
+                @Override
+                public Type responseType() {
+                    return responseType;
+                }
+
+                @Override
+                public <R> MyCall<R> adapt(Call<R> call) {
+                    return new MyCallAdapter<>(call, callbackExecutor);
+                }
+            };
+        }
     }
 
-    @Override public void enqueue(final MyCallback<T> callback) {
-      call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, Response<T> response) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
-
-          int code = response.code();
-          if (code >= 200 && code < 300) {
-            callback.success(response);
-          } else if (code == 401) {
-            callback.unauthenticated(response);
-          } else if (code >= 400 && code < 500) {
-            callback.clientError(response);
-          } else if (code >= 500 && code < 600) {
-            callback.serverError(response);
-          } else {
-            callback.unexpectedError(new RuntimeException("Unexpected response " + response));
-          }
+    /**
+     * Adapts a {@link Call} to {@link MyCall}.
+     */
+    static class MyCallAdapter<T> implements MyCall<T> {
+        private final Call<T> call;
+        private final Executor callbackExecutor;
+
+        MyCallAdapter(Call<T> call, Executor callbackExecutor) {
+            this.call = call;
+            this.callbackExecutor = callbackExecutor;
         }
 
-        @Override public void onFailure(Call<T> call, Throwable t) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+        @Override
+        public void cancel() {
+            call.cancel();
+        }
+
+        @Override
+        public void enqueue(final MyCallback<T> callback) {
+            call.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, Response<T> response) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    int code = response.code();
+                    if (code >= 200 && code < 300) {
+                        callback.success(response);
+                    } else if (code == 401) {
+                        callback.unauthenticated(response);
+                    } else if (code >= 400 && code < 500) {
+                        callback.clientError(response);
+                    } else if (code >= 500 && code < 600) {
+                        callback.serverError(response);
+                    } else {
+                        callback.unexpectedError(new RuntimeException("Unexpected response " + response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<T> call, Throwable t) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    if (t instanceof IOException) {
+                        callback.networkError((IOException) t);
+                    } else {
+                        callback.unexpectedError(t);
+                    }
+                }
+            });
+        }
 
-          if (t instanceof IOException) {
-            callback.networkError((IOException) t);
-          } else {
-            callback.unexpectedError(t);
-          }
+        @Override
+        public MyCall<T> clone() {
+            return new MyCallAdapter<>(call.clone(), callbackExecutor);
         }
-      });
     }
 
-    @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone(), callbackExecutor);
+    interface HttpBinService {
+        @GET("/ip")
+        MyCall<Ip> getIp();
+    }
+
+    static class Ip {
+        String origin;
+    }
+
+    public static void main(String... args) {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://httpbin.org")
+                .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+
+        HttpBinService service = retrofit.create(HttpBinService.class);
+        MyCall<Ip> ip = service.getIp();
+        ip.enqueue(new MyCallback<Ip>() {
+            @Override
+            public void success(Response<Ip> response) {
+                System.out.println("SUCCESS! " + response.body().origin);
+            }
+
+            @Override
+            public void unauthenticated(Response<?> response) {
+                System.out.println("UNAUTHENTICATED");
+            }
+
+            @Override
+            public void clientError(Response<?> response) {
+                System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void serverError(Response<?> response) {
+                System.out.println("SERVER ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void networkError(IOException e) {
+                System.err.println("NETOWRK ERROR " + e.getMessage());
+            }
+
+            @Override
+            public void unexpectedError(Throwable t) {
+                System.err.println("FATAL ERROR " + t.getMessage());
+            }
+        });
     }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    MyCall<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    MyCall<Ip> ip = service.getIp();
-    ip.enqueue(new MyCallback<Ip>() {
-      @Override public void success(Response<Ip> response) {
-        System.out.println("SUCCESS! " + response.body().origin);
-      }
-
-      @Override public void unauthenticated(Response<?> response) {
-        System.out.println("UNAUTHENTICATED");
-      }
-
-      @Override public void clientError(Response<?> response) {
-        System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void serverError(Response<?> response) {
-        System.out.println("SERVER ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
-      }
-
-      @Override public void unexpectedError(Throwable t) {
-        System.err.println("FATAL ERROR " + t.getMessage());
-      }
-    });
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
index 2163f3dec..3c9123caa 100644
--- a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -19,13 +19,16 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.simpleframework.xml.Attribute;
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
+
 import retrofit2.Call;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
@@ -43,86 +46,90 @@
  * converter.
  */
 public final class JsonAndXmlConverters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  @Retention(RUNTIME)
-  @interface Xml {
-  }
+    @Retention(RUNTIME)
+    @interface Xml {
+    }
 
-  static class QualifiedTypeConverterFactory extends Converter.Factory {
-    private final Converter.Factory jsonFactory;
-    private final Converter.Factory xmlFactory;
+    static class QualifiedTypeConverterFactory extends Converter.Factory {
+        private final Converter.Factory jsonFactory;
+        private final Converter.Factory xmlFactory;
 
-    QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
-      this.jsonFactory = jsonFactory;
-      this.xmlFactory = xmlFactory;
-    }
+        QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
+            this.jsonFactory = jsonFactory;
+            this.xmlFactory = xmlFactory;
+        }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+        @Override
+        public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                                                                Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+                }
+                if (annotation instanceof Xml) {
+                    return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+                }
+            }
+            return null;
         }
-        if (annotation instanceof Xml) {
-          return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+
+        @Override
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                                                              Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            for (Annotation annotation : parameterAnnotations) {
+                if (annotation instanceof Json) {
+                    return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+                            retrofit);
+                }
+                if (annotation instanceof Xml) {
+                    return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+                            retrofit);
+                }
+            }
+            return null;
         }
-      }
-      return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      for (Annotation annotation : parameterAnnotations) {
-        if (annotation instanceof Json) {
-          return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-        if (annotation instanceof Xml) {
-          return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-      }
-      return null;
+    @Default(value = DefaultType.FIELD)
+    static class User {
+        @Attribute
+        public String name;
+    }
+
+    interface Service {
+        @GET("/")
+        @Json
+        Call<User> exampleJson();
+
+        @GET("/")
+        @Xml
+        Call<User> exampleXml();
+    }
+
+    public static void main(String... args) throws IOException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
+        server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new QualifiedTypeConverterFactory(
+                        GsonConverterFactory.create(),
+                        SimpleXmlConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        User user1 = service.exampleJson().execute().body();
+        System.out.println("User 1: " + user1.name);
+
+        User user2 = service.exampleXml().execute().body();
+        System.out.println("User 2: " + user2.name);
+
+        server.shutdown();
     }
-  }
-
-  @Default(value = DefaultType.FIELD)
-  static class User {
-    @Attribute
-    public String name;
-  }
-
-  interface Service {
-    @GET("/") @Json
-    Call<User> exampleJson();
-    @GET("/") @Xml
-    Call<User> exampleXml();
-  }
-
-  public static void main(String... args) throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
-    server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new QualifiedTypeConverterFactory(
-            GsonConverterFactory.create(),
-            SimpleXmlConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    User user1 = service.exampleJson().execute().body();
-    System.out.println("User 1: " + user1.name);
-
-    User user2 = service.exampleXml().execute().body();
-    System.out.println("User 2: " + user2.name);
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index bc29f8355..c24b6ee7d 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -36,79 +37,81 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class JsonQueryParameters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  static class JsonStringConverterFactory extends Converter.Factory {
-    private final Converter.Factory delegateFactory;
+    static class JsonStringConverterFactory extends Converter.Factory {
+        private final Converter.Factory delegateFactory;
 
-    JsonStringConverterFactory(Converter.Factory delegateFactory) {
-      this.delegateFactory = delegateFactory;
-    }
+        JsonStringConverterFactory(Converter.Factory delegateFactory) {
+            this.delegateFactory = delegateFactory;
+        }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
-          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
-          // reference to it explicitly as a field.
-          Converter<?, RequestBody> delegate =
-              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
-          return new DelegateToStringConverter<>(delegate);
+        @Override
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                                                    Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+                    // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+                    // reference to it explicitly as a field.
+                    Converter<?, RequestBody> delegate =
+                            delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+                    return new DelegateToStringConverter<>(delegate);
+                }
+            }
+            return null;
+        }
+
+        static class DelegateToStringConverter<T> implements Converter<T, String> {
+            private final Converter<T, RequestBody> delegate;
+
+            DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+                this.delegate = delegate;
+            }
+
+            @Override
+            public String convert(T value) throws IOException {
+                Buffer buffer = new Buffer();
+                delegate.convert(value).writeTo(buffer);
+                return buffer.readUtf8();
+            }
         }
-      }
-      return null;
     }
 
-    static class DelegateToStringConverter<T> implements Converter<T, String> {
-      private final Converter<T, RequestBody> delegate;
+    static class Filter {
+        public final String userId;
 
-      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
-        this.delegate = delegate;
-      }
+        public Filter(String userId) {
+            this.userId = userId;
+        }
+    }
 
-      @Override public String convert(T value) throws IOException {
-        Buffer buffer = new Buffer();
-        delegate.convert(value).writeTo(buffer);
-        return buffer.readUtf8();
-      }
+    interface Service {
+        @GET("/filter")
+        Call<ResponseBody> example(@Json @Query("value") Filter value);
     }
-  }
 
-  static class Filter {
-    public final String userId;
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse());
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Call<ResponseBody> call = service.example(new Filter("123"));
+        Response<ResponseBody> response = call.execute();
+        // TODO handle user response...
+
+        // Print the request path that the server saw to show the JSON query param:
+        RecordedRequest recordedRequest = server.takeRequest();
+        System.out.println(recordedRequest.getPath());
 
-    public Filter(String userId) {
-      this.userId = userId;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @GET("/filter")
-    Call<ResponseBody> example(@Json @Query("value") Filter value);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse());
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Call<ResponseBody> call = service.example(new Filter("123"));
-    Response<ResponseBody> response = call.execute();
-    // TODO handle user response...
-
-    // Print the request path that the server saw to show the JSON query param:
-    RecordedRequest recordedRequest = server.takeRequest();
-    System.out.println(recordedRequest.getPath());
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..c6b9d9059 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -3,6 +3,7 @@
 
 import com.example.retrofit.SimpleService.Contributor;
 import com.example.retrofit.SimpleService.GitHub;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+
 import retrofit2.Call;
 import retrofit2.Retrofit;
 import retrofit2.mock.BehaviorDelegate;
@@ -21,89 +23,92 @@
  * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
  */
 public final class SimpleMockService {
-  /** A mock implementation of the {@link GitHub} API interface. */
-  static final class MockGitHub implements GitHub {
-    private final BehaviorDelegate<GitHub> delegate;
-    private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
-
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
-      this.delegate = delegate;
-      ownerRepoContributors = new LinkedHashMap<>();
-
-      // Seed some mock data.
-      addContributor("square", "retrofit", "John Doe", 12);
-      addContributor("square", "retrofit", "Bob Smith", 2);
-      addContributor("square", "retrofit", "Big Bird", 40);
-      addContributor("square", "picasso", "Proposition Joe", 39);
-      addContributor("square", "picasso", "Keiser Soze", 152);
-    }
+    /**
+     * A mock implementation of the {@link GitHub} API interface.
+     */
+    static final class MockGitHub implements GitHub {
+        private final BehaviorDelegate<GitHub> delegate;
+        private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
+
+        public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+            this.delegate = delegate;
+            ownerRepoContributors = new LinkedHashMap<>();
+
+            // Seed some mock data.
+            addContributor("square", "retrofit", "John Doe", 12);
+            addContributor("square", "retrofit", "Bob Smith", 2);
+            addContributor("square", "retrofit", "Big Bird", 40);
+            addContributor("square", "picasso", "Proposition Joe", 39);
+            addContributor("square", "picasso", "Keiser Soze", 152);
+        }
+
+        @Override
+        public Call<List<Contributor>> contributors(String owner, String repo) {
+            List<Contributor> response = Collections.emptyList();
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors != null) {
+                List<Contributor> contributors = repoContributors.get(repo);
+                if (contributors != null) {
+                    response = contributors;
+                }
+            }
+            return delegate.returningResponse(response).contributors(owner, repo);
+        }
 
-    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
-      List<Contributor> response = Collections.emptyList();
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors != null) {
-        List<Contributor> contributors = repoContributors.get(repo);
-        if (contributors != null) {
-          response = contributors;
+        public void addContributor(String owner, String repo, String name, int contributions) {
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors == null) {
+                repoContributors = new LinkedHashMap<>();
+                ownerRepoContributors.put(owner, repoContributors);
+            }
+            List<Contributor> contributors = repoContributors.get(repo);
+            if (contributors == null) {
+                contributors = new ArrayList<>();
+                repoContributors.put(repo, contributors);
+            }
+            contributors.add(new Contributor(name, contributions));
         }
-      }
-      return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<>();
-        ownerRepoContributors.put(owner, repoContributors);
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        contributors = new ArrayList<>();
-        repoContributors.put(repo, contributors);
-      }
-      contributors.add(new Contributor(name, contributions));
+    public static void main(String... args) throws IOException {
+        // Create a very simple Retrofit adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(SimpleService.API_URL)
+                .build();
+
+        // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
+        NetworkBehavior behavior = NetworkBehavior.create();
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+
+        BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
+        MockGitHub gitHub = new MockGitHub(delegate);
+
+        // Query for some contributors for a few repositories.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
+
+        // Using the mock-only methods, add some additional data.
+        System.out.println("Adding more mock data...\n");
+        gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+        gitHub.addContributor("square", "picasso", "Kit Kat", 53);
+
+        // Reduce the delay to make the next calls complete faster.
+        behavior.setDelay(500, TimeUnit.MILLISECONDS);
+
+        // Query for the contributors again so we can see the mock data that was added.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
     }
-  }
-
-  public static void main(String... args) throws IOException {
-    // Create a very simple Retrofit adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(SimpleService.API_URL)
-        .build();
-
-    // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
-    NetworkBehavior behavior = NetworkBehavior.create();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-
-    BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
-    MockGitHub gitHub = new MockGitHub(delegate);
-
-    // Query for some contributors for a few repositories.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-
-    // Using the mock-only methods, add some additional data.
-    System.out.println("Adding more mock data...\n");
-    gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
-    gitHub.addContributor("square", "picasso", "Kit Kat", 53);
-
-    // Reduce the delay to make the next calls complete faster.
-    behavior.setDelay(500, TimeUnit.MILLISECONDS);
-
-    // Query for the contributors again so we can see the mock data that was added.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-  }
-
-  private static void printContributors(GitHub gitHub, String owner, String repo)
-      throws IOException {
-    System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors.execute().body()) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+
+    private static void printContributors(GitHub gitHub, String owner, String repo)
+            throws IOException {
+        System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
+        Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+        for (Contributor contributor : contributors.execute().body()) {
+            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        }
+        System.out.println();
     }
-    System.out.println();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index ef5a3060e..afc502e14 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import retrofit2.Call;
 import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
@@ -24,42 +25,42 @@
 import retrofit2.http.Path;
 
 public final class SimpleService {
-  public static final String API_URL = "https://api.github.com";
+    public static final String API_URL = "https://api.github.com";
 
-  public static class Contributor {
-    public final String login;
-    public final int contributions;
+    public static class Contributor {
+        public final String login;
+        public final int contributions;
 
-    public Contributor(String login, int contributions) {
-      this.login = login;
-      this.contributions = contributions;
+        public Contributor(String login, int contributions) {
+            this.login = login;
+            this.contributions = contributions;
+        }
     }
-  }
 
-  public interface GitHub {
-    @GET("/repos/{owner}/{repo}/contributors")
-    Call<List<Contributor>> contributors(
-        @Path("owner") String owner,
-        @Path("repo") String repo);
-  }
+    public interface GitHub {
+        @GET("/repos/{owner}/{repo}/contributors")
+        Call<List<Contributor>> contributors(
+                @Path("owner") String owner,
+                @Path("repo") String repo);
+    }
 
-  public static void main(String... args) throws IOException {
-    // Create a very simple REST adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(API_URL)
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
+    public static void main(String... args) throws IOException {
+        // Create a very simple REST adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(API_URL)
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
 
-    // Create an instance of our GitHub API interface.
-    GitHub github = retrofit.create(GitHub.class);
+        // Create an instance of our GitHub API interface.
+        GitHub github = retrofit.create(GitHub.class);
 
-    // Create a call instance for looking up Retrofit contributors.
-    Call<List<Contributor>> call = github.contributors("square", "retrofit");
+        // Create a call instance for looking up Retrofit contributors.
+        Call<List<Contributor>> call = github.contributors("square", "retrofit");
 
-    // Fetch and print a list of the contributors to the library.
-    List<Contributor> contributors = call.execute().body();
-    for (Contributor contributor : contributors) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        // Fetch and print a list of the contributors to the library.
+        List<Contributor> contributors = call.execute().body();
+        for (Contributor contributor : contributors) {
+            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        }
     }
-  }
 }
diff --git a/website/index.html b/website/index.html
index 208a7faf5..a794ba2b6 100644
--- a/website/index.html
+++ b/website/index.html
@@ -1,6 +1,6 @@
 <!DOCTYPE html>
 <html lang="en">
-  <head>
+<head>
     <meta charset="utf-8">
     <title>Retrofit</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
@@ -8,106 +8,133 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
-    <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
-  </head>
-  <body data-target=".content-nav">
-    <header>
-      <div class="container">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300"
+          rel="stylesheet" type="text/css">
+    <!--[if lt IE 9]>
+    <script src="static/html5shiv.min.js"></script><![endif]-->
+</head>
+<body data-target=".content-nav">
+<header>
+    <div class="container">
         <div class="row">
-          <div class="span5">
-            <h1>Retrofit</h1>
-          </div>
-          <div class="span7">
-            <menu>
-              <ul>
-                <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/retrofit" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
-              </ul>
-            </menu>
-          </div>
+            <div class="span5">
+                <h1>Retrofit</h1>
+            </div>
+            <div class="span7">
+                <menu>
+                    <ul>
+                        <li><a href="#download" class="menu download">Download <span
+                                class="version-tag">Latest</span></a></li>
+                        <li><a href="http://github.com/square/retrofit"
+                               data-title="View GitHub Project" class="menu github"><img
+                                src="static/icon-github.png" alt="GitHub"/></a></li>
+                        <li><a href="http://square.github.io/"
+                               data-title="Square Open Source Portal" class="menu square"><img
+                                src="static/icon-square.png" alt="Square"/></a></li>
+                    </ul>
+                </menu>
+            </div>
         </div>
-      </div>
-    </header>
-    <section id="subtitle">
-      <div class="container">
+    </div>
+</header>
+<section id="subtitle">
+    <div class="container">
         <div class="row">
-          <div class="span12">
-            <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsung! --></h2>
-          </div>
+            <div class="span12">
+                <h2>A type-safe <strong>HTTP client</strong> for Android and Java
+                    <!-- and Samsung! --></h2>
+            </div>
         </div>
-      </div>
-    </section>
-    <section id="body">
-      <div class="container">
+    </div>
+</section>
+<section id="body">
+    <div class="container">
         <div class="row">
-          <div class="span9">
-            <section id="introduction">
-              <h3>Introduction</h3>
-              <p>Retrofit turns your HTTP API into a Java interface.</p>
+            <div class="span9">
+                <section id="introduction">
+                    <h3>Introduction</h3>
+                    <p>Retrofit turns your HTTP API into a Java interface.</p>
               <pre class="prettyprint">public interface GitHubService {
   @GET("users/{user}/repos")
   Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
-              <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+                    <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code>
+                        interface.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.github.com/")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-              <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
-              <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
-              <p>Use annotations to describe the HTTP request:</p>
-              <ul>
-                <li>URL parameter replacement and query parameter support</li>
-                <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
-                <li>Multipart request body and file upload</li>
-              </ul>
-              <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
-            </section>
+                    <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a
+                        synchronous or asynchronous HTTP request to the remote webserver.</p>
+                    <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
+                    <p>Use annotations to describe the HTTP request:</p>
+                    <ul>
+                        <li>URL parameter replacement and query parameter support</li>
+                        <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
+                        <li>Multipart request body and file upload</li>
+                    </ul>
+                    <p><em>Note:</em> This site is still in the process of being expanded for the
+                        new 2.0 APIs.</p>
+                </section>
 
-            <section id="api-declaration">
-              <h3>API Declaration</h3>
-              <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
+                <section id="api-declaration">
+                    <h3>API Declaration</h3>
+                    <p>Annotations on the interface methods and its parameters indicate how a
+                        request will be handled.</p>
 
-              <h4>Request Method</h4>
-              <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-              <pre class="prettyprint">@GET("users/list")</pre>
-              <p>You can also specify query parameters in the URL.</p>
-              <pre class="prettyprint">@GET("users/list?sort=desc")</pre>
+                    <h4>Request Method</h4>
+                    <p>Every method must have an HTTP annotation that provides the request method
+                        and relative URL. There are five built-in annotations: <code>GET</code>,
+                        <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and
+                        <code>HEAD</code>. The relative URL of the resource is specified in the
+                        annotation.</p>
+                    <pre class="prettyprint">@GET("users/list")</pre>
+                    <p>You can also specify query parameters in the URL.</p>
+                    <pre class="prettyprint">@GET("users/list?sort=desc")</pre>
 
-              <h4>URL Manipulation</h4>
-              <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
+                    <h4>URL Manipulation</h4>
+                    <p>A request URL can be updated dynamically using replacement blocks and
+                        parameters on the method. A replacement block is an alphanumeric string
+                        surrounded by <code>{</code> and <code>}</code>. A corresponding parameter
+                        must be annotated with <code>@Path</code> using the same string.</p>
               <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId);</pre>
-              <p>Query parameters can also be added.</p>
+                    <p>Query parameters can also be added.</p>
               <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
-              <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
+                    <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
               <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
-              <h4>Request Body</h4>
-              <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
+                    <h4>Request Body</h4>
+                    <p>An object can be specified for use as an HTTP request body with the <code>@Body</code>
+                        annotation.</p>
               <pre class="prettyprint">@POST("users/new")
 Call&lt;User> createUser(@Body User user);</pre>
-              <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
+                    <p>The object will also be converted using a converter specified on the <code>Retrofit</code>
+                        instance. If no converter is added, only <code>RequestBody</code> can be
+                        used.</p>
 
-              <h4>Form Encoded and Multipart</h4>
-              <p>Methods can also be declared to send form-encoded and multipart data.</p>
-              <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
+                    <h4>Form Encoded and Multipart</h4>
+                    <p>Methods can also be declared to send form-encoded and multipart data.</p>
+                    <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the
+                        method. Each key-value pair is annotated with <code>@Field</code> containing
+                        the name and the object providing the value.</p>
               <pre class="prettyprint">@FormUrlEncoded
 @POST("user/edit")
 Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
-              <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
+                    <p>Multipart requests are used when <code>@Multipart</code> is present on the
+                        method. Parts are declared using the <code>@Part</code> annotation.</p>
               <pre class="prettyprint">@Multipart
 @PUT("user/photo")
 Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
-              <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
+                    <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can
+                        implement <code>RequestBody</code> to handle their own serialization.</p>
 
-              <h4>Header Manipulation</h4>
-              <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
+                    <h4>Header Manipulation</h4>
+                    <p>You can set static headers for a method using the <code>@Headers</code>
+                        annotation.</p>
               <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
 @GET("widget/list")
 Call&lt;List&lt;Widget>> widgetList();</pre>
@@ -117,62 +144,96 @@ <h4>Header Manipulation</h4>
 })
 @GET("users/{username}")
 Call&lt;User> getUser(@Path("username") String username);</pre>
-              <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
-              <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
+                    <p>Note that headers do not overwrite each other. All headers with the same name
+                        will be included in the request.</p>
+                    <p>A request Header can be updated dynamically using the <code>@Header</code>
+                        annotation. A corresponding parameter must be provided to the
+                        <code>@Header</code>. If the value is null, the header will be omitted.
+                        Otherwise, <code>toString</code> will be called on the value, and the result
+                        used.</p>
               <pre class="prettyprint">@GET("user")
 Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
-              <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
+                    <p>Headers that need to be added to every request can be specified using an <a
+                            href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp
+                        interceptor</a>.
 
-              <h4>Synchronous vs. Asynchronous</h4>
-              <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
-              <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
-            </section>
+                    <h4>Synchronous vs. Asynchronous</h4>
+                    <p><code>Call</code> instances can be executed either synchronously or
+                        asynchronously. Each instance can only be used once, but calling <code>clone()</code>
+                        will create a new instance that can be used.</p>
+                    <p>On Android, callbacks will be executed on the main thread. On the JVM,
+                        callbacks will happen on the same thread that executed the HTTP request.</p>
+                </section>
 
-            <section id="restadapter-configuration">
-              <h3>Retrofit Configuration</h3>
-              <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+                <section id="restadapter-configuration">
+                    <h3>Retrofit Configuration</h3>
+                    <p><code>Retrofit</code> is the class through which your API interfaces are
+                        turned into callable objects. By default, Retrofit will give you sane
+                        defaults for your platform but it allows for customization.</p>
 
-              <h4>Converters</h4>
-              <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
-              <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
-              <ul>
-                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code></li>
-                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li>
-                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li>
-                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li>
-                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li>
-                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li>
-                <li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li>
-              </ul>
-              <p>Here's an example of using the <code>GsonConverterFactory</code> class to generate an implementation of the <code>GitHubService</code> interface which uses Gson for its deserialization.</p>
+                    <h4>Converters</h4>
+                    <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code>
+                        type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.
+                    </p>
+                    <p>Converters can be added to support other types. Six sibling modules adapt
+                        popular serialization libraries for your convenience.</p>
+                    <ul>
+                        <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code>
+                        </li>
+                        <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code>
+                        </li>
+                        <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code>
+                        </li>
+                        <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>:
+                            <code>com.squareup.retrofit2:converter-protobuf</code></li>
+                        <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code>
+                        </li>
+                        <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code>
+                        </li>
+                        <li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code>
+                        </li>
+                    </ul>
+                    <p>Here's an example of using the <code>GsonConverterFactory</code> class to
+                        generate an implementation of the <code>GitHubService</code> interface which
+                        uses Gson for its deserialization.</p>
               <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.github.com")
     .addConverterFactory(GsonConverterFactory.create())
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-              <h4>Custom Converters</h4>
-              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
-            </section>
+                    <h4>Custom Converters</h4>
+                    <p>If you need to communicate with an API that uses a content-format that
+                        Retrofit does not support out of the box (e.g. YAML, txt, custom format) or
+                        you wish to use a different library to implement an existing format, you can
+                        easily create your own converter. Create a class that extends the <a
+                                href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code>
+                            class</a> and pass in an instance when building your adapter.</p>
+                </section>
 
-            <section id="download">
-              <h3>Download</h3>
-              <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
-              <h4>Maven</h4>
+                <section id="download">
+                    <h3>Download</h3>
+                    <p>
+                        <a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST"
+                           class="dl version-href">&darr; <span class="version-tag">Latest</span>
+                            JAR</a></p>
+                    <p>The source code to the Retrofit, its samples, and this website is <a
+                            href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+                    <h4>Maven</h4>
               <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit2&lt;/groupId>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
-              <h4>Gradle</h4>
+                    <h4>Gradle</h4>
               <pre class="prettyprint">
 compile 'com.squareup.retrofit2:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-              <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
+                    <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-              <h4>ProGuard</h4>
-              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+                    <h4>ProGuard</h4>
+                    <p>If you are using Proguard in your project add the following lines to your
+                        configuration:</p>
               <pre class="prettyprint">
 # Platform calls Class.forName on types which do not exist on Android to determine platform.
 -dontnote retrofit2.Platform
@@ -185,17 +246,22 @@ <h4>ProGuard</h4>
 # Retain declared checked exceptions for use by a Proxy instance.
 -keepattributes Exceptions
 </pre>
-            </section>
+                </section>
 
-            <section id="contributing">
-              <h3>Contributing</h3>
-              <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-              <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
-            </section>
+                <section id="contributing">
+                    <h3>Contributing</h3>
+                    <p>If you would like to contribute code you can do so through GitHub by forking
+                        the repository and sending a pull request.</p>
+                    <p>When submitting code, please make every effort to follow existing conventions
+                        and style in order to keep the code as readable as possible. Please also
+                        make sure your code compiles by running <code>mvn clean verify</code>.</p>
+                    <p>Before your code can be accepted into the project you must also sign the <a
+                            href="http://squ.re/sign-the-cla">Individual Contributor License
+                        Agreement (CLA)</a>.</p>
+                </section>
 
-            <section id="license">
-              <h3>License</h3>
+                <section id="license">
+                    <h3>License</h3>
               <pre>Copyright 2013 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
@@ -209,38 +275,41 @@ <h3>License</h3>
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</pre>
-            </section>
-          </div>
-          <div class="span3">
-            <div class="content-nav" data-spy="affix" data-offset-top="80">
-              <ul class="nav nav-tabs nav-stacked primary">
-                <li><a href="#introduction">Introduction</a></li>
-                <li><a href="#api-declaration">API Declaration</a></li>
-                <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
-                <li><a href="#download">Download</a></li>
-                <li><a href="#contributing">Contributing</a></li>
-                <li><a href="#license">License</a></li>
-              </ul>
-              <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="2.x/retrofit/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
-              </ul>
+                </section>
+            </div>
+            <div class="span3">
+                <div class="content-nav" data-spy="affix" data-offset-top="80">
+                    <ul class="nav nav-tabs nav-stacked primary">
+                        <li><a href="#introduction">Introduction</a></li>
+                        <li><a href="#api-declaration">API Declaration</a></li>
+                        <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
+                        <li><a href="#download">Download</a></li>
+                        <li><a href="#contributing">Contributing</a></li>
+                        <li><a href="#license">License</a></li>
+                    </ul>
+                    <ul class="nav nav-pills nav-stacked secondary">
+                        <li><a href="2.x/retrofit/">Javadoc</a></li>
+                        <li>
+                            <a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a>
+                        </li>
+                    </ul>
+                </div>
             </div>
-          </div>
         </div>
         <div class="row">
-          <div class="span12 logo">
-            <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
-          </div>
+            <div class="span12 logo">
+                <a href="https://squareup.com"><img src="static/logo-square.png"
+                                                    alt="Square, Inc."/></a>
+            </div>
         </div>
-      </div>
-    </section>
-    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
-    <script src="static/bootstrap.min.js"></script>
-    <script src="static/jquery.smooth-scroll.min.js"></script>
-    <script src="static/jquery-maven-artifact.min.js"></script>
-    <script src="static/prettify.js"></script>
-    <script type="text/javascript">
+    </div>
+</section>
+<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+<script src="static/bootstrap.min.js"></script>
+<script src="static/jquery.smooth-scroll.min.js"></script>
+<script src="static/jquery-maven-artifact.min.js"></script>
+<script src="static/prettify.js"></script>
+<script type="text/javascript">
       $(function() {
         // Syntax highlight code blocks.
         prettyPrint();
@@ -277,6 +346,7 @@ <h3>License</h3>
 
       ga('create', 'UA-40704740-4', 'github.io');
       ga('send', 'pageview');
-    </script>
-  </body>
+
+</script>
+</body>
 </html>
