diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
deleted file mode 100644
index 88e5c5e4e..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.util.concurrent.Callable;
-import retrofit2.Response;
-
-final class BodyCallable<R> implements Callable<R> {
-  private final Callable<Response<R>> responseCallable;
-
-  BodyCallable(Callable<Response<R>> responseCallable) {
-    this.responseCallable = responseCallable;
-  }
-
-  @Override public R call() throws Exception {
-    Response<R> response = responseCallable.call();
-    if (response.isSuccessful()) {
-      return response.body();
-    }
-    throw new HttpException(response);
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
new file mode 100644
index 000000000..1ae1499eb
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class BodyOnSubscribe<T> implements OnSubscribe<T> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  BodyOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super T> subscriber) {
+    upstream.call(new BodySubscriber<>(subscriber));
+  }
+
+  private static class BodySubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super R> subscriber;
+    /** Indicates whether a terminal event has been sent to {@link #subscriber}. */
+    private boolean subscriberTerminated;
+
+    BodySubscriber(Subscriber<? super R> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      if (response.isSuccessful()) {
+        subscriber.onNext(response.body());
+      } else {
+        subscriberTerminated = true;
+        Throwable t = new HttpException(response);
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+      }
+    }
+
+    @Override public void onError(Throwable throwable) {
+      if (!subscriberTerminated) {
+        subscriber.onError(throwable);
+      } else {
+        // This should never happen! onNext handles and forwards errors automatically.
+        Throwable broken = new AssertionError(
+            "This should never happen! Report as a Retrofit bug with the full stacktrace.");
+        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+        broken.initCause(throwable);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(broken);
+      }
+    }
+
+    @Override public void onCompleted() {
+      if (!subscriberTerminated) {
+        subscriber.onCompleted();
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
new file mode 100644
index 000000000..7e0f53969
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Producer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class CallOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    Response<T> response;
+    try {
+      response = call.execute();
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      arbiter.emitError(t);
+      return;
+    }
+    arbiter.emitResponse(response);
+  }
+
+  static final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
+    private static final int STATE_WAITING = 0;
+    private static final int STATE_REQUESTED = 1;
+    private static final int STATE_HAS_RESPONSE = 2;
+    private static final int STATE_TERMINATED = 3;
+
+    private final Call<T> call;
+    private final Subscriber<? super Response<T>> subscriber;
+
+    private volatile Response<T> response;
+
+    CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
+      super(STATE_WAITING);
+
+      this.call = call;
+      this.subscriber = subscriber;
+    }
+
+    @Override public void unsubscribe() {
+      call.cancel();
+    }
+
+    @Override public boolean isUnsubscribed() {
+      return call.isCanceled();
+    }
+
+    @Override public void request(long amount) {
+      if (amount == 0) {
+        return;
+      }
+      while (true) {
+        int state = get();
+        switch (state) {
+          case STATE_WAITING:
+            if (compareAndSet(STATE_WAITING, STATE_REQUESTED)) {
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_HAS_RESPONSE:
+            if (compareAndSet(STATE_HAS_RESPONSE, STATE_TERMINATED)) {
+              deliverResponse(response);
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_REQUESTED:
+          case STATE_TERMINATED:
+            return; // Nothing to do.
+
+          default:
+            throw new IllegalStateException("Unknown state: " + state);
+        }
+      }
+    }
+
+    void emitResponse(Response<T> response) {
+      while (true) {
+        int state = get();
+        switch (state) {
+          case STATE_WAITING:
+            this.response = response;
+            if (compareAndSet(STATE_WAITING, STATE_HAS_RESPONSE)) {
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_REQUESTED:
+            if (compareAndSet(STATE_REQUESTED, STATE_TERMINATED)) {
+              deliverResponse(response);
+              return;
+            }
+            break; // State transition failed. Try again.
+
+          case STATE_HAS_RESPONSE:
+          case STATE_TERMINATED:
+            throw new AssertionError();
+
+          default:
+            throw new IllegalStateException("Unknown state: " + state);
+        }
+      }
+    }
+
+    private void deliverResponse(Response<T> response) {
+      try {
+        if (!isUnsubscribed()) {
+          subscriber.onNext(response);
+        }
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+        return;
+      }
+      try {
+        subscriber.onCompleted();
+      } catch (Throwable t) {
+        Exceptions.throwIfFatal(t);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+      }
+    }
+
+    void emitError(Throwable t) {
+      set(STATE_TERMINATED);
+
+      if (!isUnsubscribed()) {
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
deleted file mode 100644
index 7d075e71b..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import retrofit2.Call;
-import retrofit2.Response;
-
-final class ResponseCallable<T> implements Callable<Response<T>> {
-  private final Call<T> call;
-
-  ResponseCallable(Call<T> call) {
-    this.call = call;
-  }
-
-  @Override public Response<T> call() throws IOException {
-    // Since Call is a one-shot type, clone it for each new caller.
-    return call.clone().execute();
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
deleted file mode 100644
index ea9e37c25..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.util.concurrent.Callable;
-import retrofit2.Response;
-
-final class ResultCallable<R> implements Callable<Result<R>> {
-  private final Callable<Response<R>> responseCallable;
-
-  ResultCallable(Callable<Response<R>> responseCallable) {
-    this.responseCallable = responseCallable;
-  }
-
-  @Override public Result<R> call() {
-    try {
-      return Result.response(responseCallable.call());
-    } catch (Throwable t) {
-      return Result.error(t);
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
new file mode 100644
index 000000000..798df5af8
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultOnSubscribe.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class ResultOnSubscribe<T> implements OnSubscribe<Result<T>> {
+  private final OnSubscribe<Response<T>> upstream;
+
+  ResultOnSubscribe(OnSubscribe<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override public void call(Subscriber<? super Result<T>> subscriber) {
+    upstream.call(new ResultSubscriber<T>(subscriber));
+  }
+
+  private static class ResultSubscriber<R> extends Subscriber<Response<R>> {
+    private final Subscriber<? super Result<R>> subscriber;
+
+    ResultSubscriber(Subscriber<? super Result<R>> subscriber) {
+      super(subscriber);
+      this.subscriber = subscriber;
+    }
+
+    @Override public void onNext(Response<R> response) {
+      subscriber.onNext(Result.response(response));
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        subscriber.onNext(Result.<R>error(throwable));
+      } catch (Throwable t) {
+        try {
+          subscriber.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          CompositeException composite = new CompositeException(t, inner);
+          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+        }
+        return;
+      }
+      subscriber.onCompleted();
+    }
+
+    @Override public void onCompleted() {
+      subscriber.onCompleted();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index 19cf184ad..8d8f3776a 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -18,7 +18,9 @@
 import java.lang.reflect.Type;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
+import retrofit2.Response;
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.Scheduler;
 
 final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
@@ -44,16 +46,17 @@
   }
 
   @Override public Object adapt(Call<R> call) {
-    ResponseCallable<R> resultCallable = new ResponseCallable<>(call);
+    OnSubscribe<Response<R>> callFunc = new CallOnSubscribe<>(call);
 
-    Observable<?> observable;
+    OnSubscribe<?> func;
     if (isResult) {
-      observable = Observable.fromCallable(new ResultCallable<>(resultCallable));
+      func = new ResultOnSubscribe<>(callFunc);
     } else if (isBody) {
-      observable = Observable.fromCallable(new BodyCallable<>(resultCallable));
+      func = new BodyOnSubscribe<>(callFunc);
     } else {
-      observable = Observable.fromCallable(resultCallable);
+      func = callFunc;
     }
+    Observable<?> observable = Observable.create(func);
 
     if (scheduler != null) {
       observable = observable.subscribeOn(scheduler);
