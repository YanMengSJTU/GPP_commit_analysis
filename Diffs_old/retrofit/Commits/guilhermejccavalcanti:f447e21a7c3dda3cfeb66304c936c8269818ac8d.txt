diff --git a/pom.xml b/pom.xml
index f78b5eb10..18106b151 100644
--- a/pom.xml
+++ b/pom.xml
@@ -51,7 +51,7 @@
     <android.platform>16</android.platform>
     <gson.version>2.2.4</gson.version>
     <okhttp.version>1.6.0</okhttp.version>
-    <rxjava.version>0.18.3</rxjava.version>
+    <rxjava.version>0.19.0</rxjava.version>
     <appengine.version>1.8.9</appengine.version>
 
     <!-- Converter Dependencies -->
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
index 831f8a5a1..7c2809fd6 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
@@ -8,7 +8,7 @@
   private final Object body;
 
   MockHttpRetrofitError(String message, String url, Response response, Object body) {
-    super(message, url, response, null, null, false, null);
+    super(message, url, response, null, body.getClass(), false, null);
     this.body = body;
   }
 
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
index b0fb6923a..2eb1225bb 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
@@ -37,7 +37,7 @@
   }
 
   interface AsyncExample {
-    @GET("/") void doStuff(Callback<Object> cb);
+    @GET("/") void doStuff(Callback<String> cb);
   }
 
   interface AsyncCallbackSubtypeExample {
@@ -47,7 +47,7 @@
   }
 
   interface ObservableExample {
-    @GET("/") Observable<Object> doStuff();
+    @GET("/") Observable<String> doStuff();
   }
 
   private Executor httpExecutor;
@@ -242,7 +242,7 @@
     mockRestAdapter.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new AssertionError();
       }
     }
@@ -250,8 +250,8 @@
     AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
 
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -298,9 +298,11 @@
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hi");
+
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         cb.success(expected, null);
       }
     }
@@ -310,8 +312,8 @@
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<Object> actual = new AtomicReference<Object>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object result, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String result, Response response) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
         actual.set(result);
       }
@@ -333,9 +335,11 @@
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hello");
+
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         return Observable.from(expected);
       }
     }
@@ -373,9 +377,11 @@
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hello");
+
     class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
+      @Override public String doStuff() {
         throw new MockHttpException(404, "Not Found", expected);
       }
     }
@@ -393,6 +399,7 @@
       assertThat(e.getResponse().getStatus()).isEqualTo(404);
       assertThat(e.getResponse().getReason()).isEqualTo("Not Found");
       assertThat(e.getBody()).isSameAs(expected);
+      assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
@@ -401,9 +408,11 @@
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Greetings");
+
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw new MockHttpException(404, "Not Found", expected);
       }
     }
@@ -413,8 +422,8 @@
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
     final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -433,6 +442,7 @@
     assertThat(error.getResponse().getStatus()).isEqualTo(404);
     assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void observableHttpExceptionBecomesError() {
@@ -440,9 +450,11 @@
     mockRestAdapter.setVariancePercentage(0);
     mockRestAdapter.setErrorPercentage(0);
 
-    final Object expected = new Object();
+    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
+    final String expected = new String("Hi");
+
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw new MockHttpException(404, "Not Found", expected);
       }
     }
@@ -474,6 +486,7 @@
     assertThat(error.getResponse().getStatus()).isEqualTo(404);
     assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
   @Test public void syncErrorUsesErrorHandler() {
@@ -504,7 +517,7 @@
     mockRestAdapter.setErrorPercentage(0);
 
     class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<Object> cb) {
+      @Override public void doStuff(Callback<String> cb) {
         throw MockHttpException.newNotFound(new Object());
       }
     }
@@ -513,8 +526,8 @@
     nextError = new IllegalArgumentException("Test");
 
     final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff(new Callback<Object>() {
-      @Override public void success(Object o, Response response) {
+    mockService.doStuff(new Callback<String>() {
+      @Override public void success(String o, Response response) {
         throw new AssertionError();
       }
 
@@ -532,7 +545,7 @@
     mockRestAdapter.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
-      @Override public Observable<Object> doStuff() {
+      @Override public Observable<String> doStuff() {
         throw MockHttpException.newNotFound(new Object());
       }
     }
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 455bf5715..0eddcbbe5 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -107,406 +107,361 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  static final String THREAD_PREFIX = "Retrofit-";
-  static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
-
-  /** Simple logging abstraction for debug messages. */
-  public interface Log {
-    /** Log a debug message to the appropriate console. */
-    void log(String message);
-
-    /** A {@link Log} implementation which does not log anything. */
-    Log NONE = new Log() {
-      @Override public void log(String message) {
-      }
-    };
-  }
-
-  /** Controls the level of logging. */
-  public enum LogLevel {
-    /** No logging. */
-    NONE,
-    /** Log only the request method and URL and the response status code and execution time. */
-    BASIC,
-    /** Log the basic information along with request and response headers. */
-    HEADERS,
-    /**
+
+    static final String THREAD_PREFIX = "Retrofit-";
+
+    static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
+
+    /** Simple logging abstraction for debug messages. */
+    public interface Log {
+
+        /** Log a debug message to the appropriate console. */
+        void log(String message);
+
+        /** A {@link Log} implementation which does not log anything. */
+        Log NONE = new Log() {
+
+            @Override
+            public void log(String message) {
+            }
+        };
+    }
+
+    /** Controls the level of logging. */
+    public enum LogLevel {
+
+        /** No logging. */
+        NONE(), /** Log only the request method and URL and the response status code and execution time. */
+        BASIC(), /** Log the basic information along with request and response headers. */
+        HEADERS(), /**
      * Log the headers, body, and metadata for both requests and responses.
      * <p>
      * Note: This requires that the entire request and response body be buffered in memory!
      */
-    FULL;
+        FULL();
 
-    public boolean log() {
-      return this != NONE;
-    }
-  }
-
-  private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
-
-  final Endpoint server;
-  final Executor httpExecutor;
-  final Executor callbackExecutor;
-  final RequestInterceptor requestInterceptor;
-  final Converter converter;
-  final Log log;
-  final ErrorHandler errorHandler;
-
-  private final Client.Provider clientProvider;
-  private final Profiler profiler;
-  private RxSupport rxSupport;
-
-  volatile LogLevel logLevel;
-
-  private RestAdapter(Endpoint server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
-      Profiler profiler, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
-    this.server = server;
-    this.clientProvider = clientProvider;
-    this.httpExecutor = httpExecutor;
-    this.callbackExecutor = callbackExecutor;
-    this.requestInterceptor = requestInterceptor;
-    this.converter = converter;
-    this.profiler = profiler;
-    this.errorHandler = errorHandler;
-    this.log = log;
-    this.logLevel = logLevel;
-  }
-
-  /** Change the level of logging. */
-  public void setLogLevel(LogLevel loglevel) {
-    if (logLevel == null) {
-      throw new NullPointerException("Log level may not be null.");
-    }
-    this.logLevel = loglevel;
-  }
-
-  /** The current logging level. */
-  public LogLevel getLogLevel() {
-    return logLevel;
-  }
-
-  /** Create an implementation of the API defined by the specified {@code service} interface. */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler(getMethodInfoCache(service)));
-  }
-
-  Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
-    synchronized (serviceMethodInfoCache) {
-      Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
-      if (methodInfoCache == null) {
-        methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
-        serviceMethodInfoCache.put(service, methodInfoCache);
-      }
-      return methodInfoCache;
-    }
-  }
-
-  static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
-    synchronized (cache) {
-      RestMethodInfo methodInfo = cache.get(method);
-      if (methodInfo == null) {
-        methodInfo = new RestMethodInfo(method);
-        cache.put(method, methodInfo);
-      }
-      return methodInfo;
+        public boolean log() {
+            return this != NONE;
+        }
     }
-  }
 
-  private class RestHandler implements InvocationHandler {
-    private final Map<Method, RestMethodInfo> methodDetailsCache;
+    private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache = new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
 
-    RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
-      this.methodDetailsCache = methodDetailsCache;
-    }
+    final Endpoint server;
 
-    @SuppressWarnings("unchecked") //
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      // Load or create the details cache for the current method.
-      final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-
-      if (methodInfo.isSynchronous) {
-        try {
-          return invokeRequest(requestInterceptor, methodInfo, args);
-        } catch (RetrofitError error) {
-          Throwable newError = errorHandler.handleError(error);
-          if (newError == null) {
-            throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
-          }
-          throw newError;
-        }
-      }
-
-      if (httpExecutor == null || callbackExecutor == null) {
-        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
-      }
-
-      if (methodInfo.isObservable) {
-        if (rxSupport == null) {
-          if (Platform.HAS_RX_JAVA) {
-            rxSupport = new RxSupport(httpExecutor, errorHandler, requestInterceptor);
-          } else {
-            throw new IllegalStateException("Observable method found but no RxJava on classpath.");
-          }
-        }
-        return rxSupport.createRequestObservable(new RxSupport.Invoker() {
-          @Override public ResponseWrapper invoke(RequestInterceptor requestInterceptor) {
-            return (ResponseWrapper) invokeRequest(requestInterceptor, methodInfo, args);
-          }
-        });
-      }
-
-      // Apply the interceptor synchronously, recording the interception so we can replay it later.
-      // This way we still defer argument serialization to the background thread.
-      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-      requestInterceptor.intercept(interceptorTape);
-
-      Callback<?> callback = (Callback<?>) args[args.length - 1];
-      httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor, errorHandler) {
-        @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
-        }
-      });
-      return null; // Asynchronous methods should have return type of void.
-    }
+    final Executor httpExecutor;
 
-    /**
-     * Execute an HTTP request.
-     *
-     * @return HTTP response object of specified {@code type} or {@code null}.
-     * @throws RetrofitError if any error occurs during the HTTP request.
-     */
-    private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo,
-        Object[] args) {
-      String url = null;
-      try {
-        methodInfo.init(); // Ensure all relevant method information has been loaded.
+    final Executor callbackExecutor;
 
-        String serverUrl = server.getUrl();
-        RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
-        requestBuilder.setArguments(args);
+    final RequestInterceptor requestInterceptor;
 
-        requestInterceptor.intercept(requestBuilder);
+    final Converter converter;
 
-        Request request = requestBuilder.build();
-        url = request.getUrl();
+    final Log log;
 
-        if (!methodInfo.isSynchronous) {
-          // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
-        }
+    final ErrorHandler errorHandler;
 
-        if (logLevel.log()) {
-          // Log the request data.
-          request = logAndReplaceRequest("HTTP", request);
-        }
+    private final Client.Provider clientProvider;
 
-        Object profilerObject = null;
-        if (profiler != null) {
-          profilerObject = profiler.beforeCall();
-        }
+    private final Profiler profiler;
 
-        long start = System.nanoTime();
-        Response response = clientProvider.get().execute(request);
-        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
+    private RxSupport rxSupport;
 
-        int statusCode = response.getStatus();
-        if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(serverUrl, methodInfo, request);
-          //noinspection unchecked
-          profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
-        }
+    volatile LogLevel logLevel;
+
+    private RestAdapter(Endpoint server, Client.Provider clientProvider, Executor httpExecutor, Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter, Profiler profiler, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
+        this.server = server;
+        this.clientProvider = clientProvider;
+        this.httpExecutor = httpExecutor;
+        this.callbackExecutor = callbackExecutor;
+        this.requestInterceptor = requestInterceptor;
+        this.converter = converter;
+        this.profiler = profiler;
+        this.errorHandler = errorHandler;
+        this.log = log;
+        this.logLevel = logLevel;
+    }
 
-        if (logLevel.log()) {
-          // Log the response data.
-          response = logAndReplaceResponse(url, response, elapsedTime);
+    public void setLogLevel(LogLevel loglevel) {
+        if (logLevel == null) {
+            throw new NullPointerException("Log level may not be null.");
         }
+        this.logLevel = loglevel;
+    }
+
+    /** The current logging level. */
+    public LogLevel getLogLevel() {
+        return logLevel;
+    }
 
-        Type type = methodInfo.responseObjectType;
+    /** Create an implementation of the API defined by the specified {@code service} interface. */
+    @SuppressWarnings(value = { "unchecked" })
+    public <T extends java.lang.Object> T create(Class<T> service) {
+        Utils.validateServiceClass(service);
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service }, new RestHandler(getMethodInfoCache(service)));
+    }
 
-        if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-          // Caller requested the raw Response object directly.
-          if (type.equals(Response.class)) {
-            if (!methodInfo.isStreaming) {
-              // Read the entire stream and replace with one backed by a byte[].
-              response = Utils.readBodyToBytesIfNecessary(response);
+    Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
+        synchronized (serviceMethodInfoCache) {
+            Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
+            if (methodInfoCache == null) {
+                methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
+                serviceMethodInfoCache.put(service, methodInfoCache);
             }
+            return methodInfoCache;
+        }
+    }
 
-            if (methodInfo.isSynchronous) {
-              return response;
+    static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
+        synchronized (cache) {
+            RestMethodInfo methodInfo = cache.get(method);
+            if (methodInfo == null) {
+                methodInfo = new RestMethodInfo(method);
+                cache.put(method, methodInfo);
             }
-            return new ResponseWrapper(response, response);
-          }
+            return methodInfo;
+        }
+    }
+
+    private class RestHandler implements InvocationHandler {
 
-          TypedInput body = response.getBody();
-          if (body == null) {
-            return new ResponseWrapper(response, null);
-          }
+        private final Map<Method, RestMethodInfo> methodDetailsCache;
+
+        RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
+            this.methodDetailsCache = methodDetailsCache;
+        }
 
-          ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
-          try {
-            Object convert = converter.fromBody(wrapped, type);
+        @SuppressWarnings(value = { "unchecked" })
+        @Override
+        public Object invoke(Object proxy, Method method, final Object[] args) throws Throwable {
+            if (method.getDeclaringClass() == Object.class) {
+                return method.invoke(this, args);
+            }
+            final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
             if (methodInfo.isSynchronous) {
-              return convert;
+                try {
+                    return invokeRequest(requestInterceptor, methodInfo, args);
+                } catch (RetrofitError error) {
+                    Throwable newError = errorHandler.handleError(error);
+                    if (newError == null) {
+                        throw new IllegalStateException("Error handler returned null for wrapped exception.", error);
+                    }
+                    throw newError;
+                }
             }
-            return new ResponseWrapper(response, convert);
-          } catch (ConversionException e) {
-            // If the underlying input stream threw an exception, propagate that rather than
-            // indicating that it was a conversion exception.
-            if (wrapped.threwException()) {
-              throw wrapped.getThrownException();
+            if (httpExecutor == null || callbackExecutor == null) {
+                throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
             }
-
-            // The response body was partially read by the converter. Replace it with null.
-            response = Utils.replaceResponseBody(response, null);
-
-            throw RetrofitError.conversionError(url, response, converter, type, e);
-          }
+            if (methodInfo.isObservable) {
+                if (rxSupport == null) {
+                    if (Platform.HAS_RX_JAVA) {
+                        rxSupport = new RxSupport(httpExecutor, errorHandler, requestInterceptor);
+                    } else {
+                        throw new IllegalStateException("Observable method found but no RxJava on classpath.");
+                    }
+                }
+                return rxSupport.createRequestObservable(new RxSupport.Invoker() {
+
+                    @Override
+                    public ResponseWrapper invoke(RequestInterceptor requestInterceptor) {
+                        return (ResponseWrapper) invokeRequest(requestInterceptor, methodInfo, args);
+                    }
+                });
+            }
+            final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
+            requestInterceptor.intercept(interceptorTape);
+            Callback<?> callback = (Callback<?>) args[args.length - 1];
+            httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor, errorHandler) {
+
+                @Override
+                public ResponseWrapper obtainResponse() {
+                    return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
+                }
+            });
+            return null;
         }
 
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(url, response, converter, type);
-      } catch (RetrofitError e) {
-        throw e; // Pass through our own errors.
-      } catch (IOException e) {
-        if (logLevel.log()) {
-          logException(e, url);
-        }
-        throw RetrofitError.networkError(url, e);
-      } catch (Throwable t) {
-        if (logLevel.log()) {
-          logException(t, url);
-        }
-        throw RetrofitError.unexpectedError(url, t);
-      } finally {
-        if (!methodInfo.isSynchronous) {
-          Thread.currentThread().setName(IDLE_THREAD_NAME);
+        /**
+     * Execute an HTTP request.
+     *
+     * @return HTTP response object of specified {@code type} or {@code null}.
+     * @throws RetrofitError if any error occurs during the HTTP request.
+     */
+        private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo, Object[] args) {
+            String url = null;
+            try {
+                methodInfo.init();
+                String serverUrl = server.getUrl();
+                RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
+                requestBuilder.setArguments(args);
+                requestInterceptor.intercept(requestBuilder);
+                Request request = requestBuilder.build();
+                url = request.getUrl();
+                if (!methodInfo.isSynchronous) {
+                    Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
+                }
+                if (logLevel.log()) {
+                    request = logAndReplaceRequest("HTTP", request);
+                }
+                Object profilerObject = null;
+                if (profiler != null) {
+                    profilerObject = profiler.beforeCall();
+                }
+                long start = System.nanoTime();
+                Response response = clientProvider.get().execute(request);
+                long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
+                int statusCode = response.getStatus();
+                if (profiler != null) {
+                    RequestInformation requestInfo = getRequestInfo(serverUrl, methodInfo, request);
+                    profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
+                }
+                if (logLevel.log()) {
+                    response = logAndReplaceResponse(url, response, elapsedTime);
+                }
+                Type type = methodInfo.responseObjectType;
+                if (statusCode >= 200 && statusCode < 300) {
+                    if (type.equals(Response.class)) {
+                        if (!methodInfo.isStreaming) {
+                            response = Utils.readBodyToBytesIfNecessary(response);
+                        }
+                        if (methodInfo.isSynchronous) {
+                            return response;
+                        }
+                        return new ResponseWrapper(response, response);
+                    }
+                    TypedInput body = response.getBody();
+                    if (body == null) {
+                        if (methodInfo.isSynchronous) {
+                            return null;
+                        }
+                        return new ResponseWrapper(response, null);
+                    }
+                    ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
+                    try {
+                        Object convert = converter.fromBody(wrapped, type);
+                        if (methodInfo.isSynchronous) {
+                            return convert;
+                        }
+                        return new ResponseWrapper(response, convert);
+                    } catch (ConversionException e) {
+                        if (wrapped.threwException()) {
+                            throw wrapped.getThrownException();
+                        }
+                        response = Utils.replaceResponseBody(response, null);
+                        throw RetrofitError.conversionError(url, response, converter, type, e);
+                    }
+                }
+                response = Utils.readBodyToBytesIfNecessary(response);
+                throw RetrofitError.httpError(url, response, converter, type);
+            } catch (RetrofitError e) {
+                throw e;
+            } catch (IOException e) {
+                if (logLevel.log()) {
+                    logException(e, url);
+                }
+                throw RetrofitError.networkError(url, e);
+            } catch (Throwable t) {
+                if (logLevel.log()) {
+                    logException(t, url);
+                }
+                throw RetrofitError.unexpectedError(url, t);
+            } finally {
+                if (!methodInfo.isSynchronous) {
+                    Thread.currentThread().setName(IDLE_THREAD_NAME);
+                }
+            }
         }
-      }
     }
-  }
-
-  /** Log request headers and body. Consumes request body and returns identical replacement. */
-  Request logAndReplaceRequest(String name, Request request) throws IOException {
-    log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : request.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      String bodySize = "no";
-      TypedOutput body = request.getBody();
-      if (body != null) {
-        String bodyMime = body.mimeType();
-        if (bodyMime != null) {
-          log.log("Content-Type: " + bodyMime);
-        }
-
-        long bodyLength = body.length();
-        bodySize = bodyLength + "-byte";
-        if (bodyLength != -1) {
-          log.log("Content-Length: " + bodyLength);
-        }
 
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!request.getHeaders().isEmpty()) {
-            log.log("");
-          }
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body to we can log it and replace the original response
-            request = Utils.readBodyToBytesIfNecessary(request);
-            body = request.getBody();
-          }
-
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          String bodyCharset = MimeUtil.parseCharset(body.mimeType());
-          log.log(new String(bodyBytes, bodyCharset));
+    /** Log request headers and body. Consumes request body and returns identical replacement. */
+    Request logAndReplaceRequest(String name, Request request) throws IOException {
+        log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
+        if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
+            for (Header header : request.getHeaders()) {
+                log.log(header.toString());
+            }
+            String bodySize = "no";
+            TypedOutput body = request.getBody();
+            if (body != null) {
+                String bodyMime = body.mimeType();
+                if (bodyMime != null) {
+                    log.log("Content-Type: " + bodyMime);
+                }
+                long bodyLength = body.length();
+                bodySize = bodyLength + "-byte";
+                if (bodyLength != -1) {
+                    log.log("Content-Length: " + bodyLength);
+                }
+                if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+                    if (!request.getHeaders().isEmpty()) {
+                        log.log("");
+                    }
+                    if (!(body instanceof TypedByteArray)) {
+                        request = Utils.readBodyToBytesIfNecessary(request);
+                        body = request.getBody();
+                    }
+                    byte[] bodyBytes = ((TypedByteArray) body).getBytes();
+                    String bodyCharset = MimeUtil.parseCharset(body.mimeType());
+                    log.log(new String(bodyBytes, bodyCharset));
+                }
+            }
+            log.log(String.format("---> END %s (%s body)", name, bodySize));
         }
-      }
-
-      log.log(String.format("---> END %s (%s body)", name, bodySize));
+        return request;
     }
 
-    return request;
-  }
-
-  /** Log response headers and body. Consumes response body and returns identical replacement. */
-  private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
-      throws IOException {
-    log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : response.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      long bodySize = 0;
-      TypedInput body = response.getBody();
-      if (body != null) {
-        bodySize = body.length();
-
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!response.getHeaders().isEmpty()) {
-            log.log("");
-          }
-
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body so we can log it and replace the original response
-            response = Utils.readBodyToBytesIfNecessary(response);
-            body = response.getBody();
-          }
-
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          bodySize = bodyBytes.length;
-          String bodyMime = body.mimeType();
-          String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          log.log(new String(bodyBytes, bodyCharset));
+    /** Log response headers and body. Consumes response body and returns identical replacement. */
+    private Response logAndReplaceResponse(String url, Response response, long elapsedTime) throws IOException {
+        log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
+        if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
+            for (Header header : response.getHeaders()) {
+                log.log(header.toString());
+            }
+            long bodySize = 0;
+            TypedInput body = response.getBody();
+            if (body != null) {
+                bodySize = body.length();
+                if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+                    if (!response.getHeaders().isEmpty()) {
+                        log.log("");
+                    }
+                    if (!(body instanceof TypedByteArray)) {
+                        response = Utils.readBodyToBytesIfNecessary(response);
+                        body = response.getBody();
+                    }
+                    byte[] bodyBytes = ((TypedByteArray) body).getBytes();
+                    bodySize = bodyBytes.length;
+                    String bodyMime = body.mimeType();
+                    String bodyCharset = MimeUtil.parseCharset(bodyMime);
+                    log.log(new String(bodyBytes, bodyCharset));
+                }
+            }
+            log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
         }
-      }
-
-      log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
+        return response;
     }
 
-    return response;
-  }
-
-  /** Log an exception that occurred during the processing of a request or response. */
-  void logException(Throwable t, String url) {
-    log.log(String.format("---- ERROR %s", url != null ? url : ""));
-    StringWriter sw = new StringWriter();
-    t.printStackTrace(new PrintWriter(sw));
-    log.log(sw.toString());
-    log.log("---- END ERROR");
-  }
-
-  private static Profiler.RequestInformation getRequestInfo(String serverUrl,
-      RestMethodInfo methodDetails, Request request) {
-    long contentLength = 0;
-    String contentType = null;
-
-    TypedOutput body = request.getBody();
-    if (body != null) {
-      contentLength = body.length();
-      contentType = body.mimeType();
+    /** Log an exception that occurred during the processing of a request or response. */
+    void logException(Throwable t, String url) {
+        log.log(String.format("---- ERROR %s", url != null ? url : ""));
+        StringWriter sw = new StringWriter();
+        t.printStackTrace(new PrintWriter(sw));
+        log.log(sw.toString());
+        log.log("---- END ERROR");
     }
 
-    return new Profiler.RequestInformation(methodDetails.requestMethod, serverUrl,
-        methodDetails.requestUrl, contentLength, contentType);
-  }
+    private static Profiler.RequestInformation getRequestInfo(String serverUrl, RestMethodInfo methodDetails, Request request) {
+        long contentLength = 0;
+        String contentType = null;
+        TypedOutput body = request.getBody();
+        if (body != null) {
+            contentLength = body.length();
+            contentType = body.mimeType();
+        }
+        return new Profiler.RequestInformation(methodDetails.requestMethod, serverUrl, methodDetails.requestUrl, contentLength, contentType);
+    }
 
-  /**
+    /**
    * Build a new {@link RestAdapter}.
    * <p>
    * Calling the following methods is required before calling {@link #build()}:
@@ -522,58 +477,70 @@ void logException(Throwable t, String url) {
    * <li>{@link #setExecutors(java.util.concurrent.Executor, java.util.concurrent.Executor)}</li>
    * </ul>
    */
-  public static class Builder {
-    private Endpoint endpoint;
-    private Client.Provider clientProvider;
-    private Executor httpExecutor;
-    private Executor callbackExecutor;
-    private RequestInterceptor requestInterceptor;
-    private Converter converter;
-    private Profiler profiler;
-    private ErrorHandler errorHandler;
-    private Log log;
-    private LogLevel logLevel = LogLevel.NONE;
-
-    /** API endpoint URL. */
-    public Builder setEndpoint(String endpoint) {
-      if (endpoint == null || endpoint.trim().length() == 0) {
-        throw new NullPointerException("Endpoint may not be blank.");
-      }
-      this.endpoint = Endpoints.newFixedEndpoint(endpoint);
-      return this;
-    }
+    public static class Builder {
 
-    /** API endpoint. */
-    public Builder setEndpoint(Endpoint endpoint) {
-      if (endpoint == null) {
-        throw new NullPointerException("Endpoint may not be null.");
-      }
-      this.endpoint = endpoint;
-      return this;
-    }
+        private Endpoint endpoint;
+
+        private Client.Provider clientProvider;
+
+        private Executor httpExecutor;
+
+        private Executor callbackExecutor;
+
+        private RequestInterceptor requestInterceptor;
+
+        private Converter converter;
+
+        private Profiler profiler;
+
+        private ErrorHandler errorHandler;
+
+        private Log log;
+
+        private LogLevel logLevel = LogLevel.NONE;
 
-    /** The HTTP client used for requests. */
-    public Builder setClient(final Client client) {
-      if (client == null) {
-        throw new NullPointerException("Client may not be null.");
-      }
-      return setClient(new Client.Provider() {
-        @Override public Client get() {
-          return client;
+        /** API endpoint URL. */
+        public Builder setEndpoint(String endpoint) {
+            if (endpoint == null || endpoint.trim().length() == 0) {
+                throw new NullPointerException("Endpoint may not be blank.");
+            }
+            this.endpoint = Endpoints.newFixedEndpoint(endpoint);
+            return this;
         }
-      });
-    }
 
-    /** The HTTP client used for requests. */
-    public Builder setClient(Client.Provider clientProvider) {
-      if (clientProvider == null) {
-        throw new NullPointerException("Client provider may not be null.");
-      }
-      this.clientProvider = clientProvider;
-      return this;
-    }
+        /** API endpoint. */
+        public Builder setEndpoint(Endpoint endpoint) {
+            if (endpoint == null) {
+                throw new NullPointerException("Endpoint may not be null.");
+            }
+            this.endpoint = endpoint;
+            return this;
+        }
 
-    /**
+        /** The HTTP client used for requests. */
+        public Builder setClient(final Client client) {
+            if (client == null) {
+                throw new NullPointerException("Client may not be null.");
+            }
+            return setClient(new Client.Provider() {
+
+                @Override
+                public Client get() {
+                    return client;
+                }
+            });
+        }
+
+        /** The HTTP client used for requests. */
+        public Builder setClient(Client.Provider clientProvider) {
+            if (clientProvider == null) {
+                throw new NullPointerException("Client provider may not be null.");
+            }
+            this.clientProvider = clientProvider;
+            return this;
+        }
+
+        /**
      * Executors used for asynchronous HTTP client downloads and callbacks.
      *
      * @param httpExecutor Executor on which HTTP client calls will be made.
@@ -581,107 +548,106 @@ public Builder setClient(Client.Provider clientProvider) {
      * this argument is {@code null} then callback methods will be run on the same thread as the
      * HTTP client.
      */
-    public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
-      if (httpExecutor == null) {
-        throw new NullPointerException("HTTP executor may not be null.");
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = new Utils.SynchronousExecutor();
-      }
-      this.httpExecutor = httpExecutor;
-      this.callbackExecutor = callbackExecutor;
-      return this;
-    }
+        public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
+            if (httpExecutor == null) {
+                throw new NullPointerException("HTTP executor may not be null.");
+            }
+            if (callbackExecutor == null) {
+                callbackExecutor = new Utils.SynchronousExecutor();
+            }
+            this.httpExecutor = httpExecutor;
+            this.callbackExecutor = callbackExecutor;
+            return this;
+        }
 
-    /** A request interceptor for adding data to every request. */
-    public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
-      if (requestInterceptor == null) {
-        throw new NullPointerException("Request interceptor may not be null.");
-      }
-      this.requestInterceptor = requestInterceptor;
-      return this;
-    }
+        /** A request interceptor for adding data to every request. */
+        public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
+            if (requestInterceptor == null) {
+                throw new NullPointerException("Request interceptor may not be null.");
+            }
+            this.requestInterceptor = requestInterceptor;
+            return this;
+        }
 
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder setConverter(Converter converter) {
-      if (converter == null) {
-        throw new NullPointerException("Converter may not be null.");
-      }
-      this.converter = converter;
-      return this;
-    }
+        /** The converter used for serialization and deserialization of objects. */
+        public Builder setConverter(Converter converter) {
+            if (converter == null) {
+                throw new NullPointerException("Converter may not be null.");
+            }
+            this.converter = converter;
+            return this;
+        }
 
-    /** Set the profiler used to measure requests. */
-    public Builder setProfiler(Profiler profiler) {
-      if (profiler == null) {
-        throw new NullPointerException("Profiler may not be null.");
-      }
-      this.profiler = profiler;
-      return this;
-    }
+        /** Set the profiler used to measure requests. */
+        public Builder setProfiler(Profiler profiler) {
+            if (profiler == null) {
+                throw new NullPointerException("Profiler may not be null.");
+            }
+            this.profiler = profiler;
+            return this;
+        }
 
-    /**
+        /**
      * The error handler allows you to customize the type of exception thrown for errors on
      * synchronous requests.
      */
-    public Builder setErrorHandler(ErrorHandler errorHandler) {
-      if (errorHandler == null) {
-        throw new NullPointerException("Error handler may not be null.");
-      }
-      this.errorHandler = errorHandler;
-      return this;
-    }
+        public Builder setErrorHandler(ErrorHandler errorHandler) {
+            if (errorHandler == null) {
+                throw new NullPointerException("Error handler may not be null.");
+            }
+            this.errorHandler = errorHandler;
+            return this;
+        }
 
-    /** Configure debug logging mechanism. */
-    public Builder setLog(Log log) {
-      if (log == null) {
-        throw new NullPointerException("Log may not be null.");
-      }
-      this.log = log;
-      return this;
-    }
+        /** Configure debug logging mechanism. */
+        public Builder setLog(Log log) {
+            if (log == null) {
+                throw new NullPointerException("Log may not be null.");
+            }
+            this.log = log;
+            return this;
+        }
 
-    /** Change the level of logging. */
-    public Builder setLogLevel(LogLevel logLevel) {
-      if (logLevel == null) {
-        throw new NullPointerException("Log level may not be null.");
-      }
-      this.logLevel = logLevel;
-      return this;
-    }
+        /** Change the level of logging. */
+        public Builder setLogLevel(LogLevel logLevel) {
+            if (logLevel == null) {
+                throw new NullPointerException("Log level may not be null.");
+            }
+            this.logLevel = logLevel;
+            return this;
+        }
 
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
-      if (endpoint == null) {
-        throw new IllegalArgumentException("Endpoint may not be null.");
-      }
-      ensureSaneDefaults();
-      return new RestAdapter(endpoint, clientProvider, httpExecutor, callbackExecutor,
-          requestInterceptor, converter, profiler, errorHandler, log, logLevel);
-    }
+        /** Create the {@link RestAdapter} instances. */
+        public RestAdapter build() {
+            if (endpoint == null) {
+                throw new IllegalArgumentException("Endpoint may not be null.");
+            }
+            ensureSaneDefaults();
+            return new RestAdapter(endpoint, clientProvider, httpExecutor, callbackExecutor, requestInterceptor, converter, profiler, errorHandler, log, logLevel);
+        }
 
-    private void ensureSaneDefaults() {
-      if (converter == null) {
-        converter = Platform.get().defaultConverter();
-      }
-      if (clientProvider == null) {
-        clientProvider = Platform.get().defaultClient();
-      }
-      if (httpExecutor == null) {
-        httpExecutor = Platform.get().defaultHttpExecutor();
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = Platform.get().defaultCallbackExecutor();
-      }
-      if (errorHandler == null) {
-        errorHandler = ErrorHandler.DEFAULT;
-      }
-      if (log == null) {
-        log = Platform.get().defaultLog();
-      }
-      if (requestInterceptor == null) {
-        requestInterceptor = RequestInterceptor.NONE;
-      }
+        private void ensureSaneDefaults() {
+            if (converter == null) {
+                converter = Platform.get().defaultConverter();
+            }
+            if (clientProvider == null) {
+                clientProvider = Platform.get().defaultClient();
+            }
+            if (httpExecutor == null) {
+                httpExecutor = Platform.get().defaultHttpExecutor();
+            }
+            if (callbackExecutor == null) {
+                callbackExecutor = Platform.get().defaultCallbackExecutor();
+            }
+            if (errorHandler == null) {
+                errorHandler = ErrorHandler.DEFAULT;
+            }
+            if (log == null) {
+                log = Platform.get().defaultLog();
+            }
+            if (requestInterceptor == null) {
+                requestInterceptor = RequestInterceptor.NONE;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
index 909c2f9fc..7b923e8f3 100644
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/RetrofitError.java
@@ -83,6 +83,14 @@ public Object getBody() {
     return getBodyAs(successType);
   }
 
+  /**
+   * The type declared by either the interface method return type or the generic type of the
+   * supplied {@link Callback} parameter.
+   */
+  public Type getSuccessType() {
+    return successType;
+  }
+
   /**
    * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
    */
diff --git a/retrofit/src/main/java/retrofit/RxSupport.java b/retrofit/src/main/java/retrofit/RxSupport.java
index 97e1293e6..9f1c61415 100644
--- a/retrofit/src/main/java/retrofit/RxSupport.java
+++ b/retrofit/src/main/java/retrofit/RxSupport.java
@@ -57,9 +57,6 @@ private Runnable getRunnable(final Subscriber<? super Object> subscriber, final
           subscriber.onCompleted();
         } catch (RetrofitError e) {
           subscriber.onError(errorHandler.handleError(e));
-        } catch (Exception e) {
-          // This is from the Callable.  It shouldn't actually throw.
-          throw new RuntimeException(e);
         }
       }
     };
diff --git a/retrofit/src/test/java/retrofit/EndpointsTest.java b/retrofit/src/test/java/retrofit/EndpointsTest.java
new file mode 100644
index 000000000..79069e84d
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/EndpointsTest.java
@@ -0,0 +1,19 @@
+// Copyright 2014 Square, Inc.
+package retrofit;
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class EndpointsTest {
+  @Test public void endpointOnly() {
+    Endpoint endpoint = Endpoints.newFixedEndpoint("http://example.com");
+    assertThat(endpoint.getUrl()).isEqualTo("http://example.com");
+  }
+
+  @Test public void endpointAndName() {
+    Endpoint endpoint = Endpoints.newFixedEndpoint("http://example.com", "production");
+    assertThat(endpoint.getUrl()).isEqualTo("http://example.com");
+    assertThat(endpoint.getName()).isEqualTo("production");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 1bdab290a..dab25dde7 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -30,14 +30,11 @@
 import retrofit.mime.TypedString;
 import rx.Observable;
 import rx.functions.Action1;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.same;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doReturn;
@@ -53,552 +50,506 @@
 import static retrofit.Utils.SynchronousExecutor;
 
 public class RestAdapterTest {
-  private static final List<Header> NO_HEADERS = Collections.emptyList();
-  private static final List<Header> TWO_HEADERS =
-      Arrays.asList(new Header("Content-Type", "application/json"),
-          new Header("Content-Length", "42"));
-
-  /** Not all servers play nice and add content-type headers to responses. */
-  private static final TypedInput NO_MIME_BODY = new TypedInput() {
-    @Override public String mimeType() {
-      return null;
+
+    private static final List<Header> NO_HEADERS = Collections.emptyList();
+
+    private static final List<Header> TWO_HEADERS = Arrays.asList(new Header("Content-Type", "application/json"), new Header("Content-Length", "42"));
+
+    /** Not all servers play nice and add content-type headers to responses. */
+    private static final TypedInput NO_MIME_BODY = new TypedInput() {
+
+        @Override
+        public String mimeType() {
+            return null;
+        }
+
+        @Override
+        public long length() {
+            return 2;
+        }
+
+        @Override
+        public InputStream in() throws IOException {
+            return new ByteArrayInputStream("Hi".getBytes("UTF-8"));
+        }
+    };
+
+    private interface Example {
+
+        @Headers(value = "Foo: Bar")
+        @GET(value = "/")
+        String something();
+
+        @Headers(value = "Foo: Bar")
+        @POST(value = "/")
+        Object something(@Body TypedOutput body);
+
+        @GET("/")
+        void something(Callback<String> callback);
+
+        @GET(value = "/")
+        Response direct();
+
+        @GET(value = "/")
+        void direct(Callback<Response> callback);
+
+        @GET("/")
+        @Streaming
+        Response streaming();
+
+        @POST(value = "/")
+        Observable<String> observable(@Body String body);
+
+        @POST(value = "/{x}/{y}")
+        Observable<Response> observable(@Path(value = "x") String x, @Path(value = "y") String y);
     }
 
-    @Override public long length() {
-      return 2;
+    private interface InvalidExample extends Example {
     }
 
-    @Override public InputStream in() throws IOException {
-      return new ByteArrayInputStream("{}".getBytes("UTF-8"));
+    private Client mockClient;
+
+    private Executor mockRequestExecutor;
+
+    private Executor mockCallbackExecutor;
+
+    private Profiler<Object> mockProfiler;
+
+    private Example example;
+
+    @SuppressWarnings(value = { "unchecked" })
+    @Before
+    public void setUp() throws Exception {
+        mockClient = mock(Client.class);
+        mockRequestExecutor = spy(new SynchronousExecutor());
+        mockCallbackExecutor = spy(new SynchronousExecutor());
+        mockProfiler = mock(Profiler.class);
+        example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).build().create(Example.class);
     }
-  };
-
-  private interface Example {
-    @Headers("Foo: Bar")
-    @GET("/") Object something();
-    @Headers("Foo: Bar")
-    @POST("/") Object something(@Body TypedOutput body);
-    @GET("/") void something(Callback<Object> callback);
-    @GET("/") Response direct();
-    @GET("/") void direct(Callback<Response> callback);
-    @GET("/") @Streaming Response streaming();
-    @POST("/") Observable<String> observable(@Body String body);
-    @POST("/{x}/{y}") Observable<Response> observable(@Path("x") String x, @Path("y") String y);
-  }
-  private interface InvalidExample extends Example {
-  }
-
-  private Client mockClient;
-  private Executor mockRequestExecutor;
-  private Executor mockCallbackExecutor;
-  private Profiler<Object> mockProfiler;
-  private Example example;
-
-  @SuppressWarnings("unchecked") // Mock profiler type erasure.
-  @Before public void setUp() throws Exception{
-    mockClient = mock(Client.class);
-    mockRequestExecutor = spy(new SynchronousExecutor());
-    mockCallbackExecutor = spy(new SynchronousExecutor());
-    mockProfiler = mock(Profiler.class);
-
-    example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .build()
-        .create(Example.class);
-  }
-
-  @Test public void objectMethodsStillWork() {
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    try {
-      new RestAdapter.Builder().setEndpoint("http://foo/").build().create(InvalidExample.class);
-      fail("Interface inheritance should not be supported.");
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+
+    @Test
+    public void objectMethodsStillWork() {
+        assertThat(example.hashCode()).isNotZero();
+        assertThat(example.equals(this)).isFalse();
+        assertThat(example.toString()).isNotEmpty();
     }
-  }
-
-  @Test public void profilerObjectPassThrough() throws Exception {
-    Object data = new Object();
-    when(mockProfiler.beforeCall()).thenReturn(data);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, null));
-
-    example.something();
-
-    verify(mockProfiler).beforeCall();
-    verify(mockClient).execute(any(Request.class));
-    verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
-  }
-
-  @Test public void logRequestResponseBasic() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(BASIC)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(
-            new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something();
-    assertThat(logMessages).hasSize(2);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-  }
-
-  @Test public void logRequestResponseHeaders() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void interfaceWithExtendIsNotSupported() {
+        try {
+            new RestAdapter.Builder().setEndpoint("http://foo/").build().create(InvalidExample.class);
+            fail("Interface inheritance should not be supported.");
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+        }
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(HEADERS)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something();
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenResponseBodyPresent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void profilerObjectPassThrough() throws Exception {
+        Object data = new Object();
+        when(mockProfiler.beforeCall()).thenReturn(data);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey")));
+        example.something();
+        verify(mockProfiler).beforeCall();
+        verify(mockClient).execute(any(Request.class));
+        verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something(new TypedString("Hi"));
-    assertThat(logMessages).hasSize(13);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP POST http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("Content-Type: text/plain; charset=UTF-8");
-    assertThat(logMessages.get(3)).isEqualTo("Content-Length: 2");
-    assertThat(logMessages.get(4)).isEqualTo("");
-    assertThat(logMessages.get(5)).isEqualTo("Hi");
-    assertThat(logMessages.get(6)).isEqualTo("---> END HTTP (2-byte body)");
-    assertThat(logMessages.get(7)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(8)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(9)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(10)).isEqualTo("");
-    assertThat(logMessages.get(11)).isEqualTo("{}");
-    assertThat(logMessages.get(12)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void logRequestResponseBasic() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(BASIC).build().create(Example.class);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("Hi")));
+        example.something();
+        assertThat(logMessages).hasSize(2);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, null));
-
-    example.something();
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenMimeTypeMissing() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void logRequestResponseHeaders() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(HEADERS).build().create(Example.class);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("Hi")));
+        example.something();
+        assertThat(logMessages).hasSize(7);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (2-byte body)");
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-    assertThat(logMessages).hasSize(9);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("");
-    assertThat(logMessages.get(7)).isEqualTo("{}");
-    assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void synchronousDoesNotUseExecutors() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, null));
-
-    example.something();
-
-    verifyZeroInteractions(mockRequestExecutor);
-    verifyZeroInteractions(mockCallbackExecutor);
-  }
-
-  @Test public void asynchronousUsesExecutors() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("{}"));
-    when(mockClient.execute(any(Request.class))).thenReturn(response);
-    Callback<Object> callback = mock(Callback.class);
-
-    example.something(callback);
-
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(anyString(), same(response));
-  }
-
-  @Test public void malformedResponseThrowsConversionException() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("{")));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on malformed response body.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(200);
-      assertThat(e.getCause()).isInstanceOf(ConversionException.class);
-      assertThat(e.getResponse().getBody()).isNull();
+    @Test
+    public void logSuccessfulRequestResponseFullWhenResponseBodyPresent() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(FULL).build().create(Example.class);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("{}")));
+        example.something(new TypedString("Hi"));
+        assertThat(logMessages).hasSize(13);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP POST http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("Content-Type: text/plain; charset=UTF-8");
+        assertThat(logMessages.get(3)).isEqualTo("Content-Length: 2");
+        assertThat(logMessages.get(4)).isEqualTo("");
+        assertThat(logMessages.get(5)).isEqualTo("Hi");
+        assertThat(logMessages.get(6)).isEqualTo("---> END HTTP (2-byte body)");
+        assertThat(logMessages.get(7)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(8)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(9)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(10)).isEqualTo("");
+        assertThat(logMessages.get(11)).isEqualTo("{}");
+        assertThat(logMessages.get(12)).isEqualTo("<--- END HTTP (2-byte body)");
     }
-  }
 
-  @Test public void errorResponseThrowsHttpError() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 500, "Internal Server Error", NO_HEADERS, null));
+    @Test
+    public void logSuccessfulRequestResponseFullWhenResponseBodyAbsent() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(FULL).build().create(Example.class);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, null));
+        example.something();
+        assertThat(logMessages).hasSize(7);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
+    }
 
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+    @Test
+    public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, NO_MIME_BODY));
+        example.something();
     }
-  }
-
-  @Test public void logErrorRequestResponseFullWhenMimeTypeMissing() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    Response responseMissingMimeType = //
-        new Response("http://example.com/", 403, "Forbidden", TWO_HEADERS, NO_MIME_BODY);
-
-    when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
-
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(403);
+    @Test
+    public void logSuccessfulRequestResponseFullWhenMimeTypeMissing() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(FULL).build().create(Example.class);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, NO_MIME_BODY));
+        example.something();
+        assertThat(logMessages).hasSize(9);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("");
+        assertThat(logMessages.get(7)).isEqualTo("Hi");
+        assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
     }
 
-    assertThat(logMessages).hasSize(9);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("");
-    assertThat(logMessages.get(7)).isEqualTo("{}");
-    assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logErrorRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
+    @Test
+    public void synchronousDoesNotUseExecutors() throws Exception {
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hi")));
+        example.something();
+        verifyZeroInteractions(mockRequestExecutor);
+        verifyZeroInteractions(mockCallbackExecutor);
+    }
 
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 500, "Internal Server Error", TWO_HEADERS, null));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+    @Test
+    public void asynchronousUsesExecutors() throws Exception {
+        Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        Callback<String> callback = mock(Callback.class);
+        example.something(callback);
+        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+        verify(mockCallbackExecutor).execute(any(Runnable.class));
+        verify(callback).success(eq("Hey"), same(response));
     }
 
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-  }
-
-  @Test public void clientExceptionThrowsNetworkError() throws Exception {
-    IOException exception = new IOException("I'm broken!");
-    when(mockClient.execute(any(Request.class))).thenThrow(exception);
-
-    try {
-      example.something();
-      fail("RetrofitError expected when client throws exception.");
-    } catch (RetrofitError e) {
-      assertThat(e.getCause()).isSameAs(exception);
+    @Test
+    public void malformedResponseThrowsConversionException() throws Exception {
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("{")));
+        try {
+            example.something();
+            fail("RetrofitError expected on malformed response body.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(200);
+            assertThat(e.getCause()).isInstanceOf(ConversionException.class);
+            assertThat(e.getResponse().getBody()).isNull();
+        }
     }
-  }
-
-  @Test public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
-    TypedInput body = spy(new TypedString("{}"));
-    InputStream bodyStream = mock(InputStream.class, new Answer() {
-      @Override public Object answer(InvocationOnMock invocation) throws Throwable {
-        throw new IOException("I'm broken!");
-      }
-    });
-    doReturn(bodyStream).when(body).in();
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, body));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on malformed response body.");
-    } catch (RetrofitError e) {
-      assertThat(e.isNetworkError());
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-      assertThat(e.getCause()).hasMessage("I'm broken!");
+
+    @Test
+    public void errorResponseThrowsHttpError() throws Exception {
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 500, "Internal Server Error", NO_HEADERS, null));
+        try {
+            example.something();
+            fail("RetrofitError expected on non-2XX response code.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(500);
+            assertThat(e.getSuccessType()).isEqualTo(String.class);
+        }
     }
-  }
 
-  @Test public void unexpectedExceptionThrows() {
-    RuntimeException exception = new RuntimeException("More breakage.");
-    when(mockProfiler.beforeCall()).thenThrow(exception);
+    @Test
+    public void logErrorRequestResponseFullWhenMimeTypeMissing() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(FULL).build().create(Example.class);
+        Response responseMissingMimeType = new Response("http://example.com/", 403, "Forbidden", TWO_HEADERS, NO_MIME_BODY);
+        when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
+        try {
+            example.something();
+            fail("RetrofitError expected on non-2XX response code.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(403);
+        }
+        assertThat(logMessages).hasSize(9);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("");
+        assertThat(logMessages.get(7)).isEqualTo("Hi");
+        assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
+    }
 
-    try {
-      example.something();
-      fail("RetrofitError expected when unexpected exception thrown.");
-    } catch (RetrofitError e) {
-      assertThat(e.getCause()).isSameAs(exception);
+    @Test
+    public void logErrorRequestResponseFullWhenResponseBodyAbsent() throws Exception {
+        final List<String> logMessages = new ArrayList<String>();
+        RestAdapter.Log log = new RestAdapter.Log() {
+
+            public void log(String message) {
+                logMessages.add(message);
+            }
+        };
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(log).setLogLevel(FULL).build().create(Example.class);
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 500, "Internal Server Error", TWO_HEADERS, null));
+        try {
+            example.something();
+            fail("RetrofitError expected on non-2XX response code.");
+        } catch (RetrofitError e) {
+            assertThat(e.getResponse().getStatus()).isEqualTo(500);
+        }
+        assertThat(logMessages).hasSize(7);
+        assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
+        assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
+        assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
+        assertThat(logMessages.get(3)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
+        assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
+        assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
+        assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
+    }
+
+    @Test
+    public void clientExceptionThrowsNetworkError() throws Exception {
+        IOException exception = new IOException("I\'m broken!");
+        when(mockClient.execute(any(Request.class))).thenThrow(exception);
+        try {
+            example.something();
+            fail("RetrofitError expected when client throws exception.");
+        } catch (RetrofitError e) {
+            assertThat(e.getCause()).isSameAs(exception);
+        }
+    }
+
+    @Test
+    public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
+        TypedInput body = spy(new TypedString("{}"));
+        InputStream bodyStream = mock(InputStream.class, new Answer() {
+
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                throw new IOException("I\'m broken!");
+            }
+        });
+        doReturn(bodyStream).when(body).in();
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, body));
+        try {
+            example.something();
+            fail("RetrofitError expected on malformed response body.");
+        } catch (RetrofitError e) {
+            assertThat(e.isNetworkError());
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+            assertThat(e.getCause()).hasMessage("I\'m broken!");
+        }
+    }
+
+    @Test
+    public void unexpectedExceptionThrows() {
+        RuntimeException exception = new RuntimeException("More breakage.");
+        when(mockProfiler.beforeCall()).thenThrow(exception);
+        try {
+            example.something();
+            fail("RetrofitError expected when unexpected exception thrown.");
+        } catch (RetrofitError e) {
+            assertThat(e.getCause()).isSameAs(exception);
+        }
+    }
+
+    @Test
+    public void getResponseDirectly() throws Exception {
+        Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, null);
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        assertThat(example.direct()).isSameAs(response);
     }
-  }
-
-  @Test public void getResponseDirectly() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, null);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    assertThat(example.direct()).isSameAs(response);
-  }
-
-  @Test public void streamingResponse() throws Exception {
-    final InputStream is = new ByteArrayInputStream("Hey".getBytes("UTF-8"));
-    TypedInput in = new TypedInput() {
-      @Override public String mimeType() {
-        return "text/string";
-      }
-
-      @Override public long length() {
-        return 3;
-      }
-
-      @Override public InputStream in() throws IOException {
-        return is;
-      }
-    };
 
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, in));
-
-    Response response = example.streaming();
-    assertThat(response.getBody().in()).isSameAs(is);
-  }
-
-  @Test public void closeInputStream() throws IOException {
-    // Set logger and profiler on example to make sure we exercise all the code paths.
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(RestAdapter.Log.NONE)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
-    TypedInput typedInput = mock(TypedInput.class);
-    when(typedInput.in()).thenReturn(is);
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, typedInput);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    example.something();
-    verify(is).close();
-  }
-
-  @Test public void getResponseDirectlyAsync() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, null);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    Callback<Response> callback = mock(Callback.class);
-
-    example.direct(callback);
-
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(response), same(response));
-  }
-
-  @Test public void observableCallsOnNext() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
-    Action1<String> action = mock(Action1.class);
-    example.observable("Howdy").subscribe(action);
-    verify(action).call(eq("hello"));
-  }
-
-  @Test public void observableCallsOnError() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 300, "FAIL", NO_HEADERS, new TypedString("bummer")));
-    Action1<String> onSuccess = mock(Action1.class);
-    Action1<Throwable> onError = mock(Action1.class);
-    example.observable("Howdy").subscribe(onSuccess, onError);
-    verifyZeroInteractions(onSuccess);
-    verify(onError).call(isA(RetrofitError.class));
-  }
-
-  @Test public void observableHandlesParams() throws Exception {
-    ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
-    when(mockClient.execute(requestCaptor.capture())) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
-    ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
-    Action1<Response> action = mock(Action1.class);
-    example.observable("X", "Y").subscribe(action);
-
-    Request request = requestCaptor.getValue();
-    assertThat(request.getUrl()).contains("/X/Y");
-
-    verify(action).call(responseCaptor.capture());
-    Response response = responseCaptor.getValue();
-    assertThat(response.getStatus()).isEqualTo(200);
-  }
-
-  @Test public void observableUsesHttpExecutor() throws IOException {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello"));
-    when(mockClient.execute(any(Request.class))).thenReturn(response);
-
-    example.observable("Howdy").subscribe(mock(Action1.class));
-
-    verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
-    verifyZeroInteractions(mockCallbackExecutor);
-  }
-
-  @Test public void testEndpointFactories() {
-    Endpoint endpoint1 = Endpoints.newFixedEndpoint("http://example.com");
-    Endpoint endpoint2 = Endpoints.newFixedEndpoint("http://example.com", "exampleName");
-
-    assertThat(endpoint1.getUrl()).isEqualTo("http://example.com");
-    assertThat(endpoint2.getUrl()).isEqualTo("http://example.com");
-    assertThat(endpoint2.getName()).isEqualTo("exampleName");
-  }
+    @Test
+    public void streamingResponse() throws Exception {
+        final InputStream is = new ByteArrayInputStream("Hey".getBytes("UTF-8"));
+        TypedInput in = new TypedInput() {
+
+            @Override
+            public String mimeType() {
+                return "text/string";
+            }
+
+            @Override
+            public long length() {
+                return 3;
+            }
+
+            @Override
+            public InputStream in() throws IOException {
+                return is;
+            }
+        };
+        //
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, in));
+        Response response = example.streaming();
+        assertThat(response.getBody().in()).isSameAs(is);
+    }
 
+    @Test
+    public void closeInputStream() throws IOException {
+        Example example = new RestAdapter.Builder().setClient(mockClient).setExecutors(mockRequestExecutor, mockCallbackExecutor).setEndpoint("http://example.com").setProfiler(mockProfiler).setLog(RestAdapter.Log.NONE).setLogLevel(FULL).build().create(Example.class);
+        ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
+        TypedInput typedInput = mock(TypedInput.class);
+        when(typedInput.in()).thenReturn(is);
+        Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, typedInput);
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        example.something();
+        verify(is).close();
+    }
+
+    @Test
+    public void getResponseDirectlyAsync() throws Exception {
+        Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        Callback<Response> callback = mock(Callback.class);
+        example.direct(callback);
+        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+        verify(mockCallbackExecutor).execute(any(Runnable.class));
+        verify(callback).success(eq(response), same(response));
+    }
+
+    @Test
+    public void getAsync() throws Exception {
+        Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
+        //
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        Callback<String> callback = mock(Callback.class);
+        example.something(callback);
+        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+        verify(mockCallbackExecutor).execute(any(Runnable.class));
+        ArgumentCaptor<String> responseCaptor = ArgumentCaptor.forClass(String.class);
+        verify(callback).success(responseCaptor.capture(), same(response));
+        assertThat(responseCaptor.getValue()).isEqualTo("Hey");
+    }
+
+    @Test
+    public void errorAsync() throws Exception {
+        Response response = new Response("http://example.com/", 500, "Broken!", NO_HEADERS, new TypedString("Hey"));
+        //
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        Callback<String> callback = mock(Callback.class);
+        example.something(callback);
+        verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
+        verify(mockCallbackExecutor).execute(any(Runnable.class));
+        ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
+        verify(callback).failure(errorCaptor.capture());
+        RetrofitError error = errorCaptor.getValue();
+        assertThat(error.getResponse().getStatus()).isEqualTo(500);
+        assertThat(error.getResponse().getReason()).isEqualTo("Broken!");
+        assertThat(error.getSuccessType()).isEqualTo(String.class);
+        assertThat(error.getBody()).isEqualTo("Hey");
+    }
+
+    @Test
+    public void observableCallsOnNext() throws Exception {
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
+        Action1<String> action = mock(Action1.class);
+        example.observable("Howdy").subscribe(action);
+        verify(action).call(eq("hello"));
+    }
+
+    @Test
+    public void observableCallsOnError() throws Exception {
+        when(mockClient.execute(any(Request.class))).thenReturn(new Response("http://example.com/", 300, "FAIL", NO_HEADERS, new TypedString("bummer")));
+        Action1<String> onSuccess = mock(Action1.class);
+        Action1<Throwable> onError = mock(Action1.class);
+        example.observable("Howdy").subscribe(onSuccess, onError);
+        verifyZeroInteractions(onSuccess);
+        ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
+        verify(onError).call(errorCaptor.capture());
+        RetrofitError value = errorCaptor.getValue();
+        assertThat(value.getSuccessType()).isEqualTo(String.class);
+    }
+
+    @Test
+    public void observableHandlesParams() throws Exception {
+        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
+        when(mockClient.execute(requestCaptor.capture())).thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
+        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
+        Action1<Response> action = mock(Action1.class);
+        example.observable("X", "Y").subscribe(action);
+        Request request = requestCaptor.getValue();
+        assertThat(request.getUrl()).contains("/X/Y");
+        verify(action).call(responseCaptor.capture());
+        Response response = responseCaptor.getValue();
+        assertThat(response.getStatus()).isEqualTo(200);
+    }
+
+    @Test
+    public void observableUsesHttpExecutor() throws IOException {
+        Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello"));
+        when(mockClient.execute(any(Request.class))).thenReturn(response);
+        example.observable("Howdy").subscribe(mock(Action1.class));
+        verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
+        verifyZeroInteractions(mockCallbackExecutor);
+    }
 }
