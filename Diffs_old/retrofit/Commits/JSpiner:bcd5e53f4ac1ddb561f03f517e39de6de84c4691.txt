diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResponseObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResponseObservable.java
new file mode 100644
index 000000000..375d51d61
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResponseObservable.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Response;
+
+
+/**
+ * @author JSpiner (jspiner@naver.com)
+ */
+final class ResponseObservable<T> extends Observable<Response<T>> {
+  private final Observable<Response<T>> upstream;
+  ResponseObservable(Observable<Response<T>> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    upstream.subscribe(new ResponseObservable.ResponseObserver<T>(observer));
+  }
+
+  private static class ResponseObserver<R> implements Observer<Response<R>> {
+    private final Observer<? super Response<R>> observer;
+
+    ResponseObserver(Observer<? super Response<R>> observer) {
+      this.observer = observer;
+    }
+
+    @Override public void onSubscribe(Disposable disposable) {
+      observer.onSubscribe(disposable);
+    }
+
+    @Override public void onNext(Response<R> response) {
+      observer.onNext(response);
+    }
+
+    @Override public void onComplete() {
+      observer.onComplete();
+    }
+
+    @Override public void onError(Throwable throwable) {
+      try {
+        observer.onError(throwable);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        RxJavaPlugins.onError(new CompositeException(throwable, inner));
+      }
+      return;
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index eccd30da3..42c7061ea 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -28,6 +28,7 @@
   private final Type responseType;
   private final @Nullable Scheduler scheduler;
   private final boolean isAsync;
+  private final boolean isResponseObservable;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isFlowable;
@@ -36,11 +37,12 @@
   private final boolean isCompletable;
 
   RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,
-      boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
-      boolean isCompletable) {
+      boolean isResponseObservable, boolean isResult, boolean isBody, boolean isFlowable,
+      boolean isSingle, boolean isMaybe, boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
     this.isAsync = isAsync;
+    this.isResponseObservable = isResponseObservable;
     this.isResult = isResult;
     this.isBody = isBody;
     this.isFlowable = isFlowable;
@@ -59,7 +61,9 @@
         : new CallExecuteObservable<>(call);
 
     Observable<?> observable;
-    if (isResult) {
+    if (isResponseObservable) {
+      observable = new ResponseObservable<>(responseObservable);
+    } else if (isResult) {
       observable = new ResultObservable<>(responseObservable);
     } else if (isBody) {
       observable = new BodyObservable<>(responseObservable);
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index 8af54c505..40d53828d 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -97,14 +97,16 @@ private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync
     if (rawType == Completable.class) {
       // Completable is not parameterized (which is what the rest of this method deals with) so it
       // can only be created with a single configuration.
-      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
-          false, true);
+      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, false, true,
+          false, false, false, true);
     }
 
     boolean isFlowable = rawType == Flowable.class;
     boolean isSingle = rawType == Single.class;
     boolean isMaybe = rawType == Maybe.class;
-    if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
+    boolean isResponseObservable = rawType == ResponseObservable.class;
+    if (rawType != Observable.class && !isResponseObservable && !isFlowable && !isSingle
+            && !isMaybe) {
       return null;
     }
 
@@ -139,7 +141,7 @@ private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync
       isBody = true;
     }
 
-    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
-        isSingle, isMaybe, false);
+    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResponseObservable, isResult,
+        isBody, isFlowable, isSingle, isMaybe, false);
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
index e421c1652..ce7996059 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -17,6 +17,10 @@
 
 import io.reactivex.Observable;
 import java.io.IOException;
+
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Consumer;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
@@ -37,6 +41,7 @@
     @GET("/") Observable<String> body();
     @GET("/") Observable<Response<String>> response();
     @GET("/") Observable<Result<String>> result();
+    @GET("/") ResponseObservable<String> responseObservable();
   }
 
   private Service service;
@@ -133,4 +138,31 @@
     assertThat(result.error()).isInstanceOf(IOException.class);
     observer.assertComplete();
   }
+
+  @Test public void responseObservableSuccess200() {
+    server.enqueue(new MockResponse());
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.responseObservable().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isTrue();
+    observer.assertComplete();
+  }
+
+  @Test public void responseObservableSuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.responseObservable().subscribe(observer);
+    assertThat(observer.takeValue().isSuccessful()).isFalse();
+    observer.assertComplete();
+  }
+
+  @Test public void responseObservableFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    RecordingObserver<Response<String>> observer = observerRule.create();
+    service.responseObservable().subscribe(observer);
+    observer.assertError(IOException.class);
+  }
+
 }
