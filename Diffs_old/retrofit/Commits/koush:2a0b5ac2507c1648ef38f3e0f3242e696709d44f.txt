diff --git a/retrofit/AndroidManifest.xml b/retrofit/AndroidManifest.xml
new file mode 100644
index 000000000..a07bab745
--- /dev/null
+++ b/retrofit/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.retrofit"
+    android:versionCode="103"
+    android:versionName="1.0.3" >
+
+    <uses-sdk
+        android:minSdkVersion="8"
+        android:targetSdkVersion="17" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.READ_LOGS"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+    <application>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 8b549fc76..f9fa73918 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -17,13 +17,16 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
+import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
 import retrofit.Profiler.RequestInformation;
 import retrofit.client.Client;
@@ -154,6 +157,10 @@ public void setDebug(boolean debug) {
         new RestHandler());
   }
 
+  private static interface ResponseReady {
+    Object onResponse(Response response) throws IOException;
+  }
+
   private class RestHandler implements InvocationHandler {
     private final Map<Method, RestMethodInfo> methodDetailsCache =
         new LinkedHashMap<Method, RestMethodInfo>();
@@ -193,13 +200,28 @@ public void setDebug(boolean debug) {
       if (httpExecutor == null || callbackExecutor == null) {
         throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
       }
-      Callback<?> callback = (Callback<?>) args[args.length - 1];
-      httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
-        @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(methodDetails, args);
+      invokeRequest(methodDetails, args);
+      return null;
+    }
+
+    private class NamedExecutor implements Executor {
+      private String url;
+      private String serverUrl;
+      private NamedExecutor(String serverUrl, String url) {
+        this.url = url;
+        this.serverUrl = serverUrl;
+      }
+      @Override
+      public void execute(Runnable runnable) {
+        if (true)throw new Error("shit");
+        try {
+          // If we are executing asynchronously then update the current thread with a useful name.
+//          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
+          httpExecutor.execute(runnable);
+        } finally {
+//          Thread.currentThread().setName(IDLE_THREAD_NAME);
         }
-      });
-      return null; // Asynchronous methods should have return type of void.
+      }
     }
 
     /**
@@ -208,94 +230,169 @@ public void setDebug(boolean debug) {
      * @return HTTP response object of specified {@code type} or {@code null}.
      * @throws RetrofitError if any error occurs during the HTTP request.
      */
-    private Object invokeRequest(RestMethodInfo methodDetails, Object[] args) {
+    @SuppressWarnings("unchecked")
+    private Object invokeRequest(final RestMethodInfo methodDetails, Object[] args) {
       methodDetails.init(); // Ensure all relevant method information has been loaded.
 
-      String serverUrl = server.getUrl();
-      String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
+      final String serverUrl = server.getUrl();
+      final Request request;
+      final Object profilerObject;
+      String tmpUrl = serverUrl;
       try {
-        Request request = new RequestBuilder(converter) //
+        Request tmpRequest = new RequestBuilder(converter) //
             .apiUrl(serverUrl) //
             .args(args) //
             .headers(requestHeaders.get()) //
             .methodInfo(methodDetails) //
             .build();
-        url = request.getUrl();
-
-        if (!methodDetails.isSynchronous) {
-          // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
-        }
+        tmpUrl = tmpRequest.getUrl();
 
         if (debug) {
-          request = logAndReplaceRequest(request);
+            request = logAndReplaceRequest(tmpRequest);
+        }
+        else {
+          request = tmpRequest;
         }
 
-        Object profilerObject = null;
         if (profiler != null) {
           profilerObject = profiler.beforeCall();
         }
-
-        long start = System.nanoTime();
-        Response response = clientProvider.get().execute(request);
-        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
-
-        int statusCode = response.getStatus();
-        if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(serverUrl, methodDetails, request);
-          //noinspection unchecked
-          profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
+        else {
+          profilerObject = null;
         }
+      } catch (IOException e) {
+        throw RetrofitError.networkError(tmpUrl, e);
+      } catch (Throwable t) {
+        throw RetrofitError.unexpectedError(tmpUrl, t);
+      }
 
-        if (debug) {
-          response = logAndReplaceResponse(url, response, elapsedTime);
-        }
+      final String url = tmpUrl;
+      final long start = System.nanoTime();
 
-        Type type = methodDetails.responseObjectType;
+      // execute synchronously
+      if (methodDetails.isSynchronous) {
+        try {
+          return handleResponse(clientProvider.get().execute(request), request,
+                  methodDetails, serverUrl, url, start, profilerObject);
+        } catch (RetrofitError e) {
+          throw e; // Pass through our own errors.
+        } catch (IOException e) {
+          throw RetrofitError.networkError(url, e);
+        } catch (Throwable t) {
+          throw RetrofitError.unexpectedError(url, t);
+        }
+      }
 
-        if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-          // Caller requested the raw Response object directly.
-          if (type.equals(Response.class)) {
-            // Read the entire stream and replace with one backed by a byte[]
-            response = Utils.readBodyToBytesIfNecessary(response);
+      // get the callback and create a client
+      final Callback callback = (Callback) args[args.length - 1];
+      final Client client = clientProvider.get();
 
-            if (methodDetails.isSynchronous) {
-              return response;
+      // this async call requires an executor, use the httpExecutor
+      FutureTask futureTask = new FutureTask(new Callable() {
+        @Override
+        public Object call() throws Exception {
+          return null;
+        }
+      });
+      if (client.needsExecutor()) {
+        httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
+          @Override
+          public ResponseWrapper obtainResponse() {
+            try {
+              return (ResponseWrapper)handleResponse(client.execute(request), request,
+                      methodDetails, serverUrl, url, start, profilerObject);
+            } catch (IOException e) {
+              throw RetrofitError.networkError(url, e);
+            } catch (Throwable t) {
+              throw RetrofitError.unexpectedError(url, t);
             }
-            return new ResponseWrapper(response, response);
           }
+        });
+        return futureTask;
+      }
 
-          TypedInput body = response.getBody();
-          if (body == null) {
-            return new ResponseWrapper(response, null);
-          }
-          try {
-            Object convert = converter.fromBody(body, type);
-            if (methodDetails.isSynchronous) {
-              return convert;
+      // no executor necessary for the http request (nio)
+      clientProvider.get().executeAsync(request, null, new Client.ResponseCallback() {
+        @SuppressWarnings("unchecked")
+        @Override
+        public void success(final Response response) {
+          new CallbackRunnable(callback, callbackExecutor) {
+            @Override
+            public ResponseWrapper obtainResponse() {
+              try {
+                return  (ResponseWrapper) handleResponse(client.execute(request), request,
+                        methodDetails, serverUrl, url, start, profilerObject);
+              } catch (IOException e) {
+                throw RetrofitError.networkError(url, e);
+              }
             }
-            return new ResponseWrapper(response, convert);
-          } catch (ConversionException e) {
-            // The response body was partially read by the converter. Replace it with null.
-            response = Utils.replaceResponseBody(response, null);
-
-            throw RetrofitError.conversionError(url, response, converter, type, e);
-          }
+          }.run();
         }
 
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(url, response, converter, type);
-      } catch (RetrofitError e) {
-        throw e; // Pass through our own errors.
-      } catch (IOException e) {
-        throw RetrofitError.networkError(url, e);
-      } catch (Throwable t) {
-        throw RetrofitError.unexpectedError(url, t);
-      } finally {
-        if (!methodDetails.isSynchronous) {
-          Thread.currentThread().setName(IDLE_THREAD_NAME);
+        @Override
+        public void failure(final RetrofitError e) {
+          System.out.println("response failed");
+          callbackExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+              callback.failure(e);
+            }
+          });
         }
+      });
+      return null;
+    }
+  }
+
+  Object handleResponse(Response response, final Request request,
+                        final RestMethodInfo methodDetails, final String serverUrl,
+                        final String url, final long start, final Object profilerObject)
+          throws IOException {
+    long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
+
+    int statusCode = response.getStatus();
+    if (profiler != null) {
+      RequestInformation requestInfo = getRequestInfo(serverUrl, methodDetails, request);
+      //noinspection unchecked
+      profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
+    }
+
+    if (debug) {
+      response = logAndReplaceResponse(url, response, elapsedTime);
+    }
+
+    Type type = methodDetails.responseObjectType;
+
+    if (statusCode < 200 || statusCode >= 300) { // 2XX == successful request
+      response = Utils.readBodyToBytesIfNecessary(response);
+      throw RetrofitError.httpError(url, response, converter, type);
+    }
+    // Caller requested the raw Response object directly.
+    if (type.equals(Response.class)) {
+      // Read the entire stream and replace with one backed by a byte[]
+      response = Utils.readBodyToBytesIfNecessary(response);
+
+      if (methodDetails.isSynchronous) {
+        return response;
       }
+      return new ResponseWrapper(response, response);
+    }
+
+    TypedInput body = response.getBody();
+    if (body == null) {
+      return new ResponseWrapper(response, null);
+    }
+    try {
+      Object convert = converter.fromBody(body, type);
+      if (methodDetails.isSynchronous) {
+        return convert;
+      }
+      return new ResponseWrapper(response, convert);
+    } catch (ConversionException e) {
+      // The response body was partially read by the converter. Replace it with null.
+      response = Utils.replaceResponseBody(response, null);
+
+      throw RetrofitError.conversionError(url, response, converter, type, e);
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit/client/ApacheClient.java b/retrofit/src/main/java/retrofit/client/ApacheClient.java
index 1b75da3d1..6da137966 100644
--- a/retrofit/src/main/java/retrofit/client/ApacheClient.java
+++ b/retrofit/src/main/java/retrofit/client/ApacheClient.java
@@ -23,6 +23,8 @@
 import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.Executor;
+
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.StatusLine;
@@ -33,11 +35,14 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.message.BasicHeader;
 import org.apache.http.util.EntityUtils;
+
+import retrofit.Callback;
+import retrofit.RetrofitError;
 import retrofit.mime.TypedByteArray;
 import retrofit.mime.TypedOutput;
 
 /** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
-public class ApacheClient implements Client {
+public class ApacheClient extends ClientBase {
   private final HttpClient client;
 
   /** Creates an instance backed by {@link DefaultHttpClient}. */
diff --git a/retrofit/src/main/java/retrofit/client/Client.java b/retrofit/src/main/java/retrofit/client/Client.java
index 5608b5352..ca9660263 100644
--- a/retrofit/src/main/java/retrofit/client/Client.java
+++ b/retrofit/src/main/java/retrofit/client/Client.java
@@ -16,6 +16,9 @@
 package retrofit.client;
 
 import java.io.IOException;
+import java.util.concurrent.Future;
+
+import retrofit.RetrofitError;
 
 /**
  * Abstraction of an HTTP client which can execute {@link Request Requests}. This class must be
@@ -27,6 +30,13 @@
    * into a {@link Response} instance.
    */
   Response execute(Request request) throws IOException;
+  Future executeAsync(Request request, Future future, ResponseCallback callback);
+  boolean needsExecutor();
+
+  interface ResponseCallback {
+    void success(Response response);
+    void failure(RetrofitError e);
+  }
 
   /**
    * Deferred means of obtaining a {@link Client}. For asynchronous requests this will always be
diff --git a/retrofit/src/main/java/retrofit/client/ClientBase.java b/retrofit/src/main/java/retrofit/client/ClientBase.java
new file mode 100644
index 000000000..f3ec34eb5
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/client/ClientBase.java
@@ -0,0 +1,26 @@
+package retrofit.client;
+
+import java.io.IOException;
+import java.util.concurrent.Future;
+
+import retrofit.RetrofitError;
+
+/**
+ * Created by koush on 6/2/13.
+ */
+abstract public class ClientBase implements Client {
+  @Override public Future executeAsync(final Request request, Future future, final ResponseCallback callback) {
+    try {
+      callback.success(execute(request));
+    }
+    catch (IOException e) {
+      callback.failure(RetrofitError.networkError(request.getUrl(), e));
+    }
+    return future;
+  }
+
+  @Override
+  public boolean needsExecutor() {
+    return true;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
index fcca8c484..dd21b4ed9 100644
--- a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
+++ b/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
@@ -22,11 +22,15 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Executor;
+
+import retrofit.Callback;
+import retrofit.RetrofitError;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
 
 /** Retrofit client that uses {@link HttpURLConnection} for communication. */
-public class UrlConnectionClient implements Client {
+public class UrlConnectionClient extends ClientBase {
   @Override public Response execute(Request request) throws IOException {
     HttpURLConnection connection = openConnection(request);
     prepareRequest(connection, request);
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
index 981b3b05b..486aa3bbb 100644
--- a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
+++ b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
@@ -3,9 +3,12 @@
 
 import java.io.IOException;
 import java.util.Collections;
+import java.util.concurrent.Executor;
+
 import org.junit.Before;
 import org.junit.Test;
 import retrofit.client.Client;
+import retrofit.client.ClientBase;
 import retrofit.client.Header;
 import retrofit.client.Request;
 import retrofit.client.Response;
@@ -28,7 +31,7 @@
   }
 
   /* An HTTP client which always returns a 400 response */
-  static class MockInvalidResponseClient implements Client {
+  static class MockInvalidResponseClient extends ClientBase {
     @Override public Response execute(Request request) throws IOException {
       return new Response(400, "invalid request", Collections.<Header>emptyList(), null);
     }
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 282fff5ea..969b3b00a 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -49,6 +49,8 @@
   @SuppressWarnings("unchecked") // Mock profiler type erasure.
   @Before public void setUp() throws Exception{
     mockClient = mock(Client.class);
+    when(mockClient.needsExecutor())
+            .thenReturn(true);
     mockRequestExecutor = spy(new SynchronousExecutor());
     mockCallbackExecutor = spy(new SynchronousExecutor());
     mockProfiler = mock(Profiler.class);
@@ -95,7 +97,9 @@
     Response response = new Response(200, "OK", NO_HEADERS, new TypedString("{}"));
     when(mockClient.execute(any(Request.class))) //
         .thenReturn(response);
-    Callback<Object> callback = mock(Callback.class);
+    when(mockClient.needsExecutor())
+        .thenReturn(true);
+    Callback< Object > callback = mock(Callback.class);
 
     example.something(callback);
 
