diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index a2b1afbdd..e4aac4739 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -8,64 +8,65 @@
  */
 public class Call<T> {
 
-	private final RestAdapter.RestHandler handler;
-	private final RequestInterceptor interceptor;
-	private final RestMethodInfo methodInfo;
-	private final Object[] args;
-	private final Executor httpExecutor;
+  private final RestAdapter.RestHandler handler;
+  private final RequestInterceptor interceptor;
+  private final RestMethodInfo methodInfo;
+  private final Object[] args;
+  private final Executor httpExecutor;
 
-	/**
-	 * 
-	 * @param handler RestHandler that created this Call<T> and 
-	 * that will carry out the actual request.
-	 * @param interceptor Interceptor to call invokeRequest() with.
-	 * @param methodInfo RestMethodInfo to call invokeRequest() with.
-	 * @param args Object[] to call invokeRequest() with.
-	 * @param httpExecutor Executor for HTTP requests.
-	 */
-	public Call(RestAdapter.RestHandler handler,
-			RequestInterceptor interceptor, RestMethodInfo methodInfo,
-			Object[] args, Executor httpExecutor) {
-		this.handler = handler;
-		this.interceptor = interceptor;
-		this.methodInfo = methodInfo;
-		this.args = args;
-		this.httpExecutor = httpExecutor;
-	}
+  /**
+   * Constructor
+   *
+   * @param handler RestHandler that created this Call<T> and
+   * that will carry out the actual request.
+   * @param interceptor Interceptor to call invokeRequest() with.
+   * @param methodInfo RestMethodInfo to call invokeRequest() with.
+   * @param args Object[] to call invokeRequest() with.
+   * @param httpExecutor Executor for HTTP requests.
+   */
+  public Call(RestAdapter.RestHandler handler,
+      RequestInterceptor interceptor, RestMethodInfo methodInfo,
+      Object[] args, Executor httpExecutor) {
+    this.handler = handler;
+    this.interceptor = interceptor;
+    this.methodInfo = methodInfo;
+    this.args = args;
+    this.httpExecutor = httpExecutor;
+  }
 
-	/**
-	 * Execute the request synchronously.
-	 * @return the request's response of type T
-	 */
-	@SuppressWarnings("unchecked")
-	public T execute() {
-		return (T) handler.invokeRequest(interceptor, methodInfo, args);
-	}
+  /**
+   * Execute the request synchronously.
+   * @return the request's response of type T
+   */
+  @SuppressWarnings("unchecked")
+  public T execute() {
+    return (T) handler.invokeRequest(interceptor, methodInfo, args);
+  }
 
-	/**
-	 * Execute the request asynchronously with a (API 2.0) callback.
-	 * @param callback (API 2.0) Callback2 to process the request with. 
-	 * @return Asynchronous execute() return void. 
-	 */
-	public void execute(final Callback2<T> callback) {
-		// Not handling the interceptor or observable for now. The synchronous
-		// version of RestHandler.invoke() does not handle this either.
+  /**
+   * Execute the request asynchronously with a (API 2.0) callback.
+   * @param callback (API 2.0) Callback2 to process the request with.
+   * @return Asynchronous execute() return void.
+   */
+  public void execute(final Callback2<T> callback) {
+    // Not handling the interceptor or observable for now. The synchronous
+    // version of RestHandler.invoke() does not handle this either.
 
-		httpExecutor.execute(new Runnable() {
-			@SuppressWarnings("unchecked")
-			@Override
-			public void run() {
-				T response;
+    httpExecutor.execute(new Runnable() {
+      @SuppressWarnings("unchecked")
+      @Override
+      public void run() {
+        T response;
 
-				try {
-					response = (T) handler.invokeRequest(interceptor, methodInfo, args);
-				} catch (RetrofitError err) {
-					callback.failure(err);
-					return;
-				}
+        try {
+          response = (T) handler.invokeRequest(interceptor, methodInfo, args);
+        } catch (RetrofitError err) {
+          callback.failure(err);
+          return;
+        }
 
-				callback.success(response);
-			}
-		});
-	}
+        callback.success(response);
+      }
+    });
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/Callback2.java b/retrofit/src/main/java/retrofit/Callback2.java
index ff8e3b9ca..0979dc582 100644
--- a/retrofit/src/main/java/retrofit/Callback2.java
+++ b/retrofit/src/main/java/retrofit/Callback2.java
@@ -28,4 +28,4 @@
    * exception. Under API 2.0 this is broken into several methods.
    */
   void failure(RetrofitError error);
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 449ca04db..412d9a5e5 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -23,7 +23,6 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
-import java.lang.reflect.Constructor;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.Callable;
@@ -41,7 +40,6 @@
 import retrofit.mime.TypedByteArray;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
-import retrofit.Call;
 import rx.Observable;
 import rx.Observer;
 import rx.Scheduler;
@@ -280,9 +278,9 @@ Observable createRequestObservable(final Callable<ResponseWrapper> request) {
 
       // Load or create the details cache for the current method.
       final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-      
-      if(methodInfo.isCallable) {
-    	return new Call(this, requestInterceptor, methodInfo, args, httpExecutor); 
+
+      if (methodInfo.isCallable) {
+        return new Call(this, requestInterceptor, methodInfo, args, httpExecutor);
       }
 
       if (methodInfo.isSynchronous) {
@@ -382,7 +380,7 @@ Object invokeRequest(RequestInterceptor requestInterceptor,
         // Check if the method returns a Call<T>, and if so use its generic
         // argument as the request return type
         if (methodInfo.isCallable) {
-          ParameterizedType pt = (ParameterizedType)methodInfo.responseObjectType;
+          ParameterizedType pt = (ParameterizedType) methodInfo.responseObjectType;
           type = pt.getActualTypeArguments()[0];
         }
 
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index 2c9ec5a93..1089acd43 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -273,14 +273,14 @@ private ResponseType parseResponseType() {
 
     if (hasReturnType) {
       if (Platform.HAS_RX_JAVA) {
-    	Class rawReturnType = Types.getRawType(returnType);
+      Class rawReturnType = Types.getRawType(returnType);
         if (rawReturnType == Observable.class) {
           returnType = Types.getSupertype(returnType, rawReturnType, Observable.class);
           responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
           return ResponseType.OBSERVABLE;
         }
       }
-      
+
       responseObjectType = returnType;
       return ResponseType.OBJECT;
     }
