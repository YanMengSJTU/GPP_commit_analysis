diff --git a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
index 0f0713b92..beb72cf38 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
@@ -7,6 +7,7 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.WildcardType;
 import java.util.LinkedHashSet;
+import java.util.Locale;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -105,7 +106,7 @@ private void parseMethodAnnotations() {
       pathQueryParams = new QueryParam[0];
     } else {
       for (QueryParam pathQueryParam : pathQueryParams) {
-        if (pathParams.contains(pathQueryParam.name())) {
+        if (pathParams.contains(pathQueryParam.name().toLowerCase(Locale.ENGLISH))) {
           throw new IllegalStateException("Query parameters cannot be present in URL.");
         }
       }
@@ -189,7 +190,7 @@ private void parseParameters() {
       for (Annotation parameterAnnotation : parameterAnnotations) {
         Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
         if (annotationType == Name.class) {
-          String name = ((Name) parameterAnnotation).value();
+          String name = ((Name) parameterAnnotation).value().toLowerCase(Locale.ENGLISH);
           namedParams[i] = name;
           boolean isPathParam = pathParams.contains(name);
           if (parameterType == TypedOutput.class && (isPathParam || !restMethod.hasBody())) {
@@ -238,7 +239,7 @@ private void parseParameters() {
     Matcher m = PATH_PARAMETERS.matcher(path);
     Set<String> patterns = new LinkedHashSet<String>();
     while (m.find()) {
-      patterns.add(m.group(1));
+      patterns.add(m.group(1).toLowerCase(Locale.ENGLISH));
     }
     return patterns;
   }
diff --git a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
index 80255d253..f0b8bc5c7 100644
--- a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
@@ -7,6 +7,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import org.junit.Test;
@@ -31,6 +32,10 @@
     expectParams("foo/bar/{taco}/or/{taco}", "taco");
     expectParams("foo/bar/{taco-shell}", "taco-shell");
     expectParams("foo/bar/{taco_shell}", "taco_shell");
+    expectParams("foo/bar/{camelCase}", "camelcase");
+    expectParams("foo/bar/{UPPERCASE}", "uppercase");
+    expectParams("foo/bar/{mixedCase}/or/{MIXEDCASE}", "mixedcase");
+    expectParams("foo/bar/{mixedCase}/or/{MIXEDCASE}", "mixedcase");
   }
 
   private static void expectParams(String path, String... expected) {
@@ -377,6 +382,25 @@ Response a() {
     assertThat(param2.value()).isEqualTo("d");
   }
 
+  @Test public void queryParamCaseSensitivity() {
+      class Example {
+        @GET("/foo")
+        @QueryParam(name = "A", value = "B")
+        Response a() {
+          return null;
+        }
+      }
+
+      Method method = TestingUtils.getMethod(Example.class, "a");
+      RestMethodInfo methodInfo = new RestMethodInfo(method);
+      methodInfo.init();
+
+      assertThat(methodInfo.pathQueryParams).hasSize(1);
+      QueryParam param = methodInfo.pathQueryParams[0];
+      assertThat(param.name()).isEqualTo("A");
+      assertThat(param.value()).isEqualTo("B");
+    }
+
   @Test(expected = IllegalStateException.class)
   public void bothQueryParamAnnotations() {
     class Example {
