diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
new file mode 100644
index 000000000..b2c35b2da
--- /dev/null
+++ b/BUG-BOUNTY.md
@@ -0,0 +1,10 @@
+Serious about security
+======================
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
+
diff --git a/checkstyle.xml b/checkstyle.xml
index 693c0db7f..de5302db0 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -53,7 +53,7 @@
         <module name="LineLength">
             <property name="max" value="100"/>
         </module>
-        <module name="MethodLength"/>
+        <!--<module name="MethodLength"/>-->
         <!--module name="ParameterNumber"/-->
 
 
@@ -92,7 +92,6 @@
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
         <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
         <module name="EmptyStatement"/>
         <module name="EqualsAvoidNull"/>
         <module name="EqualsHashCode"/>
diff --git a/pom.xml b/pom.xml
index 5f43662a0..649318e49 100644
--- a/pom.xml
+++ b/pom.xml
@@ -34,8 +34,9 @@
 
   <modules>
     <module>retrofit</module>
+    <module>retrofit-adapters</module>
     <module>retrofit-converters</module>
-    <module>retrofit-mock</module>
+    <!--<module>retrofit-mock</module>-->
     <module>samples</module>
   </modules>
 
@@ -44,23 +45,26 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
+    <java.version>1.7</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.3.1</gson.version>
-    <okhttp.version>2.2.0</okhttp.version>
-    <rxjava.version>1.0.0</rxjava.version>
+    <okhttp.version>2.5.0-SNAPSHOT</okhttp.version>
+
+    <!-- Adapter Dependencies -->
+    <rxjava.version>1.0.10</rxjava.version>
 
     <!-- Converter Dependencies -->
+    <gson.version>2.3.1</gson.version>
     <protobuf.version>2.5.0</protobuf.version>
     <jackson.version>2.4.3</jackson.version>
-    <wire.version>1.5.2</wire.version>
+    <wire.version>1.7.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
+    <moshi.version>0.9.0</moshi.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.11</junit.version>
+    <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
     <guava.version>18.0</guava.version>
@@ -133,6 +137,11 @@
         <artifactId>simple-xml</artifactId>
         <version>${simplexml.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.squareup.moshi</groupId>
+        <artifactId>moshi</artifactId>
+        <version>${moshi.version}</version>
+      </dependency>
 
       <dependency>
         <groupId>junit</groupId>
@@ -190,7 +199,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
+        <version>2.15</version>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
diff --git a/retrofit-adapters/README.md b/retrofit-adapters/README.md
new file mode 100644
index 000000000..2dd0b7d47
--- /dev/null
+++ b/retrofit-adapters/README.md
@@ -0,0 +1,4 @@
+Retrofit Adapters
+=================
+
+TODO
diff --git a/samples/github-client/pom.xml b/retrofit-adapters/pom.xml
similarity index 56%
rename from samples/github-client/pom.xml
rename to retrofit-adapters/pom.xml
index 123f2ddd9..2b0b0e146 100644
--- a/samples/github-client/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -4,20 +4,17 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.retrofit.samples</groupId>
+    <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
     <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>github-client</artifactId>
-  <name>Sample: GitHub Client</name>
+  <artifactId>retrofit-adapters</artifactId>
+  <name>Adapters</name>
+  <packaging>pom</packaging>
 
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
+  <modules>
+    <module>rxjava</module>
+  </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
new file mode 100644
index 000000000..2a0ac8787
--- /dev/null
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava</artifactId>
+  <name>Adapter: RxJava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
new file mode 100644
index 000000000..b40be0e69
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Action0;
+import rx.functions.Func1;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * TODO docs
+ */
+public final class ObservableCallAdapterFactory implements CallAdapter.Factory {
+  /**
+   * TODO
+   */
+  public static ObservableCallAdapterFactory create() {
+    return new ObservableCallAdapterFactory();
+  }
+
+  private ObservableCallAdapterFactory() {
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName();
+  }
+
+  @Override public CallAdapter<?> get(Type returnType) {
+    if (Utils.getRawType(returnType) != Observable.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Observable return type must be parameterized"
+          + " as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+    Class<?> rawObservableType = Utils.getRawType(observableType);
+
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResponseCallAdapter<>(responseType);
+    }
+
+    if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResultCallAdapter<>(responseType);
+    }
+
+    return new SimpleCallAdapter(observableType);
+  }
+
+  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
+    private final Call<T> originalCall;
+
+    private CallOnSubscribe(Call<T> originalCall) {
+      this.originalCall = originalCall;
+    }
+
+    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
+      // Since Call is a one-shot type, clone it for each new subscriber.
+      final Call<T> call = originalCall.clone();
+
+      // Attempt to cancel the call if it is still in-flight on unsubscription.
+      subscriber.add(Subscriptions.create(new Action0() {
+        @Override public void call() {
+          call.cancel();
+        }
+      }));
+
+      call.enqueue(new Callback<T>() {
+        @Override public void success(Response<T> response) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          try {
+            subscriber.onNext(response);
+          } catch (Throwable t) {
+            subscriber.onError(t);
+            return;
+          }
+          subscriber.onCompleted();
+        }
+
+        @Override public void failure(Throwable t) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          subscriber.onError(t);
+        }
+      });
+    }
+  }
+
+  static final class ResponseCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<Response<T>> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call));
+    }
+  }
+
+  static final class SimpleCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    SimpleCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<T> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .flatMap(new Func1<Response<T>, Observable<T>>() {
+            @Override public Observable<T> call(Response<T> response) {
+              if (response.isSuccess()) {
+                return Observable.just(response.body());
+              }
+              return Observable.error(new IOException()); // TODO non-suck message.
+            }
+          });
+    }
+  }
+
+  static final class ResultCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    ResultCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<Result<T>> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .map(new Func1<Response<T>, Result<T>>() {
+            @Override public Result<T> call(Response<T> response) {
+              return Result.fromResponse(response);
+            }
+          })
+          .onErrorReturn(new Func1<Throwable, Result<T>>() {
+            @Override public Result<T> call(Throwable throwable) {
+              return Result.fromError(throwable);
+            }
+          });
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
new file mode 100644
index 000000000..1302136ce
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+
+import static retrofit.Utils.checkNotNull;
+
+/** The result of executing an HTTP request. */
+public final class Result<T> {
+  static <T> Result<T> fromError(Throwable error) {
+    return new Result<>(null, checkNotNull(error, "error == null"));
+  }
+
+  static <T> Result<T> fromResponse(Response<T> response) {
+    return new Result<>(checkNotNull(response, "response == null"), null);
+  }
+
+  private final Response<T> response;
+  private final Throwable error;
+
+  Result(Response<T> response, Throwable error) {
+    this.response = response;
+    this.error = error;
+  }
+
+  /**
+   * The response received from executing an HTTP request. Only present when {@link #isError()} is
+   * false, null otherwise.
+   */
+  public Response<T> response() {
+    return response;
+  }
+
+  /**
+   * The error experienced while attempting to execute an HTTP request. Only present when {@link
+   * #isError()} is true, null otherwise.
+   * <p>
+   * If the error is an {@link IOException} then there was a problem with the transport to the
+   * remote server. Any other exception type indicates an unexpected failure and should be
+   * considered fatal (configuration error, programming error, etc.).
+   */
+  public Throwable error() {
+    return error;
+  }
+
+  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+  public boolean isError() {
+    return error != null;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
new file mode 100644
index 000000000..b5ef199bf
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.GET;
+import rx.Observable;
+import rx.observables.BlockingObservable;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ObservableCallAdapterFactoryTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface Service {
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new StringConverterFactory())
+        .callAdapterFactory(ObservableCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    assertThat(o.first()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      // TODO assert on some indicator of 404.
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<String> o = service.body().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+
+  @Test public void responseType() {
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    Type classType = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType).responseType()) //
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseType).responseType()).isEqualTo(String.class);
+    Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultType).responseType()).isEqualTo(String.class);
+  }
+
+  @Test public void nonObservableTypeReturnsNull() {
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    CallAdapter<?> adapter = factory.get(String.class);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type type = new TypeToken<Observable>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    try {
+      factory.get(type);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type type = new TypeToken<Observable<Response>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    try {
+      factory.get(type);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type type = new TypeToken<Observable<Result>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
+    try {
+      factory.get(type);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+
+  static class StringConverterFactory implements Converter.Factory {
+    @Override public Converter<?> get(Type type) {
+      return new Converter<String>() {
+        @Override public String fromBody(ResponseBody body) throws IOException {
+          return body.string();
+        }
+
+        @Override public RequestBody toBody(String value) {
+          return RequestBody.create(MediaType.parse("text/plain"), value);
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
new file mode 100644
index 000000000..7bf80ca88
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResultTest {
+  @Test public void response() {
+    Response<String> response = Response.fakeSuccess("Hi");
+    Result<String> result = Result.fromResponse(response);
+    assertThat(result.isError()).isFalse();
+    assertThat(result.error()).isNull();
+    assertThat(result.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      Result.fromResponse(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+
+  @Test public void error() {
+    Throwable error = new IOException();
+    Result<Object> result = Result.fromError(error);
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isSameAs(error);
+    assertThat(result.response()).isNull();
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Result.fromError(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("error == null");
+    }
+  }
+}
diff --git a/retrofit-converters/README.md b/retrofit-converters/README.md
index ec010c032..1e440adef 100644
--- a/retrofit-converters/README.md
+++ b/retrofit-converters/README.md
@@ -4,11 +4,11 @@ Retrofit Converters
 Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
 agnostic. The child modules contained herein are additional converters for other popular formats.
 
-To use, supply an instance of your desired converter when building your `RestAdapter` instance.
+To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint("https://api.example.com")
-    .setConverter(new ProtoConverter())
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.example.com")
+    .converter(new ProtoConverter())
     .build();
 ```
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
new file mode 100644
index 000000000..1568926f2
--- /dev/null
+++ b/retrofit-converters/gson/README.md
@@ -0,0 +1,10 @@
+Gson Converter
+==============
+
+A `Converter` which uses [Gson][1] for serialization to and from JSON.
+
+A default `Gson` instance will be created or one can be configured and passed to the
+`GsonConverter` construction to further control the serialization.
+
+
+ [1]: https://github.com/google/gson
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
new file mode 100644
index 000000000..0cb591ace
--- /dev/null
+++ b/retrofit-converters/gson/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-gson</artifactId>
+  <name>Converter: Gson</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
new file mode 100644
index 000000000..95189be9e
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverter.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.TypeAdapter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.charset.Charset;
+import okio.Buffer;
+
+final class GsonConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private final TypeAdapter<T> typeAdapter;
+
+  GsonConverter(TypeAdapter<T> typeAdapter) {
+    this.typeAdapter = typeAdapter;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    Reader in = body.charStream();
+    try {
+      return typeAdapter.fromJson(in);
+    } finally {
+      try {
+        in.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(T value) {
+    Buffer buffer = new Buffer();
+    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    try {
+      typeAdapter.toJson(writer, value);
+      writer.flush();
+    } catch (IOException e) {
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
new file mode 100644
index 000000000..adc79d39e
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Gson for JSON. */
+public final class GsonConverterFactory implements Converter.Factory {
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create() {
+    return create(new Gson());
+  }
+
+  /**
+   * Create an instance using {@code gson} for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create(Gson gson) {
+    return new GsonConverterFactory(gson);
+  }
+
+  private final Gson gson;
+
+  private GsonConverterFactory(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
+    this.gson = gson;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonConverter<>(adapter);
+  }
+}
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
new file mode 100644
index 000000000..abf65483d
--- /dev/null
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GsonConverterFactoryTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
+    @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @Override public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.peek() != JsonToken.END_OBJECT) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .create();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(GsonConverterFactory.create(gson))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+
+  }
+}
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 06c5a2992..18d0340b4 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
new file mode 100644
index 000000000..d63eeea6f
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverter.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+
+final class JacksonConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private final ObjectWriter writer;
+  private final ObjectReader reader;
+
+  JacksonConverter(ObjectWriter writer, ObjectReader reader) {
+    this.writer = writer;
+    this.reader = reader;
+  }
+
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    InputStream is = body.byteStream();
+    try {
+      return reader.readValue(is);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(T value) {
+    try {
+      byte[] bytes = writer.writeValueAsBytes(value);
+      return RequestBody.create(MEDIA_TYPE, bytes);
+    } catch (JsonProcessingException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
new file mode 100644
index 000000000..8f4efc0e8
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Jackson. */
+public final class JacksonConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
+  public static JacksonConverterFactory create() {
+    return create(new ObjectMapper());
+  }
+
+  /** Create an instance using {@code mapper} for conversion. */
+  public static JacksonConverterFactory create(ObjectMapper mapper) {
+    return new JacksonConverterFactory(mapper);
+  }
+
+  private final ObjectMapper mapper;
+
+  private JacksonConverterFactory(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException("mapper == null");
+    this.mapper = mapper;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectWriter writer = mapper.writerWithType(javaType);
+    ObjectReader reader = mapper.reader(javaType);
+    return new JacksonConverter<>(writer, reader);
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
deleted file mode 100644
index 1b41a536e..000000000
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package retrofit.converter;
-
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Type;
-
-/**
- * A {@link Converter} which uses Jackson for reading and writing entities.
- *
- * @author Kai Waldron (kaiwaldron@gmail.com)
- */
-public class JacksonConverter implements Converter {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-
-  private final ObjectMapper objectMapper;
-
-  public JacksonConverter() {
-    this(new ObjectMapper());
-  }
-
-  public JacksonConverter(ObjectMapper objectMapper) {
-    if (objectMapper == null) throw new NullPointerException("objectMapper == null");
-    this.objectMapper = objectMapper;
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    InputStream is = body.byteStream();
-    try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      return objectMapper.readValue(is, javaType);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
-      return RequestBody.create(MEDIA_TYPE, json);
-    } catch (JsonProcessingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
new file mode 100644
index 000000000..1c4d3f6d2
--- /dev/null
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.annotation.JsonAutoDetect;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.MapperFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class JacksonConverterTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private String theName;
+
+    AnImplementation() {
+    }
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
+    AnInterfaceSerializer() {
+      super(AnInterface.class);
+    }
+
+    @Override public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
+        SerializerProvider serializerProvider) throws IOException {
+      jsonGenerator.writeStartObject();
+      jsonGenerator.writeFieldName("name");
+      jsonGenerator.writeString(anInterface.getName());
+      jsonGenerator.writeEndObject();
+    }
+  }
+
+  static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
+    AnInterfaceDeserializer() {
+      super(AnInterface.class);
+    }
+
+    @Override public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
+        throws IOException {
+      if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
+        throw new AssertionError("Expected start object.");
+      }
+
+      String name = null;
+
+      while (jp.nextToken() != JsonToken.END_OBJECT) {
+        switch (jp.getCurrentName()) {
+          case "name":
+            name = jp.getValueAsString();
+            break;
+        }
+      }
+
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Service service;
+
+  @Before public void setUp() {
+    SimpleModule module = new SimpleModule();
+    module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
+    module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
+    ObjectMapper mapper = new ObjectMapper();
+    mapper.registerModule(module);
+    mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
+    mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
+    mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
+    mapper.setVisibilityChecker(mapper.getSerializationConfig()
+        .getDefaultVisibilityChecker()
+        .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(JacksonConverterFactory.create(mapper))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
deleted file mode 100644
index 4114ba075..000000000
--- a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package retrofit.converter;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.databind.JsonMappingException;
-import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class JacksonConverterTest {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-  private static final MyObject OBJECT = new MyObject("hello world", 10);
-  private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
-
-  private final JacksonConverter converter = new JacksonConverter();
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(OBJECT, MyObject.class);
-    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
-    assertBody(body).isEqualTo(JSON);
-  }
-
-  @Test public void deserialize() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
-    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
-    assertThat(result).isEqualTo(OBJECT);
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
-    try {
-      converter.fromBody(body, MyObject.class);
-    } catch (UnrecognizedPropertyException ignored) {
-    }
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
-    try {
-      converter.fromBody(body, String.class);
-    } catch (JsonMappingException ignored) {
-    }
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readUtf8());
-  }
-
-  static class MyObject {
-    private final String message;
-    private final int count;
-
-    public MyObject(@JsonProperty("message") String message, @JsonProperty("count") int count) {
-      this.message = message;
-      this.count = count;
-    }
-
-    public String getMessage() {
-      return message;
-    }
-
-    public int getCount() {
-      return count;
-    }
-
-    @Override public boolean equals(Object o) {
-      if (this == o) return true;
-      if (o == null || getClass() != o.getClass()) return false;
-
-      MyObject myObject = (MyObject) o;
-      return count == myObject.count
-          && !(message != null ? !message.equals(myObject.message) : myObject.message != null);
-    }
-
-    @Override public int hashCode() {
-      int result = message != null ? message.hashCode() : 0;
-      result = 31 * result + count;
-      return result;
-    }
-  }
-}
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
new file mode 100644
index 000000000..492e42601
--- /dev/null
+++ b/retrofit-converters/moshi/README.md
@@ -0,0 +1,10 @@
+Moshi Converter
+===============
+
+A `Converter` which uses [Moshi][1] for serialization to and from JSON.
+
+A default `Moshi` instance will be created or one can be configured and passed to the
+`MoshiConverter` construction to further control the serialization.
+
+
+ [1]: https://github.com/square/moshi
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
new file mode 100644
index 000000000..627c62b99
--- /dev/null
+++ b/retrofit-converters/moshi/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-moshi</artifactId>
+  <name>Converter: Moshi</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
new file mode 100644
index 000000000..de7c57add
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+
+final class MoshiConverter<T> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private JsonAdapter<T> adapter;
+
+  MoshiConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    BufferedSource source = body.source();
+    try {
+      return adapter.fromJson(source);
+    } finally {
+      try {
+        source.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(T value) {
+    Buffer buffer = new Buffer();
+    try {
+      adapter.toJson(buffer, value);
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
+  }
+}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
new file mode 100644
index 000000000..75506f511
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Moshi for JSON. */
+public final class MoshiConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Moshi} instance for conversion. */
+  public static MoshiConverterFactory create() {
+    return create(new Moshi.Builder().build());
+  }
+
+  /** Create an instance using {@code moshi} for conversion. */
+  public static MoshiConverterFactory create(Moshi moshi) {
+    return new MoshiConverterFactory(moshi);
+  }
+
+  private final Moshi moshi;
+
+  private MoshiConverterFactory(Moshi moshi) {
+    if (moshi == null) throw new NullPointerException("moshi == null");
+    this.moshi = moshi;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    JsonAdapter<Object> adapter = moshi.adapter(type);
+    return new MoshiConverter<>(adapter);
+  }
+}
diff --git a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
new file mode 100644
index 000000000..5b05a5335
--- /dev/null
+++ b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonReader;
+import com.squareup.moshi.JsonWriter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MoshiConverterTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceAdapter {
+    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.hasNext()) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Moshi moshi = new Moshi.Builder()
+        .add(new AnInterfaceAdapter())
+        .build();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(MoshiConverterFactory.create(moshi))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+}
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 9fa974fc9..4fe586b8e 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -15,9 +15,11 @@
   <packaging>pom</packaging>
 
   <modules>
+    <module>gson</module>
     <module>protobuf</module>
     <module>jackson</module>
     <module>wire</module>
     <module>simplexml</module>
+    <module>moshi</module>
   </modules>
 </project>
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index d2808b7ea..c635c4854 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
new file mode 100644
index 000000000..2dcd35ac9
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverter.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+
+final class ProtoConverter<T extends MessageLite> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+
+  private Parser<T> parser;
+
+  ProtoConverter(Parser<T> parser) {
+    this.parser = parser;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    InputStream is = body.byteStream();
+    try {
+      return parser.parseFrom(is);
+    } catch (InvalidProtocolBufferException e) {
+      throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(T value) {
+    byte[] bytes = value.toByteArray();
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
new file mode 100644
index 000000000..bcb9d2640
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} which uses Protocol Buffers. */
+public final class ProtoConverterFactory implements Converter.Factory {
+  public static ProtoConverterFactory create() {
+    return new ProtoConverterFactory();
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class<?>)) {
+      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
+    }
+    Class<?> c = (Class<?>) type;
+    if (!MessageLite.class.isAssignableFrom(c)) {
+      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
+    }
+
+    Parser<MessageLite> parser;
+    try {
+      Field field = c.getDeclaredField("PARSER");
+      //noinspection unchecked
+      parser = (Parser<MessageLite>) field.get(null);
+    } catch (NoSuchFieldException | IllegalAccessException e) {
+      throw new IllegalArgumentException(
+          "Expected a protobuf message but " + c.getName() + " had no PARSER field.");
+    }
+
+    return new ProtoConverter<>(parser);
+  }
+}
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
deleted file mode 100644
index b9270c44e..000000000
--- a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.google.protobuf.AbstractMessageLite;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-
-/** A {@link Converter} that reads and writes protocol buffers. */
-public class ProtoConverter implements Converter {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!AbstractMessageLite.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
-    }
-
-    InputStream is = body.byteStream();
-    try {
-      Method parseFrom = c.getMethod("parseFrom", InputStream.class);
-      return parseFrom.invoke(null, is);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(c.getName() + ".parseFrom() failed", e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof AbstractMessageLite)) {
-      throw new IllegalArgumentException(
-          "Expected a protobuf message but was " + (object != null ? object.getClass().getName()
-              : "null"));
-    }
-    byte[] bytes = ((AbstractMessageLite) object).toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
-}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
similarity index 85%
rename from retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java
rename to retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
index 460f8cc35..1f233452a 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
@@ -1,7 +1,9 @@
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
 // source: protos/phone.proto
 
-package retrofit.converter;
+package retrofit;
+
+import com.google.protobuf.AbstractMessage;
 
 public final class PhoneProtos {
   private PhoneProtos() {}
@@ -96,14 +98,14 @@ private Phone(
     }
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
-      return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+      return PhoneProtos.internal_static_retrofit_Phone_descriptor;
     }
 
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
-      return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+      return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
           .ensureFieldAccessorsInitialized(
-              retrofit.converter.PhoneProtos.Phone.class, retrofit.converter.PhoneProtos.Phone.Builder.class);
+              PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
     }
 
     public static com.google.protobuf.Parser<Phone> PARSER =
@@ -208,53 +210,53 @@ public int getSerializedSize() {
       return super.writeReplace();
     }
 
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(byte[] data)
+    public static PhoneProtos.Phone parseFrom(byte[] data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         byte[] data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+    public static PhoneProtos.Phone parseFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseFrom(input, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+    public static PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseDelimitedFrom(
+    public static PhoneProtos.Phone parseDelimitedFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
@@ -263,7 +265,7 @@ public int getSerializedSize() {
 
     public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(retrofit.converter.PhoneProtos.Phone prototype) {
+    public static Builder newBuilder(PhoneProtos.Phone prototype) {
       return newBuilder().mergeFrom(prototype);
     }
     public Builder toBuilder() { return newBuilder(this); }
@@ -279,20 +281,20 @@ protected Builder newBuilderForType(
      */
     public static final class Builder extends
         com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements retrofit.converter.PhoneProtos.PhoneOrBuilder {
+       implements PhoneProtos.PhoneOrBuilder {
       public static final com.google.protobuf.Descriptors.Descriptor
           getDescriptor() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
       }
 
       protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
           internalGetFieldAccessorTable() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+        return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
             .ensureFieldAccessorsInitialized(
-                retrofit.converter.PhoneProtos.Phone.class, retrofit.converter.PhoneProtos.Phone.Builder.class);
+                PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
       }
 
-      // Construct using retrofit.converter.PhoneProtos.Phone.newBuilder()
+      // Construct using retrofit.PhoneProtos.Phone.newBuilder()
       private Builder() {
         maybeForceBuilderInitialization();
       }
@@ -323,23 +325,23 @@ public Builder clone() {
 
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
       }
 
-      public retrofit.converter.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit.converter.PhoneProtos.Phone.getDefaultInstance();
+      public PhoneProtos.Phone getDefaultInstanceForType() {
+        return PhoneProtos.Phone.getDefaultInstance();
       }
 
-      public retrofit.converter.PhoneProtos.Phone build() {
-        retrofit.converter.PhoneProtos.Phone result = buildPartial();
+      public PhoneProtos.Phone build() {
+        PhoneProtos.Phone result = buildPartial();
         if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
+          throw AbstractMessage.Builder.newUninitializedMessageException(result);
         }
         return result;
       }
 
-      public retrofit.converter.PhoneProtos.Phone buildPartial() {
-        retrofit.converter.PhoneProtos.Phone result = new retrofit.converter.PhoneProtos.Phone(this);
+      public PhoneProtos.Phone buildPartial() {
+        PhoneProtos.Phone result = new PhoneProtos.Phone(this);
         int from_bitField0_ = bitField0_;
         int to_bitField0_ = 0;
         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
@@ -352,16 +354,16 @@ public Builder clone() {
       }
 
       public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit.converter.PhoneProtos.Phone) {
-          return mergeFrom((retrofit.converter.PhoneProtos.Phone)other);
+        if (other instanceof PhoneProtos.Phone) {
+          return mergeFrom((PhoneProtos.Phone)other);
         } else {
           super.mergeFrom(other);
           return this;
         }
       }
 
-      public Builder mergeFrom(retrofit.converter.PhoneProtos.Phone other) {
-        if (other == retrofit.converter.PhoneProtos.Phone.getDefaultInstance()) return this;
+      public Builder mergeFrom(PhoneProtos.Phone other) {
+        if (other == PhoneProtos.Phone.getDefaultInstance()) return this;
         if (other.hasNumber()) {
           bitField0_ |= 0x00000001;
           number_ = other.number_;
@@ -379,11 +381,11 @@ public Builder mergeFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
           throws java.io.IOException {
-        retrofit.converter.PhoneProtos.Phone parsedMessage = null;
+        PhoneProtos.Phone parsedMessage = null;
         try {
           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
         } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit.converter.PhoneProtos.Phone) e.getUnfinishedMessage();
+          parsedMessage = (PhoneProtos.Phone) e.getUnfinishedMessage();
           throw e;
         } finally {
           if (parsedMessage != null) {
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
new file mode 100644
index 000000000..d227110da
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static retrofit.PhoneProtos.Phone;
+
+public final class ProtoConverterTest {
+  interface Service {
+    @GET("/") Call<Phone> get();
+    @POST("/") Call<Phone> post(@Body Phone impl);
+    @GET("/") Call<String> wrongClass();
+    @GET("/") Call<List<String>> wrongType();
+  }
+
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(ProtoConverterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+  }
+
+  @Test public void deserializeEmpty() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call<Phone> call = service.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.hasNumber()).isFalse();
+  }
+
+  @Test public void deserializeWrongClass() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongClass();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
+    }
+  }
+
+  @Test public void deserializeWrongType() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongType();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+    }
+  }
+
+  @Test public void deserializeWrongValue() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("////");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<?> call = service.get();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
+          .hasMessageContaining("input ended unexpectedly");
+    }
+  }
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
deleted file mode 100644
index 99bcc58f5..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.google.protobuf.InvalidProtocolBufferException;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.util.ArrayList;
-import okio.Buffer;
-import okio.ByteString;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static retrofit.converter.PhoneProtos.Phone;
-
-public final class ProtoConverterTest {
-  private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
-  private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
-
-  private final ProtoConverter converter = new ProtoConverter();
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(PROTO, Phone.class);
-    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
-    assertBody(body).isEqualTo(ENCODED_PROTO);
-  }
-
-  @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
-    assertThat(proto).isEqualTo(PROTO);
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
-    }
-  }
-
-  @Test public void deserializeWrongType() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
-    }
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    try {
-      converter.fromBody(protoResponse("////"), Phone.class);
-      fail();
-    } catch (RuntimeException expected) {
-      assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
-    }
-  }
-
-  private static ResponseBody protoResponse(String encodedProto) {
-    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
-        encodedProto).toByteArray());
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readByteString().base64());
-  }
-}
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 63a39a470..918c94570 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,6 +1,6 @@
 package retrofit;
 
-option java_package = "retrofit.converter";
+option java_package = "retrofit";
 option java_outer_classname = "PhoneProtos";
 
 message Phone {
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index 4a83d0a78..1eba174cb 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
new file mode 100644
index 000000000..1170cba00
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import okio.Buffer;
+import org.simpleframework.xml.Serializer;
+
+final class SimpleXmlConverter<T> implements Converter<T> {
+  private static final String CHARSET = "UTF-8";
+  private static final MediaType MEDIA_TYPE =
+      MediaType.parse("application/xml; charset=" + CHARSET);
+
+  private final Class<T> cls;
+  private final Serializer serializer;
+  private final boolean strict;
+
+  SimpleXmlConverter(Class<T> cls, Serializer serializer, boolean strict) {
+    this.cls = cls;
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    InputStream is = body.byteStream();
+    try {
+      T read = serializer.read(cls, is, strict);
+      if (read == null) {
+        throw new IllegalStateException("Could not deserialize body as " + cls);
+      }
+      return read;
+    } catch (RuntimeException | IOException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(T value) {
+    Buffer buffer = new Buffer();
+    try {
+      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+      serializer.write(value, osw);
+      osw.flush();
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
new file mode 100644
index 000000000..8f394c2c4
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+import org.simpleframework.xml.Serializer;
+import org.simpleframework.xml.core.Persister;
+
+/** A {@linkplain Converter.Factory converter} which uses Simple Framework for XML. */
+public final class SimpleXmlConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Persister} instance for conversion. */
+  public static SimpleXmlConverterFactory create() {
+    return create(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for conversion. */
+  public static SimpleXmlConverterFactory create(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, true);
+  }
+
+  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict() {
+    return createNonStrict(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, false);
+  }
+
+  private final Serializer serializer;
+  private final boolean strict;
+
+  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+    if (serializer == null) throw new NullPointerException("serializer == null");
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  public boolean isStrict() {
+    return strict;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class)) {
+      throw new IllegalArgumentException("Expected a raw class but was " + type);
+    }
+    Class<?> cls = (Class<?>) type;
+    return new SimpleXmlConverter<>(cls, serializer, strict);
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
deleted file mode 100644
index 4d757a555..000000000
--- a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStreamWriter;
-import java.lang.reflect.Type;
-import okio.Buffer;
-import org.simpleframework.xml.Serializer;
-import org.simpleframework.xml.core.Persister;
-
-/**
- * A {@link Converter} which uses SimpleXML for reading and writing entities.
- *
- * @author Fabien Ric (fabien.ric@gmail.com)
- */
-public class SimpleXMLConverter implements Converter {
-  private static final boolean DEFAULT_STRICT = true;
-  private static final String CHARSET = "UTF-8";
-  private static final MediaType MEDIA_TYPE =
-      MediaType.parse("application/xml; charset=" + CHARSET);
-
-  private final Serializer serializer;
-
-  private final boolean strict;
-
-  public SimpleXMLConverter() {
-    this(DEFAULT_STRICT);
-  }
-
-  public SimpleXMLConverter(boolean strict) {
-    this(new Persister(), strict);
-  }
-
-  public SimpleXMLConverter(Serializer serializer) {
-    this(serializer, DEFAULT_STRICT);
-  }
-
-  public SimpleXMLConverter(Serializer serializer, boolean strict) {
-    this.serializer = serializer;
-    this.strict = strict;
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    InputStream is = body.byteStream();
-    try {
-      return serializer.read((Class<?>) type, is, strict);
-    } catch (IOException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object source, Type type) {
-    byte[] bytes;
-    try {
-      Buffer buffer = new Buffer();
-      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(source, osw);
-      osw.flush();
-      bytes = buffer.readByteArray();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
-
-  public boolean isStrict() {
-    return strict;
-  }
-}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java
new file mode 100644
index 000000000..398854c19
--- /dev/null
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import org.simpleframework.xml.Element;
+
+@Default(value = DefaultType.FIELD)
+final class MyObject {
+  @Element private String message;
+  @Element private int count;
+
+  public MyObject() {
+  }
+
+  public MyObject(String message, int count) {
+    this.message = message;
+    this.count = count;
+  }
+
+  public void setMessage(String message) {
+    this.message = message;
+  }
+
+  public String getMessage() {
+    return message;
+  }
+
+  public void setCount(int count) {
+    this.count = count;
+  }
+
+  public int getCount() {
+    return count;
+  }
+
+  @Override public int hashCode() {
+    int result = 1;
+    result = result * 31 + count;
+    result = result * 31 + (message == null ? 0 : message.hashCode());
+    return result;
+  }
+
+  @Override public boolean equals(Object obj) {
+    if (obj == this) return true;
+    if (!(obj instanceof MyObject)) return false;
+    MyObject other = (MyObject) obj;
+    return count == other.count
+        && (message == null ? other.message == null : message.equals(other.message));
+  }
+}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
new file mode 100644
index 000000000..35d2b120a
--- /dev/null
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.simpleframework.xml.core.ElementException;
+import org.simpleframework.xml.core.Persister;
+import org.simpleframework.xml.stream.Format;
+import org.simpleframework.xml.stream.HyphenStyle;
+import org.simpleframework.xml.stream.Verbosity;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class SimpleXmlConverterTest {
+  interface Service {
+    @GET("/") Call<MyObject> get();
+    @POST("/") Call<MyObject> post(@Body MyObject impl);
+    @GET("/") Call<String> wrongClass();
+  }
+
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+    Persister persister = new Persister(format);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(SimpleXmlConverterFactory.create(persister))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyWays() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody(
+        "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+    Call<MyObject> call = service.post(new MyObject("hello world", 10));
+    Response<MyObject> response = call.execute();
+    MyObject body = response.body();
+    assertThat(body.getMessage()).isEqualTo("hello world");
+    assertThat(body.getCount()).isEqualTo(10);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo(
+        "<my-object><message>hello world</message><count>10</count></my-object>");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
+  }
+
+  @Test public void deserializeWrongValue() throws IOException {
+    server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
+
+    Call<?> call = service.get();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(ElementException.class)
+          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit.MyObject");
+    }
+  }
+
+  @Test public void deserializeWrongClass() throws IOException {
+    server.enqueue(new MockResponse().setBody(
+        "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+    Call<?> call = service.wrongClass();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+    }
+  }
+}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
deleted file mode 100644
index 3c34b55f4..000000000
--- a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Before;
-import org.junit.Test;
-import org.simpleframework.xml.Default;
-import org.simpleframework.xml.DefaultType;
-import org.simpleframework.xml.Element;
-import org.simpleframework.xml.core.Persister;
-import org.simpleframework.xml.stream.Format;
-import org.simpleframework.xml.stream.HyphenStyle;
-import org.simpleframework.xml.stream.Verbosity;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class SimpleXMLConverterTest {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
-  private static final MyObject OBJ = new MyObject("hello world", 10);
-  private static final String XML =
-      "<my-object><message>hello world</message><count>10</count></my-object>";
-
-  private Converter converter;
-
-  @Before public void setUp() {
-    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
-    Persister persister = new Persister(format);
-    converter = new SimpleXMLConverter(persister);
-  }
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(OBJ, MyObject.class);
-    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
-    assertBody(body).isEqualTo(XML);
-  }
-
-  @Test public void deserialize() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
-    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
-    assertThat(result).isEqualTo(OBJ);
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
-    try {
-      converter.fromBody(body, MyObject.class);
-    } catch (RuntimeException ignored) {
-    }
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
-    Object result = converter.fromBody(body, String.class);
-    assertThat(result).isNull();
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
-      throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readUtf8());
-  }
-
-  @Default(value = DefaultType.FIELD) static class MyObject {
-    @Element private String message;
-    @Element private int count;
-
-    public MyObject() {
-    }
-
-    public MyObject(String message, int count) {
-      this.message = message;
-      this.count = count;
-    }
-
-    public void setMessage(String message) {
-      this.message = message;
-    }
-
-    public String getMessage() {
-      return message;
-    }
-
-    public void setCount(int count) {
-      this.count = count;
-    }
-
-    public int getCount() {
-      return count;
-    }
-
-    @Override public int hashCode() {
-      final int prime = 31;
-      int result = 1;
-      result = prime * result + count;
-      result = prime * result + ((message == null) ? 0 : message.hashCode());
-      return result;
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null) {
-        return false;
-      }
-      if (getClass() != obj.getClass()) {
-        return false;
-      }
-      MyObject other = (MyObject) obj;
-      if (count != other.count) {
-        return false;
-      }
-      if (message == null) {
-        if (other.message != null) {
-          return false;
-        }
-      } else if (!message.equals(other.message)) {
-        return false;
-      }
-      return true;
-    }
-  }
-}
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index f56ef5fcb..d2bf06f14 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -26,6 +26,13 @@
     <dependency>
       <groupId>com.squareup.wire</groupId>
       <artifactId>wire-runtime</artifactId>
+      <exclusions>
+        <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
+        <exclusion>
+          <groupId>com.squareup.okio</groupId>
+          <artifactId>okio</artifactId>
+        </exclusion>
+      </exclusions>
     </dependency>
 
     <dependency>
@@ -34,13 +41,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
new file mode 100644
index 000000000..c2a997f64
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.io.IOException;
+import java.io.InputStream;
+
+final class WireConverter<T extends Message> implements Converter<T> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+
+  private final Wire wire;
+  private final Class<T> cls;
+
+  public WireConverter(Wire wire, Class<T> cls) {
+    this.wire = wire;
+    this.cls = cls;
+  }
+
+  @Override public T fromBody(ResponseBody body) throws IOException {
+    InputStream in = body.byteStream();
+    try {
+      return wire.parseFrom(in, cls);
+    } finally {
+      try {
+        in.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
+  @Override public RequestBody toBody(T value) {
+    byte[] bytes = value.toByteArray();
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
new file mode 100644
index 000000000..135e50d61
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.lang.reflect.Type;
+
+/** A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers. */
+public final class WireConverterFactory implements Converter.Factory {
+  /** Create an instance using a default {@link Wire} instance for conversion. */
+  public static WireConverterFactory create() {
+    return create(new Wire());
+  }
+
+  /** Create an instance using {@code wire} for conversion. */
+  public static WireConverterFactory create(Wire wire) {
+    return new WireConverterFactory(wire);
+  }
+
+  private final Wire wire;
+
+  /** Create a converter using the supplied {@link Wire} instance. */
+  private WireConverterFactory(Wire wire) {
+    if (wire == null) throw new NullPointerException("wire == null");
+    this.wire = wire;
+  }
+
+  @Override public Converter<?> get(Type type) {
+    if (!(type instanceof Class<?>)) {
+      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
+    }
+    Class<?> c = (Class<?>) type;
+    if (!Message.class.isAssignableFrom(c)) {
+      throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
+    }
+    //noinspection unchecked
+    return new WireConverter<>(wire, (Class<Message>) c);
+  }
+}
diff --git a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
deleted file mode 100644
index e44c50615..000000000
--- a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Type;
-
-/** A {@link Converter} that reads and writes protocol buffers using Wire. */
-public class WireConverter implements Converter {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
-
-  private final Wire wire;
-
-  /** Create a converter with a default {@link Wire} instance. */
-  public WireConverter() {
-    this(new Wire());
-  }
-
-  /** Create a converter using the supplied {@link Wire} instance. */
-  public WireConverter(Wire wire) {
-    if (wire == null) throw new NullPointerException("wire == null");
-    this.wire = wire;
-  }
-
-  @SuppressWarnings("unchecked") //
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
-    }
-
-    InputStream in = body.byteStream();
-    try {
-      return wire.parseFrom(in, (Class<Message>) c);
-    } finally {
-      try {
-        in.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof Message)) {
-      throw new IllegalArgumentException(
-          "Expected a proto message but was " + (object != null ? object.getClass().getName()
-              : "null"));
-    }
-    byte[] bytes = ((Message) object).toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
-}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/Phone.java b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
new file mode 100644
index 000000000..e8a47989d
--- /dev/null
+++ b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
@@ -0,0 +1,69 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/person.proto
+package retrofit;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.OPTIONAL;
+
+public final class Phone extends Message {
+
+  public static final String DEFAULT_PHONE = "";
+
+  @ProtoField(tag = 1, type = STRING, label = OPTIONAL)
+  public final String number;
+
+  public Phone(String number) {
+    this.number = number;
+  }
+
+  private Phone(Builder builder) {
+    this(builder.number);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof Phone)) return false;
+    Phone o = (Phone) other;
+    return equals(number, o.number);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = number != null ? number.hashCode() : 0;
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<Phone> {
+
+    public String number;
+
+    public Builder() {
+    }
+
+    public Builder(Phone message) {
+      super(message);
+      if (message == null) return;
+      this.number = message.number;
+    }
+
+    public Builder number(String name) {
+      this.number = name;
+      return this;
+    }
+
+    @Override
+    public Phone build() {
+      checkRequiredFields();
+      return new Phone(this);
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
new file mode 100644
index 000000000..959cf4956
--- /dev/null
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class WireConverterTest {
+  interface Service {
+    @GET("/") Call<Phone> get();
+    @POST("/") Call<Phone> post(@Body Phone impl);
+    @GET("/") Call<String> wrongClass();
+    @GET("/") Call<List<String>> wrongType();
+  }
+
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(WireConverterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = service.post(new Phone("(519) 867-5309"));
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.number).isEqualTo("(519) 867-5309");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+  }
+
+  @Test public void deserializeEmpty() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call<Phone> call = service.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.number).isNull();
+  }
+
+  @Test public void deserializeWrongClass() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongClass();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
+    }
+  }
+
+  @Test public void deserializeWrongType() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongType();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+    }
+  }
+
+  @Test public void deserializeWrongValue() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("////");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<?> call = service.get();
+    try {
+      call.execute();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java b/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
deleted file mode 100644
index efffba3cb..000000000
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
+++ /dev/null
@@ -1,248 +0,0 @@
-// Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: ../wire-runtime/src/test/proto/person.proto
-package retrofit.converter;
-
-import com.squareup.wire.Message;
-import com.squareup.wire.ProtoEnum;
-import com.squareup.wire.ProtoField;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.wire.Message.Datatype.ENUM;
-import static com.squareup.wire.Message.Datatype.INT32;
-import static com.squareup.wire.Message.Datatype.STRING;
-import static com.squareup.wire.Message.Label.REPEATED;
-import static com.squareup.wire.Message.Label.REQUIRED;
-
-public final class Person extends Message {
-
-  public static final String DEFAULT_NAME = "";
-  public static final Integer DEFAULT_ID = 0;
-  public static final String DEFAULT_EMAIL = "";
-  public static final List<PhoneNumber> DEFAULT_PHONE = Collections.emptyList();
-
-  /**
-   * The customer's full name.
-   */
-  @ProtoField(tag = 1, type = STRING, label = REQUIRED)
-  public final String name;
-
-  /**
-   * The customer's ID number.
-   */
-  @ProtoField(tag = 2, type = INT32, label = REQUIRED)
-  public final Integer id;
-
-  /**
-   * Email address for the customer.
-   */
-  @ProtoField(tag = 3, type = STRING)
-  public final String email;
-
-  /**
-   * A list of the customer's phone numbers.
-   */
-  @ProtoField(tag = 4, label = REPEATED)
-  public final List<PhoneNumber> phone;
-
-  public Person(String name, Integer id, String email, List<PhoneNumber> phone) {
-    this.name = name;
-    this.id = id;
-    this.email = email;
-    this.phone = immutableCopyOf(phone);
-  }
-
-  private Person(Builder builder) {
-    this(builder.name, builder.id, builder.email, builder.phone);
-    setBuilder(builder);
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) return true;
-    if (!(other instanceof Person)) return false;
-    Person o = (Person) other;
-    return equals(name, o.name)
-        && equals(id, o.id)
-        && equals(email, o.email)
-        && equals(phone, o.phone);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = hashCode;
-    if (result == 0) {
-      result = name != null ? name.hashCode() : 0;
-      result = result * 37 + (id != null ? id.hashCode() : 0);
-      result = result * 37 + (email != null ? email.hashCode() : 0);
-      result = result * 37 + (phone != null ? phone.hashCode() : 1);
-      hashCode = result;
-    }
-    return result;
-  }
-
-  public static final class Builder extends Message.Builder<Person> {
-
-    public String name;
-    public Integer id;
-    public String email;
-    public List<PhoneNumber> phone;
-
-    public Builder() {
-    }
-
-    public Builder(Person message) {
-      super(message);
-      if (message == null) return;
-      this.name = message.name;
-      this.id = message.id;
-      this.email = message.email;
-      this.phone = copyOf(message.phone);
-    }
-
-    /**
-     * The customer's full name.
-     */
-    public Builder name(String name) {
-      this.name = name;
-      return this;
-    }
-
-    /**
-     * The customer's ID number.
-     */
-    public Builder id(Integer id) {
-      this.id = id;
-      return this;
-    }
-
-    /**
-     * Email address for the customer.
-     */
-    public Builder email(String email) {
-      this.email = email;
-      return this;
-    }
-
-    /**
-     * A list of the customer's phone numbers.
-     */
-    public Builder phone(List<PhoneNumber> phone) {
-      this.phone = checkForNulls(phone);
-      return this;
-    }
-
-    @Override
-    public Person build() {
-      checkRequiredFields();
-      return new Person(this);
-    }
-  }
-
-  public enum PhoneType
-      implements ProtoEnum {
-    MOBILE(0),
-    HOME(1),
-    /**
-     * Could be phone or fax.
-     */
-    WORK(2);
-
-    private final int value;
-
-    private PhoneType(int value) {
-      this.value = value;
-    }
-
-    @Override
-    public int getValue() {
-      return value;
-    }
-  }
-
-  public static final class PhoneNumber extends Message {
-
-    public static final String DEFAULT_NUMBER = "";
-    public static final PhoneType DEFAULT_TYPE = PhoneType.HOME;
-
-    /**
-     * The customer's phone number.
-     */
-    @ProtoField(tag = 1, type = STRING, label = REQUIRED)
-    public final String number;
-
-    /**
-     * The type of phone stored here.
-     */
-    @ProtoField(tag = 2, type = ENUM)
-    public final PhoneType type;
-
-    public PhoneNumber(String number, PhoneType type) {
-      this.number = number;
-      this.type = type;
-    }
-
-    private PhoneNumber(Builder builder) {
-      this(builder.number, builder.type);
-      setBuilder(builder);
-    }
-
-    @Override
-    public boolean equals(Object other) {
-      if (other == this) return true;
-      if (!(other instanceof PhoneNumber)) return false;
-      PhoneNumber o = (PhoneNumber) other;
-      return equals(number, o.number)
-          && equals(type, o.type);
-    }
-
-    @Override
-    public int hashCode() {
-      int result = hashCode;
-      if (result == 0) {
-        result = number != null ? number.hashCode() : 0;
-        result = result * 37 + (type != null ? type.hashCode() : 0);
-        hashCode = result;
-      }
-      return result;
-    }
-
-    public static final class Builder extends Message.Builder<PhoneNumber> {
-
-      public String number;
-      public PhoneType type;
-
-      public Builder() {
-      }
-
-      public Builder(PhoneNumber message) {
-        super(message);
-        if (message == null) return;
-        this.number = message.number;
-        this.type = message.type;
-      }
-
-      /**
-       * The customer's phone number.
-       */
-      public Builder number(String number) {
-        this.number = number;
-        return this;
-      }
-
-      /**
-       * The type of phone stored here.
-       */
-      public Builder type(PhoneType type) {
-        this.type = type;
-        return this;
-      }
-
-      @Override
-      public PhoneNumber build() {
-        checkRequiredFields();
-        return new PhoneNumber(this);
-      }
-    }
-  }
-}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
deleted file mode 100644
index cc719fcbb..000000000
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.util.ArrayList;
-import okio.Buffer;
-import okio.ByteString;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WireConverterTest {
-  private static final Person PROTO =
-      new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
-  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
-
-  private final WireConverter converter = new WireConverter();
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(PROTO, Person.class);
-    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
-    assertBody(body).isEqualTo(ENCODED_PROTO);
-  }
-
-  @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
-    assertThat(proto).isEqualTo(PROTO);
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
-    }
-  }
-
-  @Test public void deserializeWrongType() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO),
-          ArrayList.class.getGenericSuperclass());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
-    }
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    try {
-      converter.fromBody(protoResponse("////"), Person.class);
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  private static ResponseBody protoResponse(String encodedProto) {
-    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
-        ByteString.decodeBase64(encodedProto).toByteArray());
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readByteString().base64());
-  }
-}
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index d7f00edc5..83c3a836e 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -20,18 +20,6 @@
       <version>${project.version}</version>
     </dependency>
 
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
-
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
-      <optional>true</optional>
-    </dependency>
-
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
index 390bb9b01..34eaea450 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpException.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
@@ -18,7 +18,7 @@
 /**
  * An exception used to trigger the simulation of an HTTP error for mock services.
  *
- * @see MockRestAdapter
+ * @see MockRetrofit
  */
 public class MockHttpException extends RuntimeException {
   /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
deleted file mode 100644
index 93112f6d1..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import java.lang.reflect.Type;
-
-class MockHttpRetrofitError extends RetrofitError {
-  private final Object body;
-
-  MockHttpRetrofitError(String message, String url, Response response, Object body,
-      Type responseType) {
-    super(message, url, response, null, responseType, Kind.HTTP, null);
-    this.body = body;
-  }
-
-  @Override public Object getBody() {
-    return body;
-  }
-
-  @Override public Object getBodyAs(Type type) {
-    return body;
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
index a5bbb9fa4..c06a7653a 100644
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
@@ -8,14 +8,9 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
-import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import rx.Observable;
-import rx.Scheduler;
-import rx.functions.Func1;
-import rx.schedulers.Schedulers;
 
 import static retrofit.RetrofitError.unexpectedError;
 
@@ -43,7 +38,7 @@
  * </pre>
  * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
  * <pre>
- *   MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+ *   MockRetrofit mockRetrofit = MockRetrofit.from(restAdapter);
  * </pre>
  * Instances of this class should be used as a singleton so that the behavior of every mock service
  * is consistent.
@@ -51,7 +46,7 @@
  * Rather than using the {@code MockUserService} directly, pass it through
  * {@link #create(Class, Object) the create method}.
  * <pre>
- *   UserService service = mockRestAdapter.create(UserService.class, new MockUserService());
+ *   UserService service = mockRetrofit.create(UserService.class, new MockUserService());
  * </pre>
  * The returned {@code UserService} instance will now behave like it is happening over the network
  * while allowing the mock implementation to be written synchronously.
@@ -60,54 +55,33 @@
  * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
  * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
  */
-public final class MockRestAdapter {
+public final class MockRetrofit {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by ±40%.
   private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
   private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
 
   /**
-   * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
+   * Create a new {@link MockRetrofit} which will act as a factory for mock services. Some of
    * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
    */
-  public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
-    return new MockRestAdapter(restAdapter, executor);
-  }
-
-  /** A listener invoked when the network behavior values for a {@link MockRestAdapter} change. */
-  public interface ValueChangeListener {
-    void onMockValuesChanged(long delayMs, int variancePct, int errorPct);
-
-    ValueChangeListener EMPTY = new ValueChangeListener() {
-      @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
-      }
-    };
+  public static MockRetrofit from(RestAdapter restAdapter, Executor executor) {
+    return new MockRetrofit(restAdapter, executor);
   }
 
   private final RestAdapter restAdapter;
   private final Executor executor;
-  private MockRxSupport mockRxSupport;
   final Random random = new Random();
 
-  private ValueChangeListener listener = ValueChangeListener.EMPTY;
   private int delayMs = DEFAULT_DELAY_MS;
   private int variancePct = DEFAULT_VARIANCE_PCT;
   private int errorPct = DEFAULT_ERROR_PCT;
 
-  private MockRestAdapter(RestAdapter restAdapter, Executor executor) {
+  private MockRetrofit(RestAdapter restAdapter, Executor executor) {
     this.restAdapter = restAdapter;
     this.executor = executor;
   }
 
-  /** Set a listener to be notified when any mock value changes. */
-  public void setValueChangeListener(ValueChangeListener listener) {
-    this.listener = listener;
-  }
-
-  private void notifyValueChangeListener() {
-    listener.onMockValuesChanged(delayMs, variancePct, errorPct);
-  }
-
   /** Set the network round trip delay, in milliseconds. */
   public void setDelay(long delayMs) {
     if (delayMs < 0) {
@@ -116,10 +90,7 @@ public void setDelay(long delayMs) {
     if (delayMs > Integer.MAX_VALUE) {
       throw new IllegalArgumentException("Delay value too large. Max: " + Integer.MAX_VALUE);
     }
-    if (this.delayMs != delayMs) {
-      this.delayMs = (int) delayMs;
-      notifyValueChangeListener();
-    }
+    this.delayMs = (int) delayMs;
   }
 
   /** The network round trip delay, in milliseconds */
@@ -132,10 +103,7 @@ public void setVariancePercentage(int variancePct) {
     if (variancePct < 0 || variancePct > 100) {
       throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
     }
-    if (this.variancePct != variancePct) {
-      this.variancePct = variancePct;
-      notifyValueChangeListener();
-    }
+    this.variancePct = variancePct;
   }
 
   /** The plus-or-minus variance percentage of the network round trip delay. */
@@ -148,10 +116,7 @@ public void setErrorPercentage(int errorPct) {
     if (errorPct < 0 || errorPct > 100) {
       throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
     }
-    if (this.errorPct != errorPct) {
-      this.errorPct = errorPct;
-      notifyValueChangeListener();
-    }
+    this.errorPct = errorPct;
   }
 
   /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
@@ -182,6 +147,8 @@ public boolean calculateIsFailure() {
    * using {@link #create(Class, Object)}.
    */
   public int calculateDelayForError() {
+    if (delayMs == 0) return 0;
+
     return random.nextInt(delayMs * ERROR_DELAY_FACTOR);
   }
 
@@ -213,16 +180,14 @@ public int calculateDelayForCall() {
   public <T> T create(Class<T> service, T mockService) {
     Utils.validateServiceClass(service);
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new MockHandler(mockService, restAdapter.getMethodInfoCache(service)));
+        new MockHandler(service, mockService));
   }
 
   private class MockHandler implements InvocationHandler {
     private final Object mockService;
-    private final Map<Method, MethodInfo> methodInfoCache;
 
-    public MockHandler(Object mockService, Map<Method, MethodInfo> methodInfoCache) {
+    public MockHandler(Object mockService, T service) {
       this.mockService = mockService;
-      this.methodInfoCache = methodInfoCache;
     }
 
     @Override public Object invoke(Object proxy, Method method, final Object[] args)
@@ -234,7 +199,7 @@ public MockHandler(Object mockService, Map<Method, MethodInfo> methodInfoCache)
 
       // Load or create the details cache for the current method.
       final MethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
-      final Request request = buildRequest(methodInfo, restAdapter.requestInterceptor, args);
+      final Request request = buildRequest(methodInfo, args);
 
       if (methodInfo.executionType == MethodInfo.ExecutionType.SYNC) {
         try {
@@ -249,17 +214,6 @@ public MockHandler(Object mockService, Map<Method, MethodInfo> methodInfoCache)
         }
       }
 
-      if (methodInfo.executionType == MethodInfo.ExecutionType.RX) {
-        if (mockRxSupport == null) {
-          if (Platform.HAS_RX_JAVA) {
-            mockRxSupport = new MockRxSupport(restAdapter, executor);
-          } else {
-            throw new IllegalStateException("Observable method found but no RxJava on classpath");
-          }
-        }
-        return mockRxSupport.createMockObservable(this, methodInfo, args, request);
-      }
-
       executor.execute(new Runnable() {
         @Override public void run() {
           invokeAsync(methodInfo, args, request);
@@ -268,16 +222,11 @@ public MockHandler(Object mockService, Map<Method, MethodInfo> methodInfoCache)
       return null; // Asynchronous methods should have return type of void.
     }
 
-    private Request buildRequest(MethodInfo methodInfo, RequestInterceptor interceptor,
-        Object[] args) throws Throwable {
+    private Request buildRequest(MethodInfo methodInfo, Object[] args) throws Throwable {
       // Begin building a normal request.
-      String apiUrl = restAdapter.endpoint.url();
+      String apiUrl = restAdapter.baseUrl.url();
       RequestBuilder requestBuilder = new RequestBuilder(apiUrl, methodInfo, restAdapter.converter);
       requestBuilder.setArguments(args);
-
-      // Run it through the interceptor.
-      interceptor.intercept(requestBuilder);
-
       return requestBuilder.build();
     }
 
@@ -314,7 +263,7 @@ private Object invokeSync(MethodInfo methodInfo, Object[] args, Request request)
         sleep(callDelay - tookMs);
 
         throw new MockHttpRetrofitError(httpEx.reason, url, response, httpEx.responseBody,
-            methodInfo.responseObjectType);
+            methodInfo.responseType);
       }
     }
 
@@ -357,7 +306,7 @@ private void invokeAsync(final MethodInfo methodInfo, final Object[] args,
             Response response = httpEx.toResponse(request, restAdapter.converter);
 
             RetrofitError error = new MockHttpRetrofitError(httpEx.getMessage(), url, response,
-                httpEx.responseBody, methodInfo.responseObjectType);
+                httpEx.responseBody, methodInfo.responseType);
             Throwable cause = restAdapter.errorHandler.handleError(error);
             final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
             callback.failure(e);
@@ -401,31 +350,4 @@ private static void sleep(long ms) {
   private static long uptimeMillis() {
     return System.nanoTime() / 1000000L;
   }
-
-  /** Indirection to avoid VerifyError if RxJava isn't present. */
-  private static class MockRxSupport {
-    private final Scheduler httpScheduler;
-    private final ErrorHandler errorHandler;
-
-    MockRxSupport(RestAdapter restAdapter, Executor executor) {
-      httpScheduler = Schedulers.from(executor);
-      errorHandler = restAdapter.errorHandler;
-    }
-
-    Observable createMockObservable(final MockHandler mockHandler, final MethodInfo methodInfo,
-        final Object[] args, final Request request) {
-      return Observable.just("nothing") //
-          .flatMap(new Func1<String, Observable<?>>() {
-            @Override public Observable<?> call(String s) {
-              try {
-                return (Observable) mockHandler.invokeSync(methodInfo, args, request);
-              } catch (RetrofitError e) {
-                return Observable.error(errorHandler.handleError(e));
-              } catch (Throwable throwable) {
-                return Observable.error(throwable);
-              }
-            }
-          }).subscribeOn(httpScheduler);
-    }
-  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java b/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
deleted file mode 100644
index 80cab9abc..000000000
--- a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.android;
-
-import android.content.SharedPreferences;
-import retrofit.MockRestAdapter;
-
-/**
- * A {@link MockRestAdapter.ValueChangeListener value change listener} for {@link MockRestAdapter}
- * which stores any customized behavior values into shared preferences.
- */
-public final class AndroidMockValuePersistence implements MockRestAdapter.ValueChangeListener {
-  private static final String KEY_DELAY = "retrofit-mock-delay";
-  private static final String KEY_VARIANCE = "retrofit-mock-variance";
-  private static final String KEY_ERROR = "retrofit-mock-error";
-
-  /**
-   * Install a {@link MockRestAdapter.ValueChangeListener value change listener} on the supplied
-   * {@link MockRestAdapter} using the {@link SharedPreferences} for storing customized behavior
-   * values. Invoking this will load any existing stored values for the mock adapter's behavior.
-   */
-  public static void install(MockRestAdapter mockRestAdapter, SharedPreferences preferences) {
-    long delay = preferences.getLong(KEY_DELAY, -1);
-    if (delay != -1) {
-      mockRestAdapter.setDelay(delay);
-    }
-
-    int variance = preferences.getInt(KEY_VARIANCE, -1);
-    if (variance != -1) {
-      mockRestAdapter.setVariancePercentage(variance);
-    }
-
-    int error = preferences.getInt(KEY_ERROR, -1);
-    if (error != -1) {
-      mockRestAdapter.setErrorPercentage(error);
-    }
-
-    mockRestAdapter.setValueChangeListener(new AndroidMockValuePersistence(preferences));
-  }
-
-  private final SharedPreferences preferences;
-
-  private AndroidMockValuePersistence(SharedPreferences preferences) {
-    this.preferences = preferences;
-  }
-
-  @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
-    preferences.edit()
-        .putLong(KEY_DELAY, delayMs)
-        .putInt(KEY_VARIANCE, variancePct)
-        .putInt(KEY_ERROR, errorPct)
-        .apply();
-  }
-}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
index d187b7895..6b0b7ad9f 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
@@ -25,10 +25,9 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
-import static retrofit.MockRestAdapter.ValueChangeListener;
 import static retrofit.Utils.SynchronousExecutor;
 
-public class MockRestAdapterTest {
+public class MockRetrofitTest {
   interface SyncExample {
     @GET("/") Object doStuff();
   }
@@ -49,8 +48,7 @@
 
   private Executor httpExecutor;
   private Executor callbackExecutor;
-  private MockRestAdapter mockRestAdapter;
-  private ValueChangeListener valueChangeListener;
+  private MockRetrofit mockRetrofit;
   private Throwable nextError;
 
   @Before public void setUp() throws IOException {
@@ -58,9 +56,9 @@
     callbackExecutor = spy(new SynchronousExecutor());
 
     RestAdapter restAdapter = new RestAdapter.Builder() //
-        .setCallbackExecutor(callbackExecutor)
-        .setEndpoint("none")
-        .setErrorHandler(new ErrorHandler() {
+        .callbackExecutor(callbackExecutor)
+        .baseUrl("http://example.com")
+        .errorHandler(new ErrorHandler() {
           @Override public Throwable handleError(RetrofitError cause) {
             if (nextError != null) {
               Throwable error = nextError;
@@ -72,24 +70,21 @@
         })
         .build();
 
-    valueChangeListener = mock(ValueChangeListener.class);
-
-    mockRestAdapter = MockRestAdapter.from(restAdapter, httpExecutor);
-    mockRestAdapter.setValueChangeListener(valueChangeListener);
+    mockRetrofit = MockRetrofit.from(restAdapter, httpExecutor);
 
     // Seed the random with a value so the tests are deterministic.
-    mockRestAdapter.random.setSeed(2847);
+    mockRetrofit.random.setSeed(2847);
   }
 
   @Test public void delayRestrictsRange() {
     try {
-      mockRestAdapter.setDelay(-1);
+      mockRetrofit.setDelay(-1);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Delay must be positive value.");
     }
     try {
-      mockRestAdapter.setDelay(Long.MAX_VALUE);
+      mockRetrofit.setDelay(Long.MAX_VALUE);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageStartingWith("Delay value too large.");
@@ -98,13 +93,13 @@
 
   @Test public void varianceRestrictsRange() {
     try {
-      mockRestAdapter.setVariancePercentage(-13);
+      mockRetrofit.setVariancePercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
     }
     try {
-      mockRestAdapter.setVariancePercentage(174);
+      mockRetrofit.setVariancePercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
@@ -113,13 +108,13 @@
 
   @Test public void errorRestrictsRange() {
     try {
-      mockRestAdapter.setErrorPercentage(-13);
+      mockRetrofit.setErrorPercentage(-13);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
     }
     try {
-      mockRestAdapter.setErrorPercentage(174);
+      mockRetrofit.setErrorPercentage(174);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
@@ -127,15 +122,15 @@
   }
 
   @Test public void errorPercentageIsAccurate() {
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setErrorPercentage(0);
     for (int i = 0; i < 10000; i++) {
-      assertThat(mockRestAdapter.calculateIsFailure()).isFalse();
+      assertThat(mockRetrofit.calculateIsFailure()).isFalse();
     }
 
-    mockRestAdapter.setErrorPercentage(3);
+    mockRetrofit.setErrorPercentage(3);
     int failures = 0;
     for (int i = 0; i < 100000; i++) {
-      if (mockRestAdapter.calculateIsFailure()) {
+      if (mockRetrofit.calculateIsFailure()) {
         failures += 1;
       }
     }
@@ -143,18 +138,18 @@
   }
 
   @Test public void delayVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
-    mockRestAdapter.setVariancePercentage(0);
+    mockRetrofit.setVariancePercentage(0);
     for (int i = 0; i < 100000; i++) {
-      assertThat(mockRestAdapter.calculateDelayForCall()).isEqualTo(2000);
+      assertThat(mockRetrofit.calculateDelayForCall()).isEqualTo(2000);
     }
 
-    mockRestAdapter.setVariancePercentage(40);
+    mockRetrofit.setVariancePercentage(40);
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForCall();
+      int delay = mockRetrofit.calculateDelayForCall();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -167,12 +162,12 @@
   }
 
   @Test public void errorVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
+    mockRetrofit.setDelay(2000);
 
     int lowerBound = Integer.MAX_VALUE;
     int upperBound = Integer.MIN_VALUE;
     for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForError();
+      int delay = mockRetrofit.calculateDelayForError();
       if (delay > upperBound) {
         upperBound = delay;
       }
@@ -184,33 +179,9 @@
     assertThat(lowerBound).isEqualTo(0);
   }
 
-  @Test public void changeListenerOnlyInvokedWhenValueHasChanged() {
-    long delay = mockRestAdapter.getDelay();
-    int variance = mockRestAdapter.getVariancePercentage();
-    int error = mockRestAdapter.getErrorPercentage();
-
-    long newDelay = delay + 1;
-    mockRestAdapter.setDelay(newDelay);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, error);
-
-    int newError = error + 1;
-    mockRestAdapter.setErrorPercentage(newError);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, newError);
-
-    int newVariance = variance + 1;
-    mockRestAdapter.setVariancePercentage(newVariance);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, newVariance, newError);
-
-    // Now try setting the same values and ensure the listener was never called.
-    mockRestAdapter.setDelay(newDelay);
-    mockRestAdapter.setVariancePercentage(newVariance);
-    mockRestAdapter.setErrorPercentage(newError);
-    verifyNoMoreInteractions(valueChangeListener);
-  }
-
   @Test public void syncFailureTriggersNetworkError() {
-    mockRestAdapter.setErrorPercentage(100);
-    mockRestAdapter.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
@@ -218,7 +189,7 @@
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     try {
       mockService.doStuff();
@@ -230,8 +201,8 @@
   }
 
   @Test public void asyncFailureTriggersNetworkError() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setErrorPercentage(100);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setErrorPercentage(100);
 
     class MockAsyncExample implements AsyncExample {
       @Override public void doStuff(Callback<String> cb) {
@@ -239,9 +210,9 @@
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff(new Callback<String>() {
       @Override public void success(String o, Response response) {
         throw new AssertionError();
@@ -261,9 +232,9 @@
   }
 
   @Test public void syncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     final AtomicBoolean called = new AtomicBoolean();
     final Object expected = new Object();
@@ -274,7 +245,7 @@
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     Object actual = mockService.doStuff();
@@ -286,9 +257,9 @@
   }
 
   @Test public void asyncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
     final String expected = new String("Hi");
@@ -299,11 +270,11 @@
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<Object>();
+    final AtomicReference<Object> actual = new AtomicReference<>();
     mockService.doStuff(new Callback<String>() {
       @Override public void success(String result, Response response) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
@@ -323,9 +294,9 @@
   }
 
   @Test public void observableApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
     final String expected = new String("Hello");
@@ -337,11 +308,11 @@
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<Object>();
+    final AtomicReference<Object> actual = new AtomicReference<>();
     Action1<Object> onSuccess = new Action1<Object>() {
       @Override public void call(Object o) {
         tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
@@ -365,9 +336,9 @@
 
 
   @Test public void syncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
     final String expected = new String("Hello");
@@ -378,7 +349,7 @@
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
 
     long startNanos = System.nanoTime();
     try {
@@ -396,9 +367,9 @@
   }
 
   @Test public void asyncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
     final String expected = new String("Greetings");
@@ -409,11 +380,11 @@
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff(new Callback<String>() {
       @Override public void success(String o, Response response) {
         throw new AssertionError();
@@ -438,9 +409,9 @@
   }
 
   @Test public void observableHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
     final String expected = new String("Hi");
@@ -452,11 +423,11 @@
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff().subscribe(new Action1<Object>() {
       @Override public void call(Object o) {
         throw new AssertionError();
@@ -482,9 +453,9 @@
   }
 
   @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
@@ -493,11 +464,11 @@
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<>();
     mockService.doStuff().subscribe(new Action1<Object>() {
       @Override public void call(Object o) {
         throw new AssertionError();
@@ -523,9 +494,9 @@
   }
 
   @Test public void syncErrorUsesErrorHandler() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockSyncExample implements SyncExample {
       @Override public Object doStuff() {
@@ -533,7 +504,7 @@
       }
     }
 
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+    SyncExample mockService = mockRetrofit.create(SyncExample.class, new MockSyncExample());
     nextError = new IllegalArgumentException("Test");
 
     try {
@@ -545,9 +516,9 @@
   }
 
   @Test public void asyncErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockAsyncExample implements AsyncExample {
       @Override public void doStuff(Callback<String> cb) {
@@ -555,7 +526,7 @@
       }
     }
 
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+    AsyncExample mockService = mockRetrofit.create(AsyncExample.class, new MockAsyncExample());
     nextError = new IllegalArgumentException("Test");
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -573,9 +544,9 @@
   }
 
   @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(100);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
@@ -584,7 +555,7 @@
     }
 
     ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+        mockRetrofit.create(ObservableExample.class, new MockObservableExample());
     nextError = new IllegalArgumentException("Test");
 
     final CountDownLatch latch = new CountDownLatch(1);
@@ -602,9 +573,9 @@
   }
 
   @Test public void asyncCanUseCallbackSubtype() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
+    mockRetrofit.setDelay(1);
+    mockRetrofit.setVariancePercentage(0);
+    mockRetrofit.setErrorPercentage(0);
 
     class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
       @Override public void doStuff(Foo foo) {
@@ -613,10 +584,10 @@
     }
 
     AsyncCallbackSubtypeExample mockService =
-        mockRestAdapter.create(AsyncCallbackSubtypeExample.class,
+        mockRetrofit.create(AsyncCallbackSubtypeExample.class,
             new MockAsyncCallbackSubtypeExample());
 
-    final AtomicReference<String> actual = new AtomicReference<String>();
+    final AtomicReference<String> actual = new AtomicReference<>();
     mockService.doStuff(new AsyncCallbackSubtypeExample.Foo() {
       @Override public void success(String result, Response response) {
         actual.set(result);
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 6871fcc9e..b4e355270 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -15,8 +15,8 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
     </dependency>
 
     <dependency>
@@ -24,15 +24,6 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
-      <optional>true</optional>
-    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -60,17 +51,4 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <!-- The AppEngine dependency has an annotation processor we don't want to run. -->
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit/BaseUrl.java b/retrofit/src/main/java/retrofit/BaseUrl.java
new file mode 100644
index 000000000..7052f5083
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/BaseUrl.java
@@ -0,0 +1,14 @@
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+
+/** The base URL of the remote service. */
+public interface BaseUrl {
+  /**
+   * The base URL.
+   * <p>
+   * Consumers will call this method every time they need to create a request allowing values
+   * to change over time.
+   */
+  HttpUrl url();
+}
diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
new file mode 100644
index 000000000..30b09ba3e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+
+public interface Call<T> extends Cloneable {
+  void enqueue(Callback<T> callback);
+  Response<T> execute() throws IOException;
+  void cancel();
+  Call<T> clone();
+}
diff --git a/retrofit/src/main/java/retrofit/CallAdapter.java b/retrofit/src/main/java/retrofit/CallAdapter.java
new file mode 100644
index 000000000..51a1678f1
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+
+public interface CallAdapter<T> {
+  Type responseType();
+  Object adapt(Call<T> call);
+
+  interface Factory {
+    CallAdapter<?> get(Type returnType);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 65f1bc5ed..e62e20d07 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -15,13 +15,11 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Response;
-
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
  * <p>
- * Callback methods are executed using the {@link RestAdapter} callback executor. When none is
+ * Callback methods are executed using the {@link Retrofit} callback executor. When none is
  * specified, the following defaults are used:
  * <ul>
  * <li>Android: Callbacks are executed on the application's main (UI) thread.</li>
@@ -29,16 +27,11 @@
  * </ul>
  *
  * @param <T> expected response type
- * @see RestAdapter.Builder#setCallbackExecutor
  */
 public interface Callback<T> {
-
   /** Successful HTTP response. */
-  void success(T t, Response response);
+  void success(Response<T> response);
 
-  /**
-   * Unsuccessful HTTP response due to network failure, non-2XX status code, or unexpected
-   * exception.
-   */
-  void failure(RetrofitError error);
+  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
+  void failure(Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
similarity index 51%
rename from retrofit/src/main/java/retrofit/converter/Converter.java
rename to retrofit/src/main/java/retrofit/Converter.java
index 8c93f9934..7405a9898 100644
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -13,31 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit.converter;
+package retrofit;
 
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
 
-/**
- * Arbiter for converting objects to and from their representation in HTTP.
- */
-public interface Converter {
-  /**
-   * Convert an HTTP response body to a concrete object of the specified type.
-   *
-   * @param body HTTP response body.
-   * @param type Target object type.
-   * @return Instance of {@code type} which will be cast by the caller.
-   */
-  Object fromBody(ResponseBody body, Type type) throws IOException;
+/** Convert objects to and from their representation as HTTP bodies. */
+public interface Converter<T> {
+  /** Convert an HTTP response body to a concrete object of the specified type. */
+  T fromBody(ResponseBody body) throws IOException;
+
+  /** Convert an object to an appropriate representation for HTTP transport. */
+  RequestBody toBody(T value);
 
-  /**
-   * Convert an object to an appropriate representation for HTTP transport.
-   *
-   * @param object Object instance to convert.
-   * @return Representation of the specified object as bytes.
-   */
-  RequestBody toBody(Object object, Type type);
+  interface Factory {
+    Converter<?> get(Type type);
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/Endpoint.java b/retrofit/src/main/java/retrofit/Endpoint.java
deleted file mode 100644
index 771013c22..000000000
--- a/retrofit/src/main/java/retrofit/Endpoint.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package retrofit;
-
-import static retrofit.Utils.checkNotNull;
-
-/** An API endpoint. */
-public abstract class Endpoint {
-  /** Create an endpoint with the provided {@code url}. */
-  public static Endpoint createFixed(final String url) {
-    checkNotNull(url, "url == null");
-    return new Endpoint() {
-      @Override public String url() {
-        return url;
-      }
-    };
-  }
-
-  /**
-   * The base URL.
-   * <p>
-   * Consumers will call this method every time they need to create a request allowing values
-   * to change over time.
-   */
-  public abstract String url();
-}
diff --git a/retrofit/src/main/java/retrofit/ErrorHandler.java b/retrofit/src/main/java/retrofit/ErrorHandler.java
deleted file mode 100644
index 83c05a36d..000000000
--- a/retrofit/src/main/java/retrofit/ErrorHandler.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/**
- * A hook allowing clients to customize {@link RetrofitError RetrofitError}.
- *
- * @author Sam Beran sberan@gmail.com
- */
-public interface ErrorHandler {
-  /**
-   * Return a custom exception to be thrown for a {@link RetrofitError}. It is recommended that you
-   * pass the supplied error as the cause to any new exceptions.
-   * <p>
-   * If the return exception is checked it must be declared to be thrown on the interface method.
-   * <p>
-   * Example usage:
-   * <pre>
-   * class MyErrorHandler implements ErrorHandler {
-   *   &#64;Override public Throwable handleError(RetrofitError cause) {
-   *     Response r = cause.getResponse();
-   *     if (r != null &amp;&amp; r.getStatus() == 401) {
-   *       return new UnauthorizedException(cause);
-   *     }
-   *     return cause;
-   *   }
-   * }
-   * </pre>
-   *
-   * @param cause the original {@link RetrofitError} exception
-   * @return Throwable an exception which will be thrown from a synchronous interface method or
-   *         passed to an asynchronous error callback. Must not be {@code null}.
-   */
-  Throwable handleError(RetrofitError cause);
-
-  /** An {@link ErrorHandler} which returns the original error. */
-  ErrorHandler DEFAULT = new ErrorHandler() {
-    @Override public Throwable handleError(RetrofitError cause) {
-      return cause;
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
index db7c14d63..52d0e819c 100644
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -8,7 +8,7 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
-class ExceptionCatchingRequestBody extends ResponseBody {
+final class ExceptionCatchingRequestBody extends ResponseBody {
   private final ResponseBody delegate;
   private IOException thrownException;
 
@@ -20,12 +20,24 @@
     return delegate.contentType();
   }
 
-  @Override public long contentLength() {
-    return delegate.contentLength();
+  @Override public long contentLength() throws IOException {
+    try {
+      return delegate.contentLength();
+    } catch (IOException e) {
+      thrownException = e;
+      throw e;
+    }
   }
 
-  @Override public BufferedSource source() {
-    return Okio.buffer(new ForwardingSource(delegate.source()) {
+  @Override public BufferedSource source() throws IOException {
+    BufferedSource delegateSource;
+    try {
+      delegateSource = delegate.source();
+    } catch (IOException e) {
+      thrownException = e;
+      throw e;
+    }
+    return Okio.buffer(new ForwardingSource(delegateSource) {
       @Override public long read(Buffer sink, long byteCount) throws IOException {
         try {
           return super.read(sink, byteCount);
@@ -37,11 +49,13 @@
     });
   }
 
-  IOException getThrownException() {
-    return thrownException;
+  @Override public void close() throws IOException {
+    delegate.close();
   }
 
-  boolean threwException() {
-    return thrownException != null;
+  void throwIfCaught() throws IOException {
+    if (thrownException != null) {
+      throw thrownException;
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
new file mode 100644
index 000000000..8196101e3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+
+final class ExecutorCallAdapterFactory implements CallAdapter.Factory {
+  private final Executor callbackExecutor;
+
+  ExecutorCallAdapterFactory(Executor callbackExecutor) {
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  @Override public String toString() {
+    return "ExecutorCallAdapterFactory[" + callbackExecutor + ']';
+  }
+
+  @Override public CallAdapter<?> get(Type returnType) {
+    if (Utils.getRawType(returnType) != Call.class) {
+      return null;
+    }
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Object>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<Object> adapt(Call<Object> call) {
+        return new ExecutorCallbackCall<>(callbackExecutor, call);
+      }
+    };
+  }
+
+  static final class ExecutorCallbackCall<T> implements Call<T> {
+    private final Executor callbackExecutor;
+    private final Call<T> delegate;
+
+    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void enqueue(Callback<T> callback) {
+      delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback));
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      return delegate.execute();
+    }
+
+    @Override public void cancel() {
+      delegate.cancel();
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+    @Override public Call<T> clone() {
+      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+    }
+  }
+
+  static final class ExecutorCallback<T> implements Callback<T> {
+    private final Executor callbackExecutor;
+    private final Callback<T> delegate;
+
+    ExecutorCallback(Executor callbackExecutor, Callback<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void success(final Response<T> response) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          delegate.success(response);
+        }
+      });
+    }
+
+    @Override public void failure(final Throwable t) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          delegate.failure(t);
+        }
+      });
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
new file mode 100644
index 000000000..f0231aef8
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/MethodHandler.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import retrofit.http.Streaming;
+
+import static retrofit.Utils.methodError;
+
+final class MethodHandler<T> {
+  @SuppressWarnings("unchecked")
+  static MethodHandler<?> create(Method method, OkHttpClient client, BaseUrl baseUrl,
+      CallAdapter.Factory callAdapterFactory, Converter.Factory converterFactory) {
+    CallAdapter<Object> callAdapter =
+        (CallAdapter<Object>) createCallAdapter(method, callAdapterFactory);
+    Converter<Object> responseConverter =
+        (Converter<Object>) createResponseConverter(method, callAdapter.responseType(),
+            converterFactory);
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactory);
+    return new MethodHandler<>(client, requestFactory, callAdapter, responseConverter);
+  }
+
+  private static CallAdapter<?> createCallAdapter(Method method,
+      CallAdapter.Factory adapterFactory) {
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw methodError(method,
+          "Method return type must not include a type variable or wildcard: %s", returnType);
+    }
+
+    if (returnType == void.class) {
+      throw methodError(method, "Service methods cannot return void.");
+    }
+
+    CallAdapter<?> adapter = adapterFactory.get(returnType);
+    if (adapter == null) {
+      throw methodError(method, "Call adapter factory '%s' was unable to handle return type %s",
+          adapterFactory, returnType);
+    }
+    return adapter;
+  }
+
+  private static Converter<?> createResponseConverter(Method method, Type responseType,
+      Converter.Factory converterFactory) {
+    if (responseType == ResponseBody.class) {
+      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
+      return new OkHttpResponseBodyConverter(isStreaming);
+    }
+
+    if (converterFactory == null) {
+      throw methodError(method, "Method response type is "
+          + responseType
+          + " but no converter factory registered. "
+          + "Either add a converter factory to the Retrofit instance or use ResponseBody.");
+    }
+
+    Converter<?> converter = converterFactory.get(responseType);
+    if (converter == null) {
+      throw methodError(method, "Converter factory '%s' was unable to handle response type %s",
+          converterFactory, responseType);
+    }
+    return converter;
+  }
+
+  private final OkHttpClient client;
+  private final RequestFactory requestFactory;
+  private final CallAdapter<T> callAdapter;
+  private final Converter<T> responseConverter;
+
+  private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
+      CallAdapter<T> callAdapter, Converter<T> responseConverter) {
+    this.client = client;
+    this.requestFactory = requestFactory;
+    this.callAdapter = callAdapter;
+    this.responseConverter = responseConverter;
+  }
+
+  Object invoke(Object... args) {
+    return callAdapter.adapt(new OkHttpCall<>(client, requestFactory, responseConverter, args));
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
deleted file mode 100644
index 40c0bd59a..000000000
--- a/retrofit/src/main/java/retrofit/MethodInfo.java
+++ /dev/null
@@ -1,439 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.WildcardType;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import retrofit.http.Body;
-import retrofit.http.DELETE;
-import retrofit.http.Field;
-import retrofit.http.FieldMap;
-import retrofit.http.FormUrlEncoded;
-import retrofit.http.GET;
-import retrofit.http.HEAD;
-import retrofit.http.Header;
-import retrofit.http.Headers;
-import retrofit.http.Multipart;
-import retrofit.http.PATCH;
-import retrofit.http.POST;
-import retrofit.http.PUT;
-import retrofit.http.Part;
-import retrofit.http.PartMap;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.QueryMap;
-import retrofit.http.HTTP;
-import retrofit.http.Streaming;
-import rx.Observable;
-
-/** Request metadata about a service interface declaration. */
-final class MethodInfo {
-  enum ExecutionType {
-    ASYNC,
-    RX,
-    SYNC
-  }
-
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-  enum RequestType {
-    /** No content-specific logic required. */
-    SIMPLE,
-    /** Multi-part request body. */
-    MULTIPART,
-    /** Form URL-encoded request body. */
-    FORM_URL_ENCODED
-  }
-
-  final Method method;
-
-  // Method-level details
-  final ExecutionType executionType;
-  Type responseObjectType;
-  Type requestObjectType;
-  RequestType requestType = RequestType.SIMPLE;
-  String requestMethod;
-  boolean requestHasBody;
-  String requestUrl;
-  Set<String> requestUrlParamNames;
-  String requestQuery;
-  com.squareup.okhttp.Headers headers;
-  String contentTypeHeader;
-  boolean isStreaming;
-
-  // Parameter-level details
-  Annotation[] requestParamAnnotations;
-
-  MethodInfo(Method method) {
-    this.method = method;
-    executionType = parseResponseType();
-
-    parseMethodAnnotations();
-    parseParameters();
-  }
-
-  private RuntimeException methodError(String message, Object... args) {
-    if (args.length > 0) {
-      message = String.format(message, args);
-    }
-    return new IllegalArgumentException(
-        method.getDeclaringClass().getSimpleName() + "." + method.getName() + ": " + message);
-  }
-
-  private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  /** Loads {@link #requestMethod} and {@link #requestType}. */
-  private void parseMethodAnnotations() {
-    for (Annotation methodAnnotation : method.getAnnotations()) {
-      Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
-      if (annotationType == DELETE.class) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) methodAnnotation).value(), false);
-      } else if (annotationType == GET.class) {
-        parseHttpMethodAndPath("GET", ((GET) methodAnnotation).value(), false);
-      } else if (annotationType == HEAD.class) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) methodAnnotation).value(), false);
-      } else if (annotationType == PATCH.class) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) methodAnnotation).value(), true);
-      } else if (annotationType == POST.class) {
-        parseHttpMethodAndPath("POST", ((POST) methodAnnotation).value(), true);
-      } else if (annotationType == PUT.class) {
-        parseHttpMethodAndPath("PUT", ((PUT) methodAnnotation).value(), true);
-      } else if (annotationType == HTTP.class) {
-        HTTP http = (HTTP) methodAnnotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotationType == Headers.class) {
-        String[] headersToParse = ((Headers) methodAnnotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotationType == Multipart.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        throw new UnsupportedOperationException("Multipart shall return!");
-        //requestType = RequestType.MULTIPART;
-      } else if (annotationType == FormUrlEncoded.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        throw new UnsupportedOperationException("Form URL encoding shall return!");
-        //requestType = RequestType.FORM_URL_ENCODED;
-      } else if (annotationType == Streaming.class) {
-        if (responseObjectType != Response.class) {
-          throw methodError(
-              "Only methods having %s as data type are allowed to have @%s annotation.",
-              Response.class.getSimpleName(), Streaming.class.getSimpleName());
-        }
-        isStreaming = true;
-      }
-    }
-
-    if (requestMethod == null) {
-      throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-    }
-    if (!requestHasBody) {
-      if (requestType == RequestType.MULTIPART) {
-        throw methodError(
-            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-      }
-      if (requestType == RequestType.FORM_URL_ENCODED) {
-        throw methodError("FormUrlEncoded can only be specified on HTTP methods with request body "
-                + "(e.g., @POST).");
-      }
-    }
-  }
-
-  /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
-  private void parseHttpMethodAndPath(String method, String path, boolean hasBody) {
-    if (requestMethod != null) {
-      throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
-          method);
-    }
-    if (path == null || path.length() == 0 || path.charAt(0) != '/') {
-      throw methodError("URL path \"%s\" must start with '/'.", path);
-    }
-
-    // Get the relative URL path and existing query string, if present.
-    String url = path;
-    String query = null;
-    int question = path.indexOf('?');
-    if (question != -1 && question < path.length() - 1) {
-      url = path.substring(0, question);
-      query = path.substring(question + 1);
-
-      // Ensure the query string does not have any named parameters.
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
-      if (queryParamMatcher.find()) {
-        throw methodError("URL query string \"%s\" must not have replace block. For dynamic query"
-            + " parameters use @Query.", query);
-      }
-    }
-
-    Set<String> urlParams = parsePathParameters(path);
-
-    requestMethod = method;
-    requestHasBody = hasBody;
-    requestUrl = url;
-    requestUrlParamNames = urlParams;
-    requestQuery = query;
-  }
-
-  com.squareup.okhttp.Headers parseHeaders(String[] headers) {
-    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
-    for (String header : headers) {
-      int colon = header.indexOf(':');
-      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",
-            header);
-      }
-      String headerName = header.substring(0, colon);
-      String headerValue = header.substring(colon + 1).trim();
-      if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentTypeHeader = headerValue;
-      } else {
-        builder.add(headerName, headerValue);
-      }
-    }
-    return builder.build();
-  }
-
-  /** Loads {@link #responseObjectType}. */
-  private ExecutionType parseResponseType() {
-    // Synchronous methods have a non-void return type.
-    // Observable methods have a return type of Observable.
-    Type returnType = method.getGenericReturnType();
-
-    // Asynchronous methods should have a Callback type as the last argument.
-    Type lastArgType = null;
-    Class<?> lastArgClass = null;
-    Type[] parameterTypes = method.getGenericParameterTypes();
-    if (parameterTypes.length > 0) {
-      Type typeToCheck = parameterTypes[parameterTypes.length - 1];
-      lastArgType = typeToCheck;
-      if (typeToCheck instanceof ParameterizedType) {
-        typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
-      }
-      if (typeToCheck instanceof Class) {
-        lastArgClass = (Class<?>) typeToCheck;
-      }
-    }
-
-    boolean hasReturnType = returnType != void.class;
-    boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
-
-    // Check for invalid configurations.
-    if (hasReturnType && hasCallback) {
-      throw methodError("Must have return type or Callback as last argument, not both.");
-    }
-    if (!hasReturnType && !hasCallback) {
-      throw methodError("Must have either a return type or Callback as last argument.");
-    }
-
-    if (hasReturnType) {
-      if (Platform.HAS_RX_JAVA) {
-        Class rawReturnType = Types.getRawType(returnType);
-        if (RxSupport.isObservable(rawReturnType)) {
-          returnType = RxSupport.getObservableType(returnType, rawReturnType);
-          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
-          return ExecutionType.RX;
-        }
-      }
-      responseObjectType = returnType;
-      return ExecutionType.SYNC;
-    }
-
-    lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
-    if (lastArgType instanceof ParameterizedType) {
-      responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
-      return ExecutionType.ASYNC;
-    }
-
-    throw methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");
-  }
-
-  private static Type getParameterUpperBound(ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    for (int i = 0; i < types.length; i++) {
-      Type paramType = types[i];
-      if (paramType instanceof WildcardType) {
-        types[i] = ((WildcardType) paramType).getUpperBounds()[0];
-      }
-    }
-    return types[0];
-  }
-
-  /**
-   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
-   */
-  private void parseParameters() {
-    Type[] methodParameterTypes = method.getGenericParameterTypes();
-
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
-    int count = methodParameterAnnotationArrays.length;
-    if (executionType == ExecutionType.ASYNC) {
-      count -= 1; // Callback is last argument when not a synchronous method.
-    }
-
-    Annotation[] requestParamAnnotations = new Annotation[count];
-
-    boolean gotField = false;
-    boolean gotPart = false;
-    boolean gotBody = false;
-
-    for (int i = 0; i < count; i++) {
-      Type methodParameterType = methodParameterTypes[i];
-      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
-      if (methodParameterAnnotations != null) {
-        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          Class<? extends Annotation> methodAnnotationType =
-              methodParameterAnnotation.annotationType();
-
-          if (methodAnnotationType == Path.class) {
-            String name = ((Path) methodParameterAnnotation).value();
-            validatePathName(i, name);
-          } else if (methodAnnotationType == Query.class) {
-            // Nothing to do.
-          } else if (methodAnnotationType == QueryMap.class) {
-            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
-              throw parameterError(i, "@QueryMap parameter type must be Map.");
-            }
-          } else if (methodAnnotationType == Header.class) {
-            // Nothing to do.
-          } else if (methodAnnotationType == Field.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw parameterError(i, "@Field parameters can only be used with form encoding.");
-            }
-
-            gotField = true;
-          } else if (methodAnnotationType == FieldMap.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
-              throw parameterError(i, "@FieldMap parameter type must be Map.");
-            }
-
-            gotField = true;
-          } else if (methodAnnotationType == Part.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
-            }
-
-            gotPart = true;
-          } else if (methodAnnotationType == PartMap.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw parameterError(i,
-                  "@PartMap parameters can only be used with multipart encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
-              throw parameterError(i, "@PartMap parameter type must be Map.");
-            }
-
-            gotPart = true;
-          } else if (methodAnnotationType == Body.class) {
-            if (requestType != RequestType.SIMPLE) {
-              throw parameterError(i,
-                  "@Body parameters cannot be used with form or multi-part encoding.");
-            }
-            if (gotBody) {
-              throw methodError("Multiple @Body method annotations found.");
-            }
-
-            requestObjectType = methodParameterType;
-            gotBody = true;
-          } else {
-            // This is a non-Retrofit annotation. Skip to the next one.
-            continue;
-          }
-
-          if (requestParamAnnotations[i] != null) {
-            throw parameterError(i,
-                "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
-                requestParamAnnotations[i].annotationType().getSimpleName(),
-                methodAnnotationType.getSimpleName());
-          }
-          requestParamAnnotations[i] = methodParameterAnnotation;
-        }
-      }
-
-      if (requestParamAnnotations[i] == null) {
-        throw parameterError(i, "No Retrofit annotation found.");
-      }
-    }
-
-    if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
-      throw methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
-    }
-    if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
-      throw methodError("Form-encoded method must contain at least one @Field.");
-    }
-    if (requestType == RequestType.MULTIPART && !gotPart) {
-      throw methodError("Multipart method must contain at least one @Part.");
-    }
-
-    this.requestParamAnnotations = requestParamAnnotations;
-  }
-
-  private void validatePathName(int index, String name) {
-    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
-          PARAM_URL_REGEX.pattern(), name);
-    }
-    // Verify URL replacement name is actually present in the URL path.
-    if (!requestUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", requestUrl, name);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<String>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  /** Indirection to avoid log complaints if RxJava isn't present. */
-  private static final class RxSupport {
-    public static boolean isObservable(Class rawType) {
-      return rawType == Observable.class;
-    }
-
-    public static Type getObservableType(Type contextType, Class contextRawType) {
-      return Types.getSupertype(contextType, contextRawType, Observable.class);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/NoContentResponseBody.java b/retrofit/src/main/java/retrofit/NoContentResponseBody.java
new file mode 100644
index 000000000..098087653
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/NoContentResponseBody.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.BufferedSource;
+
+final class NoContentResponseBody extends ResponseBody {
+  private final MediaType contentType;
+  private final long contentLength;
+
+  NoContentResponseBody(MediaType contentType, long contentLength) {
+    this.contentType = contentType;
+    this.contentLength = contentLength;
+  }
+
+  @Override public MediaType contentType() {
+    return contentType;
+  }
+
+  @Override public long contentLength() throws IOException {
+    return contentLength;
+  }
+
+  @Override public BufferedSource source() throws IOException {
+    throw new IllegalStateException("Cannot read raw response body of a converted body.");
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
new file mode 100644
index 000000000..6ba1ca996
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+import static retrofit.Utils.closeQuietly;
+
+final class OkHttpCall<T> implements Call<T> {
+  private final OkHttpClient client;
+  private final RequestFactory requestFactory;
+  private final Converter<T> responseConverter;
+  private final Object[] args;
+
+  private volatile com.squareup.okhttp.Call rawCall;
+  private boolean executed; // Guarded by this.
+
+  OkHttpCall(OkHttpClient client, RequestFactory requestFactory, Converter<T> responseConverter,
+      Object[] args) {
+    this.client = client;
+    this.requestFactory = requestFactory;
+    this.responseConverter = responseConverter;
+    this.args = args;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public OkHttpCall<T> clone() {
+    return new OkHttpCall<>(client, requestFactory, responseConverter, args);
+  }
+
+  public void enqueue(final Callback<T> callback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+
+    com.squareup.okhttp.Call rawCall;
+    try {
+      rawCall = createRawCall();
+    } catch (Throwable t) {
+      callback.failure(t);
+      return;
+    }
+    this.rawCall = rawCall;
+
+    rawCall.enqueue(new com.squareup.okhttp.Callback() {
+      private void callFailure(Throwable e) {
+        try {
+          callback.failure(e);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      private void callSuccess(Response<T> response) {
+        try {
+          callback.success(response);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      @Override public void onFailure(Request request, IOException e) {
+        callFailure(e);
+      }
+
+      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
+        final Response<T> response;
+        try {
+          response = parseResponse(rawResponse);
+        } catch (final Throwable e) {
+          callFailure(e);
+          return;
+        }
+        callSuccess(response);
+      }
+    });
+  }
+
+  public Response<T> execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+
+    final com.squareup.okhttp.Call rawCall = createRawCall();
+    this.rawCall = rawCall;
+
+    return parseResponse(rawCall.execute());
+  }
+
+  private com.squareup.okhttp.Call createRawCall() {
+    return client.newCall(requestFactory.create(args));
+  }
+
+  private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
+    ResponseBody rawBody = rawResponse.body();
+
+    // Remove the body's source (the only stateful object) so we can pass the response along.
+    rawResponse = rawResponse.newBuilder()
+        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+        .build();
+
+    int code = rawResponse.code();
+    if (code < 200 || code >= 300) {
+      try {
+        // Buffer the entire body to avoid future I/O.
+        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+        return Response.error(bufferedBody, rawResponse);
+      } finally {
+        closeQuietly(rawBody);
+      }
+    }
+
+    if (code == 204 || code == 205) {
+      return Response.success(null, rawResponse);
+    }
+
+    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    try {
+      T body = responseConverter.fromBody(catchingBody);
+      return Response.success(body, rawResponse);
+    } catch (RuntimeException e) {
+      // If the underlying source threw an exception, propagate that rather than indicating it was
+      // a runtime exception.
+      catchingBody.throwIfCaught();
+      throw e;
+    }
+  }
+
+  public void cancel() {
+    com.squareup.okhttp.Call rawCall = this.rawCall;
+    if (rawCall == null) {
+      throw new IllegalStateException("enqueue or execute must be called first");
+    }
+    rawCall.cancel();
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
new file mode 100644
index 000000000..ad2434e47
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+final class OkHttpRequestBodyConverter implements Converter<RequestBody> {
+  @Override public RequestBody fromBody(ResponseBody body) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public RequestBody toBody(RequestBody value) {
+    return value;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
new file mode 100644
index 000000000..3538c789b
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+import static retrofit.Utils.closeQuietly;
+
+final class OkHttpResponseBodyConverter implements Converter<ResponseBody> {
+  private final boolean isStreaming;
+
+  OkHttpResponseBodyConverter(boolean isStreaming) {
+    this.isStreaming = isStreaming;
+  }
+
+  @Override public ResponseBody fromBody(ResponseBody body) throws IOException {
+    if (isStreaming) {
+      return body;
+    }
+
+    // Buffer the entire body to avoid future I/O.
+    try {
+      return Utils.readBodyToBytesIfNecessary(body);
+    } finally {
+      closeQuietly(body);
+    }
+  }
+
+  @Override public RequestBody toBody(ResponseBody value) {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 928fd1ae8..4f694322b 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -19,16 +19,13 @@
 import android.os.Handler;
 import android.os.Looper;
 import com.squareup.okhttp.OkHttpClient;
+import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
-  static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
-
   static Platform get() {
     return PLATFORM;
   }
@@ -45,12 +42,11 @@ private static Platform findPlatform() {
     return new Platform();
   }
 
-  Converter defaultConverter() {
-    return new GsonConverter();
-  }
-
-  Executor defaultCallbackExecutor() {
-    return new Utils.SynchronousExecutor();
+  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+    if (callbackExecutor != null) {
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+    return new NothingCallAdapterFactory();
   }
 
   OkHttpClient defaultClient() {
@@ -62,24 +58,54 @@ OkHttpClient defaultClient() {
   }
 
   /** Provides sane defaults for operation on Android. */
-  private static class Android extends Platform {
-    @Override Executor defaultCallbackExecutor() {
-      return new Executor() {
-        private final Handler handler = new Handler(Looper.getMainLooper());
-
-        @Override public void execute(Runnable r) {
-          handler.post(r);
-        }
-      };
+  static class Android extends Platform {
+    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+      if (callbackExecutor == null) {
+        callbackExecutor = new MainThreadExecutor();
+      }
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+
+    static class MainThreadExecutor implements Executor {
+      private final Handler handler = new Handler(Looper.getMainLooper());
+
+      @Override public void execute(Runnable r) {
+        handler.post(r);
+      }
+
+      @Override public String toString() {
+        return "MainThreadExecutor";
+      }
     }
   }
 
-  private static boolean hasRxJavaOnClasspath() {
-    try {
-      Class.forName("rx.Observable");
-      return true;
-    } catch (ClassNotFoundException ignored) {
+  static final class NothingCallAdapterFactory implements CallAdapter.Factory {
+    @Override public CallAdapter<?> get(Type returnType) {
+      if (Utils.getRawType(returnType) != Call.class) {
+        return null;
+      }
+      Type responseType = Utils.getCallResponseType(returnType);
+      return new NothingCallAdapter<>(responseType);
+    }
+
+    @Override public String toString() {
+      return "Default";
+    }
+
+    static final class NothingCallAdapter<T> implements CallAdapter<T> {
+      private final Type responseType;
+
+      NothingCallAdapter(Type responseType) {
+        this.responseType = responseType;
+      }
+
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public Call<T> adapt(Call<T> call) {
+        return call;
+      }
     }
-    return false;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index d87332bec..b620f3aad 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -15,95 +15,77 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.FormEncodingBuilder;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.MultipartBuilder;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Array;
 import java.net.URLEncoder;
-import java.util.Map;
 import okio.BufferedSink;
-import retrofit.converter.Converter;
-import retrofit.http.Body;
-import retrofit.http.Header;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.QueryMap;
 
-final class RequestBuilder implements RequestInterceptor.RequestFacade {
-  private static final Headers NO_HEADERS = Headers.of();
-
-  private final Converter converter;
-  private final Annotation[] paramAnnotations;
-  private final String requestMethod;
-  private final boolean async;
-  private final String apiUrl;
-
-  private RequestBody body;
+final class RequestBuilder {
+  private final String method;
 
+  private final HttpUrl baseUrl;
   private String relativeUrl;
-  private StringBuilder queryParams;
-  private Headers.Builder headers;
-  private String contentTypeHeader;
+  private HttpUrl.Builder urlBuilder;
 
-  RequestBuilder(String apiUrl, MethodInfo methodInfo, Converter converter) {
-    this.apiUrl = apiUrl;
-    this.converter = converter;
+  private final Request.Builder requestBuilder;
+  private MediaType mediaType;
 
-    paramAnnotations = methodInfo.requestParamAnnotations;
-    requestMethod = methodInfo.requestMethod;
-    async = methodInfo.executionType == MethodInfo.ExecutionType.ASYNC;
+  private final boolean hasBody;
+  private MultipartBuilder multipartBuilder;
+  private FormEncodingBuilder formEncodingBuilder;
+  private RequestBody body;
 
-    if (methodInfo.headers != null) {
-      headers = methodInfo.headers.newBuilder();
-    }
-    contentTypeHeader = methodInfo.contentTypeHeader;
+  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
+      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+    this.method = method;
 
-    relativeUrl = methodInfo.requestUrl;
+    this.baseUrl = baseUrl;
+    this.relativeUrl = relativeUrl;
 
-    String requestQuery = methodInfo.requestQuery;
-    if (requestQuery != null) {
-      queryParams = new StringBuilder().append('?').append(requestQuery);
+    Request.Builder requestBuilder = new Request.Builder();
+    if (headers != null) {
+      requestBuilder.headers(headers);
     }
-  }
+    this.requestBuilder = requestBuilder;
+    this.mediaType = mediaType;
 
-  @Override public void addHeader(String name, String value) {
-    if (name == null) {
-      throw new IllegalArgumentException("Header name must not be null.");
-    }
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      contentTypeHeader = value;
-      return;
-    }
+    this.hasBody = hasBody;
 
-    Headers.Builder headers = this.headers;
-    if (headers == null) {
-      this.headers = headers = new Headers.Builder();
+    if (isFormEncoded) {
+      // Will be set to 'body' in 'build'.
+      formEncodingBuilder = new FormEncodingBuilder();
+    } else if (isMultipart) {
+      // Will be set to 'body' in 'build'.
+      multipartBuilder = new MultipartBuilder();
     }
-    headers.add(name, value);
   }
 
-  @Override public void addPathParam(String name, String value) {
-    addPathParam(name, value, true);
+  void setRelativeUrl(String relativeUrl) {
+    this.relativeUrl = relativeUrl;
   }
 
-  @Override public void addEncodedPathParam(String name, String value) {
-    addPathParam(name, value, false);
+  void addHeader(String name, String value) {
+    if ("Content-Type".equalsIgnoreCase(name)) {
+      mediaType = MediaType.parse(value);
+    } else {
+      requestBuilder.addHeader(name, value);
+    }
   }
 
-  private void addPathParam(String name, String value, boolean urlEncodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Path replacement name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException(
-          "Path replacement \"" + name + "\" value must not be null.");
+  void addPathParam(String name, String value, boolean encoded) {
+    if (relativeUrl == null) {
+      // The relative URL is cleared when the first query parameter is set.
+      throw new AssertionError();
     }
     try {
-      if (urlEncodeValue) {
+      if (!encoded) {
         String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
         // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
         // encode spaces rather than +. Query encoding difference specified in HTML spec.
@@ -119,262 +101,71 @@ private void addPathParam(String name, String value, boolean urlEncodeValue) {
     }
   }
 
-  @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, false, true);
-  }
-
-  @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false, false);
-  }
+  void addQueryParam(String name, String value, boolean encoded) {
+    if (relativeUrl != null) {
+      // Do a one-time combination of the built relative URL and the base URL.
+      urlBuilder = baseUrl.resolve(relativeUrl).newBuilder();
+      relativeUrl = null;
+    }
 
-  private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
-    if (value instanceof Iterable) {
-      for (Object iterableValue : (Iterable<?>) value) {
-        if (iterableValue != null) { // Skip null values
-          addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
-        }
-      }
-    } else if (value.getClass().isArray()) {
-      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-        Object arrayValue = Array.get(value, x);
-        if (arrayValue != null) { // Skip null values
-          addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
-        }
-      }
+    if (encoded) {
+      urlBuilder.addEncodedQueryParameter(name, value);
     } else {
-      addQueryParam(name, value.toString(), encodeName, encodeValue);
+      urlBuilder.addQueryParameter(name, value);
     }
   }
 
-  private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Query param name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
-    }
-    try {
-      StringBuilder queryParams = this.queryParams;
-      if (queryParams == null) {
-        this.queryParams = queryParams = new StringBuilder();
-      }
-
-      queryParams.append(queryParams.length() > 0 ? '&' : '?');
-
-      if (encodeName) {
-        name = URLEncoder.encode(name, "UTF-8");
-      }
-      if (encodeValue) {
-        value = URLEncoder.encode(value, "UTF-8");
-      }
-      queryParams.append(name).append('=').append(value);
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
+  void addFormField(String name, String value, boolean encoded) {
+    if (encoded) {
+      formEncodingBuilder.addEncoded(name, value);
+    } else {
+      formEncodingBuilder.add(name, value);
     }
   }
 
-  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames,
-      boolean encodeValues) {
-    for (Map.Entry<?, ?> entry : map.entrySet()) {
-      Object entryKey = entry.getKey();
-      if (entryKey == null) {
-        throw new IllegalArgumentException(
-            "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
-      }
-      Object entryValue = entry.getValue();
-      if (entryValue != null) { // Skip null values.
-        addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
-      }
-    }
+  void addPart(Headers headers, RequestBody body) {
+    multipartBuilder.addPart(headers, body);
   }
 
-  void setArguments(Object[] args) {
-    if (args == null) {
-      return;
-    }
-    int count = args.length;
-    if (async) {
-      count -= 1;
-    }
-    for (int i = 0; i < count; i++) {
-      Object value = args[i];
-
-      Annotation annotation = paramAnnotations[i];
-      Class<? extends Annotation> annotationType = annotation.annotationType();
-      if (annotationType == Path.class) {
-        Path path = (Path) annotation;
-        String name = path.value();
-        if (value == null) {
-          throw new IllegalArgumentException(
-              "Path parameter \"" + name + "\" value must not be null.");
-        }
-        addPathParam(name, value.toString(), path.encode());
-      } else if (annotationType == Query.class) {
-        if (value != null) { // Skip null values.
-          Query query = (Query) annotation;
-          addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
-        }
-      } else if (annotationType == QueryMap.class) {
-        if (value != null) { // Skip null values.
-          QueryMap queryMap = (QueryMap) annotation;
-          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
-        }
-      } else if (annotationType == Header.class) {
-        if (value != null) { // Skip null values.
-          String name = ((Header) annotation).value();
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                addHeader(name, iterableValue.toString());
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                addHeader(name, arrayValue.toString());
-              }
-            }
-          } else {
-            addHeader(name, value.toString());
-          }
-        }
-      // TODO bring back form url encoding!
-      //} else if (annotationType == Field.class) {
-      //  if (value != null) { // Skip null values.
-      //    Field field = (Field) annotation;
-      //    String name = field.value();
-      //    boolean encodeName = field.encodeName();
-      //    boolean encodeValue = field.encodeValue();
-      //    if (value instanceof Iterable) {
-      //      for (Object iterableValue : (Iterable<?>) value) {
-      //        if (iterableValue != null) { // Skip null values.
-      //          formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
-      //        }
-      //      }
-      //    } else if (value.getClass().isArray()) {
-      //      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-      //        Object arrayValue = Array.get(value, x);
-      //        if (arrayValue != null) { // Skip null values.
-      //          formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
-      //        }
-      //      }
-      //    } else {
-      //      formBody.addField(name, encodeName, value.toString(), encodeValue);
-      //    }
-      //  }
-      //} else if (annotationType == FieldMap.class) {
-      //  if (value != null) { // Skip null values.
-      //    FieldMap fieldMap = (FieldMap) annotation;
-      //    boolean encodeNames = fieldMap.encodeNames();
-      //    boolean encodeValues = fieldMap.encodeValues();
-      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-      //      Object entryKey = entry.getKey();
-      //      if (entryKey == null) {
-      //        throw new IllegalArgumentException(
-      //            "Parameter #" + (i + 1) + " field map contained null key.");
-      //      }
-      //      Object entryValue = entry.getValue();
-      //      if (entryValue != null) { // Skip null values.
-      //        formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
-      //            encodeValues);
-      //      }
-      //    }
-      //  }
-      // TODO bring back multipart!
-      //} else if (annotationType == Part.class) {
-      //  if (value != null) { // Skip null values.
-      //    String name = ((Part) annotation).value();
-      //    String transferEncoding = ((Part) annotation).encoding();
-      //    if (value instanceof RequestBody) {
-      //      multipartBody.addPart((RequestBody) value);
-      //      multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-      //    } else if (value instanceof String) {
-      //      multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-      //    } else {
-      //      multipartBody.addPart(name, transferEncoding,
-      //          converter.toBody(value, value.getClass()));
-      //    }
-      //  }
-      //} else if (annotationType == PartMap.class) {
-      //  if (value != null) { // Skip null values.
-      //    String transferEncoding = ((PartMap) annotation).encoding();
-      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-      //      Object entryKey = entry.getKey();
-      //      if (entryKey == null) {
-      //        throw new IllegalArgumentException(
-      //            "Parameter #" + (i + 1) + " part map contained null key.");
-      //      }
-      //      String entryName = entryKey.toString();
-      //      Object entryValue = entry.getValue();
-      //      if (entryValue != null) { // Skip null values.
-      //        if (entryValue instanceof TypedOutput) {
-      //          multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-      //        } else if (entryValue instanceof String) {
-      //          multipartBody.addPart(entryName, transferEncoding,
-      //              new TypedString((String) entryValue));
-      //        } else {
-      //          multipartBody.addPart(entryName, transferEncoding,
-      //              converter.toBody(entryValue, entryValue.getClass()));
-      //        }
-      //      }
-      //    }
-      //  }
-      } else if (annotationType == Body.class) {
-        if (value == null) {
-          throw new IllegalArgumentException("Body parameter value must not be null.");
-        }
-        if (value instanceof RequestBody) {
-          body = (RequestBody) value;
-        } else {
-          body = converter.toBody(value, value.getClass());
-        }
-      } else {
-        throw new IllegalArgumentException(
-            "Unknown annotation: " + annotationType.getCanonicalName());
-      }
-    }
+  void setBody(RequestBody body) {
+    this.body = body;
   }
 
   Request build() {
-    //if (multipartBody != null && multipartBody.getPartCount() == 0) {
-    //  throw new IllegalStateException("Multipart requests must contain at least one part.");
-    //}
-
-    String apiUrl = this.apiUrl;
-    StringBuilder url = new StringBuilder(apiUrl);
-    if (apiUrl.endsWith("/")) {
-      // We require relative paths to start with '/'. Prevent a double-slash.
-      url.deleteCharAt(url.length() - 1);
+    HttpUrl url;
+    HttpUrl.Builder urlBuilder = this.urlBuilder;
+    if (urlBuilder != null) {
+      url = urlBuilder.build();
+    } else {
+      // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      url = baseUrl.resolve(relativeUrl);
     }
 
-    url.append(relativeUrl);
-
-    StringBuilder queryParams = this.queryParams;
-    if (queryParams != null) {
-      url.append(queryParams);
+    RequestBody body = this.body;
+    if (body == null) {
+      // Try to pull from one of the builders.
+      if (formEncodingBuilder != null) {
+        body = formEncodingBuilder.build();
+      } else if (multipartBuilder != null) {
+        body = multipartBuilder.build();
+      } else if (hasBody) {
+        // Body is absent, make an empty body.
+        body = RequestBody.create(null, new byte[0]);
+      }
     }
 
-    RequestBody body = this.body;
-    Headers.Builder headerBuilder = this.headers;
-    if (contentTypeHeader != null) {
+    MediaType mediaType = this.mediaType;
+    if (mediaType != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
+        body = new MediaTypeOverridingRequestBody(body, mediaType);
       } else {
-        if (headerBuilder == null) {
-          headerBuilder = new Headers.Builder();
-        }
-        headerBuilder.add("Content-Type", contentTypeHeader);
+        requestBuilder.addHeader("Content-Type", mediaType.toString());
       }
     }
 
-    Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
-
-    return new Request.Builder()
-        .url(url.toString())
-        .method(requestMethod, body)
-        .headers(headers)
+    return requestBuilder
+        .url(url)
+        .method(method, body)
         .build();
   }
 
@@ -382,9 +173,9 @@ Request build() {
     private final RequestBody delegate;
     private final MediaType mediaType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
+    MediaTypeOverridingRequestBody(RequestBody delegate, MediaType mediaType) {
       this.delegate = delegate;
-      this.mediaType = MediaType.parse(mediaType);
+      this.mediaType = mediaType;
     }
 
     @Override public MediaType contentType() {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
new file mode 100644
index 000000000..bc8b1a472
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import java.lang.reflect.Array;
+import java.util.Map;
+
+import static retrofit.Utils.checkNotNull;
+
+abstract class RequestBuilderAction {
+  abstract void perform(RequestBuilder builder, Object value);
+
+  static final class Url extends RequestBuilderAction {
+    @Override void perform(RequestBuilder builder, Object value) {
+      builder.setRelativeUrl((String) value);
+    }
+  }
+
+  static final class Header extends RequestBuilderAction {
+    private final String name;
+
+    Header(String name) {
+      this.name = checkNotNull(name, "name == null");
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addHeader(name, iterableValue.toString());
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addHeader(name, arrayValue.toString());
+          }
+        }
+      } else {
+        builder.addHeader(name, value.toString());
+      }
+    }
+  }
+
+  static final class Path extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Path(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) {
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
+      }
+      builder.addPathParam(name, value.toString(), encoded);
+    }
+  }
+
+  static final class Query extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Query(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addQueryParam(name, iterableValue.toString(), encoded);
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addQueryParam(name, arrayValue.toString(), encoded);
+          }
+        }
+      } else {
+        builder.addQueryParam(name, value.toString(), encoded);
+      }
+    }
+  }
+
+  static final class QueryMap extends RequestBuilderAction {
+    private final boolean encoded;
+
+    QueryMap(boolean encoded) {
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Query map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Field extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Field(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addFormField(name, iterableValue.toString(), encoded);
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addFormField(name, arrayValue.toString(), encoded);
+          }
+        }
+      } else {
+        builder.addFormField(name, value.toString(), encoded);
+      }
+    }
+  }
+
+  static final class FieldMap extends RequestBuilderAction {
+    private final boolean encoded;
+
+    FieldMap(boolean encoded) {
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Field map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Part<T> extends RequestBuilderAction {
+    private final Headers headers;
+    private final Converter<T> converter;
+
+    Part(Headers headers, Converter<T> converter) {
+      this.headers = headers;
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      //noinspection unchecked
+      builder.addPart(headers, converter.toBody((T) value));
+    }
+  }
+
+  static final class PartMap extends RequestBuilderAction {
+    private final Converter.Factory converterFactory;
+    private final String transferEncoding;
+
+    PartMap(Converter.Factory converterFactory, String transferEncoding) {
+      this.converterFactory = converterFactory;
+      this.transferEncoding = transferEncoding;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Part map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue == null) {
+          continue; // Skip null values.
+        }
+
+        Headers headers = Headers.of(
+            "Content-Disposition", "name=\"" + entryKey + "\"",
+            "Content-Transfer-Encoding", transferEncoding);
+        //noinspection unchecked
+        Converter<Object> converter =
+            (Converter<Object>) converterFactory.get(entryValue.getClass());
+        builder.addPart(headers, converter.toBody(entryValue));
+      }
+    }
+  }
+
+  static final class Body<T> extends RequestBuilderAction {
+    private final Converter<T> converter;
+
+    Body(Converter<T> converter) {
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) {
+        throw new IllegalArgumentException("Body parameter value must not be null.");
+      }
+      //noinspection unchecked
+      builder.setBody(converter.toBody((T) value));
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
new file mode 100644
index 000000000..99f0891e8
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestFactory.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+
+final class RequestFactory {
+  private final String method;
+  private final BaseUrl baseUrl;
+  private final String relativeUrl;
+  private final Headers headers;
+  private final MediaType mediaType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final RequestBuilderAction[] requestBuilderActions;
+
+  RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
+      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
+      RequestBuilderAction[] requestBuilderActions) {
+    this.method = method;
+    this.baseUrl = baseUrl;
+    this.relativeUrl = relativeUrl;
+    this.headers = headers;
+    this.mediaType = mediaType;
+    this.hasBody = hasBody;
+    this.isFormEncoded = isFormEncoded;
+    this.isMultipart = isMultipart;
+    this.requestBuilderActions = requestBuilderActions;
+  }
+
+  Request create(Object... args) {
+    RequestBuilder requestBuilder =
+        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, mediaType, hasBody,
+            isFormEncoded, isMultipart);
+
+    if (args != null) {
+      RequestBuilderAction[] actions = requestBuilderActions;
+      for (int i = 0, count = args.length; i < count; i++) {
+        actions[i].perform(requestBuilder, args[i]);
+      }
+    }
+
+    return requestBuilder.build();
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
new file mode 100644
index 000000000..bdac016cd
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import retrofit.http.Body;
+import retrofit.http.DELETE;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.FormUrlEncoded;
+import retrofit.http.GET;
+import retrofit.http.HEAD;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+import retrofit.http.Headers;
+import retrofit.http.Multipart;
+import retrofit.http.PATCH;
+import retrofit.http.POST;
+import retrofit.http.PUT;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
+import retrofit.http.Url;
+
+import static retrofit.Utils.methodError;
+
+/** Request metadata about a service interface declaration. */
+final class RequestFactoryParser {
+  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+
+  static RequestFactory parse(Method method, BaseUrl baseUrl, Converter.Factory converterFactory) {
+    RequestFactoryParser parser = new RequestFactoryParser(method);
+    parser.parseMethodAnnotations();
+    parser.parseParameters(converterFactory);
+    return parser.toRequestFactory(baseUrl);
+  }
+
+  private final Method method;
+
+  private String httpMethod;
+  private boolean hasBody;
+  private boolean isFormEncoded;
+  private boolean isMultipart;
+  private String relativeUrl;
+  private com.squareup.okhttp.Headers headers;
+  private MediaType mediaType;
+  private RequestBuilderAction[] requestBuilderActions;
+
+  private Set<String> relativeUrlParamNames;
+
+  private RequestFactoryParser(Method method) {
+    this.method = method;
+  }
+
+  private RequestFactory toRequestFactory(BaseUrl baseUrl) {
+    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, mediaType, hasBody,
+        isFormEncoded, isMultipart, requestBuilderActions);
+  }
+
+  private RuntimeException parameterError(int index, String message, Object... args) {
+    return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
+  }
+
+  private void parseMethodAnnotations() {
+    for (Annotation annotation : method.getAnnotations()) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof Headers) {
+        String[] headersToParse = ((Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError(method, "@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    if (httpMethod == null) {
+      throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+    }
+    if (!hasBody) {
+      if (isMultipart) {
+        throw methodError(method,
+            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+      }
+      if (isFormEncoded) {
+        throw methodError(method,
+            "FormUrlEncoded can only be specified on HTTP methods with request body "
+                + "(e.g., @POST).");
+      }
+    }
+  }
+
+  private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+    if (this.httpMethod != null) {
+      throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+          this.httpMethod, httpMethod);
+    }
+    this.httpMethod = httpMethod;
+    this.hasBody = hasBody;
+
+    if (value.isEmpty()) {
+      return;
+    }
+
+    // Get the relative URL path and existing query string, if present.
+    int question = value.indexOf('?');
+    if (question != -1 && question < value.length() - 1) {
+      // Ensure the query string does not have any named parameters.
+      String queryParams = value.substring(question + 1);
+      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+      if (queryParamMatcher.find()) {
+        throw methodError(method, "URL query string \"%s\" must not have replace block. "
+            + "For dynamic query parameters use @Query.", queryParams);
+      }
+    }
+
+    this.relativeUrl = value;
+    this.relativeUrlParamNames = parsePathParameters(value);
+  }
+
+  private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
+    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
+    for (String header : headers) {
+      int colon = header.indexOf(':');
+      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+        throw methodError(method,
+            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+      }
+      String headerName = header.substring(0, colon);
+      String headerValue = header.substring(colon + 1).trim();
+      if ("Content-Type".equalsIgnoreCase(headerName)) {
+        mediaType = MediaType.parse(headerValue);
+      } else {
+        builder.add(headerName, headerValue);
+      }
+    }
+    return builder.build();
+  }
+
+  private void parseParameters(Converter.Factory converterFactory) {
+    Type[] methodParameterTypes = method.getGenericParameterTypes();
+    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+
+    boolean gotField = false;
+    boolean gotPart = false;
+    boolean gotBody = false;
+    boolean gotPath = false;
+    boolean gotQuery = false;
+    boolean gotUrl = false;
+
+    int count = methodParameterAnnotationArrays.length;
+    RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
+    for (int i = 0; i < count; i++) {
+      Type methodParameterType = methodParameterTypes[i];
+      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
+      if (methodParameterAnnotations != null) {
+        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
+          if (requestBuilderActions[i] != null) {
+            throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
+          }
+
+          if (methodParameterAnnotation instanceof Url) {
+            if (gotUrl) {
+              throw parameterError(i, "Multiple @Url method annotations found.");
+            }
+            if (gotPath) {
+              throw parameterError(i, "@Path parameters may not be used with @Url.");
+            }
+            if (gotQuery) {
+              throw parameterError(i, "A @Url parameter must not come after a @Query");
+            }
+            if (methodParameterType != String.class) {
+              throw parameterError(i, "@Url must be String type.");
+            }
+            if (relativeUrl != null) {
+              throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
+            }
+            gotUrl = true;
+            requestBuilderActions[i] = new RequestBuilderAction.Url();
+
+          } else if (methodParameterAnnotation instanceof Path) {
+            if (gotQuery) {
+              throw parameterError(i, "A @Path parameter must not come after a @Query.");
+            }
+            if (gotUrl) {
+              throw parameterError(i, "@Path parameters may not be used with @Url.");
+            }
+            if (relativeUrl == null) {
+              throw parameterError(i, "@Path can only be used with relative url on @%s",
+                  httpMethod);
+            }
+            gotPath = true;
+
+            Path path = (Path) methodParameterAnnotation;
+            String name = path.value();
+            validatePathName(i, name);
+            requestBuilderActions[i] = new RequestBuilderAction.Path(name, path.encoded());
+
+          } else if (methodParameterAnnotation instanceof Query) {
+            Query query = (Query) methodParameterAnnotation;
+            requestBuilderActions[i] =
+                new RequestBuilderAction.Query(query.value(), query.encoded());
+            gotQuery = true;
+
+          } else if (methodParameterAnnotation instanceof QueryMap) {
+            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+              throw parameterError(i, "@QueryMap parameter type must be Map.");
+            }
+            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
+            requestBuilderActions[i] = new RequestBuilderAction.QueryMap(queryMap.encoded());
+
+          } else if (methodParameterAnnotation instanceof Header) {
+            Header header = (Header) methodParameterAnnotation;
+            requestBuilderActions[i] = new RequestBuilderAction.Header(header.value());
+
+          } else if (methodParameterAnnotation instanceof Field) {
+            if (!isFormEncoded) {
+              throw parameterError(i, "@Field parameters can only be used with form encoding.");
+            }
+            Field field = (Field) methodParameterAnnotation;
+            requestBuilderActions[i] =
+                new RequestBuilderAction.Field(field.value(), field.encoded());
+            gotField = true;
+
+          } else if (methodParameterAnnotation instanceof FieldMap) {
+            if (!isFormEncoded) {
+              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
+            }
+            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+              throw parameterError(i, "@FieldMap parameter type must be Map.");
+            }
+            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
+            requestBuilderActions[i] = new RequestBuilderAction.FieldMap(fieldMap.encoded());
+            gotField = true;
+
+          } else if (methodParameterAnnotation instanceof Part) {
+            if (!isMultipart) {
+              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
+            }
+            Part part = (Part) methodParameterAnnotation;
+            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
+                "Content-Disposition", "name=\"" + part.value() + "\"",
+                "Content-Transfer-Encoding", part.encoding());
+            Converter<?> converter;
+            if (methodParameterType == RequestBody.class) {
+              converter = new OkHttpRequestBodyConverter();
+            } else {
+              if (converterFactory == null) {
+                throw parameterError(i, "@Part parameter is %s"
+                    + " but no converter factory registered. Either add a converter factory"
+                    + " to the Retrofit instance or use RequestBody.",
+                    methodParameterType);
+              }
+              converter = converterFactory.get(methodParameterType);
+            }
+            requestBuilderActions[i] = new RequestBuilderAction.Part<>(headers, converter);
+            gotPart = true;
+
+          } else if (methodParameterAnnotation instanceof PartMap) {
+            if (!isMultipart) {
+              throw parameterError(i,
+                  "@PartMap parameters can only be used with multipart encoding.");
+            }
+            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+              throw parameterError(i, "@PartMap parameter type must be Map.");
+            }
+            PartMap partMap = (PartMap) methodParameterAnnotation;
+            requestBuilderActions[i] =
+                new RequestBuilderAction.PartMap(converterFactory, partMap.encoding());
+            gotPart = true;
+
+          } else if (methodParameterAnnotation instanceof Body) {
+            if (isFormEncoded || isMultipart) {
+              throw parameterError(i,
+                  "@Body parameters cannot be used with form or multi-part encoding.");
+            }
+            if (gotBody) {
+              throw parameterError(i, "Multiple @Body method annotations found.");
+            }
+
+            Converter<?> converter;
+            if (methodParameterType == RequestBody.class) {
+              converter = new OkHttpRequestBodyConverter();
+            } else {
+              if (converterFactory == null) {
+                throw parameterError(i, "@Body parameter is %s"
+                        + " but no converter factory registered. Either add a converter factory"
+                        + " to the Retrofit instance or use RequestBody.",
+                    methodParameterType);
+              }
+              converter = converterFactory.get(methodParameterType);
+            }
+
+            requestBuilderActions[i] = new RequestBuilderAction.Body<>(converter);
+            gotBody = true;
+          }
+        }
+      }
+
+      if (requestBuilderActions[i] == null) {
+        throw parameterError(i, "No Retrofit annotation found.");
+      }
+    }
+
+    if (relativeUrl == null && !gotUrl) {
+      throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
+    }
+    if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+      throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+    }
+    if (isFormEncoded && !gotField) {
+      throw methodError(method, "Form-encoded method must contain at least one @Field.");
+    }
+    if (isMultipart && !gotPart) {
+      throw methodError(method, "Multipart method must contain at least one @Part.");
+    }
+
+    this.requestBuilderActions = requestBuilderActions;
+  }
+
+  private void validatePathName(int index, String name) {
+    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
+          PARAM_URL_REGEX.pattern(), name);
+    }
+    // Verify URL replacement name is actually present in the URL path.
+    if (!relativeUrlParamNames.contains(name)) {
+      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+    }
+  }
+
+  /**
+   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+   * in the URI, it will only show up once in the set.
+   */
+  static Set<String> parsePathParameters(String path) {
+    Matcher m = PARAM_URL_REGEX.matcher(path);
+    Set<String> patterns = new LinkedHashSet<>();
+    while (m.find()) {
+      patterns.add(m.group(1));
+    }
+    return patterns;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptor.java b/retrofit/src/main/java/retrofit/RequestInterceptor.java
deleted file mode 100644
index 406014a99..000000000
--- a/retrofit/src/main/java/retrofit/RequestInterceptor.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package retrofit;
-
-/** Intercept every request before it is executed in order to add additional data. */
-public interface RequestInterceptor {
-  /** Called for every request. Add data using methods on the supplied {@link RequestFacade}. */
-  void intercept(RequestFacade request);
-
-  interface RequestFacade {
-    /** Add a header to the request. This will not replace any existing headers. */
-    void addHeader(String name, String value);
-
-    /**
-     * Add a path parameter replacement. This works exactly like a {@link retrofit.http.Path
-     * &#64;Path}-annotated method argument.
-     */
-    void addPathParam(String name, String value);
-
-    /**
-     * Add a path parameter replacement without first URI encoding. This works exactly like a
-     * {@link retrofit.http.Path &#64;Path}-annotated method argument with {@code encode=false}.
-     */
-    void addEncodedPathParam(String name, String value);
-
-    /** Add an additional query parameter. This will not replace any existing query parameters. */
-    void addQueryParam(String name, String value);
-
-    /**
-     * Add an additional query parameter without first URI encoding. This will not replace any
-     * existing query parameters.
-     */
-    void addEncodedQueryParam(String name, String value);
-  }
-
-  /** A {@link RequestInterceptor} which does no modification of requests. */
-  RequestInterceptor NONE = new RequestInterceptor() {
-    @Override public void intercept(RequestFacade request) {
-      // Do nothing.
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
new file mode 100644
index 000000000..b3a63e616
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.ResponseBody;
+
+import static retrofit.Utils.checkNotNull;
+
+/**
+ * TODO
+ */
+public final class Response<T> {
+  /**
+   * TODO
+   */
+  public static <T> Response<T> fakeSuccess(T body) {
+    return success(body, new com.squareup.okhttp.Response.Builder() //
+        .code(200)
+        .protocol(Protocol.HTTP_1_1)
+        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+            .build())
+        .build());
+  }
+
+  /**
+   * TODO
+   */
+  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
+    return new Response<>(rawResponse, body, null);
+  }
+
+  /**
+   * TODO
+   */
+  public static <T> Response<T> fakeError(int code, ResponseBody body) {
+    return error(body, new com.squareup.okhttp.Response.Builder() //
+        .code(code)
+        .protocol(Protocol.HTTP_1_1)
+        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+            .build())
+        .build());
+  }
+
+  /**
+   * TODO
+   */
+  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
+    return new Response<>(rawResponse, null, body);
+  }
+
+  private final com.squareup.okhttp.Response rawResponse;
+  private final T body;
+  private final ResponseBody errorBody;
+
+  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+    this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
+    this.body = body;
+    this.errorBody = errorBody;
+  }
+
+  /** The raw response from the HTTP client. */
+  public com.squareup.okhttp.Response raw() {
+    return rawResponse;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return rawResponse.code();
+  }
+
+  public Headers headers() {
+    return rawResponse.headers();
+  }
+
+  /** {@code true} if {@link #code()} is in the range [200..300). */
+  public boolean isSuccess() {
+    return rawResponse.isSuccessful();
+  }
+
+  /** The deserialized response body of a {@linkplain #isSuccess() successful} response. */
+  public T body() {
+    return body;
+  }
+
+  /** The raw response body of an {@linkplain #isSuccess() unsuccessful} response. */
+  public ResponseBody errorBody() {
+    return errorBody;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
deleted file mode 100644
index afd1ff400..000000000
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.concurrent.Executor;
-import retrofit.converter.Converter;
-import retrofit.http.HTTP;
-import retrofit.http.Header;
-
-/**
- * Adapts a Java interface to a REST API.
- * <p>
- * API endpoints are defined as methods on an interface with annotations providing metadata about
- * the form in which the HTTP call should be made.
- * <p>
- * The relative path for a given method is obtained from an annotation on the method describing
- * the request type. The built-in methods are {@link retrofit.http.GET GET},
- * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.POST PATCH},
- * {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a custom
- * HTTP method with {@link HTTP @HTTP}.
- * <p>
- * Method parameters can be used to replace parts of the URL by annotating them with
- * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
- * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}.
- * <p>
- * HTTP requests happen in one of two ways:
- * <ul>
- * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
- * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
- * response will be converted to the callback's parameter type using the specified
- * {@link retrofit.converter.Converter Converter}. If the callback parameter type uses a wildcard,
- * the lower bound will be used as the conversion type.
- * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
- * response will be converted to the method's return type using the specified
- * {@link retrofit.converter.Converter Converter}.
- * </ul>
- * <p>
- * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
- * will be converted to request representation by a call to
- * {@link retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type) toBody}
- * on the supplied {@link retrofit.converter.Converter Converter} for this instance.
- * <p>
- * Alternative request body formats are supported by method annotations and corresponding parameter
- * annotations:
- * <ul>
- * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
- * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
- * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
- * specified by the {@link retrofit.http.Part @Part} parameter annotation.
- * </ul>
- * <p>
- * Additional static headers can be added for an endpoint using the
- * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
- * annotate a parameter with {@link Header @Header}.
- * <p>
- * For example:
- * <pre>
- * public interface MyApi {
- *   &#64;POST("/category/{cat}") // Asynchronous execution.
- *   void categoryList(@Path("cat") String a, @Query("page") int b,
- *                     Callback&lt;List&lt;Item&gt;&gt; cb);
- *   &#64;POST("/category/{cat}") // Synchronous execution.
- *   List&lt;Item&gt; categoryList(@Path("cat") String a, @Query("page") int b);
- * }
- * </pre>
- * <p>
- * Calling {@link #create(Class)} with {@code MyApi.class} will validate and create a new
- * implementation of the API.
- *
- * @author Bob Lee (bob@squareup.com)
- * @author Jake Wharton (jw@squareup.com)
- */
-public class RestAdapter {
-  private final Map<Class<?>, Map<Method, MethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, MethodInfo>>();
-
-  final Endpoint endpoint;
-  final Executor callbackExecutor;
-  final RequestInterceptor requestInterceptor;
-  final Converter converter;
-  final ErrorHandler errorHandler;
-
-  private final OkHttpClient client;
-  private RxSupport rxSupport;
-
-  private RestAdapter(Endpoint endpoint, OkHttpClient client, Executor callbackExecutor,
-      RequestInterceptor requestInterceptor, Converter converter, ErrorHandler errorHandler) {
-    this.endpoint = endpoint;
-    this.client = client;
-    this.callbackExecutor = callbackExecutor;
-    this.requestInterceptor = requestInterceptor;
-    this.converter = converter;
-    this.errorHandler = errorHandler;
-  }
-
-  /** Create an implementation of the API defined by the specified {@code service} interface. */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler(getMethodInfoCache(service)));
-  }
-
-  Map<Method, MethodInfo> getMethodInfoCache(Class<?> service) {
-    synchronized (serviceMethodInfoCache) {
-      Map<Method, MethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
-      if (methodInfoCache == null) {
-        methodInfoCache = new LinkedHashMap<Method, MethodInfo>();
-        serviceMethodInfoCache.put(service, methodInfoCache);
-      }
-      return methodInfoCache;
-    }
-  }
-
-  static MethodInfo getMethodInfo(Map<Method, MethodInfo> cache, Method method) {
-    synchronized (cache) {
-      MethodInfo methodInfo = cache.get(method);
-      if (methodInfo == null) {
-        methodInfo = new MethodInfo(method);
-        cache.put(method, methodInfo);
-      }
-      return methodInfo;
-    }
-  }
-
-  private class RestHandler implements InvocationHandler {
-    private final Map<Method, MethodInfo> methodDetailsCache;
-
-    RestHandler(Map<Method, MethodInfo> methodDetailsCache) {
-      this.methodDetailsCache = methodDetailsCache;
-    }
-
-    @SuppressWarnings("unchecked") //
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      MethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-      Request request = createRequest(methodInfo, args);
-      switch (methodInfo.executionType) {
-        case SYNC:
-          return invokeSync(methodInfo, request);
-        case ASYNC:
-          invokeAsync(methodInfo, request, (Callback) args[args.length - 1]);
-          return null; // Async has void return type.
-        case RX:
-          return invokeRx(methodInfo, request);
-        default:
-          throw new IllegalStateException("Unknown response type: " + methodInfo.executionType);
-      }
-    }
-
-    private Object invokeSync(MethodInfo methodInfo, Request request) throws Throwable {
-      try {
-        Response response = client.newCall(request).execute();
-        return createResult(methodInfo, response);
-      } catch (IOException e) {
-        throw handleError(RetrofitError.networkFailure(request.urlString(), e));
-      } catch (RetrofitError error) {
-        throw handleError(error);
-      }
-    }
-
-    private Throwable handleError(RetrofitError error) {
-      Throwable throwable = errorHandler.handleError(error);
-      if (throwable == null) {
-        return new IllegalStateException("Error handler returned null for wrapped exception.",
-            error);
-      }
-      return throwable;
-    }
-
-    private void invokeAsync(final MethodInfo methodInfo, final Request request,
-        final Callback callback) {
-      Call call = client.newCall(request);
-      call.enqueue(new com.squareup.okhttp.Callback() {
-        @Override public void onFailure(Request request, IOException e) {
-          callFailure(callback, RetrofitError.networkFailure(request.urlString(), e));
-        }
-
-        @Override public void onResponse(Response response) {
-          try {
-            Object result = createResult(methodInfo, response);
-            callResponse(callback, result, response);
-          } catch (RetrofitError error) {
-            callFailure(callback, error);
-          }
-        }
-      });
-    }
-
-    private Object invokeRx(final MethodInfo methodInfo, final Request request) {
-      if (rxSupport == null) {
-        if (Platform.HAS_RX_JAVA) {
-          rxSupport = new RxSupport();
-        } else {
-          throw new IllegalStateException("Found Observable return type but RxJava not present.");
-        }
-      }
-      return rxSupport.createRequestObservable(new RxSupport.Invoker() {
-        @Override public void invoke(final Callback callback) {
-          Call call = client.newCall(request);
-          call.enqueue(new com.squareup.okhttp.Callback() {
-            @Override public void onFailure(Request request, IOException e) {
-              callback.next(RetrofitError.networkFailure(request.urlString(), e));
-            }
-
-            @Override public void onResponse(Response response) {
-              try {
-                Object result = createResult(methodInfo, response);
-                callback.next(result);
-              } catch (RetrofitError error) {
-                callback.error(handleError(error));
-              }
-            }
-          });
-
-        }
-      });
-    }
-
-    /**
-     * Create the object to return to the caller for a response.
-     *
-     * @throws RetrofitError if any HTTP, network, or unexpected errors occurred.
-     */
-    private Object createResult(MethodInfo methodInfo, Response response) {
-      try {
-        return parseResult(methodInfo, response);
-      } catch (RetrofitError error) {
-        throw error; // Let our own errors pass through.
-      } catch (IOException e) {
-        throw RetrofitError.networkError(response, e);
-      } catch (Throwable t) {
-        throw RetrofitError.unexpectedError(response, t);
-      }
-    }
-
-    /**
-     * Parse the object to return to the caller from a response.
-     *
-     * @throws RetrofitError on non-2xx response codes (kind = HTTP).
-     * @throws IOException on network problems reading the response data.
-     * @throws RuntimeException on malformed response data.
-     */
-    private Object parseResult(MethodInfo methodInfo, Response response)
-        throws IOException {
-      Type type = methodInfo.responseObjectType;
-
-      int statusCode = response.code();
-      if (statusCode < 200 || statusCode >= 300) {
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(response, converter, type);
-      }
-
-      if (type.equals(Response.class)) {
-        if (!methodInfo.isStreaming) {
-          // Read the entire stream and replace with one backed by a byte[].
-          response = Utils.readBodyToBytesIfNecessary(response);
-        }
-        return response;
-      }
-
-      ResponseBody body = response.body();
-      if (body == null) {
-        return null;
-      }
-
-      ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(body);
-      try {
-        return converter.fromBody(wrapped, type);
-      } catch (RuntimeException e) {
-        // If the underlying input stream threw an exception, propagate that rather than
-        // indicating that it was a conversion exception.
-        if (wrapped.threwException()) {
-          throw wrapped.getThrownException();
-        }
-        throw e;
-      }
-    }
-
-    private void callResponse(final Callback callback, final Object result,
-        final Response response) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.success(result, response);
-        }
-      });
-    }
-
-    private void callFailure(final Callback callback, RetrofitError error) {
-      Throwable throwable = handleError(error);
-      if (throwable != error) {
-        Response response = error.getResponse();
-        if (response != null) {
-          error = RetrofitError.unexpectedError(response, throwable);
-        } else {
-          error = RetrofitError.unexpectedError(error.getUrl(), throwable);
-        }
-      }
-      final RetrofitError finalError = error;
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.failure(finalError);
-        }
-      });
-    }
-
-    private Request createRequest(MethodInfo methodInfo, Object[] args) {
-      String serverUrl = endpoint.url();
-      RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
-      requestBuilder.setArguments(args);
-
-      requestInterceptor.intercept(requestBuilder);
-
-      return requestBuilder.build();
-    }
-  }
-
-  /**
-   * Build a new {@link RestAdapter}.
-   * <p>
-   * Calling {@link #setEndpoint} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static class Builder {
-    private Endpoint endpoint;
-    private OkHttpClient client;
-    private Executor callbackExecutor;
-    private RequestInterceptor requestInterceptor;
-    private Converter converter;
-    private ErrorHandler errorHandler;
-
-    /** API endpoint URL. */
-    public Builder setEndpoint(String url) {
-       return setEndpoint(Endpoint.createFixed(url));
-    }
-
-    /** API endpoint. */
-    public Builder setEndpoint(Endpoint endpoint) {
-      if (endpoint == null) {
-        throw new NullPointerException("Endpoint may not be null.");
-      }
-      this.endpoint = endpoint;
-      return this;
-    }
-
-    /** The HTTP client used for requests. */
-    public Builder setClient(OkHttpClient client) {
-      if (client == null) {
-        throw new NullPointerException("Client may not be null.");
-      }
-      this.client = client;
-      return this;
-    }
-
-    /**
-     * Executor on which any {@link Callback} methods will be invoked. If this argument is
-     * {@code null} then callback methods will be run on the same thread as the HTTP client.
-     */
-    public Builder setCallbackExecutor(Executor callbackExecutor) {
-      if (callbackExecutor == null) {
-        callbackExecutor = new Utils.SynchronousExecutor();
-      }
-      this.callbackExecutor = callbackExecutor;
-      return this;
-    }
-
-    /** A request interceptor for adding data to every request. */
-    public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
-      if (requestInterceptor == null) {
-        throw new NullPointerException("Request interceptor may not be null.");
-      }
-      this.requestInterceptor = requestInterceptor;
-      return this;
-    }
-
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder setConverter(Converter converter) {
-      if (converter == null) {
-        throw new NullPointerException("Converter may not be null.");
-      }
-      this.converter = converter;
-      return this;
-    }
-
-    /**
-     * The error handler allows you to customize the type of exception thrown for errors on
-     * synchronous requests.
-     */
-    public Builder setErrorHandler(ErrorHandler errorHandler) {
-      if (errorHandler == null) {
-        throw new NullPointerException("Error handler may not be null.");
-      }
-      this.errorHandler = errorHandler;
-      return this;
-    }
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
-      if (endpoint == null) {
-        throw new IllegalArgumentException("Endpoint may not be null.");
-      }
-      ensureSaneDefaults();
-      return new RestAdapter(endpoint, client, callbackExecutor, requestInterceptor, converter,
-          errorHandler);
-    }
-
-    private void ensureSaneDefaults() {
-      if (converter == null) {
-        converter = Platform.get().defaultConverter();
-      }
-      if (client == null) {
-        client = Platform.get().defaultClient();
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = Platform.get().defaultCallbackExecutor();
-      }
-      if (errorHandler == null) {
-        errorHandler = ErrorHandler.DEFAULT;
-      }
-      if (requestInterceptor == null) {
-        requestInterceptor = RequestInterceptor.NONE;
-      }
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
new file mode 100644
index 000000000..b50751631
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+
+import static retrofit.Utils.checkNotNull;
+
+/**
+ * Adapts a Java interface to a REST API.
+ * <p>
+ * API endpoints are defined as methods on an interface with annotations providing metadata about
+ * the form in which the HTTP call should be made.
+ * <p>
+ * The relative path for a given method is obtained from an annotation on the method describing
+ * the request type. The built-in methods are {@link retrofit.http.GET GET},
+ * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.PATCH
+ * PATCH}, {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a
+ * custom HTTP method with {@link HTTP @HTTP}.
+ * <p>
+ * Method parameters can be used to replace parts of the URL by annotating them with
+ * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
+ * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+ * {@link retrofit.http.Query @Query}.
+ * <p>
+ * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
+ * will be converted to request representation by a call to
+ * {@link Converter#toBody(Object) toBody}
+ * on the supplied {@link Converter} for this instance. A {@link RequestBody} can also be used
+ * which will not use the {@code Converter}.
+ * <p>
+ * Alternative request body formats are supported by method annotations and corresponding parameter
+ * annotations:
+ * <ul>
+ * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+ * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
+ * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
+ * specified by the {@link retrofit.http.Part @Part} parameter annotation.
+ * </ul>
+ * <p>
+ * Additional static headers can be added for an endpoint using the
+ * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
+ * annotate a parameter with {@link Header @Header}.
+ * <p>
+ * By default, methods return a {@link Call} which represents the HTTP request. The generic
+ * parameter of the call is the response body type and will be converted by a call to
+ * {@link Converter#fromBody(ResponseBody) fromBody} on the supplied {@link Converter} for
+ * this instance. {@link ResponseBody} can also be used which will not use the {@code Converter}.
+ * <p>
+ * For example:
+ * <pre>
+ * public interface CategoryService {
+ *   &#64;POST("/category/{cat}")
+ *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+ * }
+ * </pre>
+ * <p>
+ * Calling {@link #create(Class) create()} with {@code CategoryService.class} will validate the
+ * annotations and create a new implementation of the service definition.
+ *
+ * @author Bob Lee (bob@squareup.com)
+ * @author Jake Wharton (jw@squareup.com)
+ */
+public final class Retrofit {
+  private final Map<Method, MethodHandler<?>> methodHandlerCache = new LinkedHashMap<>();
+
+  private final OkHttpClient client;
+  private final BaseUrl baseUrl;
+  private final Converter.Factory converterFactory;
+  private final CallAdapter.Factory adapterFactory;
+  private final Executor callbackExecutor;
+
+  private Retrofit(OkHttpClient client, BaseUrl baseUrl, Converter.Factory converterFactory,
+      CallAdapter.Factory adapterFactory, Executor callbackExecutor) {
+    this.client = client;
+    this.baseUrl = baseUrl;
+    this.converterFactory = converterFactory;
+    this.adapterFactory = adapterFactory;
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  /** Create an implementation of the API defined by the {@code service} interface. */
+  @SuppressWarnings("unchecked") // Single interface proxy creation guarded by parameter safety.
+  public <T> T create(Class<T> service) {
+    Utils.validateServiceClass(service);
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
+        handler);
+  }
+
+  private final InvocationHandler handler = new InvocationHandler() {
+    @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable {
+      // If the method is a method from Object then defer to normal invocation.
+      if (method.getDeclaringClass() == Object.class) {
+        return method.invoke(this, args);
+      }
+      return loadMethodHandler(method).invoke(args);
+    }
+  };
+
+  MethodHandler<?> loadMethodHandler(Method method) {
+    MethodHandler<?> handler;
+    synchronized (methodHandlerCache) {
+      handler = methodHandlerCache.get(method);
+      if (handler == null) {
+        handler = MethodHandler.create(method, client, baseUrl, adapterFactory, converterFactory);
+        methodHandlerCache.put(method, handler);
+      }
+    }
+    return handler;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public BaseUrl baseUrl() {
+    return baseUrl;
+  }
+
+  /**
+   * TODO
+   * <p>
+   * May be null.
+   */
+  public Converter.Factory converterFactory() {
+    return converterFactory;
+  }
+
+  public CallAdapter.Factory callAdapterFactory() {
+    return adapterFactory;
+  }
+
+  public Executor callbackExecutor() {
+    return callbackExecutor;
+  }
+
+  /**
+   * Build a new {@link Retrofit}.
+   * <p>
+   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+   * are optional.
+   */
+  public static final class Builder {
+    private OkHttpClient client;
+    private BaseUrl baseUrl;
+    private Converter.Factory converterFactory;
+    private CallAdapter.Factory adapterFactory;
+    private Executor callbackExecutor;
+
+    /** The HTTP client used for requests. */
+    public Builder client(OkHttpClient client) {
+      this.client = checkNotNull(client, "client == null");
+      return this;
+    }
+
+    /** API base URL. */
+    public Builder baseUrl(String baseUrl) {
+      checkNotNull(baseUrl, "baseUrl == null");
+      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+      if (httpUrl == null) {
+        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+      }
+      return baseUrl(httpUrl);
+    }
+
+    /** API base URL. */
+    public Builder baseUrl(final HttpUrl baseUrl) {
+      checkNotNull(baseUrl, "baseUrl == null");
+      return baseUrl(new BaseUrl() {
+        @Override public HttpUrl url() {
+          return baseUrl;
+        }
+      });
+    }
+
+    /** API base URL. */
+    public Builder baseUrl(BaseUrl baseUrl) {
+      this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
+      return this;
+    }
+
+    /** The converter used for serialization and deserialization of objects. */
+    public Builder converterFactory(Converter.Factory converterFactory) {
+      this.converterFactory = checkNotNull(converterFactory, "converterFactory == null");
+      return this;
+    }
+
+    /**
+     * TODO
+     */
+    public Builder callAdapterFactory(CallAdapter.Factory factory) {
+      this.adapterFactory = checkNotNull(factory, "factory == null");
+      return this;
+    }
+
+    /**
+     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+     * your service method.
+     */
+    public Builder callbackExecutor(Executor callbackExecutor) {
+      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
+      return this;
+    }
+
+    /** Create the {@link Retrofit} instances. */
+    public Retrofit build() {
+      if (baseUrl == null) {
+        throw new IllegalStateException("Base URL required.");
+      }
+
+      // Set any platform-appropriate defaults for unspecified components.
+      if (client == null) {
+        client = Platform.get().defaultClient();
+      }
+      if (adapterFactory == null) {
+        adapterFactory = Platform.get().defaultCallAdapterFactory(callbackExecutor);
+      }
+
+      return new Retrofit(client, baseUrl, converterFactory, adapterFactory, callbackExecutor);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
deleted file mode 100644
index f604ac583..000000000
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import retrofit.converter.Converter;
-
-public class RetrofitError extends RuntimeException {
-  public static RetrofitError networkFailure(String url, IOException exception) {
-    return new RetrofitError(exception.getMessage(), url, null, null, null, Kind.NETWORK,
-        exception);
-  }
-
-  public static RetrofitError networkError(Response response, IOException exception) {
-    response = response.newBuilder().body(null).build(); // Remove any body.
-    return new RetrofitError(exception.getMessage(), response.request().urlString(), null, null,
-        null, Kind.NETWORK, exception);
-  }
-
-  public static RetrofitError httpError(Response response, Converter converter, Type successType) {
-    String message = response.code() + " " + response.message();
-    return new RetrofitError(message, response.request().urlString(), response, converter,
-        successType, Kind.HTTP, null);
-  }
-
-  public static RetrofitError unexpectedError(Response response, Throwable exception) {
-    response = response.newBuilder().body(null).build(); // Remove any body.
-    return new RetrofitError(exception.getMessage(), response.request().urlString(), response,
-        null, null, Kind.UNEXPECTED, exception);
-  }
-
-  public static RetrofitError unexpectedError(String url, Throwable exception) {
-    return new RetrofitError(exception.getMessage(), url, null, null, null, Kind.UNEXPECTED,
-        exception);
-  }
-
-  /** Identifies the event kind which triggered a {@link RetrofitError}. */
-  public enum Kind {
-    /** An {@link IOException} occurred while communicating to the server. */
-    NETWORK,
-    /** A non-200 HTTP status code was received from the server. */
-    HTTP,
-    /**
-     * An internal error occurred while attempting to execute a request. It is best practice to
-     * re-throw this exception so your application crashes.
-     */
-    UNEXPECTED
-  }
-
-  private final String url;
-  private final Response response;
-  private final Converter converter;
-  private final Type successType;
-  private final Kind kind;
-
-  RetrofitError(String message, String url, Response response, Converter converter,
-      Type successType, Kind kind, Throwable exception) {
-    super(message, exception);
-    this.url = url;
-    this.response = response;
-    this.converter = converter;
-    this.successType = successType;
-    this.kind = kind;
-  }
-
-  /** The request URL which produced the error. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Response object containing status code, headers, body, etc. */
-  public Response getResponse() {
-    return response;
-  }
-
-  /** The event kind which triggered this error. */
-  public Kind getKind() {
-    return kind;
-  }
-
-  /**
-   * HTTP response body converted to the type declared by either the interface method return type
-   * or the generic type of the supplied {@link Callback} parameter. {@code null} if there is no
-   * response.
-   *
-   * @throws RuntimeException if unable to convert the body to the {@link #getSuccessType() success
-   * type}.
-   */
-  public Object getBody() {
-    return getBodyAs(successType);
-  }
-
-  /**
-   * The type declared by either the interface method return type or the generic type of the
-   * supplied {@link Callback} parameter.
-   */
-  public Type getSuccessType() {
-    return successType;
-  }
-
-  /**
-   * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
-   *
-   * @throws RuntimeException if unable to convert the body to the specified {@code type}.
-   */
-  public Object getBodyAs(Type type) {
-    if (response == null) {
-      return null;
-    }
-    ResponseBody body = response.body();
-    if (body == null) {
-      return null;
-    }
-    try {
-      return converter.fromBody(body, type);
-    } catch (IOException e) {
-      throw new RuntimeException(e); // Body is a Buffer, can't be a real IO exception.
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RxSupport.java b/retrofit/src/main/java/retrofit/RxSupport.java
deleted file mode 100644
index 80295b8c3..000000000
--- a/retrofit/src/main/java/retrofit/RxSupport.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package retrofit;
-
-import rx.Observable;
-import rx.Subscriber;
-
-/**
- * Utilities for supporting RxJava Observables.
- * <p>
- * RxJava might not be on the available to use. Check {@link Platform#HAS_RX_JAVA} before calling.
- */
-final class RxSupport {
-  interface Invoker {
-    void invoke(Callback callback);
-
-    interface Callback {
-      void next(Object o);
-      void error(Throwable t);
-    }
-  }
-
-  RxSupport() {
-  }
-
-  Observable createRequestObservable(final Invoker invoker) {
-    return Observable.create(new Observable.OnSubscribe<Object>() {
-      @Override public void call(final Subscriber<? super Object> subscriber) {
-        invoker.invoke(new Invoker.Callback() {
-          @Override public void next(Object o) {
-            if (!subscriber.isUnsubscribed()) {
-              subscriber.onNext(o);
-              subscriber.onCompleted();
-            }
-          }
-
-          @Override public void error(Throwable t) {
-            if (!subscriber.isUnsubscribed()) {
-              subscriber.onError(t);
-            }
-          }
-        });
-      }
-    });
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Types.java b/retrofit/src/main/java/retrofit/Types.java
deleted file mode 100644
index da28b1197..000000000
--- a/retrofit/src/main/java/retrofit/Types.java
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.GenericDeclaration;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.NoSuchElementException;
-
-/**
- * Static methods for working with types.
- *
- * @author Bob Lee
- * @author Jesse Wilson
- */
-final class Types {
-  private static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
-
-  private Types() {
-    // No instances.
-  }
-
-  public static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
-    }
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  public static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
-    }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
-    }
-
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
-
-    // We can't resolve this further.
-    return toResolve;
-  }
-
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
-    }
-    throw new NoSuchElementException();
-  }
-
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  private static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  public static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
-        }
-
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
-
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
-
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
-        }
-        return original;
-
-      } else {
-        return toResolve;
-      }
-    }
-  }
-
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
-
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
-
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  private static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
-    }
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
-    }
-
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
-    }
-
-    @Override public Type getRawType() {
-      return rawType;
-    }
-
-    @Override public Type getOwnerType() {
-      return ownerType;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);
-    }
-
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
-    }
-
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
-    }
-  }
-
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
-
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
-
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Types.equals(this, (GenericArrayType) o);
-    }
-
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
-
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
-
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
-
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Types.equals(this, (WildcardType) other);
-    }
-
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
-    }
-
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index abe79ab44..e90cd3c73 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,31 +16,45 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+import java.io.Closeable;
 import java.io.IOException;
-import java.util.concurrent.Executor;
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Source;
 
 final class Utils {
-  static <T> T checkNotNull(T object, String message, Object... args) {
+  static <T> T checkNotNull(T object, String message) {
     if (object == null) {
-      throw new NullPointerException(String.format(message, args));
+      throw new NullPointerException(message);
     }
     return object;
   }
 
+  static void closeQuietly(Closeable closeable) {
+    if (closeable == null) return;
+    try {
+      closeable.close();
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Replace a {@link Response} with an identical copy whose body is backed by a
    * {@link Buffer} rather than a {@link Source}.
    */
-  static Response readBodyToBytesIfNecessary(Response response) throws IOException {
-    final ResponseBody body = response.body();
+  static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws IOException {
     if (body == null) {
-      return response;
+      return null;
     }
 
     BufferedSource source = body.source();
@@ -48,26 +62,12 @@ static Response readBodyToBytesIfNecessary(Response response) throws IOException
     buffer.writeAll(source);
     source.close();
 
-    return response.newBuilder()
-        .body(new ResponseBody() {
-          @Override public MediaType contentType() {
-            return body.contentType();
-          }
-
-          @Override public long contentLength() {
-            return buffer.size();
-          }
-
-          @Override public BufferedSource source() {
-            return buffer.clone();
-          }
-        })
-        .build();
+    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
   static <T> void validateServiceClass(Class<T> service) {
     if (!service.isInterface()) {
-      throw new IllegalArgumentException("Only interface endpoint definitions are supported.");
+      throw new IllegalArgumentException("Only interface baseUrl definitions are supported.");
     }
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
@@ -77,10 +77,103 @@ static Response readBodyToBytesIfNecessary(Response response) throws IOException
     }
   }
 
-  static class SynchronousExecutor implements Executor {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
+  public static Type getSingleParameterUpperBound(ParameterizedType type) {
+    Type[] types = type.getActualTypeArguments();
+    if (types.length != 1) {
+      throw new IllegalArgumentException(
+          "Expected one type argument but got: " + Arrays.toString(types));
+    }
+    Type paramType = types[0];
+    if (paramType instanceof WildcardType) {
+      return ((WildcardType) paramType).getUpperBounds()[0];
+    }
+    return paramType;
+  }
+
+  public static boolean hasUnresolvableType(Type type) {
+    if (type instanceof Class<?>) {
+      return false;
+    }
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+        if (hasUnresolvableType(typeArgument)) {
+          return true;
+        }
+      }
+      return false;
+    }
+    if (type instanceof GenericArrayType) {
+      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+    }
+    if (type instanceof TypeVariable) {
+      return true;
+    }
+    if (type instanceof WildcardType) {
+      return true;
+    }
+    String className = type == null ? "null" : type.getClass().getName();
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+        + "GenericArrayType, but <" + type + "> is of type " + className);
+  }
+
+  // This method is copyright 2008 Google Inc. and is taken from Gson under the Apache 2.0 license.
+  public static Class<?> getRawType(Type type) {
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+
+    } else if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+
+    } else if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+
+    } else if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    } else {
+      String className = type == null ? "null" : type.getClass().getName();
+      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+  }
+
+  static RuntimeException methodError(Method method, String message, Object... args) {
+    message = String.format(message, args);
+    return new IllegalArgumentException(message
+        + "\n    for method "
+        + method.getDeclaringClass().getSimpleName()
+        + "."
+        + method.getName());
+  }
+
+  static Type getCallResponseType(Type returnType) {
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    final Type responseType = getSingleParameterUpperBound((ParameterizedType) returnType);
+
+    // Ensure the Call response type is not Response, we automatically deliver the Response object.
+    if (getRawType(responseType) == retrofit.Response.class) {
+      throw new IllegalArgumentException(
+          "Call<T> cannot use Response as its generic parameter. "
+              + "Specify the response body type only (e.g., Call<TweetResponse>).");
     }
+    return responseType;
   }
 
   private Utils() {
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
deleted file mode 100644
index 7240dc15e..000000000
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.converter;
-
-import com.google.gson.Gson;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Type;
-import java.nio.charset.Charset;
-
-/**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- */
-public class GsonConverter implements Converter {
-  private final Gson gson;
-  private final Charset charset;
-  private final MediaType mediaType;
-
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter() {
-    this(new Gson());
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, Charset.forName("UTF-8"));
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
-   */
-  public GsonConverter(Gson gson, Charset charset) {
-    if (gson == null) throw new NullPointerException("gson == null");
-    if (charset == null) throw new NullPointerException("charset == null");
-    this.gson = gson;
-    this.charset = charset;
-    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    Charset charset = this.charset;
-    if (body.contentType() != null) {
-      charset = body.contentType().charset(charset);
-    }
-
-    InputStream is = body.byteStream();
-    try {
-      return gson.fromJson(new InputStreamReader(is, charset), type);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    String json = gson.toJson(object, type);
-    return RequestBody.create(mediaType, json);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/Body.java b/retrofit/src/main/java/retrofit/http/Body.java
index 393a5e14f..782559502 100644
--- a/retrofit/src/main/java/retrofit/http/Body.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -18,6 +18,8 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,8 +27,8 @@
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body). The object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
- * {@link retrofit.converter.Converter Converter} and the result will be set directly as the
+ * body). The object will be serialized using the {@link Retrofit Retrofit} instance
+ * {@link Converter Converter} and the result will be set directly as the
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index 6f13b99fe..1f7dbdc5b 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
index fce09d9c0..bfe020ec0 100644
--- a/retrofit/src/main/java/retrofit/http/Field.java
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -57,9 +57,6 @@
 public @interface Field {
   String value();
 
-  /** Specifies whether {@link #value()} is URL encoded. */
-  boolean encodeName() default true;
-
-  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
-  boolean encodeValue() default true;
+  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/FieldMap.java b/retrofit/src/main/java/retrofit/http/FieldMap.java
index 09b6f4c0d..97c5684a2 100644
--- a/retrofit/src/main/java/retrofit/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit/http/FieldMap.java
@@ -44,9 +44,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
-  /** Specifies whether parameter names (keys in the map) are URL encoded. */
-  boolean encodeNames() default true;
-
-  /** Specifies whether parameter values (values in the map) are URL encoded. */
-  boolean encodeValues() default true;
+  /** Specifies whether the names and values are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index de81a111c..b2dd2a4cf 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface GET {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index b73685295..9ae6f7adc 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HEAD {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/HTTP.java b/retrofit/src/main/java/retrofit/http/HTTP.java
index 759c5939f..f699bbe7d 100644
--- a/retrofit/src/main/java/retrofit/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -27,6 +27,6 @@
 @Retention(RUNTIME)
 public @interface HTTP {
   String method();
-  String path();
+  String path() default "";
   boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/PATCH.java b/retrofit/src/main/java/retrofit/http/PATCH.java
index 83b061978..2788ee8f0 100644
--- a/retrofit/src/main/java/retrofit/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit/http/PATCH.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PATCH {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index b1f7b1088..0d39b2d1a 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface POST {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index 915df56d7..5c382e33d 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PUT {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 573a46d04..154af6086 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -29,8 +30,8 @@
  * <ul>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
- * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Retrofit#converterFactory() a converter}.</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index 0e9a292f3..512f3545f 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -29,8 +30,8 @@
  * <ul>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
- * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Retrofit#converterFactory() a converter}.</li>
  * </ul>
  * <p>
  * <pre>
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
index 6a9deecf3..0a3afa4e8 100644
--- a/retrofit/src/main/java/retrofit/http/Path.java
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -52,6 +52,8 @@
 public @interface Path {
   String value();
 
-  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
-  boolean encode() default true;
+  /**
+   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+   */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
index f4cd0fd46..8e53a9c6a 100644
--- a/retrofit/src/main/java/retrofit/http/Query.java
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -49,23 +49,15 @@
  * void list(@Query("category") String... categories);
  * </pre>
  * Calling with {@code foo.list("bar", "baz")} yields
- * {@code /list?category=foo&category=bar}.
+ * {@code /list?category=bar&category=baz}.
  * <p>
- * Parameter names are not URL encoded. Specify {@link #encodeName() encodeName=true} to change
- * this behavior.
+ * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
+ * to change this behavior.
  * <pre>
  * &#64;GET("/search")
- * void list(@Query(value="foo+bar", encodeName=true) String foobar);
+ * void list(@Query(value="foo", encoded=true) String foo);
  * </pre>
- * Calling with {@code foo.list("baz")} yields {@code /search?foo%2Bbar=foo}.
- * <p>
- * Parameter values are URL encoded by default. Specify {@link #encodeValue() encodeValue=false} to
- * change this behavior.
- * <pre>
- * &#64;GET("/search")
- * void list(@Query(value="foo", encodeValue=false) String foo);
- * </pre>
- * Calling with {@code foo.list("foo+foo"))} yields {@code /search?foo=foo+bar}.
+ * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
  *
  * @see QueryMap
  */
@@ -76,9 +68,8 @@
   /** The query parameter name. */
   String value();
 
-  /** Specifies whether {@link #value()} is URL encoded. */
-  boolean encodeName() default false;
-
-  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
-  boolean encodeValue() default true;
+  /**
+   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+   */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/QueryMap.java b/retrofit/src/main/java/retrofit/http/QueryMap.java
index a6a5e3c28..6aaaab78f 100644
--- a/retrofit/src/main/java/retrofit/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit/http/QueryMap.java
@@ -37,20 +37,11 @@
  * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
  * {@code /search?foo=bar&kit=kat}.
  * <p>
- * Map keys representing the parameter names are not URL encoded. Specify
- * {@link #encodeNames() encodeNames=true} to change this behavior.
+ * Map keys and values representing parameter values are URL encoded by default. Specify
+ * {@link #encoded() encoded=true} to change this behavior.
  * <pre>
  * &#64;GET("/search")
- * void list(@QueryMap(encodeNames=true) Map&lt;String, String&gt; filters);
- * </pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo+bar", "foo+bar"))} yields
- * {@code /search?foo%2Bbar=foo}.
- * <p>
- * Map values representing parameter values are URL encoded by default. Specify
- * {@link #encodeValues() encodeValues=false} to change this behavior.
- * <pre>
- * &#64;GET("/search")
- * void list(@QueryMap(encodeValues=false) Map&lt;String, String&gt; filters);
+ * void list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * </pre>
  * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+foo"))} yields
  * {@code /search?foo=foo%2Bbar}.
@@ -61,9 +52,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
-  /** Specifies whether parameter names (keys in the map) are URL encoded. */
-  boolean encodeNames() default false;
-
-  /** Specifies whether parameter values (values in the map) are URL encoded. */
-  boolean encodeValues() default true;
+  /** Specifies whether parameter names and values are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Url.java b/retrofit/src/main/java/retrofit/http/Url.java
new file mode 100644
index 000000000..b953a3060
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Url.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import retrofit.Retrofit;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Relative URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
+ * <pre>
+ * &#64;GET
+ * void list(@Url String url);
+ * </pre>
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Url {
+}
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
new file mode 100644
index 000000000..b03372369
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+import retrofit.http.Streaming;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class CallTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface Service {
+    @GET("/") Call<String> getString();
+    @GET("/") Call<ResponseBody> getBody();
+    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
+    @POST("/") Call<String> postString(@Body String body);
+  }
+
+  @Test public void http200Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http200Async() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void failure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Async() throws InterruptedException, IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void failure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void transportProblemSync() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    Call<String> call = example.getString();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void transportProblemAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Throwable failure = failureRef.get();
+    assertThat(failure).isInstanceOf(IOException.class);
+  }
+
+  @Test public void conversionProblemOutgoingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public RequestBody toBody(Object value) {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    Call<String> call = example.postString("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public RequestBody toBody(Object value) {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postString("Hi").enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void conversionProblemIncomingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.postString("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
+    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
+    OkHttpClient client = new OkHttpClient();
+    client.interceptors().add(new Interceptor() {
+      @Override public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
+        com.squareup.okhttp.Response response = chain.proceed(chain.request());
+        ResponseBody body = response.body();
+        BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public long read(Buffer sink, long byteCount) throws IOException {
+            throw new IOException("cause");
+          }
+        });
+        body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+        return response.newBuilder().body(body).build();
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .client(client)
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                try {
+                  return super.fromBody(body);
+                } catch (IOException e) {
+                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                  throw new RuntimeException("wrapper", e);
+                }
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("cause");
+    }
+  }
+
+  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter<?> get(Type type) {
+            return new StringConverter() {
+              @Override public String fromBody(ResponseBody body) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postString("Hi").enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void http204SkipsConverter() throws IOException {
+    final Converter converter = spy(new ToStringConverterFactory.StringConverter());
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter get(Type type) {
+            return converter;
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.code()).isEqualTo(204);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void http205SkipsConverter() throws IOException {
+    final Converter converter = spy(new ToStringConverterFactory.StringConverter());
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory() {
+          @Override public Converter get(Type type) {
+            return converter;
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.code()).isEqualTo(205);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("1234"));
+
+    Response<ResponseBody> response = example.getBody().execute();
+    assertThat(response.body().string()).isEqualTo("1234");
+  }
+
+  @Test public void responseBodyBuffers() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call<ResponseBody> buffered = example.getBody();
+    // When buffering we will detect all socket problems before returning the Response.
+    try {
+      buffered.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
+  }
+
+  @Test public void responseBodyStreams() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+    Response<ResponseBody> response = example.getStreamingBody().execute();
+
+    ResponseBody streamedBody = response.body();
+    // When streaming we only detect socket problems as the ResponseBody is read.
+    try {
+      streamedBody.string();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
+  }
+
+  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+    ResponseBody rawBody = response.raw().body();
+    assertThat(rawBody.contentLength()).isEqualTo(2);
+    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
+    try {
+      rawBody.source();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("");
+    ResponseBody rawBody = response.raw().body();
+    assertThat(rawBody.contentLength()).isEqualTo(0);
+    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
+  }
+
+  @Test public void cancelThrowsBeforeExecute() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+    Call<String> call = service.getString();
+
+    try {
+      call.cancel();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("enqueue or execute must be called first");
+    }
+  }
+
+  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = service.getString();
+    assertThat(call.execute().body()).isEqualTo("Hi");
+
+    Call<String> cloned = call.clone();
+    try {
+      cloned.cancel();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("enqueue or execute must be called first");
+    }
+  }
+
+  @Test public void cancelRequest() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    Call<String> call = service.getString();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void success(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    call.cancel();
+
+    assertTrue(latch.await(2, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/EndpointsTest.java b/retrofit/src/test/java/retrofit/EndpointsTest.java
deleted file mode 100644
index 50c41dcf3..000000000
--- a/retrofit/src/test/java/retrofit/EndpointsTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2014 Square, Inc.
-package retrofit;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class EndpointsTest {
-  @Test public void endpoint() {
-    Endpoint endpoint = Endpoint.createFixed("http://example.com");
-    assertThat(endpoint.url()).isEqualTo("http://example.com");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
deleted file mode 100644
index 6de8d00f4..000000000
--- a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import org.junit.Before;
-import org.junit.Test;
-import retrofit.http.GET;
-import rx.Observable;
-import rx.Observer;
-
-import static com.squareup.okhttp.Protocol.HTTP_1_1;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-
-public class ErrorHandlerTest {
-
-  interface ExampleClient {
-    @GET("/")
-    Response throwsCustomException() throws TestException;
-
-    @GET("/")
-    void onErrorWrappedCustomException(Callback<Response> callback);
-
-    @GET("/")
-    Observable<Response> onErrorCustomException();
-  }
-
-  static class TestException extends Exception {
-  }
-
-  ExampleClient example;
-  ErrorHandler errorHandler;
-
-  @Before public void setup() {
-    errorHandler = mock(ErrorHandler.class);
-
-    OkHttpClient client = new OkHttpClient();
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return new Response.Builder()
-            .code(400)
-            .message("Invalid")
-            .request(chain.request())
-            .protocol(HTTP_1_1)
-            .build();
-      }
-    });
-
-    example = new RestAdapter.Builder() //
-        .setEndpoint("http://example.com")
-        .setClient(client)
-        .setErrorHandler(errorHandler)
-        .setCallbackExecutor(new Utils.SynchronousExecutor())
-        .build()
-        .create(ExampleClient.class);
-  }
-
-  @Test public void customizedExceptionUsed() throws Throwable {
-    TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    try {
-      example.throwsCustomException();
-      failBecauseExceptionWasNotThrown(TestException.class);
-    } catch (TestException e) {
-      assertThat(e).isSameAs(exception);
-    }
-  }
-
-  @Test public void onErrorWrappedCustomException() throws Throwable {
-    final TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    example.onErrorWrappedCustomException(new Callback<Response>() {
-
-      @Override public void success(Response response, Response response2) {
-        failBecauseExceptionWasNotThrown(TestException.class);
-      }
-
-      @Override public void failure(RetrofitError error) {
-        assertThat(error.getCause()).isSameAs(exception);
-      }
-    });
-  }
-
-  @Test public void onErrorCustomException() throws Throwable {
-    final TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.onErrorCustomException().subscribe(new Observer<Response>() {
-      @Override public void onCompleted() {
-        failBecauseExceptionWasNotThrown(TestException.class);
-      }
-
-      @Override public void onError(Throwable e) {
-        assertThat(e).isSameAs(exception);
-        latch.countDown();
-      }
-
-      @Override public void onNext(Response response) {
-        failBecauseExceptionWasNotThrown(TestException.class);
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-  }
-
-  @Test public void returningNullThrowsException() throws Exception {
-    doReturn(null).when(errorHandler).handleError(any(RetrofitError.class));
-
-    try {
-      example.throwsCustomException();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Error handler returned null for wrapped exception.");
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
new file mode 100644
index 000000000..6c95f8882
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.Executor;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@SuppressWarnings("unchecked")
+public final class ExecutorCallAdapterFactoryTest {
+  private final Callback<String> callback = mock(Callback.class);
+  private final Executor callbackExecutor = spy(new Executor() {
+    @Override public void execute(Runnable runnable) {
+      runnable.run();
+    }
+  });
+  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
+
+  @Test public void rawTypeThrows() {
+    try {
+      factory.get(Call.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+  }
+
+  @Test public void responseThrows() {
+    Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
+    try {
+      factory.get(returnType);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
+          + "Specify the response body type only (e.g., Call<TweetResponse>).");
+    }
+  }
+
+  @Test public void responseType() {
+    Type classType = new TypeToken<Call<String>>() {}.getType();
+    assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType).responseType()).isEqualTo(String.class);
+    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType).responseType()) //
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+  }
+
+  @Test public void adaptedCallExecute() throws IOException {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    final Response<String> response = Response.fakeSuccess("Hi");
+    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+      @Override public Response<String> execute() throws IOException {
+        return response;
+      }
+    });
+    assertThat(call.execute()).isSameAs(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    final Response<String> response = Response.fakeSuccess("Hi");
+    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<String> callback) {
+        callback.success(response);
+      }
+    });
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verify(callback).success(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    final Throwable throwable = new IOException();
+    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<String> callback) {
+        callback.failure(throwable);
+      }
+    });
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(callbackExecutor);
+    verify(callback).failure(throwable);
+    verifyNoMoreInteractions(callback);
+  }
+
+  @Test public void adaptedCallCloneDeepCopy() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    Call<String> delegate = mock(Call.class);
+    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> cloned = call.clone();
+    assertThat(cloned).isNotSameAs(call);
+    verify(delegate).clone();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  @Test public void adaptedCallCancel() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    Call<String> delegate = mock(Call.class);
+    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    call.cancel();
+    verify(delegate).cancel();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  static class EmptyCall implements Call<String> {
+    @Override public void enqueue(Callback<String> callback) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Response<String> execute() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public void cancel() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Call<String> clone() {
+      throw new UnsupportedOperationException();
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/MethodInfoTest.java b/retrofit/src/test/java/retrofit/MethodInfoTest.java
deleted file mode 100644
index cffec1afc..000000000
--- a/retrofit/src/test/java/retrofit/MethodInfoTest.java
+++ /dev/null
@@ -1,220 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.google.gson.reflect.TypeToken;
-import com.squareup.okhttp.Response;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.POST;
-import retrofit.http.Streaming;
-import rx.Observable;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-@SuppressWarnings("unused") // Lots of unused parameters for example code.
-public class MethodInfoTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
-
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = MethodInfo.parsePathParameters(path);
-    assertThat(calculated).hasSize(expected.length);
-    if (expected.length > 0) {
-      assertThat(calculated).containsExactly(expected);
-    }
-  }
-
-  static class Dummy {
-  }
-
-  @Test public void concreteBodyType() {
-    class Example {
-      @POST("/foo") Response a(@Body Dummy body) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.requestObjectType).isEqualTo(Dummy.class);
-  }
-
-  @Test public void genericBodyType() {
-    class Example {
-      @POST("/foo") Response a(@Body List<String> body) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.requestObjectType).isEqualTo(expected);
-  }
-
-  @Test public void wildcardBodyType() {
-    class Example {
-      @POST("/foo") Response a(@Body List<? super String> body) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    Type expected = new TypeToken<List<? super String>>() {}.getType();
-    assertThat(methodInfo.requestObjectType).isEqualTo(expected);
-  }
-
-  @Test public void concreteCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<Response> cb) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void wildcardGenericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<? extends Response> c) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackWithGenericType() {
-    class Example {
-      @GET("/foo") void a(Callback<List<String>> c) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
-  // a little of everything: a parameterized type, a generic array, and a wildcard.
-  private static Map<? extends String, Set<Long>[]> extendingGenericCallbackType;
-
-  @Test public void extendingGenericCallback() throws Exception {
-    class Example {
-      @GET("/foo") void a(MultimapCallback<String, Set<Long>> callback) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(
-        MethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
-  }
-
-  @Test public void synchronousResponse() {
-    class Example {
-      @GET("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void synchronousGenericResponse() {
-    class Example {
-      @GET("/foo") List<String> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  @Test public void streamingResponse() {
-    class Example {
-      @GET("/foo") @Streaming Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void observableResponse() {
-    class Example {
-      @GET("/foo") Observable<Response> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void observableGenericResponse() {
-    class Example {
-      @GET("/foo") Observable<List<String>> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  private static interface ResponseCallback extends Callback<Response> {
-  }
-
-  private static interface MultimapCallback<K, V> extends Callback<Map<? extends K, V[]>> {
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/MockClient.java b/retrofit/src/test/java/retrofit/MockClient.java
deleted file mode 100644
index 1fea6c0cc..000000000
--- a/retrofit/src/test/java/retrofit/MockClient.java
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2015 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Deque;
-
-import static com.squareup.okhttp.Protocol.HTTP_1_1;
-
-final class MockClient implements Interceptor {
-  private Deque<Object> events = new ArrayDeque<Object>();
-  private Deque<Request> requests = new ArrayDeque<Request>();
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-    requests.addLast(request);
-
-    Object event = events.removeFirst();
-    if (event instanceof IOException) {
-      throw (IOException) event;
-    }
-    if (event instanceof RuntimeException) {
-      throw (RuntimeException) event;
-    }
-    if (event instanceof Response.Builder) {
-      Response.Builder response = (Response.Builder) event;
-      return response.request(request).protocol(HTTP_1_1).build();
-    }
-    throw new IllegalStateException("Unknown event " + event.getClass());
-  }
-
-  public void enqueueResponse(Response.Builder response) {
-    events.addLast(response);
-  }
-
-  public void enqueueUnexpectedException(RuntimeException exception) {
-    events.addLast(exception);
-  }
-
-  public void enqueueIOException(IOException exception) {
-    events.addLast(exception);
-  }
-
-  public Request takeRequest() {
-    return requests.removeFirst();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 3585600be..d097628f6 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -1,32 +1,32 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.google.gson.Gson;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
 import retrofit.http.Body;
 import retrofit.http.DELETE;
 import retrofit.http.Field;
 import retrofit.http.FieldMap;
+import retrofit.http.FormUrlEncoded;
 import retrofit.http.GET;
 import retrofit.http.HEAD;
 import retrofit.http.HTTP;
 import retrofit.http.Header;
 import retrofit.http.Headers;
+import retrofit.http.Multipart;
 import retrofit.http.PATCH;
 import retrofit.http.POST;
 import retrofit.http.PUT;
@@ -35,20 +35,20 @@
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
-import retrofit.http.Streaming;
-import rx.Observable;
+import retrofit.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
-@SuppressWarnings("UnusedParameters") // Parameters inspected reflectively.
-public class RequestBuilderTest {
-  private RequestInterceptor interceptor;
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderTest {
+  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
 
-  @Test public void custom1Method() {
+  @Test public void customMethodNoBody() {
     class Example {
       @HTTP(method = "CUSTOM1", path = "/foo")
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -59,11 +59,11 @@ Response method() {
     assertThat(request.body()).isNull();
   }
 
-  @Ignore // TODO https://github.com/square/okhttp/issues/229
-  @Test public void custom2Method() {
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -75,62 +75,30 @@ Response method(@Body RequestBody body) {
     assertBody(request.body(), "hi");
   }
 
-  //@Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-  //  class Example {
-  //    @Multipart //
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-  //  }
-  //}
-  //
-  //@Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @Multipart //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-  //  }
-  //}
-
-  @Test public void invalidPathParam() throws Exception {
+  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
     class Example {
-      @GET("/") //
-      Response method(@Path("hey!") String thing) {
+      @Multipart //
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method() {
         return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)");
+          "Only one encoding annotation is allowed.\n    for method Example.method");
     }
   }
 
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
+  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
     class Example {
-      @GET("/foo?bar={bar}") //
-      Response method(@Path("bar") String thing) {
+      @FormUrlEncoded //
+      @Multipart //
+      @POST("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -139,33 +107,14 @@ Response method(@Path("bar") String thing) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.");
+          "Only one encoding annotation is allowed.\n    for method Example.method");
     }
   }
 
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
+  @Test public void invalidPathParam() throws Exception {
     class Example {
       @GET("/") //
-      Response method(@Body @Query("nope") Object o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: Multiple Retrofit annotations found, only one allowed:"
-              + " @Body, @Query. (parameter #1)");
-    }
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Response method() {
+      Call<Object> method(@Path("hey!") String thing) {
         return null;
       }
     }
@@ -175,49 +124,50 @@ Response method() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Only one HTTP method is allowed. Found: PATCH and POST.");
+          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+              + " Found: hey! (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void pathMustBePrefixedWithSlash() {
+  @Test public void pathParamNotAllowedInQuery() throws Exception {
     class Example {
-      @GET("foo/bar") //
-      Response method() {
+      @GET("/foo?bar={bar}") //
+      Call<Object> method(@Path("bar") String thing) {
         return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: URL path \"foo/bar\" must start with '/'.");
+      assertThat(e).hasMessage(
+          "URL query string \"bar={bar}\" must not have replace block."
+              + " For dynamic query parameters use @Query.\n    for method Example.method");
     }
   }
 
-  @Test public void streamingResponseNotAllowed() {
+  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
     class Example {
-      @GET("/foo") //
-      @Streaming //
-      String method() {
+      @GET("/") //
+      Call<Object> method(@Body @Query("nope") Object o) {
         return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Only methods having Response as data type are allowed to have @Streaming annotation.");
+          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void streamingResponseWithCallbackNotAllowed() {
+  @Test public void twoMethodsFail() {
     class Example {
-      @GET("/foo") //
-      @Streaming //
-      void method(Callback<String> callback) {
+      @PATCH("/foo") //
+      @POST("/foo") //
+      Call<Object> method() {
+        return null;
       }
     }
 
@@ -226,14 +176,13 @@ void method(Callback<String> callback) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Only methods having Response as data type are allowed to have @Streaming annotation.");
+          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
     }
   }
 
-  @Test public void observableWithCallback() {
+  @Test public void lackingMethod() {
     class Example {
-      @GET("/foo") //
-      Observable<Response> method(Callback<Response> callback) {
+      Call<Object> method() {
         return null;
       }
     }
@@ -242,30 +191,31 @@ void method(Callback<String> callback) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Must have return type or Callback as last argument, not both.");
+          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
     }
   }
 
-  @Test public void missingCallbackTypes() {
+  @Test public void implicitMultipartForbidden() {
     class Example {
-      @GET("/foo") //
-      void method(@Query("id") String id) {
+      @POST("/") //
+      Call<Object> method(@Part("a") int a) {
+        return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Must have either a return type or Callback as last argument.");
+          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void nonParameterizedCallbackFails() {
+  @Test public void implicitMultipartWithPartMapForbidden() {
     class Example {
-      @GET("/foo") //
-      void method(Callback cb) {
+      @POST("/") //
+      Call<Object> method(@PartMap Map<String, String> params) {
+        return null;
       }
     }
     try {
@@ -273,14 +223,15 @@ void method(Callback cb) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Last parameter must be of type Callback<X> or Callback<? super X>.");
+          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void synchronousWithAsyncCallback() {
+  @Test public void multipartFailsOnNonBodyMethod() {
     class Example {
-      @GET("/foo") //
-      Response method(Callback<Response> callback) {
+      @Multipart //
+      @GET("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -289,13 +240,15 @@ Response method(Callback<Response> callback) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Must have return type or Callback as last argument, not both.");
+          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
     }
   }
 
-  @Test public void lackingMethod() {
+  @Test public void multipartFailsWithNoParts() {
     class Example {
-      Response method() {
+      @Multipart //
+      @POST("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -304,14 +257,14 @@ Response method() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+          "Multipart method must contain at least one @Part.\n    for method Example.method");
     }
   }
 
-  @Test public void implicitMultipartForbidden() {
+  @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
       @POST("/") //
-      Response method(@Part("a") int a) {
+      Call<Object> method(@Field("a") int a) {
         return null;
       }
     }
@@ -320,14 +273,14 @@ Response method(@Part("a") int a) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Part parameters can only be used with multipart encoding. (parameter #1)");
+          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void implicitMultipartWithPartMapForbidden() {
+  @Test public void implicitFormEncodingByFieldMapForbidden() {
     class Example {
       @POST("/") //
-      Response method(@PartMap Map<String, String> params) {
+      Call<Object> method(@FieldMap Map<String, String> a) {
         return null;
       }
     }
@@ -336,47 +289,15 @@ Response method(@PartMap Map<String, String> params) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
-    }
-  }
-
-  //@Test public void multipartFailsOnNonBodyMethod() {
-  //  class Example {
-  //    @Multipart //
-  //    @GET("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage(
-  //        "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-  //  }
-  //}
-  //
-  //@Test public void multipartFailsWithNoParts() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
-  //  }
-  //}
+          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+    }
+  }
 
-  @Test public void implicitFormEncodingByFieldForbidden() {
+  @Test public void formEncodingFailsOnNonBodyMethod() {
     class Example {
-      @POST("/") //
-      Response method(@Field("a") int a) {
+      @FormUrlEncoded //
+      @GET("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -385,14 +306,15 @@ Response method(@Field("a") int a) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Field parameters can only be used with form encoding. (parameter #1)");
+          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
     }
   }
 
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
+  @Test public void formEncodingFailsWithNoParts() {
     class Example {
+      @FormUrlEncoded //
       @POST("/") //
-      Response method(@FieldMap Map<String, String> a) {
+      Call<Object> method() {
         return null;
       }
     }
@@ -400,49 +322,15 @@ Response method(@FieldMap Map<String, String> a) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: @FieldMap parameters can only be used with form encoding. (parameter #1)");
-    }
-  }
-
-  //@Test public void formEncodingFailsOnNonBodyMethod() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @GET("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage(
-  //        "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
-  //  }
-  //}
-  //
-  //@Test public void formEncodingFailsWithNoParts() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
-  //  }
-  //}
+      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+    }
+  }
 
   @Test public void headersFailWhenEmptyOnMethod() {
     class Example {
       @GET("/") //
       @Headers({}) //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -450,7 +338,7 @@ Response method() {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: @Headers annotation is empty.");
+      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
     }
   }
 
@@ -458,7 +346,7 @@ Response method() {
     class Example {
       @GET("/") //
       @Headers("Malformed") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -467,14 +355,14 @@ Response method() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Headers value must be in the form \"Name: Value\". Found: \"Malformed\"");
+          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
     }
   }
 
   @Test public void pathParamNonPathParamAndTypedBytes() {
     class Example {
       @PUT("/{a}") //
-      Response method(@Path("a") int a, @Path("b") int b, @Body int c) {
+      Call<Object> method(@Path("a") int a, @Path("b") int b, @Body int c) {
         return null;
       }
     }
@@ -482,14 +370,15 @@ Response method(@Path("a") int a, @Path("b") int b, @Body int c) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: URL \"/{a}\" does not contain \"{b}\". (parameter #2)");
+      assertThat(e).hasMessage(
+          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
     }
   }
 
   @Test public void parameterWithoutAnnotation() {
     class Example {
       @GET("/") //
-      Response method(String a) {
+      Call<Object> method(String a) {
         return null;
       }
     }
@@ -497,14 +386,15 @@ Response method(String a) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: No Retrofit annotation found. (parameter #1)");
+      assertThat(e).hasMessage(
+          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
     }
   }
 
   @Test public void nonBodyHttpMethodWithSingleEntity() {
     class Example {
       @GET("/") //
-      Response method(@Body Object o) {
+      Call<Object> method(@Body Object o) {
         return null;
       }
     }
@@ -513,14 +403,14 @@ Response method(@Body Object o) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Non-body HTTP method cannot contain @Body or @TypedOutput.");
+          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
     }
   }
 
   @Test public void queryMapMustBeAMap() {
     class Example {
       @GET("/") //
-      Response method(@QueryMap List<String> a) {
+      Call<Object> method(@QueryMap List<String> a) {
         return null;
       }
     }
@@ -528,19 +418,20 @@ Response method(@QueryMap List<String> a) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: @QueryMap parameter type must be Map. (parameter #1)");
+      assertThat(e).hasMessage(
+          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
     }
   }
 
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
-      Response method(@QueryMap Map<String, String> a) {
+      Call<Object> method(@QueryMap Map<String, String> a) {
         return null;
       }
     }
 
-    Map<String, String> queryParams = new LinkedHashMap<String, String>();
+    Map<String, String> queryParams = new LinkedHashMap<>();
     queryParams.put("ping", "pong");
     queryParams.put(null, "kat");
 
@@ -548,14 +439,31 @@ Response method(@QueryMap Map<String, String> a) {
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter #1 query map contained null key.");
+      assertThat(e).hasMessage("Query map contained null key.");
     }
   }
 
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
-      Response method(@Body int o1, @Body int o2) {
+      Call<Object> method(@Body int o1, @Body int o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+    }
+  }
+
+  @Test public void bodyInNonBodyRequest() {
+    class Example {
+      @Multipart //
+      @PUT("/") //
+      Call<Object> method(@Part("one") int o1, @Body int o2) {
         return null;
       }
     }
@@ -563,31 +471,15 @@ Response method(@Body int o1, @Body int o2) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Multiple @Body method annotations found.");
-    }
-  }
-
-  //@Test public void bodyInNonBodyRequest() {
-  //  class Example {
-  //    @Multipart //
-  //    @PUT("/") //
-  //    Response method(@Part("one") int o1, @Body int o2) {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage(
-  //        "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
-  //  }
-  //}
+      assertThat(e).hasMessage(
+          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+    }
+  }
 
   @Test public void get() {
     class Example {
       @GET("/foo/bar/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -601,7 +493,7 @@ Response method() {
   @Test public void delete() {
     class Example {
       @DELETE("/foo/bar/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -609,13 +501,13 @@ Response method() {
     assertThat(request.method()).isEqualTo("DELETE");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
+    assertNull(request.body());
   }
 
   @Test public void head() {
     class Example {
       @HEAD("/foo/bar/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -629,7 +521,7 @@ Response method() {
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -644,7 +536,7 @@ Response method(@Body RequestBody body) {
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -659,7 +551,7 @@ Response method(@Body RequestBody body) {
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -674,7 +566,7 @@ Response method(@Body RequestBody body) {
   @Test public void getWithPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping) {
+      Call<Object> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -685,159 +577,38 @@ Response method(@Path("ping") String ping) {
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Response method(@Path(value = "ping", encode = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithInterceptorPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("ping", "po ng");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithInterceptorEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addEncodedPathParam("ping", "po%20ng");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParam() {
+  @Test public void getWithUnusedAndInvalidNamedPathParam() {
     class Example {
-      @GET("/foo/bar/{ping}/{kit}/") //
-      Response method(@Path("ping") String ping) {
+      @GET("/foo/bar/{ping}/{kit,kat}/") //
+      Call<Object> method(@Path("ping") String ping) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("kit", "kat");
-      }
-    };
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithInterceptorQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addQueryParam("ping", "po ng");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=po+ng");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorQueryParam() {
-    class Example {
-      @GET("/foo/bar/{kit}/") //
-      Response method(@Path("kit") String kit) {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addQueryParam("ping", "pong");
-      }
-    };
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/kat/?ping=pong");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithInterceptorPathParamAndInterceptorQueryParam() {
+  @Test public void getWithEncodedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("ping", "pong");
-        request.addQueryParam("butter", "finger");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParamAndInterceptorQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit}/") //
-      Response method(@Path("ping") String ping) {
+      Call<Object> method(@Path(value = "ping", encoded = true) String ping) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("kit", "kat");
-        request.addQueryParam("butter", "finger");
-      }
-    };
-    Request request = buildRequest(Example.class, "pong");
+    Request request = buildRequest(Example.class, "po%20ng");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
     assertThat(request.body()).isNull();
   }
 
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping) {
+      Call<Object> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -852,7 +623,7 @@ Response method(@Path("ping") String ping) {
   @Test public void getWithQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("ping") String ping) {
+      Call<Object> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -866,49 +637,21 @@ Response method(@Query("ping") String ping) {
   @Test public void getWithEncodedQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query(value = "ping", encodeValue = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p+o+n+g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodeNameQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Response method(@Query(value = "pi ng", encodeName = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodeNameEncodedValueQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Response method(@Query(value = "pi ng", encodeName = true, encodeValue = false) String ping) {
+      Call<Object> method(@Query(value = "pi%20ng", encoded = true) String ping) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, "po+ng");
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=po+ng");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
     assertThat(request.body()).isNull();
   }
 
   @Test public void queryParamOptionalOmitsQuery() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("ping") String ping) {
+      Call<Object> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -919,7 +662,7 @@ Response method(@Query("ping") String ping) {
   @Test public void queryParamOptional() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("foo") String foo, @Query("ping") String ping,
+      Call<Object> method(@Query("foo") String foo, @Query("ping") String ping,
           @Query("kit") String kit) {
         return null;
       }
@@ -931,7 +674,7 @@ Response method(@Query("foo") String foo, @Query("ping") String ping,
   @Test public void getWithQueryUrlAndParam() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Response method(@Query("ping") String ping) {
+      Call<Object> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -945,7 +688,7 @@ Response method(@Query("ping") String ping) {
   @Test public void getWithQuery() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -959,7 +702,7 @@ Response method() {
   @Test public void getWithPathAndQueryParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit,
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit,
           @Query("riff") String riff) {
         return null;
       }
@@ -972,10 +715,27 @@ Response method(@Path("ping") String ping, @Query("kit") String kit,
     assertThat(request.body()).isNull();
   }
 
+  @Test public void getWithQueryThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Query("kit") String kit, @Path("ping") String ping) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "kat", "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -983,14 +743,14 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
     Request request = buildRequest(Example.class, "pong?", "kat?");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
     assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryAmpersandParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -1005,7 +765,7 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
   @Test public void getWithPathAndQueryHashParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -1020,7 +780,7 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
   @Test public void getWithQueryParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("key") List<Object> keys) {
+      Call<Object> method(@Query("key") List<Object> keys) {
         return null;
       }
     }
@@ -1036,7 +796,7 @@ Response method(@Query("key") List<Object> keys) {
   @Test public void getWithQueryParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("key") Object[] keys) {
+      Call<Object> method(@Query("key") Object[] keys) {
         return null;
       }
     }
@@ -1052,7 +812,7 @@ Response method(@Query("key") Object[] keys) {
   @Test public void getWithQueryParamPrimitiveArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("key") int[] keys) {
+      Call<Object> method(@Query("key") int[] keys) {
         return null;
       }
     }
@@ -1068,12 +828,12 @@ Response method(@Query("key") int[] keys) {
   @Test public void getWithQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@QueryMap Map<String, Object> query) {
+      Call<Object> method(@QueryMap Map<String, Object> query) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "kat");
     params.put("foo", null);
     params.put("ping", "pong");
@@ -1088,590 +848,680 @@ Response method(@QueryMap Map<String, Object> query) {
   @Test public void getWithEncodedQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@QueryMap(encodeValues = false) Map<String, Object> query) {
+      Call<Object> method(@QueryMap(encoded = true) Map<String, Object> query) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "k%20t");
     params.put("foo", null);
-    params.put("ping", "p%20g");
+    params.put("pi%20ng", "p%20g");
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&ping=p%20g");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithEncodeNameQueryParamMap() {
+  @Test public void getWithUrl() {
     class Example {
-      @GET("/foo/bar/") //
-      Response method(@QueryMap(encodeNames = true) Map<String, Object> query) {
+      @GET
+      Call<Object> method(@Url String url) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("k it", "k t");
-    params.put("fo o", null);
-    params.put("pi ng", "p g");
-
-    Request request = buildRequest(Example.class, params);
+    Request request = buildRequest(Example.class, "foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithEncodeNameEncodedValueQueryParamMap() {
+  @Test public void getAbsoluteUrl() {
     class Example {
-      @GET("/foo/bar/") //
-      Response method(
-          @QueryMap(encodeNames = true, encodeValues = false) Map<String, Object> query) {
+      @GET("http://example2.com/foo/bar/")
+      Call<Object> method() {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("k it", "k%20t");
-    params.put("fo o", null);
-    params.put("pi ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
+    Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g");
+    assertThat(request.urlString()).isEqualTo("http://example2.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void normalPostWithPathParam() {
+  @Test public void getWithUrlAbsolute() {
     class Example {
-      @POST("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping) {
+      @GET
+      Call<Object> method(@Url String url) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("POST");
+
+    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "");
+    assertThat(request.urlString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
-  @Test public void bodyGson() {
+  @Test public void getWithUrlAbsoluteSameHost() {
     class Example {
-      @POST("/foo/bar/") //
-      Response method(@Body Object body) {
+      @GET
+      Call<Object> method(@Url String url) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, Arrays.asList("quick", "brown", "fox"));
-    assertThat(request.method()).isEqualTo("POST");
+
+    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
+    assertThat(request.body()).isNull();
   }
 
-  @Test public void bodyTypedInput() {
+  @Test public void getWithNonStringUrlThrows() {
     class Example {
-      @POST("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      @GET
+      Call<Object> method(@Url Object url) {
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
+          + "    for method Example.method");
+    }
   }
 
-  @Test public void bodyRequired() {
+  @Test public void getUrlAndUrlParamThrows() {
     class Example {
-      @POST("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      @GET("foo/bar")
+      Call<Object> method(@Url Object url) {
         return null;
       }
     }
+
     try {
-      buildRequest(Example.class, new Object[] { null });
+      buildRequest(Example.class, "foo/bar");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
+          + "    for method Example.method");
     }
   }
 
-  @Test public void bodyWithPathParams() {
+  @Test public void getWithoutUrlThrows() {
     class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Response method(@Path("ping") String ping, @Body Object body, @Path("kit") String kit) {
+      @GET
+      Call<Object> method() {
         return null;
       }
     }
-    Request request =
-        buildRequest(Example.class, "pong", Arrays.asList("quick", "brown", "fox"), "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-  //
-  //@Test public void simpleMultipart() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part("ping") String ping, @Part("kit") TypedInput kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartWithEncoding() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part(value = "ping", encoding = "8-bit") String ping,
-  //        @Part(value = "kit", encoding = "7-bit") TypedInput kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n")
-  //      .contains("Content-Transfer-Encoding: 8-bit")
-  //      .endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"")
-  //      .contains("Content-Transfer-Encoding: 7-bit")
-  //      .endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartPartMap() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@PartMap Map<String, Object> parts) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
-  //  params.put("ping", "pong");
-  //  params.put("kit", new TypedString("kat"));
-  //
-  //  Request request = buildRequest(Example.class, params);
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartPartMapWithEncoding() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
-  //  params.put("ping", "pong");
-  //  params.put("kit", new TypedString("kat"));
-  //
-  //  Request request = buildRequest(Example.class, params);
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n")
-  //      .contains("Content-Transfer-Encoding: 8-bit")
-  //      .endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"")
-  //      .contains("Content-Transfer-Encoding: 8-bit")
-  //      .endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartPartMapRejectsNullKeys() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@PartMap Map<String, Object> parts) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
-  //  params.put("ping", "pong");
-  //  params.put(null, "kat");
-  //
-  //  try {
-  //    buildRequest(Example.class, params);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Parameter #1 part map contained null key.");
-  //  }
-  //}
-  //
-  //@Test public void multipartNullRemovesPart() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part("ping") String ping, @Part("fizz") String fizz) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "pong", null);
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(1);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
-  //}
-  //
-  //@Test public void multipartPartOptional() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part("ping") RequestBody ping) {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class, new Object[] { null });
-  //    fail();
-  //  } catch (IllegalStateException e) {
-  //    assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
-  //  }
-  //}
-  //
-  //@Test public void simpleFormEncoded() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") String foo, @Field("ping") String ping) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "bar", "pong");
-  //  assertBody(request.body(), "foo=bar&ping=pong");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedNameFieldParam() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field(value = "na+me", encodeName = false) String foo) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "ba r");
-  //  assertBody(request.body(), "na+me=ba+r");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedValueFieldParam() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field(value = "na me", encodeValue = false) String foo) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "ba+r");
-  //  assertBody(request.body(), "na+me=ba+r");
-  //}
-  //
-  //@Test public void formEncodedFieldOptional() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") String foo, @Field("ping") String ping,
-  //        @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "bar", null, "kat");
-  //  assertBody(request.body(), "foo=bar&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedFieldList() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-  //  Request request = buildRequest(Example.class, values, "kat");
-  //  assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedFieldArray() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Object[] values = { 1, 2, null, "three" };
-  //  Request request = buildRequest(Example.class, values, "kat");
-  //  assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedFieldPrimitiveArray() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  int[] values = { 1, 2, 3 };
-  //  Request request = buildRequest(Example.class, values, "kat");
-  //  assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedNameFieldParamMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("k+it", "k at");
-  //  fieldMap.put("pin+g", "po ng");
-  //
-  //  Request request = buildRequest(Example.class, fieldMap);
-  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedValueFieldParamMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("k it", "k+at");
-  //  fieldMap.put("pin g", "po+ng");
-  //
-  //  Request request = buildRequest(Example.class, fieldMap);
-  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
-  //}
-  //
-  //@Test public void formEncodedFieldMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@FieldMap Map<String, Object> fieldMap) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("kit", "kat");
-  //  fieldMap.put("foo", null);
-  //  fieldMap.put("ping", "pong");
-  //
-  //  Request request = buildRequest(Example.class, fieldMap);
-  //  assertBody(request.body(), "kit=kat&ping=pong");
-  //}
-  //
-  //@Test public void fieldMapRejectsNullKeys() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method(@FieldMap Map<String, Object> a) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("kit", "kat");
-  //  fieldMap.put("foo", null);
-  //  fieldMap.put(null, "pong");
-  //
-  //  try {
-  //    buildRequest(Example.class, fieldMap);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Parameter #1 field map contained null key.");
-  //  }
-  //}
-  //
-  //@Test public void fieldMapMustBeAMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method(@FieldMap List<String> a) {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
-  //  }
-  //}
 
-  @Test public void simpleHeaders() {
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithUrlThenPathThrows() {
     class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Response method() {
+      @GET
+      Call<Object> method(@Url String url, @Path("hey") String hey) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class);
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithPathThenUrlThrows() {
+    class Example {
+      @GET
+      Call<Object> method(@Path("hey") String hey, @Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryThenUrlThrows() {
+    class Example {
+      @GET("foo/bar")
+      Call<Object> method(@Query("hey") String hey, @Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "hey", "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithUrlThenQuery() {
+    class Example {
+      @GET
+      Call<Object> method(@Url String url, @Query("hey") String hey) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
   }
 
-  @Test public void simpleInterceptorHeaders() {
+  @Test public void postWithUrl() {
     class Example {
-      @GET("/foo/bar/")
-      Response method() {
+      @POST
+      Call<Object> method(@Url String url, @Body RequestBody body) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("ping", "pong");
-        request.addHeader("kit", "kat");
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void normalPostWithPathParam() {
+    class Example {
+      @POST("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Body RequestBody body) {
+        return null;
       }
-    };
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void emptyBody() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method() {
+        return null;
+      }
+    }
     Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
+    assertBody(request.body(), "");
   }
 
-  @Test public void headersAndInterceptorHeaders() {
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodEmptyBody() {
     class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Response method() {
+      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
+      Call<Object> method() {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("kit", "kat");
-      }
-    };
     Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.method()).isEqualTo("CUSTOM");
+    assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
+    assertBody(request.body(), "");
   }
 
-  @Test public void allThreeHeaderTypes() {
+  @Test public void bodyResponseBody() {
     class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Response method(@Header("fizz") String fizz) {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("kit", "kat");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void bodyRequired() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
       }
-    };
-    Request request = buildRequest(Example.class, "buzz");
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+    }
+  }
+
+  @Test public void bodyWithPathParams() {
+    class Example {
+      @POST("/foo/bar/{ping}/{kit}/") //
+      Call<Object> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body, "kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void simpleMultipart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
+          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString).contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString).contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 7-bit")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMap() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put("foo", null); // Should be skipped.
+    params.put("kit", "kat");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+
+    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
+  }
+
+  @Test public void multipartPartMapWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put("foo", null); // Should be skipped.
+    params.put("kit", "kat");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString).contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString).contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\nkat\r\n--");
+
+    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
+  }
+
+  @Test public void multipartPartMapRejectsNullKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put(null, "kat");
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map contained null key.");
+    }
+  }
+
+  @Test public void multipartPartMapMustBeMap() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap List<Object> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.emptyList());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void multipartNullRemovesPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong", null);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"")
+        .contains("\r\npong\r\n--");
+  }
+
+  @Test public void multipartPartOptional() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") RequestBody ping) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+    }
+  }
+
+  @Test public void simpleFormEncoded() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", "pong");
+    assertBody(request.body(), "foo=bar&ping=pong");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParam() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field(value = "na%20me", encoded = true) String foo) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "ba%20r");
+    assertBody(request.body(), "na%20me=ba%20r");
+  }
+
+  @Test public void formEncodedFieldOptional() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping,
+          @Field("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertBody(request.body(), "foo=bar&kit=kat");
+  }
+
+  @Test public void formEncodedFieldList() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedFieldArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three" };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  }
+
+  @Test public void formEncodedFieldPrimitiveArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3 };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParamMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("k%20it", "k%20at");
+    fieldMap.put("pin%20g", "po%20ng");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+  }
+
+  @Test public void formEncodedFieldMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@FieldMap Map<String, Object> fieldMap) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+    fieldMap.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "kit=kat&ping=pong");
+  }
+
+  @Test public void fieldMapRejectsNullKeys() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+    fieldMap.put(null, "pong");
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map contained null key.");
+    }
+  }
+
+  @Test public void fieldMapMustBeAMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method(@FieldMap List<String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void simpleHeaders() {
+    class Example {
+      @GET("/foo/bar/")
+      @Headers({
+          "ping: pong",
+          "kit: kat"
+      })
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(3);
+    assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(headers.get("fizz")).isEqualTo("buzz");
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
@@ -1679,7 +1529,7 @@ Response method(@Header("fizz") String fizz) {
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Header("kit") BigInteger kit) {
+      Call<Object> method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
@@ -1696,7 +1546,7 @@ Response method(@Header("kit") BigInteger kit) {
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Response method(@Header("kit") String kit) {
+      Call<Object> method(@Header("kit") String kit) {
         return null;
       }
     }
@@ -1713,7 +1563,7 @@ Response method(@Header("kit") String kit) {
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Header("foo") List<String> kit) {
+      Call<Object> method(@Header("foo") List<String> kit) {
         return null;
       }
     }
@@ -1729,7 +1579,7 @@ Response method(@Header("foo") List<String> kit) {
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Header("foo") String[] kit) {
+      Call<Object> method(@Header("foo") String[] kit) {
         return null;
       }
     }
@@ -1746,7 +1596,7 @@ Response method(@Header("foo") String[] kit) {
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1759,26 +1609,10 @@ Response method(@Body RequestBody body) {
     class Example {
       @DELETE("/") //
       @Headers("Content-Type: text/not-plain") //
-      Response method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeInterceptorHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("Content-Type", "text/not-plain");
-      }
-    };
     Request request = buildRequest(Example.class);
     assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
   }
@@ -1786,7 +1620,7 @@ Response method() {
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Response method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+      Call<Object> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
@@ -1806,18 +1640,17 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  private static final Converter GSON = new GsonConverter(new Gson());
-
   private Request buildRequest(Class<?> cls, Object... args) {
     Method method = TestingUtils.onlyMethod(cls);
-    MethodInfo methodInfo = new MethodInfo(method);
 
-    RequestBuilder builder = new RequestBuilder("http://example.com/", methodInfo, GSON);
-    if (interceptor != null) {
-      interceptor.intercept(builder);
-    }
-    builder.setArguments(args);
+    BaseUrl baseUrl = new BaseUrl() {
+      @Override public HttpUrl url() {
+        return HttpUrl.parse("http://example.com/");
+      }
+    };
+    Converter.Factory converterFactory = new ToStringConverterFactory();
 
-    return builder.build();
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactory);
+    return requestFactory.create(args);
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java b/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java
new file mode 100644
index 000000000..59d9cd9a9
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java
@@ -0,0 +1,33 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.util.Set;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class RequestFactoryParserTest {
+  @Test public void pathParameterParsing() throws Exception {
+    expectParams("/");
+    expectParams("/foo");
+    expectParams("/foo/bar");
+    expectParams("/foo/bar/{}");
+    expectParams("/foo/bar/{taco}", "taco");
+    expectParams("/foo/bar/{t}", "t");
+    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+    expectParams("/foo/bar/{}/{taco}", "taco");
+    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("/foo/bar/{taco-shell}", "taco-shell");
+    expectParams("/foo/bar/{taco_shell}", "taco_shell");
+    expectParams("/foo/bar/{sha256}", "sha256");
+    expectParams("/foo/bar/{TACO}", "TACO");
+    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+  }
+
+  private static void expectParams(String path, String... expected) {
+    Set<String> calculated = RequestFactoryParser.parsePathParameters(path);
+    assertThat(calculated).containsExactly(expected);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
deleted file mode 100644
index d435fd514..000000000
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ /dev/null
@@ -1,232 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.google.gson.JsonParseException;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.Headers;
-import retrofit.http.POST;
-import retrofit.http.Streaming;
-import rx.Observable;
-import rx.functions.Action1;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class RestAdapterTest {
-  private interface Example {
-    @Headers("Foo: Bar")
-    @GET("/") String something();
-    @Headers("Foo: Bar")
-    @GET("/") void something(Callback<String> callback);
-    @GET("/") Response direct();
-    @GET("/") void direct(Callback<Response> callback);
-    @GET("/") @Streaming Response streaming();
-    @POST("/") Observable<String> observable(@Body String body);
-  }
-  private interface InvalidExample extends Example {
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-
-  private Example example;
-
-  @Before public void setUp() {
-    OkHttpClient client = new OkHttpClient();
-
-    example = new RestAdapter.Builder() //
-        .setClient(client)
-        .setCallbackExecutor(new SynchronousExecutor())
-        .setEndpoint(server.getUrl("/").toString())
-        .build()
-        .create(Example.class);
-  }
-
-  @Test public void objectMethodsStillWork() {
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    try {
-      new RestAdapter.Builder().setEndpoint("http://foo/").build().create(InvalidExample.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-    String string = example.something();
-    assertThat(string).isEqualTo("Hi");
-  }
-
-  @Test public void malformedResponseThrowsConversionException() throws Exception {
-    server.enqueue(new MockResponse().setBody("{"));
-    try {
-      example.something();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.UNEXPECTED);
-      assertThat(e.getResponse().code()).isEqualTo(200);
-      assertThat(e.getCause()).isInstanceOf(JsonParseException.class);
-      assertThat(e.getResponse().body()).isNull();
-    }
-  }
-
-  @Test public void errorResponseThrowsHttpError() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken"));
-
-    try {
-      example.something();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-      assertThat(e.getResponse().code()).isEqualTo(500);
-      assertThat(e.getSuccessType()).isEqualTo(String.class);
-    }
-  }
-
-  @Test public void clientExceptionThrowsNetworkError() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi").setSocketPolicy(DISCONNECT_AT_START));
-
-    try {
-      example.something();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-    }
-  }
-
-  @Test public void getResponseDirectly() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey"));
-    Response response = example.direct();
-    assertThat(response.body().string()).isEqualTo("Hey");
-  }
-
-  @Test public void streamingResponse() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey").setBodyDelayTimeMs(500));
-    Response response = example.streaming();
-    long startNs = System.nanoTime();
-    response.body().string();
-    long tookNs = System.nanoTime() - startNs;
-    assertThat(tookNs).isGreaterThanOrEqualTo(500);
-  }
-
-  @Test public void getResponseDirectlyAsync() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey"));
-
-    final AtomicReference<Response> responseRef = new AtomicReference<Response>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.direct(new Callback<Response>() {
-      @Override public void success(Response response, Response response2) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    assertThat(responseRef.get().body().string()).isEqualTo("Hey");
-  }
-
-  @Test public void getAsync() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey"));
-
-    final AtomicReference<String> bodyRef = new AtomicReference<String>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.something(new Callback<String>() {
-      @Override public void success(String body, Response response) {
-        bodyRef.set(body);
-        latch.countDown();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    assertThat(bodyRef.get()).isEqualTo("Hey");
-  }
-
-  @Test public void errorAsync() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken!").setBody("Hey"));
-
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.something(new Callback<String>() {
-      @Override public void success(String s, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        errorRef.set(error);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    RetrofitError error = errorRef.get();
-    assertThat(error.getResponse().code()).isEqualTo(500);
-    assertThat(error.getResponse().message()).isEqualTo("Broken!");
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-    assertThat(error.getBody()).isEqualTo("Hey");
-  }
-
-  @Test public void observableCallsOnNext() throws Exception {
-    server.enqueue(new MockResponse().setBody("hello"));
-
-    final AtomicReference<String> bodyRef = new AtomicReference<String>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.observable("Howdy").subscribe(new Action1<String>() {
-      @Override public void call(String body) {
-        bodyRef.set(body);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    assertThat(bodyRef.get()).isEqualTo("hello");
-  }
-
-  @Test public void observableCallsOnError() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-
-    final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.observable("Howdy").subscribe(new Action1<String>() {
-      @Override public void call(String s) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable throwable) {
-        errorRef.set(throwable);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    RetrofitError error = (RetrofitError) errorRef.get();
-    assertThat(error.getResponse().code()).isEqualTo(500);
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
new file mode 100644
index 000000000..773132906
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -0,0 +1,547 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class RetrofitTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  interface CallMethod {
+    @GET("/") Call<String> disallowed();
+    @POST("/") Call<ResponseBody> disallowed(@Body String body);
+    @GET("/") Call<ResponseBody> allowed();
+    @POST("/") Call<ResponseBody> allowed(@Body RequestBody body);
+  }
+  interface FutureMethod {
+    @GET("/") Future<String> method();
+  }
+  interface Extending extends CallMethod {
+  }
+  interface StringService {
+    @GET("/") String get();
+  }
+  interface Unresolvable {
+    @GET("/") <T> Call<T> typeVariable();
+    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
+    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
+    @GET("/") Call<?> wildcard();
+    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
+  }
+  interface VoidService {
+    @GET("/") void nope();
+  }
+
+  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+  @Test public void objectMethodsStillWork() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    assertThat(example.hashCode()).isNotZero();
+    assertThat(example.equals(this)).isFalse();
+    assertThat(example.toString()).isNotEmpty();
+  }
+
+  @Test public void interfaceWithExtendIsNotSupported() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    try {
+      retrofit.create(Extending.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
+    }
+  }
+
+  @Test public void voidReturnTypeNotAllowed() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    VoidService service = retrofit.create(VoidService.class);
+
+    try {
+      service.nope();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
+  @Test public void callReturnTypeAdapterAddedByDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    assertThat(example.allowed()).isNotNull();
+  }
+
+  @Test public void callReturnTypeCustomAdapter() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
+    final AtomicBoolean adapterCalled = new AtomicBoolean();
+    class MyCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<?> get(final Type returnType) {
+        factoryCalled.set(true);
+        if (Utils.getRawType(returnType) != Call.class) {
+          return null;
+        }
+        return new CallAdapter<Object>() {
+          @Override public Type responseType() {
+            return Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+          }
+
+          @Override public Object adapt(Call<Object> call) {
+            adapterCalled.set(true);
+            return call;
+          }
+        };
+      }
+    }
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    assertThat(example.allowed()).isNotNull();
+    assertThat(factoryCalled.get()).isTrue();
+    assertThat(adapterCalled.get()).isTrue();
+  }
+
+  @Test public void customReturnTypeAdapter() {
+    class GreetingCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<?> get(Type returnType) {
+        if (Utils.getRawType(returnType) != String.class) {
+          return null;
+        }
+        return new CallAdapter<Object>() {
+          @Override public Type responseType() {
+            return String.class;
+          }
+
+          @Override public String adapt(Call<Object> call) {
+            return "Hi!";
+          }
+        };
+      }
+    }
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .callAdapterFactory(new GreetingCallAdapterFactory())
+        .build();
+    StringService example = retrofit.create(StringService.class);
+    assertThat(example.get()).isEqualTo("Hi!");
+  }
+
+  @Test public void customReturnTypeAdapterMissingThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    FutureMethod example = retrofit.create(FutureMethod.class);
+    try {
+      example.method();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call adapter factory 'Default' was unable to"
+              + " handle return type java.util.concurrent.Future<java.lang.String>\n"
+              + "    for method FutureMethod.method");
+    }
+  }
+
+  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    try {
+      example.disallowed("Hi!");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@Body parameter is class java.lang.String but no converter factory registered. Either"
+              + " add a converter factory to the Retrofit instance or use RequestBody. (parameter #1)\n"
+              + "    for method CallMethod.disallowed");
+    }
+  }
+
+  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    try {
+      example.disallowed();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Method response type is class java.lang.String but no converter factory registered. "
+              + "Either add a converter factory to the Retrofit instance or use ResponseBody.\n"
+              + "    for method CallMethod.disallowed");
+    }
+  }
+
+  @Test public void converterReturningNullThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new Converter.Factory() {
+          @Override public Converter<?> get(Type type) {
+            return null;
+          }
+
+          @Override public String toString() {
+            return "Nully";
+          }
+        })
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+
+    try {
+      service.disallowed();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Converter factory 'Nully' was unable to handle response type class java.lang.String\n"
+              + "    for method CallMethod.disallowed");
+    }
+  }
+
+  @Test public void requestBodyOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<ResponseBody> response = example.allowed().execute();
+    assertThat(response.body().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    Response<ResponseBody> response = example.allowed(body).execute();
+    assertThat(response.body().string()).isEqualTo("Hi");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+  }
+
+  @Test public void unresolvableTypeThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .converterFactory(new ToStringConverterFactory())
+        .build();
+    Unresolvable example = retrofit.create(Unresolvable.class);
+
+    try {
+      example.typeVariable();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<T>\n    for method Unresolvable.typeVariable");
+    }
+    try {
+      example.typeVariableUpperBound();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<T>\n    for method Unresolvable.typeVariableUpperBound");
+    }
+    try {
+      example.crazy();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
+          + "    for method Unresolvable.crazy");
+    }
+    try {
+      example.wildcard();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<?>\n    for method Unresolvable.wildcard");
+    }
+    try {
+      example.wildcardUpperBound();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<? extends com.squareup.okhttp.ResponseBody>\n"
+          + "    for method Unresolvable.wildcardUpperBound");
+    }
+  }
+
+  @Test public void baseUrlRequired() {
+    try {
+      new Retrofit.Builder().build();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Base URL required.");
+    }
+  }
+
+  @Test public void baseUrlNullThrows() {
+    try {
+      new Retrofit.Builder().baseUrl((String) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+    try {
+      new Retrofit.Builder().baseUrl((HttpUrl) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+    try {
+      new Retrofit.Builder().baseUrl((BaseUrl) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+  }
+
+  @Test public void baseUrlInvalidThrows() {
+    try {
+      new Retrofit.Builder().baseUrl("ftp://foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    }
+  }
+
+  @Test public void baseUrlStringPropagated() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    BaseUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isNotNull();
+    assertThat(baseUrl.url().toString()).isEqualTo("http://example.com/");
+  }
+
+  @Test public void baseHttpUrlPropagated() {
+    HttpUrl url = HttpUrl.parse("http://example.com/");
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(url)
+        .build();
+    BaseUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isNotNull();
+    assertThat(baseUrl.url()).isSameAs(url);
+  }
+
+  @Test public void baseUrlPropagated() {
+    BaseUrl baseUrl = mock(BaseUrl.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(baseUrl)
+        .build();
+    assertThat(retrofit.baseUrl()).isSameAs(baseUrl);
+  }
+
+  @Test public void clientNullThrows() {
+    try {
+      new Retrofit.Builder().client(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("client == null");
+    }
+  }
+
+  @Test public void clientDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
+      assertThat(retrofit.client()).isNotNull();
+  }
+
+  @Test public void clientPropagated() {
+    OkHttpClient client = new OkHttpClient();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .client(client)
+        .build();
+    assertThat(retrofit.client()).isSameAs(client);
+  }
+
+  @Test public void converterNullThrows() {
+    try {
+      new Retrofit.Builder().converterFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("converterFactory == null");
+    }
+  }
+
+  @Test public void converterNoDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.converterFactory()).isNull();
+  }
+
+  @Test public void converterFactoryPropagated() {
+    Converter.Factory factory = mock(Converter.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .converterFactory(factory)
+        .build();
+    assertThat(retrofit.converterFactory()).isSameAs(factory);
+  }
+
+  @Test public void callAdapterFactoryNullThrows() {
+    try {
+      new Retrofit.Builder().callAdapterFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("factory == null");
+    }
+  }
+
+  @Test public void callAdapterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callAdapterFactory()).isNotNull();
+  }
+
+  @Test public void callAdapterFactoryPropagated() {
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callAdapterFactory(factory)
+        .build();
+    assertThat(retrofit.callAdapterFactory()).isSameAs(factory);
+  }
+
+  @Test public void callbackExecutorNullThrows() {
+    try {
+      new Retrofit.Builder().callbackExecutor(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("callbackExecutor == null");
+    }
+  }
+
+  @Test public void callbackExecutorNoDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isNull();
+  }
+
+  @Test public void callbackExecutorPropagated() {
+    Executor executor = mock(Executor.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callbackExecutor(executor)
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
+  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
+    Executor executor = spy(new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.allowed();
+
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void success(Response<ResponseBody> response) {
+        latch.countDown();
+      }
+
+      @Override public void failure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+    verify(executor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(executor);
+  }
+
+  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
+    Executor executor = spy(new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.allowed();
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void success(Response<ResponseBody> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(Throwable t) {
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+    verify(executor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(executor);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
new file mode 100644
index 000000000..291622d94
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+
+class ToStringConverterFactory implements Converter.Factory {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+
+  @Override public Converter get(Type type) {
+    return new StringConverter();
+  }
+
+  static class StringConverter implements Converter<Object> {
+    @Override public String fromBody(ResponseBody body) throws IOException {
+      return body.string();
+    }
+
+    @Override public RequestBody toBody(Object value) {
+      return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
deleted file mode 100644
index 98c10c93b..000000000
--- a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-// Copyright 2015 Square, Inc.
-package retrofit.converter;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import okio.Buffer;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-
-public final class GsonConverterTest {
-  private Converter converter;
-
-  interface Example {
-    String getName();
-  }
-
-  class Impl implements Example {
-    private final String theName;
-
-    Impl(String name) {
-      theName = name;
-    }
-
-    @Override public String getName() {
-      return theName;
-    }
-  }
-
-  @Before public void setUp() {
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapter(Example.class, new JsonSerializer<Example>() {
-          @Override public JsonElement serialize(Example example, Type type,
-              JsonSerializationContext json) {
-            JsonObject object = new JsonObject();
-            object.addProperty("name", example.getName());
-            return object;
-          }
-        })
-        .create();
-    converter = new GsonConverter(gson);
-  }
-
-  @Test public void serialization() throws IOException {
-    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
-    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
-  }
-
-  @Test public void serializationTypeUsed() throws IOException {
-    RequestBody body = converter.toBody(new Impl("value"), Example.class);
-    assertBody(body).isEqualTo("{\"name\":\"value\"}");
-  }
-
-  @Test public void deserialization() throws IOException {
-    ResponseBody body =
-        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
-    Impl impl = (Impl) converter.fromBody(body, Impl.class);
-    assertEquals("value", impl.getName());
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readUtf8());
-  }
-}
diff --git a/samples/mock-github-client/pom.xml b/samples/mock-github-client/pom.xml
deleted file mode 100644
index 11327d99b..000000000
--- a/samples/mock-github-client/pom.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!--
-  ~ Copyright 2013 Square, Inc.
-  -->
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.retrofit.samples</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>mock-github-client</artifactId>
-  <name>Sample: Mock GitHub Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit-mock</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/pom.xml b/samples/pom.xml
index 272a39608..f60dae06c 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -10,13 +10,36 @@
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <groupId>com.squareup.retrofit.samples</groupId>
-  <artifactId>parent</artifactId>
+  <artifactId>samples</artifactId>
   <name>Samples</name>
-  <packaging>pom</packaging>
 
-  <modules>
-    <module>github-client</module>
-    <module>mock-github-client</module>
-  </modules>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <!--<dependency>-->
+      <!--<groupId>com.squareup.retrofit</groupId>-->
+      <!--<artifactId>retrofit-mock</artifactId>-->
+      <!--<version>${project.version}</version>-->
+    <!--</dependency>-->
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
new file mode 100644
index 000000000..b58b9b0ad
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
+import retrofit.Call;
+import retrofit.CallAdapter;
+import retrofit.Callback;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+/**
+ * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
+ * a service method return type.
+ */
+public final class CustomCallAdapter {
+  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
+    @Override public CallAdapter<?> get(Type returnType) {
+      TypeToken<?> token = TypeToken.of(returnType);
+      if (token.getRawType() != ListenableFuture.class) {
+        return null;
+      }
+
+      TypeToken<?> componentType = token.getComponentType();
+      if (componentType == null) {
+        throw new IllegalStateException(); // TODO
+      }
+      final Type responseType = componentType.getType();
+
+      return new CallAdapter<Object>() {
+        @Override public Type responseType() {
+          return responseType;
+        }
+
+        @Override public ListenableFuture<?> adapt(Call<Object> call) {
+          CallFuture<Object> future = new CallFuture<>(call);
+          call.enqueue(future);
+          return future;
+        }
+      };
+    }
+
+    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
+      private final Call<T> call;
+
+      private CallFuture(Call<T> call) {
+        this.call = call;
+      }
+
+      @Override protected void interruptTask() {
+        call.cancel();
+      }
+
+      @Override public void success(Response<T> response) {
+        if (response.isSuccess()) {
+          set(response.body());
+        } else {
+          setException(new IOException()); // TODO something more useful.
+        }
+      }
+
+      @Override public void failure(Throwable t) {
+        setException(t);
+      }
+    }
+  }
+
+  interface HttpBinService {
+    @GET("/ip")
+    ListenableFuture<Ip> getIp();
+  }
+
+  static class Ip {
+    String origin;
+  }
+
+  public static void main(String... args) {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://httpbin.org")
+        .callAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .build();
+
+    HttpBinService service = retrofit.create(HttpBinService.class);
+    final ListenableFuture<Ip> ip = service.getIp();
+    ip.addListener(new Runnable() {
+      @Override public void run() {
+        try {
+          System.out.println("IP: " + ip.get().origin);
+        } catch (InterruptedException | ExecutionException e) {
+          e.printStackTrace();
+        }
+      }
+    }, Executors.newSingleThreadExecutor());
+  }
+}
diff --git a/samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
similarity index 52%
rename from samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/src/main/java/com/example/retrofit/SimpleService.java
index f71a10bac..a57edb3ca 100644
--- a/samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -15,38 +15,47 @@
  */
 package com.example.retrofit;
 
+import java.io.IOException;
 import java.util.List;
-import retrofit.RestAdapter;
+import retrofit.Call;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
 
-public class GitHubClient {
-  private static final String API_URL = "https://api.github.com";
+public final class SimpleService {
+  public static final String API_URL = "https://api.github.com";
 
-  static class Contributor {
-    String login;
-    int contributions;
+  public static class Contributor {
+    public final String login;
+    public final int contributions;
+
+    public Contributor(String login, int contributions) {
+      this.login = login;
+      this.contributions = contributions;
+    }
   }
 
-  interface GitHub {
+  public interface GitHub {
     @GET("/repos/{owner}/{repo}/contributors")
-    List<Contributor> contributors(
+    Call<List<Contributor>> contributors(
         @Path("owner") String owner,
-        @Path("repo") String repo
-    );
+        @Path("repo") String repo);
   }
 
-  public static void main(String... args) {
-    // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setEndpoint(API_URL)
+  public static void main(String... args) throws IOException {
+    // Create a very simple REST adapter which points the GitHub API.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(API_URL)
         .build();
 
     // Create an instance of our GitHub API interface.
-    GitHub github = restAdapter.create(GitHub.class);
+    GitHub github = retrofit.create(GitHub.class);
+
+    // Create a call instance for looking up Retrofit contributors.
+    Call<List<Contributor>> call = github.contributors("square", "retrofit");
 
-    // Fetch and print a list of the contributors to this library.
-    List<Contributor> contributors = github.contributors("square", "retrofit");
+    // Fetch and print a list of the contributors to the library.
+    List<Contributor> contributors = call.execute().body();
     for (Contributor contributor : contributors) {
       System.out.println(contributor.login + " (" + contributor.contributions + ")");
     }
diff --git a/samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/src/main/not_java/SimpleMockService.java
similarity index 73%
rename from samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/src/main/not_java/SimpleMockService.java
index 27563c9a7..9b776ce85 100644
--- a/samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/src/main/not_java/SimpleMockService.java
@@ -1,41 +1,28 @@
 // Copyright 2013 Square, Inc.
 package com.example.retrofit;
 
+import com.example.retrofit.SimpleService.Contributor;
+import com.example.retrofit.SimpleService.GitHub;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executors;
-import retrofit.MockRestAdapter;
-import retrofit.RestAdapter;
-import retrofit.http.GET;
-import retrofit.http.Path;
-
-public class GitHubClient {
-  private static final String API_URL = "https://api.github.com";
-
-  static class Contributor {
-    public final String login;
-    public final int contributions;
-
-    Contributor(String login, int contributions) {
-      this.login = login;
-      this.contributions = contributions;
-    }
-  }
-
-  public interface GitHub {
-    @GET("/repos/{owner}/{repo}/contributors")
-    List<Contributor> contributors(@Path("owner") String owner, @Path("repo") String repo);
-  }
-
+import retrofit.MockRetrofit;
+import retrofit.Retrofit;
+
+/**
+ * An example of using {@link MockRetrofit} to create a mock service implementation with
+ * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
+ */
+public final class SimpleMockService {
   /** A mock implementation of the {@link GitHub} API interface. */
-  static class MockGitHub implements GitHub {
+  static final class MockGitHub implements GitHub {
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
     public MockGitHub() {
-      ownerRepoContributors = new LinkedHashMap<String, Map<String, List<Contributor>>>();
+      ownerRepoContributors = new LinkedHashMap<>();
 
       // Seed some mock data.
       addContributor("square", "retrofit", "John Doe", 12);
@@ -60,12 +47,12 @@ public MockGitHub() {
     public void addContributor(String owner, String repo, String name, int contributions) {
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
       if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<String, List<Contributor>>();
+        repoContributors = new LinkedHashMap<>();
         ownerRepoContributors.put(owner, repoContributors);
       }
       List<Contributor> contributors = repoContributors.get(repo);
       if (contributors == null) {
-        contributors = new ArrayList<Contributor>();
+        contributors = new ArrayList<>();
         repoContributors.put(repo, contributors);
       }
       contributors.add(new Contributor(name, contributions));
@@ -73,19 +60,18 @@ public void addContributor(String owner, String repo, String name, int contribut
   }
 
   public static void main(String... args) {
-    // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setEndpoint(API_URL)
+    // Create a very simple REST adapter which points the GitHub API.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(SimpleService.API_URL)
         .build();
 
     // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRestAdapter mockRestAdapter =
-        MockRestAdapter.from(restAdapter, Executors.newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = MockRetrofit.from(retrofit, Executors.newSingleThreadExecutor());
 
     // Instantiate a mock object so we can interact with it later.
     MockGitHub mockGitHub = new MockGitHub();
     // Use the mock REST adapter and our mock object to create the API interface.
-    GitHub gitHub = mockRestAdapter.create(GitHub.class, mockGitHub);
+    GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
     printContributors(gitHub, "square", "retrofit");
diff --git a/website/index.html b/website/index.html
index cfd04f78b..fbbda6a98 100644
--- a/website/index.html
+++ b/website/index.html
@@ -8,7 +8,7 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
     <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
   </head>
   <body data-target=".content-nav">
@@ -48,12 +48,12 @@ <h3 id="introduction">Introduction</h3>
   @GET("/users/{user}/repos")
   List&lt;Repo> listRepos(@Path("user") String user);
 }</pre>
-            <p>The <code>RestAdapter</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class="prettyprint">RestAdapter restAdapter = new RestAdapter.Builder()
+            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint("https://api.github.com")
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
             <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
             <pre class="prettyprint">List&lt;Repo> repos = service.listRepos("octocat");</pre>
             <p>Use annotations to describe the HTTP request:</p>
@@ -88,7 +88,7 @@ <h4>Request Body</h4>
             <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
             <pre class="prettyprint">@POST("/users/new")
 void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>RestAdapter</code>'s converter.</p>
+            <p>The object will also be converted using the <code>Retrofit</code>'s converter.</p>
 
             <h4>Form Encoded and Multipart</h4>
             <p>Methods can also be declared to send form-encoded and multipart data.</p>
@@ -100,7 +100,7 @@ <h4>Form Encoded and Multipart</h4>
             <pre class="prettyprint">@Multipart
 @PUT("/user/photo")
 User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description);</pre>
-            <p>Multipart parts use the <code>RestAdapter</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+            <p>Multipart parts use the <code>Retrofit</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
 
             <h4>Header Manipulation</h4>
             <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
@@ -125,7 +125,7 @@ <h4>Header Manipulation</h4>
   }
 };
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
   .setEndpoint("https://api.github.com")
   .setRequestInterceptor(requestInterceptor)
   .build();</pre>
@@ -146,7 +146,7 @@ <h4>Synchronous vs. Asynchronous vs. Observable</h4>
             <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
 
             <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
+            <p>HTTP responses are automatically converted to a specified type using the <code>Retrofit</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
             <pre class="prettyprint">@GET("/users/list")
 List&lt;User> userList();
 
@@ -165,11 +165,11 @@ <h4>Response Object Type</h4>
 @GET("/users/list")
 Observable&lt;Response> userList();</pre>
 
-            <h3 id="restadapter-configuration">RestAdapter Configuration</h3>
-            <p><code>RestAdapter</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+            <h3 id="restadapter-configuration">Retrofit Configuration</h3>
+            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
 
             <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>RestAdapter</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
+            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>Retrofit</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
             <h4>Custom Gson Converter Example</h4>
             <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
             <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
@@ -178,22 +178,22 @@ <h4>Custom Gson Converter Example</h4>
     .registerTypeAdapter(Date.class, new DateTypeAdapter())
     .create();
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint("https://api.github.com")
     .setConverter(new GsonConverter(gson))
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>RestAdapter</code>.</p>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
+            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>Retrofit</code>.</p>
             <h4>Content format Agnostic</h4>
             <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href="http://simple.sourceforge.net/">Simple</a>) and Protocol Buffers (using <a href="https://code.google.com/p/protobuf/">protobuf</a> or <a href="https://github.com/square/wire">Wire</a>). Please see the <a href="https://github.com/square/retrofit/tree/master/retrofit-converters">retrofit-converters</a> directory for the full listing of converters.</p>
             <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class="prettyprint">RestAdapter restAdapter = new RestAdapter.Builder()
+            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint("https://api.soundcloud.com")
     .setConverter(new SimpleXMLConverter())
     .build();
 
-SoundCloudService service = restAdapter.create(SoundCloudService.class);</pre>
+SoundCloudService service = retrofit.create(SoundCloudService.class);</pre>
             <h4>Custom Converters</h4>
             <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
             <h4>Custom Error Handling</h4>
@@ -209,21 +209,21 @@ <h4>Custom Error Handling</h4>
   }
 }
 
-RestAdapter restAdapter = new RestAdapter.Builder()
+Retrofit retrofit = new Retrofit.Builder()
     .setEndpoint("https://api.github.com")
     .setErrorHandler(new MyErrorHandler())
     .build();</pre>
             <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
 
             <h4>Logging</h4>
-            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>RestAdapter</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
+            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>Retrofit</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
             <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
             <pre class="prettyprint">
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setLogLevel(RestAdapter.LogLevel.FULL)
+Retrofit retrofit = new Retrofit.Builder()
+    .setLogLevel(Retrofit.LogLevel.FULL)
     .setEndpoint("https://api.github.com")
     .build();</pre>
-            <p>This logging can be added or changed at any point in the <code>RestAdapter</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
+            <p>This logging can be added or changed at any point in the <code>Retrofit</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
 
             <h3 id="download">Download</h3>
             <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
@@ -241,23 +241,25 @@ <h4>Gradle</h4>
             <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
 
             <h4>Integration with OkHttp</h4>
-            <p>When using Retrofit together with OkHttp, OkHttp (version 1.6.0 or newer) and OkHttp-UrlConnection are now required.</p>
+            <p>Retrofit will automatically use OkHttp (version 2.0 or newer) when it is present.</p>
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.okhttp&lt;/groupId>
   &lt;artifactId>okhttp&lt;/artifactId>
-  &lt;version>2.0.0&lt;/version>
-&lt;/dependency>
-&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
-  &lt;artifactId>okhttp-urlconnection&lt;/artifactId>
-  &lt;version>2.0.0&lt;/version>
+  &lt;version><span class="okhttpversion pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency>
 </pre>
             <h4>Gradle</h4>
 <pre class="prettyprint">
-compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.0'
-compile 'com.squareup.okhttp:okhttp:2.0.0'
+compile 'com.squareup.okhttp:okhttp:<span class="okhttpversion pln"><em>(insert latest version)</em></span>'
+</pre>
+            <h4>ProGuard</h4>
+            <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+            <pre class="prettyprint">
+-dontwarn retrofit.**
+-keep class retrofit.** { *; }
+-keepattributes Signature
+-keepattributes Exceptions
 </pre>
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
@@ -284,7 +286,7 @@ <h3 id="license">License</h3>
               <ul class="nav nav-tabs nav-stacked primary">
                 <li><a href="#introduction">Introduction</a></li>
                 <li><a href="#api-declaration">API Declaration</a></li>
-                <li><a href="#restadapter-configuration">RestAdapter Configuration</a></li>
+                <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
                 <li><a href="#download">Download</a></li>
                 <li><a href="#contributing">Contributing</a></li>
                 <li><a href="#license">License</a></li>
@@ -303,7 +305,7 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </section>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/bootstrap.min.js"></script>
     <script src="static/jquery.smooth-scroll.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
@@ -336,6 +338,9 @@ <h3 id="license">License</h3>
           $('.version-tag').text('v' + version);
           $('.version-href').attr('href', url);
         });
+        $.fn.artifactVersion('com.squareup.okhttp', 'okhttp', function(version, url) {
+          $('.okhttpversion').text(version);
+        });
       });
 
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
