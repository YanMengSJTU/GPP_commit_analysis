diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index f97a96b86..ef89a7a29 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -30,7 +30,7 @@
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
-import com.bumptech.glide.signature.ApplicationVersionSignature;
+import com.bumptech.glide.signature.AndroidResourceSignature;
 import com.bumptech.glide.util.Executors;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
@@ -495,12 +495,12 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    * load the image represented by the given {@link Integer} resource id. Defaults to {@link
    * com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
-   * <p>By default this method adds a version code based signature to the cache key used to cache
-   * this resource in Glide. This signature is sufficient to guarantee that end users will see the
-   * most up to date versions of your Drawables, but during development if you do not increment your
-   * version code before each install and you replace a Drawable with different data without
-   * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via {@link
+   * <p>By default this method adds a version code and night mode based signature to the cache key
+   * used to cache this resource in Glide. This signature is sufficient to guarantee that end users
+   * will see the most up to date versions of your Drawables, but during development if you do not
+   * increment your version code before each install and you replace a Drawable with different data
+   * without changing the Drawable name, you may see inconsistent cached data. To get around this,
+   * consider using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via {@link
    * RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)} during
    * development, and re-enabling the default {@link
    * com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
@@ -519,13 +519,13 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    * caution for non-{@link Bitmap} {@link Drawable}s.
    *
    * @see #load(Integer)
-   * @see com.bumptech.glide.signature.ApplicationVersionSignature
+   * @see com.bumptech.glide.signature.AndroidResourceSignature
    */
   @NonNull
   @CheckResult
   @Override
   public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
-    return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
+    return loadGeneric(resourceId).apply(signatureOf(AndroidResourceSignature.obtain(context)));
   }
 
   /**
@@ -623,7 +623,6 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
     Request previous = target.getRequest();
     if (request.isEquivalentTo(previous)
         && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
-      request.recycle();
       // If the request is completed, beginning again will ensure the result is re-delivered,
       // triggering RequestListeners and Targets. If the request is failed, beginning again will
       // restart the request, giving it another chance to complete. If the request is already
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index cd6b528c5..9d5c92d26 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -660,7 +660,7 @@ synchronized boolean untrack(@NonNull Target<?> target) {
       return true;
     }
 
-    if (requestTracker.clearRemoveAndRecycle(request)) {
+    if (requestTracker.clearAndRemove(request)) {
       targetTracker.untrack(target);
       target.setRequest(null);
       return true;
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 4c80874a0..c675052fe 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -59,13 +59,7 @@ void addRequest(Request request) {
    * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
    * request was removed or invalid or {@code false} if the request was not found.
    */
-  public boolean clearRemoveAndRecycle(@Nullable Request request) {
-    // It's safe for us to recycle because this is only called when the user is explicitly clearing
-    // a Target so we know that there are no remaining references to the Request.
-    return clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ true);
-  }
-
-  private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
+  public boolean clearAndRemove(@Nullable Request request) {
     if (request == null) {
       // If the Request is null, the request is already cleared and we don't need to search further
       // for its owner.
@@ -76,9 +70,6 @@ private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean is
     isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
-      if (isSafeToRecycle) {
-        request.recycle();
-      }
     }
     return isOwnedByUs;
   }
@@ -136,7 +127,7 @@ public void clearRequests() {
     for (Request request : Util.getSnapshot(requests)) {
       // It's unsafe to recycle the Request here because we don't know who might else have a
       // reference to it.
-      clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ false);
+      clearAndRemove(request);
     }
     pendingRequests.clear();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
index 36212e9b9..063ec3050 100644
--- a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -90,14 +90,6 @@ public boolean isCleared() {
     }
   }
 
-  @Override
-  public void recycle() {
-    synchronized (requestLock) {
-      primary.recycle();
-      error.recycle();
-    }
-  }
-
   @Override
   public boolean isEquivalentTo(Request o) {
     if (o instanceof ErrorRequestCoordinator) {
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index e6d5e2da1..044e198f1 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -32,9 +32,6 @@
   /** Returns true if the request has been cleared. */
   boolean isCleared();
 
-  /** Recycles the request object and releases its resources. */
-  void recycle();
-
   /**
    * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has
    * all of the same options and sizes).
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 7d68be288..fbbebfac5 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -357,11 +357,6 @@ public boolean isCleared() {
     }
   }
 
-  @Override
-  public void recycle() {
-    // TODO: remove this method, it's a no-op.
-  }
-
   @GuardedBy("requestLock")
   private Drawable getErrorDrawable() {
     if (errorDrawable == null) {
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 4782b0221..78cc3e750 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -202,14 +202,6 @@ public boolean isCleared() {
     }
   }
 
-  @Override
-  public void recycle() {
-    synchronized (requestLock) {
-      full.recycle();
-      thumb.recycle();
-    }
-  }
-
   @Override
   public boolean isEquivalentTo(Request o) {
     if (o instanceof ThumbnailRequestCoordinator) {
diff --git a/library/src/main/java/com/bumptech/glide/signature/AndroidResourceSignature.java b/library/src/main/java/com/bumptech/glide/signature/AndroidResourceSignature.java
new file mode 100644
index 000000000..0bcbed34d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/signature/AndroidResourceSignature.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.signature;
+
+import android.content.Context;
+import android.content.res.Configuration;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Util;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/** Includes information about the package as well as whether or not the device is in night mode. */
+public final class AndroidResourceSignature implements Key {
+
+  private final int nightMode;
+  private final Key applicationVersion;
+
+  @NonNull
+  public static Key obtain(@NonNull Context context) {
+    Key signature = ApplicationVersionSignature.obtain(context);
+    int nightMode =
+        context.getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;
+    return new AndroidResourceSignature(nightMode, signature);
+  }
+
+  private AndroidResourceSignature(int nightMode, Key applicationVersion) {
+    this.nightMode = nightMode;
+    this.applicationVersion = applicationVersion;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof AndroidResourceSignature) {
+      AndroidResourceSignature that = (AndroidResourceSignature) o;
+      return nightMode == that.nightMode && applicationVersion.equals(that.applicationVersion);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return Util.hashCode(applicationVersion, nightMode);
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    applicationVersion.updateDiskCacheKey(messageDigest);
+    byte[] nightModeData = ByteBuffer.allocate(4).putInt(nightMode).array();
+    messageDigest.update(nightModeData);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index d0b9708a1..b301563cf 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -27,69 +27,54 @@ public void setUp() {
   }
 
   @Test
-  public void clearRequests_doesNotRecycleRequests() {
+  public void clearAndRemove_withRequestPreviouslyClearedInClearRequests_doesNothing() {
     FakeRequest request = new FakeRequest();
     tracker.addRequest(request);
 
     tracker.clearRequests();
+    tracker.clearAndRemove(request);
 
     assertThat(request.isCleared()).isTrue();
-    assertThat(request.isRecycled()).isFalse();
   }
 
   @Test
-  public void clearRemoveAndRecycle_withRequestPreviouslyClearedInClearRequests_doesNothing() {
-    FakeRequest request = new FakeRequest();
-    tracker.addRequest(request);
-
-    tracker.clearRequests();
-    tracker.clearRemoveAndRecycle(request);
-
-    assertThat(request.isCleared()).isTrue();
-    assertThat(request.isRecycled()).isFalse();
-  }
-
-  @Test
-  public void clearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {
-    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();
+  public void clearAndRemove_withNullRequest_doesNothingAndReturnsTrue() {
+    assertThat(tracker.clearAndRemove(null)).isTrue();
   }
 
   @Test
-  public void clearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+  public void clearAndRemove_withUnTrackedRequest_doesNothingAndReturnsFalse() {
     FakeRequest request = new FakeRequest();
 
-    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+    assertThat(tracker.clearAndRemove(request)).isFalse();
 
     assertThat(request.isCleared()).isFalse();
-    assertThat(request.isRecycled()).isFalse();
   }
 
   @Test
-  public void clearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+  public void clearAndRemov_withTrackedRequest_clearssAndReturnsTrue() {
     FakeRequest request = new FakeRequest();
     tracker.addRequest(request);
 
-    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();
+    assertThat(tracker.clearAndRemove(request)).isTrue();
     assertThat(request.isCleared()).isTrue();
-    assertThat(request.isRecycled()).isTrue();
   }
 
   @Test
-  public void clearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+  public void clearAndRemove_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
     FakeRequest request = new FakeRequest();
     tracker.addRequest(request);
-    tracker.clearRemoveAndRecycle(request);
-    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+    tracker.clearAndRemove(request);
+    assertThat(tracker.clearAndRemove(request)).isFalse();
 
     assertThat(request.isCleared()).isTrue();
-    assertThat(request.isRecycled()).isTrue();
   }
 
   @Test
   public void clearRequests_withPreviouslyClearedRequest_doesNotClearRequestAgain() {
     FakeRequest request = new FakeRequest();
     tracker.addRequest(request);
-    tracker.clearRemoveAndRecycle(request);
+    tracker.clearAndRemove(request);
 
     tracker.clearRequests();
 
@@ -382,7 +367,6 @@ public void pause() {
     private boolean isRunning;
     private boolean isCleared;
     private boolean isComplete;
-    private boolean isRecycled;
 
     void setIsComplete() {
       setIsComplete(true);
@@ -396,10 +380,6 @@ void setIsRunning() {
       isRunning = true;
     }
 
-    boolean isRecycled() {
-      return isRecycled;
-    }
-
     boolean isPaused() {
       return isPaused;
     }
@@ -436,14 +416,6 @@ public boolean isCleared() {
       return isCleared;
     }
 
-    @Override
-    public void recycle() {
-      if (isRecycled) {
-        throw new IllegalStateException();
-      }
-      isRecycled = true;
-    }
-
     @Override
     public boolean isEquivalentTo(Request other) {
       throw new UnsupportedOperationException();
@@ -460,7 +432,7 @@ public boolean isEquivalentTo(Request other) {
 
     @Override
     public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-      tracker.clearRemoveAndRecycle(toRemove);
+      tracker.clearAndRemove(toRemove);
       return null;
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
index cc2c4ad31..9be4c0e74 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -200,13 +200,6 @@ public void isCleared_primaryFailed_errorCancelled_returnsTrue() {
     assertThat(coordinator.isCleared()).isTrue();
   }
 
-  @Test
-  public void recycle_recyclesPrimaryAndError() {
-    coordinator.recycle();
-    verify(primary).recycle();
-    verify(error).recycle();
-  }
-
   @Test
   public void isEquivalentTo() {
     assertThat(coordinator.isEquivalentTo(primary)).isFalse();
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index 74abef7c1..3e434165c 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -145,13 +145,6 @@ public void pause_pausesThumbAndFullInOrder() {
     order.verify(full).pause();
   }
 
-  @Test
-  public void testRecyclesRequestsWhenRecycled() {
-    coordinator.recycle();
-    verify(thumb).recycle();
-    verify(full).recycle();
-  }
-
   @Test
   public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
     coordinator = newCoordinator();
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/AndroidResourceSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/AndroidResourceSignatureTest.java
new file mode 100644
index 000000000..1a1155a65
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/AndroidResourceSignatureTest.java
@@ -0,0 +1,76 @@
+package com.bumptech.glide.signature;
+
+import static org.junit.Assert.assertNotNull;
+
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import androidx.test.core.app.ApplicationProvider;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 28)
+public class AndroidResourceSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  @Test
+  public void testCanGetKeyForSignature() {
+    Key key = AndroidResourceSignature.obtain(context);
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage() {
+    keyTester
+        .addEquivalenceGroup(
+            AndroidResourceSignature.obtain(context), AndroidResourceSignature.obtain(context))
+        .addEquivalenceGroup(new ObjectKey("test"))
+        .addRegressionTest(
+            ApplicationVersionSignature.obtain(context),
+            "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9")
+        .test();
+  }
+
+  @Test
+  public void testKeyForSignatureDiffersByNightMode() {
+    RuntimeEnvironment.setQualifiers("notnight");
+    keyTester
+        .addEquivalenceGroup(
+            AndroidResourceSignature.obtain(context), AndroidResourceSignature.obtain(context))
+        .addRegressionTest(
+            AndroidResourceSignature.obtain(context),
+            "265d958bdae1bea56e45cc31f4db672c22893b66fef85617bbc78742bd912207");
+    RuntimeEnvironment.setQualifiers("night");
+    keyTester
+        .addEquivalenceGroup(
+            AndroidResourceSignature.obtain(context), AndroidResourceSignature.obtain(context))
+        .addRegressionTest(
+            AndroidResourceSignature.obtain(context),
+            "96c9b8d5bb071ccd67df50cd9a0059640ebd02db78d08f07611ec145ce44a638");
+
+    keyTester.test();
+  }
+
+  @Test
+  public void testMissingPackageInfo() throws NameNotFoundException {
+    // Make getPackageInfo throw NameNotFoundException.
+    Shadows.shadowOf(context.getPackageManager()).removePackage(context.getPackageName());
+    Key key = AndroidResourceSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+}
